
#ifndef V_COMMIT_HASH
	#define V_COMMIT_HASH "258d1f7"
#endif

#ifndef V_CURRENT_COMMIT_HASH
	#define V_CURRENT_COMMIT_HASH "d75c408"
#endif

// V comptime_definitions:
// V compile time defines by -d or -define flags:
//     All custom defines      : debug
//     Turned ON custom defines: debug
#define CUSTOM_DEFINE_debug

#define __VTHREADS__ (1)
#define _VDEBUG (1)
#define _VAUTOFREE (0)

// V typedefs:
typedef struct IError IError;
typedef struct ui__Widget ui__Widget;
typedef struct ui__DrawText ui__DrawText;
typedef struct ui__ScrollableWidget ui__ScrollableWidget;
typedef struct ui__Layout ui__Layout;
typedef struct ui__Focusable ui__Focusable;
typedef struct ui__DrawTextWidget ui__DrawTextWidget;
typedef struct ui__ColorThemeWidget ui__ColorThemeWidget;
typedef struct ui__ComponentChild ui__ComponentChild;
typedef struct none none;
typedef struct ui__Size ui__Size;
typedef struct ui__ColorThemeCfg ui__ColorThemeCfg;

// BEGIN_multi_return_typedefs
typedef struct multi_return_u32_u32 multi_return_u32_u32;
typedef struct multi_return_u32_u32_u32 multi_return_u32_u32_u32;
typedef struct multi_return_strconv__ParserState_strconv__PrepNumber multi_return_strconv__ParserState_strconv__PrepNumber;
typedef struct multi_return_u64_int multi_return_u64_int;
typedef struct multi_return_strconv__Dec32_bool multi_return_strconv__Dec32_bool;
typedef struct multi_return_strconv__Dec64_bool multi_return_strconv__Dec64_bool;
typedef struct multi_return_int_int multi_return_int_int;
typedef struct multi_return_f64_f64_f64 multi_return_f64_f64_f64;
typedef struct multi_return_bool_ref_ui__ScrollView multi_return_bool_ref_ui__ScrollView;
typedef struct multi_return_int_f32 multi_return_int_f32;
typedef struct multi_return_Array_string_Array_int multi_return_Array_string_Array_int;
typedef struct multi_return_int_int_int_int multi_return_int_int_int_int;
typedef struct multi_return_bool_ui__Layout multi_return_bool_ui__Layout;
typedef struct multi_return_Array_int_Array_int multi_return_Array_int_Array_int;
typedef struct multi_return_ui__HorizontalAlignment_ui__VerticalAlignment multi_return_ui__HorizontalAlignment_ui__VerticalAlignment;
typedef struct multi_return_string_string multi_return_string_string;
typedef struct multi_return_string_int multi_return_string_int;
typedef struct multi_return_int_bool multi_return_int_bool;
typedef struct multi_return_u64_u64 multi_return_u64_u64;
typedef struct multi_return_f64_int multi_return_f64_int;
typedef struct multi_return_i64_i64_i64 multi_return_i64_i64_i64;
typedef struct multi_return_f64_f64 multi_return_f64_f64;
typedef struct multi_return_int_int_int multi_return_int_int_int;
typedef struct multi_return_int_int_int_int_i64_bool multi_return_int_int_int_int_i64_bool;
// END_multi_return_typedefs

typedef struct strconv__BF_param strconv__BF_param;
typedef struct strconv__PrepNumber strconv__PrepNumber;
typedef struct strconv__Dec32 strconv__Dec32;
typedef struct strconv__Dec64 strconv__Dec64;
typedef struct strconv__Uint128 strconv__Uint128;
typedef union strconv__Uf32 strconv__Uf32;
typedef union strconv__Uf64 strconv__Uf64;
typedef union strconv__Float64u strconv__Float64u;
typedef union strconv__Float32u strconv__Float32u;
typedef struct array array;
typedef struct VCastTypeIndexName VCastTypeIndexName;
typedef struct VAssertMetaInfo VAssertMetaInfo;
typedef struct MethodArgs MethodArgs;
typedef struct FunctionData FunctionData;
typedef struct FieldData FieldData;
typedef struct StructAttribute StructAttribute;
typedef struct DenseArray DenseArray;
typedef struct map map;
typedef struct Error Error;
typedef struct MessageError MessageError;
typedef struct None__ None__;
typedef struct Option Option;
typedef struct VMemoryBlock VMemoryBlock;
typedef struct SortedMap SortedMap;
typedef struct mapnode mapnode;
typedef struct string string;
typedef struct RepIndex RepIndex;
typedef union StrIntpMem StrIntpMem;
typedef struct StrIntpCgenData StrIntpCgenData;
typedef struct StrIntpData StrIntpData;
typedef struct os__File os__File;
typedef struct os__FileInfo os__FileInfo;
typedef struct os__FileNotOpenedError os__FileNotOpenedError;
typedef struct os__SizeOfTypeIs0Error os__SizeOfTypeIs0Error;
typedef struct os__FilePermission os__FilePermission;
typedef struct os__FileMode os__FileMode;
typedef struct os__Result os__Result;
typedef struct os__Command os__Command;
typedef struct os__ExecutableNotFoundError os__ExecutableNotFoundError;
typedef struct os__Uname os__Uname;
typedef struct os__Process os__Process;
typedef struct time__TimeParseError time__TimeParseError;
typedef struct time__StopWatchOptions time__StopWatchOptions;
typedef struct time__StopWatch time__StopWatch;
typedef struct time__Time time__Time;
typedef struct time__InternalTimeBase time__InternalTimeBase;
typedef struct eventbus__Publisher eventbus__Publisher;
typedef struct eventbus__Subscriber eventbus__Subscriber;
typedef struct eventbus__Registry eventbus__Registry;
typedef struct eventbus__EventHandler eventbus__EventHandler;
typedef struct eventbus__EventBus eventbus__EventBus;
typedef struct clipboard__Clipboard clipboard__Clipboard;
typedef struct stbi__Image stbi__Image;
typedef struct gx__Color gx__Color;
typedef struct gx__Image gx__Image;
typedef struct gx__TextCfg gx__TextCfg;
typedef struct math__DigitParams math__DigitParams;
typedef struct math__ChebSeries math__ChebSeries;
typedef struct sokol__sapp__Screenshot sokol__sapp__Screenshot;
typedef struct gg__Event gg__Event;
typedef struct gg__Config gg__Config;
typedef struct gg__Context gg__Context;
typedef struct gg__PenConfig gg__PenConfig;
typedef struct gg__Size gg__Size;
typedef struct gg__Image gg__Image;
typedef struct gg__StreamingImageConfig gg__StreamingImageConfig;
typedef struct gg__DrawImageConfig gg__DrawImageConfig;
typedef struct gg__Rect gg__Rect;
typedef struct gg__SSRecorderSettings gg__SSRecorderSettings;
typedef struct gg__FT gg__FT;
typedef struct gg__FTConfig gg__FTConfig;
typedef struct gg__StringToRender gg__StringToRender;
typedef struct ui__HorizontalAlignments ui__HorizontalAlignments;
typedef struct ui__VerticalAlignments ui__VerticalAlignments;
typedef struct ui__Alignments ui__Alignments;
typedef struct ui__SortedWidget ui__SortedWidget;
typedef struct ui__EventNames ui__EventNames;
typedef struct ui__EventMngr ui__EventMngr;
typedef struct ui__Dragger ui__Dragger;
typedef struct ui__ScrollView ui__ScrollView;
typedef struct ui__CachedSizes ui__CachedSizes;
typedef struct ui__Margins ui__Margins;
typedef struct ui__Margin ui__Margin;
typedef struct ui__XYPos ui__XYPos;
typedef struct ui__TextLines ui__TextLines;
typedef struct ui__Tooltip ui__Tooltip;
typedef struct ui__TooltipMessage ui__TooltipMessage;
typedef struct ui__Chunk ui__Chunk;
typedef struct ui__SyntaxChunk ui__SyntaxChunk;
typedef struct ui__SyntaxHighLighter ui__SyntaxHighLighter;
typedef struct ui__TextView ui__TextView;
typedef struct ui__TextLinesView ui__TextLinesView;
typedef struct ui__LogViewParams ui__LogViewParams;
typedef struct ui__Color ui__Color;
typedef struct ui__TextStyle ui__TextStyle;
typedef struct ui__TextStyleParams ui__TextStyleParams;
typedef struct ui__TextStyles ui__TextStyles;
typedef struct ui__FontSet ui__FontSet;
typedef struct ui__FontSearcher ui__FontSearcher;
typedef struct ui__KeyEvent ui__KeyEvent;
typedef struct ui__CanvasLayout ui__CanvasLayout;
typedef struct ui__CanvasLayoutParams ui__CanvasLayoutParams;
typedef struct ui__ColumnParams ui__ColumnParams;
typedef struct ui__Group ui__Group;
typedef struct ui__GroupParams ui__GroupParams;
typedef struct ui__RowParams ui__RowParams;
typedef struct ui__Stack ui__Stack;
typedef struct ui__StackParams ui__StackParams;
typedef struct ui__ChildrenParams ui__ChildrenParams;
typedef struct ui__MouseEvent ui__MouseEvent;
typedef struct ui__ScrollEvent ui__ScrollEvent;
typedef struct ui__MouseMoveEvent ui__MouseMoveEvent;
typedef struct ui__Pos ui__Pos;
typedef struct ui__TouchInfo ui__TouchInfo;
typedef struct ui__Touch ui__Touch;
typedef struct ui__SettingsUI ui__SettingsUI;
typedef struct ui__UI ui__UI;
typedef struct ui__Button ui__Button;
typedef struct ui__ButtonParams ui__ButtonParams;
typedef struct ui__Canvas ui__Canvas;
typedef struct ui__CanvasParams ui__CanvasParams;
typedef struct ui__CheckBox ui__CheckBox;
typedef struct ui__CheckBoxParams ui__CheckBoxParams;
typedef struct ui__Dropdown ui__Dropdown;
typedef struct ui__DropdownParams ui__DropdownParams;
typedef struct ui__DropdownItem ui__DropdownItem;
typedef struct ui__Grid ui__Grid;
typedef struct ui__GridParams ui__GridParams;
typedef struct ui__Label ui__Label;
typedef struct ui__LabelParams ui__LabelParams;
typedef struct ui__ListBox ui__ListBox;
typedef struct ui__ListItem ui__ListItem;
typedef struct ui__ListBoxParams ui__ListBoxParams;
typedef struct ui__Menu ui__Menu;
typedef struct ui__MenuItem ui__MenuItem;
typedef struct ui__MenuParams ui__MenuParams;
typedef struct ui__Picture ui__Picture;
typedef struct ui__PictureParams ui__PictureParams;
typedef struct ui__ProgressBar ui__ProgressBar;
typedef struct ui__ProgressBarParams ui__ProgressBarParams;
typedef struct ui__Radio ui__Radio;
typedef struct ui__RadioParams ui__RadioParams;
typedef struct ui__Rectangle ui__Rectangle;
typedef struct ui__RectangleParams ui__RectangleParams;
typedef struct ui__Slider ui__Slider;
typedef struct ui__SliderParams ui__SliderParams;
typedef struct ui__SubWindow ui__SubWindow;
typedef struct ui__SubWindowParams ui__SubWindowParams;
typedef struct ui__Switch ui__Switch;
typedef struct ui__SwitchParams ui__SwitchParams;
typedef struct ui__TextBox ui__TextBox;
typedef struct ui__TextBoxParams ui__TextBoxParams;
typedef struct ui__Transition ui__Transition;
typedef struct ui__TransitionParams ui__TransitionParams;
typedef struct ui__Window ui__Window;
typedef struct ui__WindowParams ui__WindowParams;
typedef struct main__User main__User;
typedef struct main__State main__State;
typedef struct Option_int Option_int;
typedef struct Option_f64 Option_f64;
typedef struct Option_u64 Option_u64;
typedef struct Option_i64 Option_i64;
typedef struct Option_rune Option_rune;
typedef struct Option_string Option_string;
typedef struct Option_u8 Option_u8;
typedef struct Option_os__File Option_os__File;
typedef struct Option_FILE_ptr Option_FILE_ptr;
typedef struct Option_void Option_void;
typedef struct Option_Array_u8 Option_Array_u8;
typedef struct Option_Array_string Option_Array_string;
typedef struct Option_bool Option_bool;
typedef struct Option_os__SignalHandler Option_os__SignalHandler;
typedef struct Option_time__Time Option_time__Time;
typedef struct Option_multi_return_int_int_int Option_multi_return_int_int_int;
typedef struct Option_multi_return_int_int_int_int_i64_bool Option_multi_return_int_int_int_int_i64_bool;
typedef struct Option_stbi__Image Option_stbi__Image;
typedef struct Option_gg__FT_ptr Option_gg__FT_ptr;
typedef struct Option_ui__TextStyle Option_ui__TextStyle;
typedef struct Option_f32 Option_f32;
typedef struct Option_ui__SettingsUI Option_ui__SettingsUI;
typedef struct Option_multi_return_string_string Option_multi_return_string_string;
typedef struct Option_ui__Widget Option_ui__Widget;

// V cheaders:
// Generated by the V compiler

	#if defined(__TINYC__) && defined(__has_include)
	// tcc does not support has_include properly yet, turn it off completely
	#undef __has_include
	#endif

#if defined(__has_include)

#if __has_include(<inttypes.h>)
#include <inttypes.h>
#else
#error VERROR_MESSAGE The C compiler can not find <inttypes.h>. Please install build-essentials
#endif

#else
#include <inttypes.h>
#endif


#if defined(__has_include)

#if __has_include(<stddef.h>)
#include <stddef.h>
#else
#error VERROR_MESSAGE The C compiler can not find <stddef.h>. Please install build-essentials
#endif

#else
#include <stddef.h>
#endif


//================================== builtin types ================================*/
typedef int64_t i64;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint8_t u8;
typedef uint16_t u16;
//typedef uint8_t byte;
typedef uint32_t rune;
typedef size_t usize;
typedef ptrdiff_t isize;
#ifndef VNOFLOAT
typedef float f32;
typedef double f64;
#else
typedef int32_t f32;
typedef int64_t f64;
#endif
typedef int64_t int_literal;
#ifndef VNOFLOAT
typedef double float_literal;
#else
typedef int64_t float_literal;
#endif
typedef unsigned char* byteptr;
typedef void* voidptr;
typedef char* charptr;
typedef u8 array_fixed_byte_300 [300];

typedef struct sync__Channel* chan;

#ifndef __cplusplus
	#ifndef bool
		#ifdef CUSTOM_DEFINE_4bytebool
			typedef int bool;
		#else
			typedef u8 bool;
		#endif
		#define true 1
		#define false 0
	#endif
#endif

typedef u64 (*MapHashFn)(voidptr);
typedef bool (*MapEqFn)(voidptr, voidptr);
typedef void (*MapCloneFn)(voidptr, voidptr);
typedef void (*MapFreeFn)(voidptr);

//============================== HELPER C MACROS =============================*/
// _SLIT0 is used as NULL string for literal arguments
// `"" s` is used to enforce a string literal argument
#define _SLIT0 (string){.str=(byteptr)(""), .len=0, .is_lit=1}
#define _SLIT(s) ((string){.str=(byteptr)("" s), .len=(sizeof(s)-1), .is_lit=1})
#define _SLEN(s, n) ((string){.str=(byteptr)("" s), .len=n, .is_lit=1})

// take the address of an rvalue
#define ADDR(type, expr) (&((type[]){expr}[0]))

// copy something to the heap
#define HEAP(type, expr) ((type*)memdup((void*)&((type[]){expr}[0]), sizeof(type)))
#define HEAP_noscan(type, expr) ((type*)memdup_noscan((void*)&((type[]){expr}[0]), sizeof(type)))

#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many(arr, tmp.data, tmp.len);}
#define _PUSH_MANY_noscan(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many_noscan(arr, tmp.data, tmp.len);}

// unsigned/signed comparisons
static inline bool _us32_gt(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a > b; }
static inline bool _us32_ge(uint32_t a, int32_t b) { return a >= INT32_MAX || (int32_t)a >= b; }
static inline bool _us32_eq(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a == b; }
static inline bool _us32_ne(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a != b; }
static inline bool _us32_le(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a <= b; }
static inline bool _us32_lt(uint32_t a, int32_t b) { return a < INT32_MAX && (int32_t)a < b; }
static inline bool _us64_gt(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a > b; }
static inline bool _us64_ge(uint64_t a, int64_t b) { return a >= INT64_MAX || (int64_t)a >= b; }
static inline bool _us64_eq(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a == b; }
static inline bool _us64_ne(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a != b; }
static inline bool _us64_le(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a <= b; }
static inline bool _us64_lt(uint64_t a, int64_t b) { return a < INT64_MAX && (int64_t)a < b; }

#define EMPTY_VARG_INITIALIZATION 0
#define EMPTY_STRUCT_INITIALIZATION 0
#define EMPTY_STRUCT_DECLARATION voidptr _dummy_pad
// Due to a tcc bug, the length of an array needs to be specified, but GCC crashes if it is...
#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[])
#define TCCSKIP(x) x

#define __NOINLINE __attribute__((noinline))
#define __IRQHANDLER __attribute__((interrupt))

#define __V_architecture 0
#if defined(__x86_64__)
	#define __V_amd64  1
	#undef __V_architecture
	#define __V_architecture 1
#endif

#if defined(__aarch64__) || defined(__arm64__)
	#define __V_arm64  1
	#undef __V_architecture
	#define __V_architecture 2
#endif

// Using just __GNUC__ for detecting gcc, is not reliable because other compilers define it too:
#ifdef __GNUC__
	#define __V_GCC__
#endif
#ifdef __TINYC__
	#undef __V_GCC__
#endif
#ifdef __cplusplus
	#undef __V_GCC__
#endif
#ifdef __clang__
	#undef __V_GCC__
#endif
#ifdef _MSC_VER
	#undef __V_GCC__
	#undef EMPTY_STRUCT_INITIALIZATION
	#define EMPTY_STRUCT_INITIALIZATION 0
#endif

#ifdef __TINYC__
	#undef EMPTY_STRUCT_DECLARATION
	#define EMPTY_STRUCT_DECLARATION voidptr _dummy_pad
	#undef EMPTY_ARRAY_OF_ELEMS
	#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])
	#undef __NOINLINE
	#undef __IRQHANDLER
	// tcc does not support inlining at all
	#define __NOINLINE
	#define __IRQHANDLER
	#undef TCCSKIP
	#define TCCSKIP(x)
	// #include <byteswap.h>
	#ifndef _WIN32
		#include <execinfo.h>
		int tcc_backtrace(const char *fmt, ...);
	#endif
#endif

// Use __offsetof_ptr instead of __offset_of, when you *do* have a valid pointer, to avoid UB:
#ifndef __offsetof_ptr
	#define __offsetof_ptr(ptr,PTYPE,FIELDNAME) ((size_t)((byte *)&((PTYPE *)ptr)->FIELDNAME - (byte *)ptr))
#endif

// for __offset_of
#ifndef __offsetof
	#define __offsetof(PTYPE,FIELDNAME) ((size_t)((char *)&((PTYPE *)0)->FIELDNAME - (char *)0))
#endif

// returns the number of CPU registers that TYPE takes up
#define _REG_WIDTH(T) (((sizeof(T) + sizeof(void*) - 1) & ~(sizeof(void*) - 1)) / sizeof(void*))
// parameters of size <= 2 registers are spilled across those two registers; larger types are passed as one pointer to some stack location
#define _REG_WIDTH_BOUNDED(T) (_REG_WIDTH(T) <= 2 ? _REG_WIDTH(T) : 1)

#define OPTION_CAST(x) (x)

#ifndef V64_PRINTFORMAT
	#ifdef PRIx64
		#define V64_PRINTFORMAT "0x%"PRIx64
	#elif defined(__WIN32__)
		#define V64_PRINTFORMAT "0x%I64x"
	#elif defined(__linux__) && defined(__LP64__)
		#define V64_PRINTFORMAT "0x%lx"
	#else
		#define V64_PRINTFORMAT "0x%llx"
	#endif
#endif

#if defined(_WIN32) || defined(__CYGWIN__)
	#define VV_EXPORTED_SYMBOL extern __declspec(dllexport)
	#define VV_LOCAL_SYMBOL static
#else
	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,
	// and does not support __has_attribute(visibility) ...
	#ifndef __has_attribute
		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.
	#endif
	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))
		#ifdef ARM
			#define VV_EXPORTED_SYMBOL  extern __attribute__((externally_visible,visibility("default")))
		#else
			#define VV_EXPORTED_SYMBOL  extern __attribute__((visibility("default")))
		#endif
		#if defined(__clang__) && (defined(_VUSECACHE) || defined(_VBUILDMODULE))
			#define VV_LOCAL_SYMBOL static
		#else
			#define VV_LOCAL_SYMBOL  __attribute__ ((visibility ("hidden")))
		#endif
	#else
		#define VV_EXPORTED_SYMBOL extern
		#define VV_LOCAL_SYMBOL static
	#endif
#endif

#ifdef __cplusplus
	#include <utility>
	#define _MOV std::move
#else
	#define _MOV
#endif

// tcc does not support has_include properly yet, turn it off completely
#if defined(__TINYC__) && defined(__has_include)
#undef __has_include
#endif


#if !defined(VWEAK)
	#define VWEAK __attribute__((weak))
	#ifdef _MSC_VER
		#undef VWEAK
		#define VWEAK
	#endif
#endif

#if !defined(VNORETURN)
	#if defined(__TINYC__)
		#include <stdnoreturn.h>
		#define VNORETURN noreturn
	#endif
	# if !defined(__TINYC__) && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
	#  define VNORETURN _Noreturn
	# elif defined(__GNUC__) && __GNUC__ >= 2
	#  define VNORETURN __attribute__((noreturn))
	# endif
	#ifndef VNORETURN
		#define VNORETURN
	#endif
#endif

#if !defined(VUNREACHABLE)
	#if defined(__GNUC__) && !defined(__clang__)
		#define V_GCC_VERSION  (__GNUC__ * 10000L + __GNUC_MINOR__ * 100L + __GNUC_PATCHLEVEL__)
		#if (V_GCC_VERSION >= 40500L)
			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#if defined(__clang__) && defined(__has_builtin)
		#if __has_builtin(__builtin_unreachable)
			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#ifndef VUNREACHABLE
		#define VUNREACHABLE() do { } while (0)
	#endif
	#if defined(__FreeBSD__) && defined(__TINYC__)
		#define VUNREACHABLE() do { } while (0)
	#endif
#endif

//likely and unlikely macros
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
	#define _likely_(x)  __builtin_expect(x,1)
	#define _unlikely_(x)  __builtin_expect(x,0)
#else
	#define _likely_(x) (x)
	#define _unlikely_(x) (x)
#endif


// c_headers
typedef int (*qsort_callback_func)(const void*, const void*);
#include <stdio.h>  // TODO remove all these includes, define all function signatures and types manually
#include <stdlib.h>
#include <string.h>

#ifndef _WIN32
	#if defined __has_include
		#if __has_include (<execinfo.h>)
			#include <execinfo.h>
		#else
			// Most probably musl OR __ANDROID__ ...
			int backtrace (void **__array, int __size) { return 0; }
			char **backtrace_symbols (void *const *__array, int __size){ return 0; }
			void backtrace_symbols_fd (void *const *__array, int __size, int __fd){}
		#endif
	#endif
#endif

#include <stdarg.h> // for va_list

//================================== GLOBALS =================================*/
int load_so(byteptr);
void _vinit(int ___argc, voidptr ___argv);
void _vcleanup(void);
#define sigaction_size sizeof(sigaction);
#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )

void v_free(voidptr ptr);
voidptr memdup(voidptr src, int sz);

#if INTPTR_MAX == INT32_MAX
	#define TARGET_IS_32BIT 1
#elif INTPTR_MAX == INT64_MAX
	#define TARGET_IS_64BIT 1
#else
	#error "The environment is not 32 or 64-bit."
#endif

#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)
	#define TARGET_ORDER_IS_BIG 1
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_X64) || defined(_M_IX86)
	#define TARGET_ORDER_IS_LITTLE 1
#else
	#error "Unknown architecture endianness"
#endif

#ifndef _WIN32
	#include <ctype.h>
	#include <locale.h> // tolower
	#include <sys/time.h>
	#include <unistd.h> // sleep
	extern char **environ;
#endif

#if defined(__CYGWIN__) && !defined(_WIN32)
	#error Cygwin is not supported, please use MinGW or Visual Studio.
#endif

#if defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__vinix__) || defined(__serenity__) || defined(__sun)
	#include <sys/types.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __OpenBSD__
	#include <sys/types.h>
	#include <sys/resource.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __NetBSD__
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef _WIN32
	#define WINVER 0x0600
	#ifdef _WIN32_WINNT
		#undef _WIN32_WINNT
	#endif
	#define _WIN32_WINNT 0x0600
	#ifndef WIN32_FULL
	#define WIN32_LEAN_AND_MEAN
	#endif
	#ifndef _UNICODE
	#define _UNICODE
	#endif
	#ifndef UNICODE
	#define UNICODE
	#endif
	#include <windows.h>

	#include <io.h> // _waccess
	#include <direct.h> // _wgetcwd
	#include <signal.h> // signal and SIGSEGV for segmentation fault handler

	#ifdef _MSC_VER
		// On MSVC these are the same (as long as /volatile:ms is passed)
		#define _Atomic volatile

		// MSVC cannot parse some things properly
		#undef EMPTY_STRUCT_DECLARATION
		#undef OPTION_CAST

		#define EMPTY_STRUCT_DECLARATION voidptr _dummy_pad
		#define OPTION_CAST(x)
		#undef __NOINLINE
		#undef __IRQHANDLER
		#define __NOINLINE __declspec(noinline)
		#define __IRQHANDLER __declspec(naked)

		#include <dbghelp.h>
		#pragma comment(lib, "Dbghelp")
	#endif
#else
	#include <pthread.h>
	#ifndef PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
		// musl does not have that
		#define pthread_rwlockattr_setkind_np(a, b)
	#endif
#endif

// g_live_info is used by live.info()
static void* g_live_info = NULL;

#if defined(__MINGW32__) || defined(__MINGW64__) || (defined(_WIN32) && defined(__TINYC__))
	#undef PRId64
	#undef PRIi64
	#undef PRIo64
	#undef PRIu64
	#undef PRIx64
	#undef PRIX64
	#define PRId64 "lld"
	#define PRIi64 "lli"
	#define PRIo64 "llo"
	#define PRIu64 "llu"
	#define PRIx64 "llx"
	#define PRIX64 "llX"
#endif

#ifdef _VFREESTANDING
#undef _VFREESTANDING
#endif


// ============== wyhash ==============
#ifndef wyhash_final_version_3
#define wyhash_final_version_3

#ifndef WYHASH_CONDOM
// protections that produce different results:
// 1: normal valid behavior
// 2: extra protection against entropy loss (probability=2^-63), aka. "blind multiplication"
#define WYHASH_CONDOM 1
#endif

#ifndef WYHASH_32BIT_MUM
// 0: normal version, slow on 32 bit systems
// 1: faster on 32 bit systems but produces different results, incompatible with wy2u0k function
#define WYHASH_32BIT_MUM 0
#endif

// includes
#include <stdint.h>
#if defined(_MSC_VER) && defined(_M_X64)
	#include <intrin.h>
	#pragma intrinsic(_umul128)
#endif

// 128bit multiply function
static inline uint64_t _wyrot(uint64_t x) { return (x>>32)|(x<<32); }
static inline void _wymum(uint64_t *A, uint64_t *B){
#if(WYHASH_32BIT_MUM)
	uint64_t hh=(*A>>32)*(*B>>32), hl=(*A>>32)*(uint32_t)*B, lh=(uint32_t)*A*(*B>>32), ll=(uint64_t)(uint32_t)*A*(uint32_t)*B;
	#if(WYHASH_CONDOM>1)
	*A^=_wyrot(hl)^hh; *B^=_wyrot(lh)^ll;
	#else
	*A=_wyrot(hl)^hh; *B=_wyrot(lh)^ll;
	#endif
#elif defined(__SIZEOF_INT128__) && !defined(VWASM)
	__uint128_t r=*A; r*=*B;
	#if(WYHASH_CONDOM>1)
	*A^=(uint64_t)r; *B^=(uint64_t)(r>>64);
	#else
	*A=(uint64_t)r; *B=(uint64_t)(r>>64);
	#endif
#elif defined(_MSC_VER) && defined(_M_X64)
	#if(WYHASH_CONDOM>1)
	uint64_t  a,  b;
	a=_umul128(*A,*B,&b);
	*A^=a;  *B^=b;
	#else
	*A=_umul128(*A,*B,B);
	#endif
#else
	uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;
	uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
	lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
	#if(WYHASH_CONDOM>1)
	*A^=lo;  *B^=hi;
	#else
	*A=lo;  *B=hi;
	#endif
#endif
}

// multiply and xor mix function, aka MUM
static inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&A,&B); return A^B; }

// endian macros
#ifndef WYHASH_LITTLE_ENDIAN
	#ifdef TARGET_ORDER_IS_LITTLE
		#define WYHASH_LITTLE_ENDIAN 1
	#else
		#define WYHASH_LITTLE_ENDIAN 0
	#endif
#endif

// read functions
#if (WYHASH_LITTLE_ENDIAN)
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return v;}
#elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return __builtin_bswap32(v);}
#elif defined(_MSC_VER)
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return _byteswap_ulong(v);}
#else
	static inline uint64_t _wyr8(const uint8_t *p) {
		uint64_t v; memcpy(&v, p, 8);
		return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000)| ((v << 24) & 0xff0000000000)| ((v << 40) & 0xff000000000000)| ((v << 56) & 0xff00000000000000));
	}
	static inline uint64_t _wyr4(const uint8_t *p) {
		uint32_t v; memcpy(&v, p, 4);
		return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));
	}
#endif
static inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];}
// wyhash main function
static inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){
	const uint8_t *p=(const uint8_t *)key; seed^=*secret;	uint64_t a, b;
	if (_likely_(len<=16)) {
		if (_likely_(len>=4)) { a=(_wyr4(p)<<32)|_wyr4(p+((len>>3)<<2)); b=(_wyr4(p+len-4)<<32)|_wyr4(p+len-4-((len>>3)<<2)); }
		else if (_likely_(len>0)) { a=_wyr3(p,len); b=0; }
		else a=b=0;
	} else {
		size_t i=len;
		if (_unlikely_(i>48)) {
			uint64_t see1=seed, see2=seed;
			do {
				seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);
				see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);
				see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);
				p+=48; i-=48;
			} while(_likely_(i>48));
			seed^=see1^see2;
		}
		while(_unlikely_(i>16)) { seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);  i-=16; p+=16; }
		a=_wyr8(p+i-16);  b=_wyr8(p+i-8);
	}
	return _wymix(secret[1]^len,_wymix(a^secret[1],b^seed));
}
// the default secret parameters
static const uint64_t _wyp[4] = {0xa0761d6478bd642full, 0xe7037ed1a0b428dbull, 0x8ebc6af09c88c6e3ull, 0x589965cc75374cc3ull};

// a useful 64bit-64bit mix function to produce deterministic pseudo random numbers that can pass BigCrush and PractRand
static inline uint64_t wyhash64(uint64_t A, uint64_t B){ A^=0xa0761d6478bd642full; B^=0xe7037ed1a0b428dbull; _wymum(&A,&B); return _wymix(A^0xa0761d6478bd642full,B^0xe7037ed1a0b428dbull);}

// the wyrand PRNG that pass BigCrush and PractRand
static inline uint64_t wyrand(uint64_t *seed){ *seed+=0xa0761d6478bd642full; return _wymix(*seed,*seed^0xe7037ed1a0b428dbull);}

#ifndef __vinix__
// convert any 64 bit pseudo random numbers to uniform distribution [0,1). It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2u01(uint64_t r){ const double _wynorm=1.0/(1ull<<52); return (r>>12)*_wynorm;}

// convert any 64 bit pseudo random numbers to APPROXIMATE Gaussian distribution. It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2gau(uint64_t r){ const double _wynorm=1.0/(1ull<<20); return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;}
#endif

#if(!WYHASH_32BIT_MUM)
// fast range integer random number generation on [0,k) credit to Daniel Lemire. May not work when WYHASH_32BIT_MUM=1. It can be combined with wyrand, wyhash64 or wyhash.
static inline uint64_t wy2u0k(uint64_t r, uint64_t k){ _wymum(&r,&k); return k; }
#endif
#endif

#define _IN_MAP(val, m) map_exists(m, val)



// V includes:

	#if defined(__TINYC__) && defined(__has_include)
	// tcc does not support has_include properly yet, turn it off completely
	#undef __has_include
	#endif


// added by module `builtin`

#if defined(__has_include)

#if __has_include(<float.h>)
#include <float.h>
#else
#error VERROR_MESSAGE Header file <float.h>, needed for module `builtin` was not found. Please install the corresponding development headers.
#endif

#else
#include <float.h>
#endif





// added by module `os`

#if defined(__has_include)

#if __has_include(<sys/stat.h>)
#include <sys/stat.h>
#else
#error VERROR_MESSAGE Header file <sys/stat.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/stat.h>
#endif





// added by module `os`
#include <errno.h>




// added by module `os`

#if defined(__has_include)

#if __has_include(<dirent.h>)
#include <dirent.h>
#else
#error VERROR_MESSAGE Header file <dirent.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <dirent.h>
#endif





// added by module `os`

#if defined(__has_include)

#if __has_include(<unistd.h>)
#include <unistd.h>
#else
#error VERROR_MESSAGE Header file <unistd.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <unistd.h>
#endif





// added by module `os`

#if defined(__has_include)

#if __has_include(<fcntl.h>)
#include <fcntl.h>
#else
#error VERROR_MESSAGE Header file <fcntl.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <fcntl.h>
#endif





// added by module `os`

#if defined(__has_include)

#if __has_include(<sys/utsname.h>)
#include <sys/utsname.h>
#else
#error VERROR_MESSAGE Header file <sys/utsname.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/utsname.h>
#endif





// added by module `os`

#if defined(__has_include)

#if __has_include(<sys/types.h>)
#include <sys/types.h>
#else
#error VERROR_MESSAGE Header file <sys/types.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/types.h>
#endif





// added by module `os`

#if defined(__has_include)

#if __has_include(<utime.h>)
#include <utime.h>
#else
#error VERROR_MESSAGE Header file <utime.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <utime.h>
#endif





// added by module `os`

#if defined(__has_include)

#if __has_include(<sys/ptrace.h>)
#include <sys/ptrace.h>
#else
#error VERROR_MESSAGE Header file <sys/ptrace.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/ptrace.h>
#endif





// added by module `os`

#if defined(__has_include)

#if __has_include(<signal.h>)
#include <signal.h>
#else
#error VERROR_MESSAGE Header file <signal.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <signal.h>
#endif





// added by module `time`

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif





// added by module `time`

#if defined(__has_include)

#if __has_include(<mach/mach_time.h>)
#include <mach/mach_time.h>
#else
#error VERROR_MESSAGE Header file <mach/mach_time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <mach/mach_time.h>
#endif





// added by module `time`

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif





// added by module `time`
#include <errno.h>




// added by module `clipboard`

#if defined(__has_include)

#if __has_include(<libkern/OSAtomic.h>)
#include <libkern/OSAtomic.h>
#else
#error VERROR_MESSAGE Header file <libkern/OSAtomic.h>, needed for module `clipboard` was not found. Please install the corresponding development headers.
#endif

#else
#include <libkern/OSAtomic.h>
#endif





// added by module `clipboard`

#if defined(__has_include)

#if __has_include(<Cocoa/Cocoa.h>)
#include <Cocoa/Cocoa.h>
#else
#error VERROR_MESSAGE Header file <Cocoa/Cocoa.h>, needed for module `clipboard` was not found. Please install the corresponding development headers.
#endif

#else
#include <Cocoa/Cocoa.h>
#endif



// defined by module `fontstash`
#define FONTSTASH_IMPLEMENTATION


// added by module `fontstash`

#if defined(__has_include)

#if __has_include("fontstash.h")
#include "fontstash.h"
#else
#error VERROR_MESSAGE Header file "fontstash.h", needed for module `fontstash` was not found. Please install the corresponding development headers.
#endif

#else
#include "fontstash.h"
#endif





// added by module `stbi`

#if defined(__has_include)

#if __has_include(<math.h>)
#include <math.h>
#else
#error VERROR_MESSAGE Header file <math.h>, needed for module `stbi` was not found. Please install the corresponding development headers.
#endif

#else
#include <math.h>
#endif





// added by module `stbi`

#if defined(__has_include)

#if __has_include("stb_image.h")
#include "stb_image.h"
#else
#error VERROR_MESSAGE Header file "stb_image.h", needed for module `stbi` was not found. Please install the corresponding development headers.
#endif

#else
#include "stb_image.h"
#endif





// added by module `stbi`

#if defined(__has_include)

#if __has_include("stb_image_write.h")
#include "stb_image_write.h"
#else
#error VERROR_MESSAGE Header file "stb_image_write.h", needed for module `stbi` was not found. Please install the corresponding development headers.
#endif

#else
#include "stb_image_write.h"
#endif





// added by module `stbi`

#if defined(__has_include)

#if __has_include("stb_v_header.h")
#include "stb_v_header.h"
#else
#error VERROR_MESSAGE Header file "stb_v_header.h", needed for module `stbi` was not found. Please install the corresponding development headers.
#endif

#else
#include "stb_v_header.h"
#endif



// defined by module `sokol.c`
#define SOKOL_IMPL


// added by module `sokol.c`

#if defined(__has_include)

#if __has_include("sokol_v.pre.h")
#include "sokol_v.pre.h"
#else
#error VERROR_MESSAGE Header file "sokol_v.pre.h", needed for module `sokol.c` was not found. Please install the corresponding development headers.
#endif

#else
#include "sokol_v.pre.h"
#endif





// added by module `sokol.c`

#if defined(__has_include)

#if __has_include("sokol_app.h")
#include "sokol_app.h"
#else
#error VERROR_MESSAGE Header file "sokol_app.h", needed for module `sokol.c` was not found. Please install the corresponding development headers.
#endif

#else
#include "sokol_app.h"
#endif



// defined by module `sokol.c`
#define SOKOL_IMPL
// defined by module `sokol.c`
#define SOKOL_NO_DEPRECATED


// added by module `sokol.c`

#if defined(__has_include)

#if __has_include("sokol_gfx.h")
#include "sokol_gfx.h"
#else
#error VERROR_MESSAGE Header file "sokol_gfx.h", needed for module `sokol.c` was not found. Please install the corresponding development headers.
#endif

#else
#include "sokol_gfx.h"
#endif



// defined by module `sokol.c`
#define SOKOL_GL_IMPL


// added by module `sokol.c`

#if defined(__has_include)

#if __has_include("util/sokol_gl.h")
#include "util/sokol_gl.h"
#else
#error VERROR_MESSAGE Header file "util/sokol_gl.h", needed for module `sokol.c` was not found. Please install the corresponding development headers.
#endif

#else
#include "util/sokol_gl.h"
#endif





// added by module `sokol.c`

#if defined(__has_include)

#if __has_include("sokol_v.post.h")
#include "sokol_v.post.h"
#else
#error VERROR_MESSAGE Header file "sokol_v.post.h", needed for module `sokol.c` was not found. Please install the corresponding development headers.
#endif

#else
#include "sokol_v.post.h"
#endif





// added by module `math`

#if defined(__has_include)

#if __has_include(<math.h>)
#include <math.h>
#else
#error VERROR_MESSAGE Header file <math.h>, needed for module `math` was not found. Please install the corresponding development headers.
#endif

#else
#include <math.h>
#endif



// defined by module `sokol.f`
#define SOKOL_FONTSTASH_IMPL


// added by module `sokol.f`

#if defined(__has_include)

#if __has_include("util/sokol_fontstash.h")
#include "util/sokol_fontstash.h"
#else
#error VERROR_MESSAGE Header file "util/sokol_fontstash.h", needed for module `sokol.f` was not found. Please install the corresponding development headers.
#endif

#else
#include "util/sokol_fontstash.h"
#endif



// defined by module `ui`
#define objc_msg ((id (*)(id, SEL, ...))objc_msgSend)
// defined by module `ui`
#define objc_cls_msg ((id (*)(Class, SEL, ...))objc_msgSend)

// Enum definitions:
typedef enum {
	strconv__ParserState__ok, // 
	strconv__ParserState__pzero, // +1
	strconv__ParserState__mzero, // +2
	strconv__ParserState__pinf, // +3
	strconv__ParserState__minf, // +4
	strconv__ParserState__invalid_number, // +5
} strconv__ParserState;

typedef enum {
	strconv__Align_text__right = 0, // 0
	strconv__Align_text__left, // 0+1
	strconv__Align_text__center, // 0+2
} strconv__Align_text;

typedef enum {
	strconv__Char_parse_state__start, // 
	strconv__Char_parse_state__norm_char, // +1
	strconv__Char_parse_state__field_char, // +2
	strconv__Char_parse_state__pad_ch, // +3
	strconv__Char_parse_state__len_set_start, // +4
	strconv__Char_parse_state__len_set_in, // +5
	strconv__Char_parse_state__check_type, // +6
	strconv__Char_parse_state__check_float, // +7
	strconv__Char_parse_state__check_float_in, // +8
	strconv__Char_parse_state__reset_params, // +9
} strconv__Char_parse_state;

typedef enum {
	ArrayFlags__noslices = 1, // 1 << 0
	ArrayFlags__noshrink = 2, // 1 << 1
} ArrayFlags;

typedef enum {
	AttributeKind__plain, // 
	AttributeKind__string, // +1
	AttributeKind__number, // +2
	AttributeKind__comptime_define, // +3
} AttributeKind;

typedef enum {
	ChanState__success, // 
	ChanState__not_ready, // +1
	ChanState__closed, // +2
} ChanState;

typedef enum {
	StrIntpType__si_no_str = 0, // 0
	StrIntpType__si_c, // 0+1
	StrIntpType__si_u8, // 0+2
	StrIntpType__si_i8, // 0+3
	StrIntpType__si_u16, // 0+4
	StrIntpType__si_i16, // 0+5
	StrIntpType__si_u32, // 0+6
	StrIntpType__si_i32, // 0+7
	StrIntpType__si_u64, // 0+8
	StrIntpType__si_i64, // 0+9
	StrIntpType__si_e32, // 0+10
	StrIntpType__si_e64, // 0+11
	StrIntpType__si_f32, // 0+12
	StrIntpType__si_f64, // 0+13
	StrIntpType__si_g32, // 0+14
	StrIntpType__si_g64, // 0+15
	StrIntpType__si_s, // 0+16
	StrIntpType__si_p, // 0+17
	StrIntpType__si_vp, // 0+18
} StrIntpType;

typedef enum {
	os__SeekMode__start, // 
	os__SeekMode__current, // +1
	os__SeekMode__end, // +2
} os__SeekMode;

typedef enum {
	os__FileType__regular, // 
	os__FileType__directory, // +1
	os__FileType__character_device, // +2
	os__FileType__block_device, // +3
	os__FileType__fifo, // +4
	os__FileType__symbolic_link, // +5
	os__FileType__socket, // +6
} os__FileType;

typedef enum {
	os__GlobMatch__exact, // 
	os__GlobMatch__ends_with, // +1
	os__GlobMatch__starts_with, // +2
	os__GlobMatch__start_and_ends_with, // +3
	os__GlobMatch__contains, // +4
	os__GlobMatch__any, // +5
} os__GlobMatch;

typedef enum {
	os__ProcessState__not_started, // 
	os__ProcessState__running, // +1
	os__ProcessState__stopped, // +2
	os__ProcessState__exited, // +3
	os__ProcessState__aborted, // +4
	os__ProcessState__closed, // +5
} os__ProcessState;

typedef enum {
	os__Signal__hup = 1, // 1
	os__Signal__int = 2, // 2
	os__Signal__quit = 3, // 3
	os__Signal__ill = 4, // 4
	os__Signal__trap = 5, // 5
	os__Signal__abrt = 6, // 6
	os__Signal__bus = 7, // 7
	os__Signal__fpe = 8, // 8
	os__Signal__kill = 9, // 9
	os__Signal__usr1 = 10, // 10
	os__Signal__segv = 11, // 11
	os__Signal__usr2 = 12, // 12
	os__Signal__pipe = 13, // 13
	os__Signal__alrm = 14, // 14
	os__Signal__term = 15, // 15
	os__Signal__stkflt = 16, // 16
	os__Signal__chld = 17, // 17
	os__Signal__cont = 18, // 18
	os__Signal__stop = 19, // 19
	os__Signal__tstp = 20, // 20
	os__Signal__ttin = 21, // 21
	os__Signal__ttou = 22, // 22
	os__Signal__urg = 23, // 23
	os__Signal__xcpu = 24, // 24
	os__Signal__xfsz = 25, // 25
	os__Signal__vtalrm = 26, // 26
	os__Signal__prof = 27, // 27
	os__Signal__winch = 28, // 28
	os__Signal__poll = 29, // 29
	os__Signal__pwr = 30, // 30
	os__Signal__sys = 31, // 31
} os__Signal;

typedef enum {
	time__FormatTime__hhmm12, // 
	time__FormatTime__hhmm24, // +1
	time__FormatTime__hhmmss12, // +2
	time__FormatTime__hhmmss24, // +3
	time__FormatTime__hhmmss24_milli, // +4
	time__FormatTime__hhmmss24_micro, // +5
	time__FormatTime__no_time, // +6
} time__FormatTime;

typedef enum {
	time__FormatDate__ddmmyy, // 
	time__FormatDate__ddmmyyyy, // +1
	time__FormatDate__mmddyy, // +2
	time__FormatDate__mmddyyyy, // +3
	time__FormatDate__mmmd, // +4
	time__FormatDate__mmmdd, // +5
	time__FormatDate__mmmddyy, // +6
	time__FormatDate__mmmddyyyy, // +7
	time__FormatDate__no_date, // +8
	time__FormatDate__yyyymmdd, // +9
	time__FormatDate__yymmdd, // +10
} time__FormatDate;

typedef enum {
	time__FormatDelimiter__dot, // 
	time__FormatDelimiter__hyphen, // +1
	time__FormatDelimiter__slash, // +2
	time__FormatDelimiter__space, // +3
	time__FormatDelimiter__no_delimiter, // +4
} time__FormatDelimiter;

typedef enum {
	fontstash__Flags__top_left = 1, // 1 << 0
	fontstash__Flags__bottom_left = 2, // 1 << 1
} fontstash__Flags;

typedef enum {
	fontstash__Align__left = 1, // 1 << 0
	fontstash__Align__center = 2, // 1 << 1
	fontstash__Align__right = 4, // 1 << 2
	fontstash__Align__top = 8, // 1 << 3
	fontstash__Align__middle = 16, // 1 << 4
	fontstash__Align__bottom = 32, // 1 << 5
	fontstash__Align__baseline = 64, // 1 << 6
} fontstash__Align;

typedef enum {
	fontstash__ErrorCode__atlas_full = 1, // 1
	fontstash__ErrorCode__scratch_full = 2, // 2
	fontstash__ErrorCode__states_overflow = 3, // 3
	fontstash__ErrorCode__states_underflow = 4, // 4
} fontstash__ErrorCode;

typedef enum {
	gx__HorizontalAlign__left = FONS_ALIGN_LEFT, // FONS_ALIGN_LEFT
	gx__HorizontalAlign__center = FONS_ALIGN_CENTER, // FONS_ALIGN_CENTER
	gx__HorizontalAlign__right = FONS_ALIGN_RIGHT, // FONS_ALIGN_RIGHT
} gx__HorizontalAlign;

typedef enum {
	gx__VerticalAlign__top = FONS_ALIGN_TOP, // FONS_ALIGN_TOP
	gx__VerticalAlign__middle = FONS_ALIGN_MIDDLE, // FONS_ALIGN_MIDDLE
	gx__VerticalAlign__bottom = FONS_ALIGN_BOTTOM, // FONS_ALIGN_BOTTOM
	gx__VerticalAlign__baseline = FONS_ALIGN_BASELINE, // FONS_ALIGN_BASELINE
} gx__VerticalAlign;

typedef enum {
	os__font__Variant__normal = 0, // 0
	os__font__Variant__bold, // 0+1
	os__font__Variant__mono, // 0+2
	os__font__Variant__italic, // 0+3
} os__font__Variant;

typedef enum {
	sokol__gfx__Backend__glcore33, // 
	sokol__gfx__Backend__gles2, // +1
	sokol__gfx__Backend__gles3, // +2
	sokol__gfx__Backend__d3d11, // +3
	sokol__gfx__Backend__metal_ios, // +4
	sokol__gfx__Backend__metal_macos, // +5
	sokol__gfx__Backend__metal_simulator, // +6
	sokol__gfx__Backend__dummy, // +7
} sokol__gfx__Backend;

typedef enum {
	sokol__gfx__PixelFormat___default, // 
	sokol__gfx__PixelFormat__none, // +1
	sokol__gfx__PixelFormat__r8, // +2
	sokol__gfx__PixelFormat__r8sn, // +3
	sokol__gfx__PixelFormat__r8ui, // +4
	sokol__gfx__PixelFormat__r8si, // +5
	sokol__gfx__PixelFormat__r16, // +6
	sokol__gfx__PixelFormat__r16sn, // +7
	sokol__gfx__PixelFormat__r16ui, // +8
	sokol__gfx__PixelFormat__r16si, // +9
	sokol__gfx__PixelFormat__r16f, // +10
	sokol__gfx__PixelFormat__rg8, // +11
	sokol__gfx__PixelFormat__rg8sn, // +12
	sokol__gfx__PixelFormat__rg8ui, // +13
	sokol__gfx__PixelFormat__rg8si, // +14
	sokol__gfx__PixelFormat__r32ui, // +15
	sokol__gfx__PixelFormat__r32si, // +16
	sokol__gfx__PixelFormat__r32f, // +17
	sokol__gfx__PixelFormat__rg16, // +18
	sokol__gfx__PixelFormat__rg16sn, // +19
	sokol__gfx__PixelFormat__rg16ui, // +20
	sokol__gfx__PixelFormat__rg16si, // +21
	sokol__gfx__PixelFormat__rg16f, // +22
	sokol__gfx__PixelFormat__rgba8, // +23
	sokol__gfx__PixelFormat__rgba8sn, // +24
	sokol__gfx__PixelFormat__rgba8ui, // +25
	sokol__gfx__PixelFormat__rgba8si, // +26
	sokol__gfx__PixelFormat__bgra8, // +27
	sokol__gfx__PixelFormat__rgb10a2, // +28
	sokol__gfx__PixelFormat__rg11b10f, // +29
	sokol__gfx__PixelFormat__rg32ui, // +30
	sokol__gfx__PixelFormat__rg32si, // +31
	sokol__gfx__PixelFormat__rg32f, // +32
	sokol__gfx__PixelFormat__rgba16, // +33
	sokol__gfx__PixelFormat__rgba16sn, // +34
	sokol__gfx__PixelFormat__rgba16ui, // +35
	sokol__gfx__PixelFormat__rgba16si, // +36
	sokol__gfx__PixelFormat__rgba16f, // +37
	sokol__gfx__PixelFormat__rgba32ui, // +38
	sokol__gfx__PixelFormat__rgba32si, // +39
	sokol__gfx__PixelFormat__rgba32f, // +40
	sokol__gfx__PixelFormat__depth, // +41
	sokol__gfx__PixelFormat__depth_stencil, // +42
	sokol__gfx__PixelFormat__bc1_rgba, // +43
	sokol__gfx__PixelFormat__bc2_rgba, // +44
	sokol__gfx__PixelFormat__bc3_rgba, // +45
	sokol__gfx__PixelFormat__bc4_r, // +46
	sokol__gfx__PixelFormat__bc4_rsn, // +47
	sokol__gfx__PixelFormat__bc5_rg, // +48
	sokol__gfx__PixelFormat__bc5_rgsn, // +49
	sokol__gfx__PixelFormat__bc6h_rgbf, // +50
	sokol__gfx__PixelFormat__bc6h_rgbuf, // +51
	sokol__gfx__PixelFormat__bc7_rgba, // +52
	sokol__gfx__PixelFormat__pvrtc_rgb_2bpp, // +53
	sokol__gfx__PixelFormat__pvrtc_rgb_4bpp, // +54
	sokol__gfx__PixelFormat__pvrtc_rgba_2bpp, // +55
	sokol__gfx__PixelFormat__pvrtc_rgba_4bpp, // +56
	sokol__gfx__PixelFormat__etc2_rgb8, // +57
	sokol__gfx__PixelFormat__etc2_rgb8a1, // +58
	sokol__gfx__PixelFormat__etc2_rgba8, // +59
	sokol__gfx__PixelFormat__etc2_rg11, // +60
	sokol__gfx__PixelFormat__etc2_rg11sn, // +61
	sokol__gfx__PixelFormat___num, // +62
} sokol__gfx__PixelFormat;

typedef enum {
	sokol__gfx__ResourceState__initial, // 
	sokol__gfx__ResourceState__alloc, // +1
	sokol__gfx__ResourceState__valid, // +2
	sokol__gfx__ResourceState__failed, // +3
	sokol__gfx__ResourceState__invalid, // +4
} sokol__gfx__ResourceState;

typedef enum {
	sokol__gfx__Usage___default, // 
	sokol__gfx__Usage__immutable, // +1
	sokol__gfx__Usage__dynamic, // +2
	sokol__gfx__Usage__stream, // +3
	sokol__gfx__Usage___num, // +4
} sokol__gfx__Usage;

typedef enum {
	sokol__gfx__BufferType___default, // 
	sokol__gfx__BufferType__vertexbuffer, // +1
	sokol__gfx__BufferType__indexbuffer, // +2
	sokol__gfx__BufferType___num, // +3
} sokol__gfx__BufferType;

typedef enum {
	sokol__gfx__IndexType___default, // 
	sokol__gfx__IndexType__none, // +1
	sokol__gfx__IndexType__uint16, // +2
	sokol__gfx__IndexType__uint32, // +3
	sokol__gfx__IndexType___num, // +4
} sokol__gfx__IndexType;

typedef enum {
	sokol__gfx__ImageType___default, // 
	sokol__gfx__ImageType___2d, // +1
	sokol__gfx__ImageType__cube, // +2
	sokol__gfx__ImageType___3d, // +3
	sokol__gfx__ImageType__array, // +4
	sokol__gfx__ImageType___num, // +5
} sokol__gfx__ImageType;

typedef enum {
	sokol__gfx__CubeFace__pos_x, // 
	sokol__gfx__CubeFace__neg_x, // +1
	sokol__gfx__CubeFace__pos_y, // +2
	sokol__gfx__CubeFace__neg_y, // +3
	sokol__gfx__CubeFace__pos_z, // +4
	sokol__gfx__CubeFace__neg_z, // +5
	sokol__gfx__CubeFace__num, // +6
	sokol__gfx__CubeFace___force_u32 = 0x7fffffff, // 0x7fffffff
} sokol__gfx__CubeFace;

typedef enum {
	sokol__gfx__ShaderStage__vs, // 
	sokol__gfx__ShaderStage__fs, // +1
} sokol__gfx__ShaderStage;

typedef enum {
	sokol__gfx__PrimitiveType___default, // 
	sokol__gfx__PrimitiveType__points, // +1
	sokol__gfx__PrimitiveType__lines, // +2
	sokol__gfx__PrimitiveType__line_strip, // +3
	sokol__gfx__PrimitiveType__triangles, // +4
	sokol__gfx__PrimitiveType__triangle_strip, // +5
	sokol__gfx__PrimitiveType___num, // +6
} sokol__gfx__PrimitiveType;

typedef enum {
	sokol__gfx__Filter___default, // 
	sokol__gfx__Filter__nearest, // +1
	sokol__gfx__Filter__linear, // +2
	sokol__gfx__Filter__nearest_mipmap_nearest, // +3
	sokol__gfx__Filter__nearest_mipmap_linear, // +4
	sokol__gfx__Filter__linear_mipmap_nearest, // +5
	sokol__gfx__Filter__linear_mipmap_linear, // +6
	sokol__gfx__Filter___num, // +7
} sokol__gfx__Filter;

typedef enum {
	sokol__gfx__Wrap___default, // 
	sokol__gfx__Wrap__repeat, // +1
	sokol__gfx__Wrap__clamp_to_edge, // +2
	sokol__gfx__Wrap__clamp_to_border, // +3
	sokol__gfx__Wrap__mirrored_repeat, // +4
	sokol__gfx__Wrap___num, // +5
} sokol__gfx__Wrap;

typedef enum {
	sokol__gfx__BorderColor___default, // 
	sokol__gfx__BorderColor__transparent_black, // +1
	sokol__gfx__BorderColor__opaque_black, // +2
	sokol__gfx__BorderColor__opaque_white, // +3
	sokol__gfx__BorderColor___num, // +4
} sokol__gfx__BorderColor;

typedef enum {
	sokol__gfx__VertexFormat__invalid, // 
	sokol__gfx__VertexFormat__float, // +1
	sokol__gfx__VertexFormat__float2, // +2
	sokol__gfx__VertexFormat__float3, // +3
	sokol__gfx__VertexFormat__float4, // +4
	sokol__gfx__VertexFormat__byte4, // +5
	sokol__gfx__VertexFormat__byte4n, // +6
	sokol__gfx__VertexFormat__ubyte4, // +7
	sokol__gfx__VertexFormat__ubyte4n, // +8
	sokol__gfx__VertexFormat__short2, // +9
	sokol__gfx__VertexFormat__short2n, // +10
	sokol__gfx__VertexFormat__ushort2n, // +11
	sokol__gfx__VertexFormat__short4, // +12
	sokol__gfx__VertexFormat__short4n, // +13
	sokol__gfx__VertexFormat__ushort4n, // +14
	sokol__gfx__VertexFormat__uint10_n2, // +15
	sokol__gfx__VertexFormat___num, // +16
} sokol__gfx__VertexFormat;

typedef enum {
	sokol__gfx__VertexStep___default, // 
	sokol__gfx__VertexStep__per_vertex, // +1
	sokol__gfx__VertexStep__per_instance, // +2
	sokol__gfx__VertexStep___num, // +3
} sokol__gfx__VertexStep;

typedef enum {
	sokol__gfx__UniformType__invalid, // 
	sokol__gfx__UniformType__float, // +1
	sokol__gfx__UniformType__float2, // +2
	sokol__gfx__UniformType__float3, // +3
	sokol__gfx__UniformType__float4, // +4
	sokol__gfx__UniformType__mat4, // +5
	sokol__gfx__UniformType___num, // +6
} sokol__gfx__UniformType;

typedef enum {
	sokol__gfx__CullMode___default, // 
	sokol__gfx__CullMode__none, // +1
	sokol__gfx__CullMode__front, // +2
	sokol__gfx__CullMode__back, // +3
	sokol__gfx__CullMode___num, // +4
} sokol__gfx__CullMode;

typedef enum {
	sokol__gfx__FaceWinding___facewinding_default, // 
	sokol__gfx__FaceWinding__facewinding_ccw, // +1
	sokol__gfx__FaceWinding__facewinding_cw, // +2
	sokol__gfx__FaceWinding___facewinding_num, // +3
} sokol__gfx__FaceWinding;

typedef enum {
	sokol__gfx__CompareFunc___default, // 
	sokol__gfx__CompareFunc__never, // +1
	sokol__gfx__CompareFunc__less, // +2
	sokol__gfx__CompareFunc__equal, // +3
	sokol__gfx__CompareFunc__less_equal, // +4
	sokol__gfx__CompareFunc__greater, // +5
	sokol__gfx__CompareFunc__not_equal, // +6
	sokol__gfx__CompareFunc__greater_equal, // +7
	sokol__gfx__CompareFunc__always, // +8
	sokol__gfx__CompareFunc___num, // +9
} sokol__gfx__CompareFunc;

typedef enum {
	sokol__gfx__StencilOp___default, // 
	sokol__gfx__StencilOp__keep, // +1
	sokol__gfx__StencilOp__zero, // +2
	sokol__gfx__StencilOp__replace, // +3
	sokol__gfx__StencilOp__incr_clamp, // +4
	sokol__gfx__StencilOp__decr_clamp, // +5
	sokol__gfx__StencilOp__invert, // +6
	sokol__gfx__StencilOp__incr_wrap, // +7
	sokol__gfx__StencilOp__decr_wrap, // +8
	sokol__gfx__StencilOp___num, // +9
} sokol__gfx__StencilOp;

typedef enum {
	sokol__gfx__BlendFactor___default, // 
	sokol__gfx__BlendFactor__zero, // +1
	sokol__gfx__BlendFactor__one, // +2
	sokol__gfx__BlendFactor__src_color, // +3
	sokol__gfx__BlendFactor__one_minus_src_color, // +4
	sokol__gfx__BlendFactor__src_alpha, // +5
	sokol__gfx__BlendFactor__one_minus_src_alpha, // +6
	sokol__gfx__BlendFactor__dst_color, // +7
	sokol__gfx__BlendFactor__one_minus_dst_color, // +8
	sokol__gfx__BlendFactor__dst_alpha, // +9
	sokol__gfx__BlendFactor__one_minus_dst_alpha, // +10
	sokol__gfx__BlendFactor__src_alpha_saturated, // +11
	sokol__gfx__BlendFactor__blend_color, // +12
	sokol__gfx__BlendFactor__one_minus_blend_color, // +13
	sokol__gfx__BlendFactor__blend_alpha, // +14
	sokol__gfx__BlendFactor__one_minus_blend_alpha, // +15
	sokol__gfx__BlendFactor___num, // +16
} sokol__gfx__BlendFactor;

typedef enum {
	sokol__gfx__BlendOp___default, // 
	sokol__gfx__BlendOp__add, // +1
	sokol__gfx__BlendOp__subtract, // +2
	sokol__gfx__BlendOp__reverse_subtract, // +3
	sokol__gfx__BlendOp___num, // +4
} sokol__gfx__BlendOp;

typedef enum {
	sokol__gfx__ColorMask___default = 0, // 0
	sokol__gfx__ColorMask__none = 0x10, // 0x10
	sokol__gfx__ColorMask__r = 1, // 1
	sokol__gfx__ColorMask__g = 2, // 2
	sokol__gfx__ColorMask__b = 4, // 4
	sokol__gfx__ColorMask__a = 8, // 8
	sokol__gfx__ColorMask__rgb = 0x7, // 0x7
	sokol__gfx__ColorMask__rgba = 0xF, // 0xF
} sokol__gfx__ColorMask;

typedef enum {
	sokol__gfx__Action___default, // 
	sokol__gfx__Action__clear, // +1
	sokol__gfx__Action__load, // +2
	sokol__gfx__Action__dontcare, // +3
	sokol__gfx__Action___num, // +4
} sokol__gfx__Action;

typedef enum {
	sokol__gfx__UniformLayout__uniformlayout_default = 0, // 0
	sokol__gfx__UniformLayout__uniformlayout_native, // 0+1
	sokol__gfx__UniformLayout__uniformlayout_std140, // 0+2
	sokol__gfx__UniformLayout___num, // 0+3
} sokol__gfx__UniformLayout;

typedef enum {
	sokol__sgl__SglError__no_error = SGL_NO_ERROR, // SGL_NO_ERROR
	sokol__sgl__SglError__vertices_full = SGL_ERROR_VERTICES_FULL, // SGL_ERROR_VERTICES_FULL
	sokol__sgl__SglError__uniforms_full = SGL_ERROR_UNIFORMS_FULL, // SGL_ERROR_UNIFORMS_FULL
	sokol__sgl__SglError__commands_full = SGL_ERROR_COMMANDS_FULL, // SGL_ERROR_COMMANDS_FULL
	sokol__sgl__SglError__stack_overflow = SGL_ERROR_STACK_OVERFLOW, // SGL_ERROR_STACK_OVERFLOW
	sokol__sgl__SglError__stack_underfloat = SGL_ERROR_STACK_UNDERFLOW, // SGL_ERROR_STACK_UNDERFLOW
	sokol__sgl__SglError__no_context = SGL_ERROR_NO_CONTEXT, // SGL_ERROR_NO_CONTEXT
} sokol__sgl__SglError;

typedef enum {
	sokol__sapp__EventType__invalid, // 
	sokol__sapp__EventType__key_down, // +1
	sokol__sapp__EventType__key_up, // +2
	sokol__sapp__EventType__char, // +3
	sokol__sapp__EventType__mouse_down, // +4
	sokol__sapp__EventType__mouse_up, // +5
	sokol__sapp__EventType__mouse_scroll, // +6
	sokol__sapp__EventType__mouse_move, // +7
	sokol__sapp__EventType__mouse_enter, // +8
	sokol__sapp__EventType__mouse_leave, // +9
	sokol__sapp__EventType__touches_began, // +10
	sokol__sapp__EventType__touches_moved, // +11
	sokol__sapp__EventType__touches_ended, // +12
	sokol__sapp__EventType__touches_cancelled, // +13
	sokol__sapp__EventType__resized, // +14
	sokol__sapp__EventType__iconified, // +15
	sokol__sapp__EventType__restored, // +16
	sokol__sapp__EventType__focused, // +17
	sokol__sapp__EventType__unfocused, // +18
	sokol__sapp__EventType__suspended, // +19
	sokol__sapp__EventType__resumed, // +20
	sokol__sapp__EventType__update_cursor, // +21
	sokol__sapp__EventType__quit_requested, // +22
	sokol__sapp__EventType__clipboard_pasted, // +23
	sokol__sapp__EventType__files_droped, // +24
	sokol__sapp__EventType__num, // +25
} sokol__sapp__EventType;

typedef enum {
	sokol__sapp__MouseButton__invalid = -1, // -1
	sokol__sapp__MouseButton__left = 0, // 0
	sokol__sapp__MouseButton__right = 1, // 1
	sokol__sapp__MouseButton__middle = 2, // 2
} sokol__sapp__MouseButton;

typedef enum {
	sokol__sapp__Modifier__shift = 1, // 1
	sokol__sapp__Modifier__ctrl = 2, // 2
	sokol__sapp__Modifier__alt = 4, // 4
	sokol__sapp__Modifier__super = 8, // 8
	sokol__sapp__Modifier__lmb = 0x100, // 0x100
	sokol__sapp__Modifier__rmb = 0x200, // 0x200
	sokol__sapp__Modifier__mmb = 0x400, // 0x400
} sokol__sapp__Modifier;

typedef enum {
	sokol__sapp__KeyCode__invalid = 0, // 0
	sokol__sapp__KeyCode__space = 32, // 32
	sokol__sapp__KeyCode__apostrophe = 39, // 39
	sokol__sapp__KeyCode__comma = 44, // 44
	sokol__sapp__KeyCode__minus = 45, // 45
	sokol__sapp__KeyCode__period = 46, // 46
	sokol__sapp__KeyCode__slash = 47, // 47
	sokol__sapp__KeyCode___0 = 48, // 48
	sokol__sapp__KeyCode___1 = 49, // 49
	sokol__sapp__KeyCode___2 = 50, // 50
	sokol__sapp__KeyCode___3 = 51, // 51
	sokol__sapp__KeyCode___4 = 52, // 52
	sokol__sapp__KeyCode___5 = 53, // 53
	sokol__sapp__KeyCode___6 = 54, // 54
	sokol__sapp__KeyCode___7 = 55, // 55
	sokol__sapp__KeyCode___8 = 56, // 56
	sokol__sapp__KeyCode___9 = 57, // 57
	sokol__sapp__KeyCode__semicolon = 59, // 59
	sokol__sapp__KeyCode__equal = 61, // 61
	sokol__sapp__KeyCode__a = 65, // 65
	sokol__sapp__KeyCode__b = 66, // 66
	sokol__sapp__KeyCode__c = 67, // 67
	sokol__sapp__KeyCode__d = 68, // 68
	sokol__sapp__KeyCode__e = 69, // 69
	sokol__sapp__KeyCode__f = 70, // 70
	sokol__sapp__KeyCode__g = 71, // 71
	sokol__sapp__KeyCode__h = 72, // 72
	sokol__sapp__KeyCode__i = 73, // 73
	sokol__sapp__KeyCode__j = 74, // 74
	sokol__sapp__KeyCode__k = 75, // 75
	sokol__sapp__KeyCode__l = 76, // 76
	sokol__sapp__KeyCode__m = 77, // 77
	sokol__sapp__KeyCode__n = 78, // 78
	sokol__sapp__KeyCode__o = 79, // 79
	sokol__sapp__KeyCode__p = 80, // 80
	sokol__sapp__KeyCode__q = 81, // 81
	sokol__sapp__KeyCode__r = 82, // 82
	sokol__sapp__KeyCode__s = 83, // 83
	sokol__sapp__KeyCode__t = 84, // 84
	sokol__sapp__KeyCode__u = 85, // 85
	sokol__sapp__KeyCode__v = 86, // 86
	sokol__sapp__KeyCode__w = 87, // 87
	sokol__sapp__KeyCode__x = 88, // 88
	sokol__sapp__KeyCode__y = 89, // 89
	sokol__sapp__KeyCode__z = 90, // 90
	sokol__sapp__KeyCode__left_bracket = 91, // 91
	sokol__sapp__KeyCode__backslash = 92, // 92
	sokol__sapp__KeyCode__right_bracket = 93, // 93
	sokol__sapp__KeyCode__grave_accent = 96, // 96
	sokol__sapp__KeyCode__world_1 = 161, // 161
	sokol__sapp__KeyCode__world_2 = 162, // 162
	sokol__sapp__KeyCode__escape = 256, // 256
	sokol__sapp__KeyCode__enter = 257, // 257
	sokol__sapp__KeyCode__tab = 258, // 258
	sokol__sapp__KeyCode__backspace = 259, // 259
	sokol__sapp__KeyCode__insert = 260, // 260
	sokol__sapp__KeyCode__delete = 261, // 261
	sokol__sapp__KeyCode__right = 262, // 262
	sokol__sapp__KeyCode__left = 263, // 263
	sokol__sapp__KeyCode__down = 264, // 264
	sokol__sapp__KeyCode__up = 265, // 265
	sokol__sapp__KeyCode__page_up = 266, // 266
	sokol__sapp__KeyCode__page_down = 267, // 267
	sokol__sapp__KeyCode__home = 268, // 268
	sokol__sapp__KeyCode__end = 269, // 269
	sokol__sapp__KeyCode__caps_lock = 280, // 280
	sokol__sapp__KeyCode__scroll_lock = 281, // 281
	sokol__sapp__KeyCode__num_lock = 282, // 282
	sokol__sapp__KeyCode__print_screen = 283, // 283
	sokol__sapp__KeyCode__pause = 284, // 284
	sokol__sapp__KeyCode__f1 = 290, // 290
	sokol__sapp__KeyCode__f2 = 291, // 291
	sokol__sapp__KeyCode__f3 = 292, // 292
	sokol__sapp__KeyCode__f4 = 293, // 293
	sokol__sapp__KeyCode__f5 = 294, // 294
	sokol__sapp__KeyCode__f6 = 295, // 295
	sokol__sapp__KeyCode__f7 = 296, // 296
	sokol__sapp__KeyCode__f8 = 297, // 297
	sokol__sapp__KeyCode__f9 = 298, // 298
	sokol__sapp__KeyCode__f10 = 299, // 299
	sokol__sapp__KeyCode__f11 = 300, // 300
	sokol__sapp__KeyCode__f12 = 301, // 301
	sokol__sapp__KeyCode__f13 = 302, // 302
	sokol__sapp__KeyCode__f14 = 303, // 303
	sokol__sapp__KeyCode__f15 = 304, // 304
	sokol__sapp__KeyCode__f16 = 305, // 305
	sokol__sapp__KeyCode__f17 = 306, // 306
	sokol__sapp__KeyCode__f18 = 307, // 307
	sokol__sapp__KeyCode__f19 = 308, // 308
	sokol__sapp__KeyCode__f20 = 309, // 309
	sokol__sapp__KeyCode__f21 = 310, // 310
	sokol__sapp__KeyCode__f22 = 311, // 311
	sokol__sapp__KeyCode__f23 = 312, // 312
	sokol__sapp__KeyCode__f24 = 313, // 313
	sokol__sapp__KeyCode__f25 = 314, // 314
	sokol__sapp__KeyCode__kp_0 = 320, // 320
	sokol__sapp__KeyCode__kp_1 = 321, // 321
	sokol__sapp__KeyCode__kp_2 = 322, // 322
	sokol__sapp__KeyCode__kp_3 = 323, // 323
	sokol__sapp__KeyCode__kp_4 = 324, // 324
	sokol__sapp__KeyCode__kp_5 = 325, // 325
	sokol__sapp__KeyCode__kp_6 = 326, // 326
	sokol__sapp__KeyCode__kp_7 = 327, // 327
	sokol__sapp__KeyCode__kp_8 = 328, // 328
	sokol__sapp__KeyCode__kp_9 = 329, // 329
	sokol__sapp__KeyCode__kp_decimal = 330, // 330
	sokol__sapp__KeyCode__kp_divide = 331, // 331
	sokol__sapp__KeyCode__kp_multiply = 332, // 332
	sokol__sapp__KeyCode__kp_subtract = 333, // 333
	sokol__sapp__KeyCode__kp_add = 334, // 334
	sokol__sapp__KeyCode__kp_enter = 335, // 335
	sokol__sapp__KeyCode__kp_equal = 336, // 336
	sokol__sapp__KeyCode__left_shift = 340, // 340
	sokol__sapp__KeyCode__left_control = 341, // 341
	sokol__sapp__KeyCode__left_alt = 342, // 342
	sokol__sapp__KeyCode__left_super = 343, // 343
	sokol__sapp__KeyCode__right_shift = 344, // 344
	sokol__sapp__KeyCode__right_control = 345, // 345
	sokol__sapp__KeyCode__right_alt = 346, // 346
	sokol__sapp__KeyCode__right_super = 347, // 347
	sokol__sapp__KeyCode__menu = 348, // 348
} sokol__sapp__KeyCode;

typedef enum {
	gg__MouseButton__left = 0, // 0
	gg__MouseButton__right = 1, // 1
	gg__MouseButton__middle = 2, // 2
	gg__MouseButton__invalid = 256, // 256
} gg__MouseButton;

typedef enum {
	gg__MouseButtons__left = 1, // 1 << 0
	gg__MouseButtons__right = 2, // 1 << 1
	gg__MouseButtons__middle = 4, // 1 << 2
} gg__MouseButtons;

typedef enum {
	gg__Modifier__shift = 1, // 1 << 0
	gg__Modifier__ctrl = 2, // 1 << 1
	gg__Modifier__alt = 4, // 1 << 2
	gg__Modifier__super = 8, // 1 << 3
} gg__Modifier;

typedef enum {
	gg__PenLineType__solid, // 
	gg__PenLineType__dashed, // +1
	gg__PenLineType__dotted, // +2
} gg__PenLineType;

typedef enum {
	gg__KeyCode__invalid = 0, // 0
	gg__KeyCode__space = 32, // 32
	gg__KeyCode__apostrophe = 39, // 39
	gg__KeyCode__comma = 44, // 44
	gg__KeyCode__minus = 45, // 45
	gg__KeyCode__period = 46, // 46
	gg__KeyCode__slash = 47, // 47
	gg__KeyCode___0 = 48, // 48
	gg__KeyCode___1 = 49, // 49
	gg__KeyCode___2 = 50, // 50
	gg__KeyCode___3 = 51, // 51
	gg__KeyCode___4 = 52, // 52
	gg__KeyCode___5 = 53, // 53
	gg__KeyCode___6 = 54, // 54
	gg__KeyCode___7 = 55, // 55
	gg__KeyCode___8 = 56, // 56
	gg__KeyCode___9 = 57, // 57
	gg__KeyCode__semicolon = 59, // 59
	gg__KeyCode__equal = 61, // 61
	gg__KeyCode__a = 65, // 65
	gg__KeyCode__b = 66, // 66
	gg__KeyCode__c = 67, // 67
	gg__KeyCode__d = 68, // 68
	gg__KeyCode__e = 69, // 69
	gg__KeyCode__f = 70, // 70
	gg__KeyCode__g = 71, // 71
	gg__KeyCode__h = 72, // 72
	gg__KeyCode__i = 73, // 73
	gg__KeyCode__j = 74, // 74
	gg__KeyCode__k = 75, // 75
	gg__KeyCode__l = 76, // 76
	gg__KeyCode__m = 77, // 77
	gg__KeyCode__n = 78, // 78
	gg__KeyCode__o = 79, // 79
	gg__KeyCode__p = 80, // 80
	gg__KeyCode__q = 81, // 81
	gg__KeyCode__r = 82, // 82
	gg__KeyCode__s = 83, // 83
	gg__KeyCode__t = 84, // 84
	gg__KeyCode__u = 85, // 85
	gg__KeyCode__v = 86, // 86
	gg__KeyCode__w = 87, // 87
	gg__KeyCode__x = 88, // 88
	gg__KeyCode__y = 89, // 89
	gg__KeyCode__z = 90, // 90
	gg__KeyCode__left_bracket = 91, // 91
	gg__KeyCode__backslash = 92, // 92
	gg__KeyCode__right_bracket = 93, // 93
	gg__KeyCode__grave_accent = 96, // 96
	gg__KeyCode__world_1 = 161, // 161
	gg__KeyCode__world_2 = 162, // 162
	gg__KeyCode__escape = 256, // 256
	gg__KeyCode__enter = 257, // 257
	gg__KeyCode__tab = 258, // 258
	gg__KeyCode__backspace = 259, // 259
	gg__KeyCode__insert = 260, // 260
	gg__KeyCode__delete = 261, // 261
	gg__KeyCode__right = 262, // 262
	gg__KeyCode__left = 263, // 263
	gg__KeyCode__down = 264, // 264
	gg__KeyCode__up = 265, // 265
	gg__KeyCode__page_up = 266, // 266
	gg__KeyCode__page_down = 267, // 267
	gg__KeyCode__home = 268, // 268
	gg__KeyCode__end = 269, // 269
	gg__KeyCode__caps_lock = 280, // 280
	gg__KeyCode__scroll_lock = 281, // 281
	gg__KeyCode__num_lock = 282, // 282
	gg__KeyCode__print_screen = 283, // 283
	gg__KeyCode__pause = 284, // 284
	gg__KeyCode__f1 = 290, // 290
	gg__KeyCode__f2 = 291, // 291
	gg__KeyCode__f3 = 292, // 292
	gg__KeyCode__f4 = 293, // 293
	gg__KeyCode__f5 = 294, // 294
	gg__KeyCode__f6 = 295, // 295
	gg__KeyCode__f7 = 296, // 296
	gg__KeyCode__f8 = 297, // 297
	gg__KeyCode__f9 = 298, // 298
	gg__KeyCode__f10 = 299, // 299
	gg__KeyCode__f11 = 300, // 300
	gg__KeyCode__f12 = 301, // 301
	gg__KeyCode__f13 = 302, // 302
	gg__KeyCode__f14 = 303, // 303
	gg__KeyCode__f15 = 304, // 304
	gg__KeyCode__f16 = 305, // 305
	gg__KeyCode__f17 = 306, // 306
	gg__KeyCode__f18 = 307, // 307
	gg__KeyCode__f19 = 308, // 308
	gg__KeyCode__f20 = 309, // 309
	gg__KeyCode__f21 = 310, // 310
	gg__KeyCode__f22 = 311, // 311
	gg__KeyCode__f23 = 312, // 312
	gg__KeyCode__f24 = 313, // 313
	gg__KeyCode__f25 = 314, // 314
	gg__KeyCode__kp_0 = 320, // 320
	gg__KeyCode__kp_1 = 321, // 321
	gg__KeyCode__kp_2 = 322, // 322
	gg__KeyCode__kp_3 = 323, // 323
	gg__KeyCode__kp_4 = 324, // 324
	gg__KeyCode__kp_5 = 325, // 325
	gg__KeyCode__kp_6 = 326, // 326
	gg__KeyCode__kp_7 = 327, // 327
	gg__KeyCode__kp_8 = 328, // 328
	gg__KeyCode__kp_9 = 329, // 329
	gg__KeyCode__kp_decimal = 330, // 330
	gg__KeyCode__kp_divide = 331, // 331
	gg__KeyCode__kp_multiply = 332, // 332
	gg__KeyCode__kp_subtract = 333, // 333
	gg__KeyCode__kp_add = 334, // 334
	gg__KeyCode__kp_enter = 335, // 335
	gg__KeyCode__kp_equal = 336, // 336
	gg__KeyCode__left_shift = 340, // 340
	gg__KeyCode__left_control = 341, // 341
	gg__KeyCode__left_alt = 342, // 342
	gg__KeyCode__left_super = 343, // 343
	gg__KeyCode__right_shift = 344, // 344
	gg__KeyCode__right_control = 345, // 345
	gg__KeyCode__right_alt = 346, // 346
	gg__KeyCode__right_super = 347, // 347
	gg__KeyCode__menu = 348, // 348
} gg__KeyCode;

typedef enum {
	ui__EasingType__linear, // 
	ui__EasingType__ease_in_quad, // +1
	ui__EasingType__ease_out_quad, // +2
	ui__EasingType__ease_in_out_quad, // +3
	ui__EasingType__ease_in_cubic, // +4
	ui__EasingType__ease_out_cubic, // +5
	ui__EasingType__ease_in_out_cubic, // +6
	ui__EasingType__ease_in_quart, // +7
	ui__EasingType__ease_out_quart, // +8
	ui__EasingType__ease_in_out_quart, // +9
	ui__EasingType__ease_in_quint, // +10
	ui__EasingType__ease_out_quint, // +11
	ui__EasingType__ease_in_out_quint, // +12
} ui__EasingType;

typedef enum {
	ui__VerticalAlignment__top = 0, // 0
	ui__VerticalAlignment__center, // 0+1
	ui__VerticalAlignment__bottom, // 0+2
} ui__VerticalAlignment;

typedef enum {
	ui__HorizontalAlignment__left = 0, // 0
	ui__HorizontalAlignment__center, // 0+1
	ui__HorizontalAlignment__right, // 0+2
} ui__HorizontalAlignment;

typedef enum {
	ui__CoordinateMode__relative, // 
	ui__CoordinateMode__drag, // +1
} ui__CoordinateMode;

typedef enum {
	ui__ScrollViewEvent__all, // 
	ui__ScrollViewEvent__mouse, // +1
	ui__ScrollViewEvent__key_x, // +2
	ui__ScrollViewEvent__key_y, // +3
	ui__ScrollViewEvent__key, // +4
	ui__ScrollViewEvent__scroll_x, // +5
	ui__ScrollViewEvent__scroll_y, // +6
	ui__ScrollViewEvent__scroll, // +7
} ui__ScrollViewEvent;

typedef enum {
	ui__ScrollViewActive__auto, // 
	ui__ScrollViewActive__auto_xy, // +1
	ui__ScrollViewActive__auto_x, // +2
	ui__ScrollViewActive__auto_y, // +3
	ui__ScrollViewActive__x, // +4
	ui__ScrollViewActive__y, // +5
	ui__ScrollViewActive__xy, // +6
} ui__ScrollViewActive;

typedef enum {
	ui__ScrollViewPart__view, // 
	ui__ScrollViewPart__btn_x, // +1
	ui__ScrollViewPart__btn_y, // +2
	ui__ScrollViewPart__bar_x, // +3
	ui__ScrollViewPart__bar_y, // +4
	ui__ScrollViewPart__bar, // +5
} ui__ScrollViewPart;

typedef enum {
	ui__WindowSizeType__normal_size, // 
	ui__WindowSizeType__resizable, // +1
	ui__WindowSizeType__max_size, // +2
	ui__WindowSizeType__fullscreen, // +3
} ui__WindowSizeType;

typedef enum {
	ui__ChildSize__compact, // 
	ui__ChildSize__fixed, // +1
	ui__ChildSize__weighted, // +2
	ui__ChildSize__stretch, // +3
	ui__ChildSize__weighted_stretch, // +4
} ui__ChildSize;

typedef enum {
	ui__Side__top, // 
	ui__Side__left, // +1
	ui__Side__right, // +2
	ui__Side__bottom, // +3
} ui__Side;

typedef enum {
	ui__ColorType__button_normal = 1, // 1
	ui__ColorType__button_pressed, // 1+1
	ui__ColorType__button_hover, // 1+2
} ui__ColorType;

typedef enum {
	ui__TextHorizontalAlign__none = -10, // -10
	ui__TextHorizontalAlign__left = FONS_ALIGN_LEFT, // FONS_ALIGN_LEFT
	ui__TextHorizontalAlign__center = FONS_ALIGN_CENTER, // FONS_ALIGN_CENTER
	ui__TextHorizontalAlign__right = FONS_ALIGN_RIGHT, // FONS_ALIGN_RIGHT
} ui__TextHorizontalAlign;

typedef enum {
	ui__TextVerticalAlign__none = -10, // -10
	ui__TextVerticalAlign__top = FONS_ALIGN_TOP, // FONS_ALIGN_TOP
	ui__TextVerticalAlign__middle = FONS_ALIGN_MIDDLE, // FONS_ALIGN_MIDDLE
	ui__TextVerticalAlign__bottom = FONS_ALIGN_BOTTOM, // FONS_ALIGN_BOTTOM
	ui__TextVerticalAlign__baseline = FONS_ALIGN_BASELINE, // FONS_ALIGN_BASELINE
} ui__TextVerticalAlign;

typedef enum {
	ui__KeyMod__shift = 1, // 1 << 0
	ui__KeyMod__ctrl = 2, // 1 << 1
	ui__KeyMod__alt = 4, // 1 << 2
	ui__KeyMod__super = 8, // 1 << 3
} ui__KeyMod;

typedef enum {
	ui__KeyState__press = 1, // 1
	ui__KeyState__release = 0, // 0
	ui__KeyState__repeat = 2, // 2
} ui__KeyState;

typedef enum {
	ui__Key__invalid = 0, // 0
	ui__Key__space = 32, // 32
	ui__Key__apostrophe = 39, // 39
	ui__Key__comma = 44, // 44
	ui__Key__minus = 45, // 45
	ui__Key__period = 46, // 46
	ui__Key__slash = 47, // 47
	ui__Key___0 = 48, // 48
	ui__Key___1 = 49, // 49
	ui__Key___2 = 50, // 50
	ui__Key___3 = 51, // 51
	ui__Key___4 = 52, // 52
	ui__Key___5 = 53, // 53
	ui__Key___6 = 54, // 54
	ui__Key___7 = 55, // 55
	ui__Key___8 = 56, // 56
	ui__Key___9 = 57, // 57
	ui__Key__semicolon = 59, // 59
	ui__Key__equal = 61, // 61
	ui__Key__a = 65, // 65
	ui__Key__b = 66, // 66
	ui__Key__c = 67, // 67
	ui__Key__d = 68, // 68
	ui__Key__e = 69, // 69
	ui__Key__f = 70, // 70
	ui__Key__g = 71, // 71
	ui__Key__h = 72, // 72
	ui__Key__i = 73, // 73
	ui__Key__j = 74, // 74
	ui__Key__k = 75, // 75
	ui__Key__l = 76, // 76
	ui__Key__m = 77, // 77
	ui__Key__n = 78, // 78
	ui__Key__o = 79, // 79
	ui__Key__p = 80, // 80
	ui__Key__q = 81, // 81
	ui__Key__r = 82, // 82
	ui__Key__s = 83, // 83
	ui__Key__t = 84, // 84
	ui__Key__u = 85, // 85
	ui__Key__v = 86, // 86
	ui__Key__w = 87, // 87
	ui__Key__x = 88, // 88
	ui__Key__y = 89, // 89
	ui__Key__z = 90, // 90
	ui__Key__left_bracket = 91, // 91
	ui__Key__backslash = 92, // 92
	ui__Key__right_bracket = 93, // 93
	ui__Key__grave_accent = 96, // 96
	ui__Key__world_1 = 161, // 161
	ui__Key__world_2 = 162, // 162
	ui__Key__escape = 256, // 256
	ui__Key__enter = 257, // 257
	ui__Key__tab = 258, // 258
	ui__Key__backspace = 259, // 259
	ui__Key__insert = 260, // 260
	ui__Key__delete = 261, // 261
	ui__Key__right = 262, // 262
	ui__Key__left = 263, // 263
	ui__Key__down = 264, // 264
	ui__Key__up = 265, // 265
	ui__Key__page_up = 266, // 266
	ui__Key__page_down = 267, // 267
	ui__Key__home = 268, // 268
	ui__Key__end = 269, // 269
	ui__Key__caps_lock = 280, // 280
	ui__Key__scroll_lock = 281, // 281
	ui__Key__num_lock = 282, // 282
	ui__Key__print_screen = 283, // 283
	ui__Key__pause = 284, // 284
	ui__Key__f1 = 290, // 290
	ui__Key__f2 = 291, // 291
	ui__Key__f3 = 292, // 292
	ui__Key__f4 = 293, // 293
	ui__Key__f5 = 294, // 294
	ui__Key__f6 = 295, // 295
	ui__Key__f7 = 296, // 296
	ui__Key__f8 = 297, // 297
	ui__Key__f9 = 298, // 298
	ui__Key__f10 = 299, // 299
	ui__Key__f11 = 300, // 300
	ui__Key__f12 = 301, // 301
	ui__Key__f13 = 302, // 302
	ui__Key__f14 = 303, // 303
	ui__Key__f15 = 304, // 304
	ui__Key__f16 = 305, // 305
	ui__Key__f17 = 306, // 306
	ui__Key__f18 = 307, // 307
	ui__Key__f19 = 308, // 308
	ui__Key__f20 = 309, // 309
	ui__Key__f21 = 310, // 310
	ui__Key__f22 = 311, // 311
	ui__Key__f23 = 312, // 312
	ui__Key__f24 = 313, // 313
	ui__Key__f25 = 314, // 314
	ui__Key__kp_0 = 320, // 320
	ui__Key__kp_1 = 321, // 321
	ui__Key__kp_2 = 322, // 322
	ui__Key__kp_3 = 323, // 323
	ui__Key__kp_4 = 324, // 324
	ui__Key__kp_5 = 325, // 325
	ui__Key__kp_6 = 326, // 326
	ui__Key__kp_7 = 327, // 327
	ui__Key__kp_8 = 328, // 328
	ui__Key__kp_9 = 329, // 329
	ui__Key__kp_decimal = 330, // 330
	ui__Key__kp_divide = 331, // 331
	ui__Key__kp_multiply = 332, // 332
	ui__Key__kp_subtract = 333, // 333
	ui__Key__kp_add = 334, // 334
	ui__Key__kp_enter = 335, // 335
	ui__Key__kp_equal = 336, // 336
	ui__Key__left_shift = 340, // 340
	ui__Key__left_control = 341, // 341
	ui__Key__left_alt = 342, // 342
	ui__Key__left_super = 343, // 343
	ui__Key__right_shift = 344, // 344
	ui__Key__right_control = 345, // 345
	ui__Key__right_alt = 346, // 346
	ui__Key__right_super = 347, // 347
	ui__Key__menu = 348, // 348
} ui__Key;

typedef enum {
	ui__Direction__row, // 
	ui__Direction__column, // +1
} ui__Direction;

typedef enum {
	ui__ChildUpdateType__add, // 
	ui__ChildUpdateType__remove, // +1
	ui__ChildUpdateType__move, // +2
	ui__ChildUpdateType__migrate, // +3
} ui__ChildUpdateType;

typedef enum {
	ui__MouseAction__up, // 
	ui__MouseAction__down, // +1
} ui__MouseAction;

typedef enum {
	ui__MouseButton__invalid = 256, // 256
	ui__MouseButton__left = 0, // 0
	ui__MouseButton__right = 1, // 1
	ui__MouseButton__middle = 2, // 2
} ui__MouseButton;

typedef enum {
	ui__Cursor__hand, // 
	ui__Cursor__arrow, // +1
	ui__Cursor__ibeam, // +2
} ui__Cursor;

typedef enum {
	ui__ButtonState__normal = 1, // 1
	ui__ButtonState__pressed = 2, // 2
} ui__ButtonState;

typedef enum {
	ui__Orientation__vertical = 0, // 0
	ui__Orientation__horizontal = 1, // 1
} ui__Orientation;

typedef enum {
	ui__SelectionDirection__nil = 0, // 0
	ui__SelectionDirection__left_to_right, // 0+1
	ui__SelectionDirection__right_to_left, // 0+2
} ui__SelectionDirection;

typedef enum {
	ui__TextBoxMode__read_only = 1, // 1 << 0
	ui__TextBoxMode__multiline = 2, // 1 << 1
	ui__TextBoxMode__word_wrap = 4, // 1 << 2
	ui__TextBoxMode__line_numbers = 8, // 1 << 3
} ui__TextBoxMode;


// V type definitions:
struct IError {
	union {
		void* _object;
		None__* _None__;
		Error* _Error;
		MessageError* _MessageError;
		os__FileNotOpenedError* _os__FileNotOpenedError;
		os__SizeOfTypeIs0Error* _os__SizeOfTypeIs0Error;
		os__ExecutableNotFoundError* _os__ExecutableNotFoundError;
		time__TimeParseError* _time__TimeParseError;
	};
	int _typ;
	string* msg;
	int* code;
};

struct string {
	u8* str;
	int len;
	int is_lit;
};



struct array {
	int element_size;
	voidptr data;
	int offset;
	int len;
	int cap;
	ArrayFlags flags;
};



struct DenseArray {
	int key_bytes;
	int value_bytes;
	int cap;
	int len;
	u32 deletes;
	u8* all_deleted;
	u8* values;
	u8* keys;
};



struct map {
	int key_bytes;
	int value_bytes;
	u32 even_index;
	u8 cached_hashbits;
	u8 shift;
	DenseArray key_values;
	u32* metas;
	u32 extra_metas;
	bool has_string_keys;
	MapHashFn hash_fn;
	MapEqFn key_eq_fn;
	MapCloneFn clone_fn;
	MapFreeFn free_fn;
	int len;
};



struct Error {
	EMPTY_STRUCT_DECLARATION;
};



struct Option {
	u8 state;
	IError err;
};


typedef array Array_string;
typedef array Array_u8;
typedef array Array_int;
typedef array Array_voidptr;
typedef array Array_VCastTypeIndexName;
typedef array Array_MethodArgs;
typedef array Array_u8_ptr;
typedef array Array_rune;
typedef string Array_fixed_string_11 [11];
typedef voidptr Array_fixed_voidptr_11 [11];
typedef array Array_RepIndex;
typedef array Array_main__User;
typedef map Map_string_int;
typedef array Array_ui__SortedWidget;
typedef array Array_ui__Widget;
typedef map Map_string_Array_ui__Widget;
typedef array Array_f64;
typedef array Array_f32;
typedef array Array_ui__ChildSize;
typedef map Map_string_ui__SyntaxChunk;
typedef map Map_string_bool;
typedef map Map_string_Array_string;
typedef array Array_Array_string;
typedef map Map_string_Array_Array_string;
typedef map Map_string_Array_rune;
typedef array Array_ui__Chunk;
typedef map Map_string_Array_ui__Chunk;
typedef map Map_string_ui__SyntaxStyle;
typedef map Map_string_ui__SyntaxMapBool;
typedef map Map_string_ui__SyntaxMapStrings;
typedef map Map_string_ui__SyntaxMapArrayStrings;
typedef map Map_string_ui__SyntaxMapRunes;
typedef map Map_int_gx__Color;
typedef array Array_ui__Color;
typedef array Array_ui__ComponentChild;
typedef map Map_string_ui__TextStyle;
typedef map Map_int_ui__XYPos;
typedef map Map_string_f32;
typedef map Map_string_string;
typedef map Map_string_gx__Color;
typedef map Map_string_Array_int;
typedef map Map_string_Array_f32;
typedef array Array_bool;
typedef map Map_string_Array_bool;
typedef array Array_gx__Color;
typedef map Map_string_Array_gx__Color;
typedef bool Array_fixed_bool_3 [3];
typedef map Map_string_gg__Image;
typedef array Array_ui__DropdownItem;
typedef array Array_ui__ListItem;
typedef array Array_ui__MenuItem;
typedef array Array_ui__SubWindow_ptr;
typedef map Map_string_ui__ColorTheme;
typedef map Map_string_ui__Widget;
typedef array Array_ui__TooltipMessage;
typedef array Array_char_ptr;
typedef int Array_fixed_int_3 [3];
typedef char Array_fixed_char_256 [256];
typedef f32 Array_fixed_f32_16 [16];
typedef array Array_gg__Image;
typedef bool Array_fixed_bool_512 [512];
typedef array Array_u64;
typedef array Array_eventbus__EventHandler;
typedef int Array_fixed_int_8 [8];
typedef u32 Array_fixed_u32_2 [2];
typedef voidptr Array_fixed_voidptr_2 [2];
typedef u8 Array_fixed_u8_5 [5];
typedef array Array_u32;
typedef array Array_strconv__Uint128;
typedef u8 Array_fixed_u8_32 [32];
typedef u8 Array_fixed_u8_26 [26];
typedef voidptr Array_fixed_voidptr_100 [100];
typedef u8 Array_fixed_u8_17 [17];
typedef array Array_StrIntpType;
typedef u8 Array_fixed_u8_1024 [1024];
typedef u8 Array_fixed_u8_4096 [4096];
typedef array Array_os__ProcessState;
typedef int Array_fixed_int_6 [6];
typedef int Array_fixed_int_17 [17];
typedef array Array_sokol__sapp__EventType;
typedef f32 Array_fixed_f32_4 [4];
typedef array Array_ui__KeyMod;
typedef array Array_ui__WindowSizeType;
typedef array Array_ui__Side;
typedef byte Array_fixed_byte_3811 [3811];
typedef byte Array_fixed_byte_818 [818];
typedef byte Array_fixed_byte_946 [946];
typedef byte Array_fixed_byte_3558 [3558];
typedef byte Array_fixed_byte_4411 [4411];
typedef byte Array_fixed_byte_163 [163];
typedef array Array_ui__Key;
typedef u8 byte;
typedef int i32;
typedef Array_u8 strings__Builder;
typedef Map_string_ui__SyntaxChunk ui__SyntaxStyle;
typedef Map_string_bool ui__SyntaxMapBool;
typedef Map_string_Array_string ui__SyntaxMapStrings;
typedef Map_string_Array_Array_string ui__SyntaxMapArrayStrings;
typedef Map_string_Array_rune ui__SyntaxMapRunes;
typedef Map_int_gx__Color ui__ColorTheme;
typedef sgl_context sokol__sgl__Context;
typedef sgl_desc_t sokol__sgl__Desc;
typedef sgl_context_desc_t sokol__sgl__ContextDesc;
typedef struct sg_pipeline_desc sokol__gfx__PipelineDesc;
typedef sgl_pipeline sokol__sgl__Pipeline;
typedef struct sg_image sokol__gfx__Image;
typedef struct sg_desc sokol__gfx__Desc;
typedef struct sg_metal_context_desc sokol__gfx__MetalContextDesc;
typedef struct sg_d3d11_context_desc sokol__gfx__D3D11ContextDesc;
typedef struct sg_context_desc sokol__gfx__ContextDesc;
typedef struct sapp_desc sokol__sapp__Desc;
typedef struct sapp_range sokol__sapp__Range;
typedef struct sapp_image_desc sokol__sapp__ImageDesc;
typedef struct sapp_icon_desc sokol__sapp__IconDesc;
typedef struct sapp_event sokol__sapp__Event;
typedef struct sapp_touchpoint sokol__sapp__TouchPoint;
typedef struct sapp_touchpoint gg__TouchPoint;
typedef struct sg_pass_action sokol__gfx__PassAction;
typedef struct sg_color_state sokol__gfx__ColorState;
typedef struct sg_blend_state sokol__gfx__BlendState;
typedef struct sg_image_desc sokol__gfx__ImageDesc;
typedef struct sg_range sokol__gfx__Range;
typedef struct sg_image_data sokol__gfx__ImageData;
typedef gx__Color gg__Color;
typedef struct FONScontext fontstash__Context;
typedef i64 time__Duration;
typedef struct sg_buffer_desc sokol__gfx__BufferDesc;
typedef struct sg_buffer sokol__gfx__Buffer;
typedef struct sg_shader_desc sokol__gfx__ShaderDesc;
typedef struct sg_shader sokol__gfx__Shader;
typedef struct sg_pipeline sokol__gfx__Pipeline;
typedef struct sg_pass_desc sokol__gfx__PassDesc;
typedef struct sg_pass sokol__gfx__Pass;
typedef struct sg_bindings sokol__gfx__Bindings;
typedef struct sg_features sokol__gfx__Features;
typedef struct sg_limits sokol__gfx__Limits;
typedef struct sg_pixelformat_info sokol__gfx__PixelFormatInfo;
typedef struct sg_buffer_info sokol__gfx__BufferInfo;
typedef struct sg_image_info sokol__gfx__ImageInfo;
typedef struct sg_shader_info sokol__gfx__ShaderInfo;
typedef struct sg_pipeline_info sokol__gfx__PipelineInfo;
typedef struct sg_pass_info sokol__gfx__PassInfo;
typedef struct sg_context sokol__gfx__Context;
typedef struct sg_gl_context_desc sokol__gfx__GLContextDesc;
typedef struct sg_layout_desc sokol__gfx__LayoutDesc;
typedef struct sg_depth_state sokol__gfx__DepthState;
typedef struct sg_stencil_state sokol__gfx__StencilState;
typedef struct sg_color sokol__gfx__Color;
typedef struct sg_shader_attr_desc sokol__gfx__ShaderAttrDesc;
typedef struct sg_shader_stage_desc sokol__gfx__ShaderStageDesc;
typedef struct sg_shader_uniform_block_desc sokol__gfx__ShaderUniformBlockDesc;
typedef struct sg_shader_image_desc sokol__gfx__ShaderImageDesc;
typedef struct sg_shader_uniform_desc sokol__gfx__ShaderUniformDesc;
typedef struct sg_pass_attachment_desc sokol__gfx__PassAttachmentDesc;
typedef struct sg_slot_info sokol__gfx__SlotInfo;
typedef struct sg_color_attachment_action sokol__gfx__ColorAttachmentAction;
typedef struct sg_depth_attachment_action sokol__gfx__DepthAttachmentAction;
typedef struct sg_stencil_attachment_action sokol__gfx__StencilAttachmentAction;
typedef struct sg_buffer_layout_desc sokol__gfx__BufferLayoutDesc;
typedef struct sg_vertex_attr_desc sokol__gfx__VertexAttrDesc;
typedef struct sg_stencil_face_state sokol__gfx__StencilFaceState;
typedef bool (*anon_fn_voidptr__bool)(voidptr);
typedef voidptr (*anon_fn_voidptr__voidptr)(voidptr);
typedef int (*anon_fn_voidptr_voidptr__int)(voidptr,voidptr);
typedef int (*anon_fn_int_int__int)(int,int);
typedef void (*FnExitCb)();
typedef int (*FnSortCB)(voidptr,voidptr);
typedef f64 (*ui__EasingFunction)(f64);
typedef void (*ui__ScrollViewChangedFn)(ui__ScrollableWidget);
typedef void (*ui__TextBoxChangeFn)(string,voidptr);
typedef void (*ui__ComponentInitFn)(voidptr);
typedef void (*ui__CanvasLayoutDrawFn)(ui__CanvasLayout*,voidptr);
typedef void (*ui__CanvasLayoutScrollFn)(ui__ScrollEvent,ui__CanvasLayout*);
typedef void (*ui__CanvasLayoutMouseMoveFn)(ui__MouseMoveEvent,ui__CanvasLayout*);
typedef void (*ui__CanvasLayoutMouseFn)(ui__MouseEvent,ui__CanvasLayout*);
typedef void (*ui__CanvasLayoutKeyFn)(ui__KeyEvent,ui__CanvasLayout*);
typedef multi_return_int_int (*ui__CanvasLayoutSizeFn)(ui__CanvasLayout*);
typedef void (*ui__ButtonClickFn)(voidptr,ui__Button*);
typedef void (*ui__ButtonKeyDownFn)(voidptr,ui__Button*,u32);
typedef void (*ui__DrawFn)(gg__Context*,voidptr,ui__Canvas*);
typedef void (*ui__CheckChangedFn)(voidptr,bool);
typedef void (*ui__CheckBowClickFn)(ui__CheckBox*,voidptr);
typedef void (*ui__DropDownSelectionChangedFn)(voidptr,ui__Dropdown*);
typedef void (*ui__ListBoxSelectionChangedFn)(voidptr,ui__ListBox*);
typedef void (*ui__MenuItemFn)(ui__Menu*,ui__MenuItem*,voidptr);
typedef void (*ui__PictureClickFn)(voidptr,voidptr);
typedef void (*ui__RadioClickFn)(voidptr,ui__Radio*);
typedef void (*ui__SliderValueChangedFn)(voidptr,voidptr);
typedef void (*ui__SwitchClickFn)(voidptr,ui__Switch*);
typedef void (*ui__SwitchKeyDownFn)(voidptr,ui__Switch*,u32);
typedef void (*ui__TextBoxKeyDownFn)(voidptr,ui__TextBox*,u32);
typedef void (*ui__TextBoxCharFn)(voidptr,ui__TextBox*,u32);
typedef void (*ui__TextBoxEnterFn)(string,voidptr);
typedef void (*ui__TextBoxValidatedFn)(ui__TextBox*,voidptr);
typedef void (*ui__WindowFn)(ui__Window*);
typedef void (*ui__ResizeFn)(int,int,ui__Window*);
typedef void (*ui__KeyFn)(ui__KeyEvent,ui__Window*);
typedef void (*ui__ClickFn)(ui__MouseEvent,ui__Window*);
typedef void (*ui__MouseMoveFn)(ui__MouseMoveEvent,ui__Window*);
typedef void (*ui__ScrollFn)(ui__ScrollEvent,ui__Window*);
typedef void (*anon_fn_string)(string);
typedef void (*os__FnWalkContextCB)(voidptr,string);
typedef void (*os__SignalHandler)(os__Signal);
typedef void (*os__FN_SA_Handler)(int);
typedef void (*anon_fn_)();
typedef void (*anon_fn_sokol__sapp__event)(sokol__sapp__Event*);
typedef void (*anon_fn_u8)(u8*);
typedef void (*anon_fn_voidptr)(voidptr);
typedef void (*anon_fn_sokol__sapp__event_voidptr)(sokol__sapp__Event*,voidptr);
typedef void (*anon_fn_char_voidptr)(char*,voidptr);
typedef void (*gg__FNCb)(voidptr);
typedef void (*gg__FNFail)(string,voidptr);
typedef void (*gg__FNEvent)(gg__Event*,voidptr);
typedef void (*gg__FNKeyDown)(gg__KeyCode,gg__Modifier,voidptr);
typedef void (*gg__FNKeyUp)(gg__KeyCode,gg__Modifier,voidptr);
typedef void (*gg__FNChar)(u32,voidptr);
typedef void (*gg__FNMove)(f32,f32,voidptr);
typedef void (*gg__FNClick)(f32,f32,gg__MouseButton,voidptr);
typedef void (*gg__FNUnClick)(f32,f32,gg__MouseButton,voidptr);
typedef void (*eventbus__EventHandlerFn)(voidptr,voidptr,voidptr);
typedef void (*anon_fn_voidptr_int_int)(voidptr,int,int);
typedef int (*anon_fn_voidptr_int_int__int)(voidptr,int,int);
typedef void (*anon_fn_voidptr_int_u8)(voidptr,int*,u8*);
typedef void (*anon_fn_voidptr_f32_f32_u32_int)(voidptr,f32*,f32*,u32*,int);
typedef voidptr (*anon_fn___voidptr)();
struct ui__Widget {
	union {
		void* _object;
		ui__Stack* _ui__Stack;
		ui__Group* _ui__Group;
		ui__CanvasLayout* _ui__CanvasLayout;
		ui__ListBox* _ui__ListBox;
		ui__TextBox* _ui__TextBox;
		ui__Label* _ui__Label;
		ui__Button* _ui__Button;
		ui__Canvas* _ui__Canvas;
		ui__CheckBox* _ui__CheckBox;
		ui__Dropdown* _ui__Dropdown;
		ui__Grid* _ui__Grid;
		ui__Menu* _ui__Menu;
		ui__Picture* _ui__Picture;
		ui__ProgressBar* _ui__ProgressBar;
		ui__Radio* _ui__Radio;
		ui__Rectangle* _ui__Rectangle;
		ui__Slider* _ui__Slider;
		ui__SubWindow* _ui__SubWindow;
		ui__Switch* _ui__Switch;
		ui__Transition* _ui__Transition;
	};
	int _typ;
	string* id;
	int* x;
	int* y;
	int* z_index;
	int* offset_x;
	int* offset_y;
	bool* hidden;
	ui__Layout* parent;
};
struct ui__DrawText {
	union {
		void* _object;
		ui__Tooltip* _ui__Tooltip;
		ui__Button* _ui__Button;
		ui__Menu* _ui__Menu;
		ui__Rectangle* _ui__Rectangle;
		ui__TextBox* _ui__TextBox;
		ui__Label* _ui__Label;
		voidptr* _voidptr;
		ui__Radio* _ui__Radio;
		ui__ListBox* _ui__ListBox;
		ui__CheckBox* _ui__CheckBox;
	};
	int _typ;
	ui__UI** ui;
	gx__TextCfg* text_cfg;
	f64* text_size;
};
struct ui__ScrollableWidget {
	union {
		void* _object;
		ui__Stack* _ui__Stack;
		ui__CanvasLayout* _ui__CanvasLayout;
		ui__ListBox* _ui__ListBox;
		ui__TextBox* _ui__TextBox;
	};
	int _typ;
	bool* has_scrollview;
	ui__ScrollView** scrollview;
	string* id;
	int* x;
	int* y;
	ui__UI** ui;
	int* offset_x;
	int* offset_y;
	ui__ScrollViewChangedFn* on_scroll_change;
};
struct ui__Layout {
	union {
		void* _object;
		ui__Stack* _ui__Stack;
		ui__Window* _ui__Window;
		ui__CanvasLayout* _ui__CanvasLayout;
		ui__Group* _ui__Group;
		ui__SubWindow* _ui__SubWindow;
	};
	int _typ;
	string* id;
};
struct ui__Focusable {
	union {
		void* _object;
		ui__TextBox* _ui__TextBox;
		ui__Button* _ui__Button;
		ui__CheckBox* _ui__CheckBox;
		ui__Dropdown* _ui__Dropdown;
		ui__ListBox* _ui__ListBox;
		ui__Radio* _ui__Radio;
		ui__Slider* _ui__Slider;
		ui__Switch* _ui__Switch;
	};
	int _typ;
	ui__UI** ui;
	string* id;
	bool* hidden;
	bool* is_focused;
};
struct ui__DrawTextWidget {
	union {
		void* _object;
		ui__TextBox* _ui__TextBox;
		ui__CanvasLayout* _ui__CanvasLayout;
		ui__Button* _ui__Button;
		ui__CheckBox* _ui__CheckBox;
		ui__Label* _ui__Label;
		ui__ListBox* _ui__ListBox;
		ui__Radio* _ui__Radio;
	};
	int _typ;
	string* id;
	ui__UI** ui;
	ui__TextStyles* text_styles;
};
struct ui__ColorThemeWidget {
	union {
		void* _object;
		ui__Button* _ui__Button;
	};
	int _typ;
	ui__UI** ui;
	ui__ColorThemeCfg* theme_cfg;
	Map_int_gx__Color* theme;
};
struct ui__ComponentChild {
	union {
		void* _object;
		ui__ProgressBar* _ui__ProgressBar;
		voidptr* _voidptr;
		ui__Label* _ui__Label;
		ui__Radio* _ui__Radio;
		ui__Button* _ui__Button;
		ui__CanvasLayout* _ui__CanvasLayout;
		ui__Stack* _ui__Stack;
		ui__Group* _ui__Group;
		ui__ListBox* _ui__ListBox;
		ui__TextBox* _ui__TextBox;
		ui__SubWindow* _ui__SubWindow;
		ui__Canvas* _ui__Canvas;
		ui__CheckBox* _ui__CheckBox;
		ui__Dropdown* _ui__Dropdown;
		ui__Menu* _ui__Menu;
		ui__Picture* _ui__Picture;
		ui__Rectangle* _ui__Rectangle;
		ui__Slider* _ui__Slider;
		ui__Switch* _ui__Switch;
	};
	int _typ;
	voidptr* component;
};
// #start sorted_symbols
struct none {
	EMPTY_STRUCT_DECLARATION;
};
typedef pthread_t __v_thread;

struct None__ {
	Error Error;
};



struct StrIntpCgenData {
	string str;
	string fmt;
	string d;
};



struct ui__EventNames {
	string on_click;
	string on_mouse_move;
	string on_mouse_down;
	string on_mouse_up;
	string on_files_droped;
	string on_swipe;
	string on_touch_move;
	string on_touch_down;
	string on_touch_up;
	string on_key_down;
	string on_char;
	string on_key_up;
	string on_scroll;
	string on_resize;
};



// Union sum type ui__Size = 
//          |  166 = Array_f64           
//          |   16 = f64                 
struct ui__Size {
	union {
		Array_f64* _Array_f64;
		f64* _f64;
	};
	int _typ;
};


// Union sum type ui__ColorThemeCfg = 
//          |  212 = ui__ColorTheme      
//          |   20 = string              
struct ui__ColorThemeCfg {
	union {
		ui__ColorTheme* _ui__ColorTheme;
		string* _string;
	};
	int _typ;
};


struct eventbus__Subscriber {
	eventbus__Registry* registry;
};



struct ui__DropdownItem {
	string text;
};



struct eventbus__EventBus {
	eventbus__Registry* registry;
	eventbus__Publisher* publisher;
	eventbus__Subscriber* subscriber;
};



struct os__FileNotOpenedError {
	Error Error;
};



struct os__SizeOfTypeIs0Error {
	Error Error;
};



struct os__ExecutableNotFoundError {
	Error Error;
};



struct os__Uname {
	string sysname;
	string nodename;
	string release;
	string version;
	string machine;
};



struct eventbus__Publisher {
	eventbus__Registry* registry;
};



struct VCastTypeIndexName {
	int tindex;
	string tname;
};



struct VAssertMetaInfo {
	string fpath;
	int line_nr;
	string fn_name;
	string src;
	string op;
	string llabel;
	string rlabel;
	string lvalue;
	string rvalue;
};



struct MethodArgs {
	int typ;
	string name;
};



struct FunctionData {
	string name;
	Array_string attrs;
	Array_MethodArgs args;
	int return_type;
	int typ;
};



struct FieldData {
	string name;
	Array_string attrs;
	bool is_pub;
	bool is_mut;
	bool is_shared;
	int typ;
};



struct StructAttribute {
	string name;
	bool has_arg;
	string arg;
	AttributeKind kind;
};



union strconv__Float64u {
	f64 f;
	u64 u;
};



union strconv__Float32u {
	f32 f;
	u32 u;
};



struct MessageError {
	string msg;
	int code;
};



struct VMemoryBlock {
	int id;
	int cap;
	byte* start;
	VMemoryBlock* previous;
	int remaining;
	u8* current;
	int mallocs;
};



struct SortedMap {
	int value_bytes;
	mapnode* root;
	int len;
};



struct RepIndex {
	int idx;
	int val_idx;
};



union StrIntpMem {
	u32 d_c;
	byte d_u8;
	i8 d_i8;
	u16 d_u16;
	i16 d_i16;
	u32 d_u32;
	int d_i32;
	u64 d_u64;
	i64 d_i64;
	f32 d_f32;
	f64 d_f64;
	string d_s;
	voidptr d_p;
	voidptr d_vp;
};



struct strconv__BF_param {
	u8 pad_ch;
	int len0;
	int len1;
	bool positive;
	bool sign_flag;
	strconv__Align_text allign;
	bool rm_tail_zero;
};



struct main__User {
	string first_name;
	string last_name;
	int age;
	string country;
};



struct ui__ProgressBar {
	string id;
	int height;
	int width;
	int x;
	int y;
	int offset_x;
	int offset_y;
	int z_index;
	ui__Layout parent;
	ui__UI* ui;
	int val;
	int min;
	int max;
	bool hidden;
	voidptr component;
};



struct main__State {
	string first_name;
	string last_name;
	string age;
	string password;
	ui__ProgressBar* pbar;
	Array_main__User users;
	ui__Window* window;
	ui__Label* label;
	ui__Radio* country;
	int txt_pos;
	bool started;
	bool is_error;
};



struct ui__HorizontalAlignments {
	Array_int left;
	Array_int center;
	Array_int right;
};



struct strconv__PrepNumber {
	bool negative;
	int exponent;
	u64 mantissa;
};



struct strconv__Dec32 {
	u32 m;
	int e;
};



union strconv__Uf32 {
	f32 f;
	u32 u;
};



struct strconv__Dec64 {
	u64 m;
	int e;
};



union strconv__Uf64 {
	f64 f;
	u64 u;
};



struct strconv__Uint128 {
	u64 lo;
	u64 hi;
};



struct ui__VerticalAlignments {
	Array_int top;
	Array_int center;
	Array_int bottom;
};



struct ui__Alignments {
	Array_int center;
	Array_int left_top;
	Array_int top;
	Array_int right_top;
	Array_int right;
	Array_int right_bottom;
	Array_int bottom;
	Array_int left_bottom;
	Array_int left;
};



struct ui__CachedSizes {
	Array_ui__ChildSize width_type;
	Array_ui__ChildSize height_type;
	Array_int adj_widths;
	Array_int adj_heights;
	Array_int fixed_widths;
	Array_int fixed_heights;
	int fixed_width;
	int fixed_height;
	int min_width;
	int min_height;
	Array_f64 weight_widths;
	f64 width_mass;
	Array_f64 weight_heights;
	f64 height_mass;
};



struct gx__Color {
	u8 r;
	u8 g;
	u8 b;
	u8 a;
};



struct ui__SortedWidget {
	int i;
	ui__Widget w;
};



struct ui__EventMngr {
	Map_string_Array_ui__Widget receivers;
	Map_string_Array_ui__Widget point_inside;
};



struct ui__MouseEvent {
	int x;
	int y;
	ui__MouseButton button;
	ui__MouseAction action;
	ui__KeyMod mods;
};



struct ui__ScrollEvent {
	f64 x;
	f64 y;
	f64 mouse_x;
	f64 mouse_y;
};



struct gg__Rect {
	f32 x;
	f32 y;
	f32 width;
	f32 height;
};



struct time__Time {
	int year;
	int month;
	int day;
	int hour;
	int minute;
	int second;
	int microsecond;
	i64 _v_unix;
	bool is_local;
};



struct ui__Group {
	string id;
	string title;
	int height;
	int width;
	int x;
	int y;
	int offset_x;
	int offset_y;
	int z_index;
	ui__Layout parent;
	ui__UI* ui;
	Array_ui__Widget children;
	int margin_left;
	int margin_top;
	int margin_right;
	int margin_bottom;
	int spacing;
	int adj_height;
	int adj_width;
	bool hidden;
	voidptr component;
	Array_string debug_ids;
};



struct ui__MouseMoveEvent {
	f64 x;
	f64 y;
	int mouse_button;
};



struct ui__KeyEvent {
	ui__Key key;
	int action;
	int code;
	ui__KeyMod mods;
	u32 codepoint;
};



struct ui__Margins {
	f32 top;
	f32 right;
	f32 bottom;
	f32 left;
};



struct ui__Margin {
	f64 top;
	f64 right;
	f64 bottom;
	f64 left;
};



struct ui__XYPos {
	int x;
	int y;
};



struct ui__TooltipMessage {
	string text;
	ui__Side side;
};



struct ui__Chunk {
	int x;
	int y;
	string text;
};



struct ui__SyntaxHighLighter {
	ui__TextView* tv;
	Array_rune ustr;
	Map_string_Array_ui__Chunk chunks;
	string lang;
	ui__SyntaxMapStrings lang_exts;
	string style;
	Map_string_ui__SyntaxStyle styles;
	Map_string_ui__SyntaxMapBool is_multiline;
	Map_string_ui__SyntaxMapStrings keywords;
	Map_string_ui__SyntaxMapStrings singleline;
	Map_string_ui__SyntaxMapArrayStrings multiline;
	Map_string_ui__SyntaxMapRunes between_one_rune;
	int i;
	int j;
	int start;
	int y;
};



struct ui__TextLinesView {
	Array_string lines;
	Array_int from_i;
	Array_int to_i;
	int from_j;
	int to_j;
	bool refresh_visible_lines;
	int cursor_pos_i;
	int cursor_pos_j;
	int sel_start_j;
	int sel_start_i;
	int sel_end_i;
	int sel_end_j;
};



struct ui__LogViewParams {
	int nb_lines;
};



struct ui__FontSet {
	Map_string_int hash;
};



struct ui__FontSearcher {
	Array_string paths;
	Array_string lpaths;
};



struct ui__SubWindow {
	string id;
	int x;
	int y;
	int z_index;
	Array_int z_index_children_orig;
	int offset_x;
	int offset_y;
	bool hidden;
	ui__UI* ui;
	bool drag;
	bool dragging;
	int drag_x;
	int drag_y;
	bool decoration;
	ui__Layout layout;
	bool is_focused;
	ui__Layout parent;
	voidptr component;
};



struct ui__GroupParams {
	string id;
	string title;
	int x;
	int y;
	int width;
	int height;
	int spacing;
	Array_ui__Widget children;
};



struct ui__ChildrenParams {
	int at;
	ui__Size widths;
	ui__Size heights;
	f64 spacing;
	Array_f64 spacings;
	ui__Widget child;
	Array_ui__Widget children;
	int from;
	int to;
	ui__Stack* target;
	ui__Size target_widths;
	ui__Size target_heights;
	f64 target_spacing;
	Array_f64 target_spacings;
};



struct ui__Pos {
	int x;
	int y;
};



struct ui__SettingsUI {
	Map_string_int int_;
	Map_string_f32 f32_;
	Map_string_bool bool_;
	Map_string_string string_;
	Map_string_gx__Color color_;
	Map_string_Array_int ints_;
	Map_string_Array_f32 f32s_;
	Map_string_Array_bool bools_;
	Map_string_Array_string strings_;
	Map_string_Array_gx__Color colors_;
};



struct clipboard__Clipboard {
	voidptr pb;
	i64 last_cb_serial;
	int foo;
};



struct ui__Canvas {
	string id;
	int width;
	int height;
	int x;
	int y;
	int offset_x;
	int offset_y;
	int z_index;
	ui__UI* ui;
	bool hidden;
	voidptr component;
	ui__Layout parent;
	ui__DrawFn draw_fn;
	gg__Context* gg;
};



struct ui__CanvasParams {
	string id;
	int width;
	int height;
	int z_index;
	string text;
	ui__DrawFn draw_fn;
};



struct ui__DropdownParams {
	string id;
	string def_text;
	int x;
	int y;
	int width;
	int height;
	int z_index;
	int selected_index;
	ui__DropDownSelectionChangedFn on_selection_changed;
	Array_ui__DropdownItem items;
	Array_string texts;
};



struct ui__Grid {
	string id;
	Array_string header;
	Array_Array_string body;
	int x;
	int y;
	int offset_x;
	int offset_y;
	int height;
	int width;
	int z_index;
	f32 cell_height;
	f32 cell_width;
	ui__Layout parent;
	ui__UI* ui;
	bool hidden;
};



struct ui__GridParams {
	Array_string header;
	Array_Array_string body;
	int height;
	int width;
	int z_index;
	f32 cell_height;
};



struct ui__ListItem {
	string id;
	ui__ListBox* list;
	int x;
	int y;
	string text;
	string draw_text;
};



struct ui__MenuItem {
	ui__MenuItemFn action;
	string text;
};



struct ui__ProgressBarParams {
	string id;
	int width;
	int height;
	int z_index;
	int min;
	int max;
	int val;
};



struct ui__Slider {
	string id;
	int height;
	int width;
	int thumb_width;
	int thumb_height;
	int slider_size;
	ui__Orientation orientation;
	int x;
	int y;
	int offset_x;
	int offset_y;
	int z_index;
	ui__Layout parent;
	ui__UI* ui;
	f32 val;
	int min;
	int max;
	bool is_focused;
	bool dragging;
	ui__SliderValueChangedFn on_value_changed;
	bool focus_on_thumb_only;
	bool rev_min_max_pos;
	bool thumb_in_track;
	bool track_line_displayed;
	bool entering;
	bool hidden;
	voidptr component;
};



struct ui__SliderParams {
	string id;
	int width;
	int height;
	int slider_size;
	int z_index;
	int min;
	int max;
	f32 val;
	ui__Orientation orientation;
	ui__SliderValueChangedFn on_value_changed;
	bool focus_on_thumb_only;
	bool rev_min_max_pos;
	bool thumb_in_track;
	bool track_line_displayed;
	bool entering;
};



struct ui__SubWindowParams {
	string id;
	int x;
	int y;
	bool hidden;
	ui__Layout layout;
	bool drag;
	bool decoration;
};



struct ui__Switch {
	string id;
	int idx;
	int height;
	int width;
	int x;
	int y;
	int offset_x;
	int offset_y;
	int z_index;
	ui__Layout parent;
	bool is_focused;
	bool open;
	ui__UI* ui;
	ui__SwitchClickFn onclick;
	ui__SwitchKeyDownFn on_key_down;
	bool hidden;
	voidptr component;
};



struct ui__SwitchParams {
	string id;
	int z_index;
	ui__SwitchClickFn onclick;
	ui__SwitchKeyDownFn on_key_down;
	bool open;
};



struct ui__Transition {
	int x;
	int y;
	int z_index;
	int offset_x;
	int offset_y;
	i64 last_draw_time;
	i64 started_time;
	i64 duration;
	bool animating;
	ui__EasingFunction easing;
	ui__Layout parent;
	int start_value;
	int last_draw_target;
	ui__UI* ui;
	bool hidden;
	string id;
	int target_value;
	int* animated_value;
};



struct ui__TransitionParams {
	int z_index;
	int duration;
	int* animated_value;
	ui__EasingFunction easing;
	ui__Transition* ref;
};



struct gg__Size {
	int width;
	int height;
};



struct gx__Image {
	voidptr obj;
	int id;
	int width;
	int height;
};



struct os__File {
	voidptr cfile;
	int fd;
	bool is_opened;
};



struct os__FileInfo {
	string name;
	int size;
};



struct os__FilePermission {
	bool read;
	bool write;
	bool execute;
};



struct os__Result {
	int exit_code;
	string output;
};



struct os__Command {
	voidptr f;
	bool eof;
	int exit_code;
	string path;
	bool redirect_stdout;
};



struct math__DigitParams {
	int base;
	bool reverse;
};



struct math__ChebSeries {
	Array_f64 c;
	int order;
	f64 a;
	f64 b;
};


typedef sokol__sapp__ImageDesc Array_fixed_sokol__sapp__ImageDesc_8 [8];
typedef sokol__sapp__TouchPoint Array_fixed_sokol__sapp__TouchPoint_8 [8];

struct sokol__sapp__Screenshot {
	int width;
	int height;
	int size;
	u8* pixels;
};


typedef gg__TouchPoint Array_fixed_gg__TouchPoint_8 [8];

struct gg__FT {
	fontstash__Context* fons;
	int font_normal;
	int font_bold;
	int font_mono;
	int font_italic;
	f32 scale;
};



struct gg__StreamingImageConfig {
	sokol__gfx__PixelFormat pixel_format;
	sokol__gfx__Wrap wrap_u;
	sokol__gfx__Wrap wrap_v;
	sokol__gfx__Filter min_filter;
	sokol__gfx__Filter mag_filter;
	int num_mipmaps;
	int num_slices;
};



struct gg__SSRecorderSettings {
	i64 stop_at_frame;
	Array_u64 screenshot_frames;
	string screenshot_folder;
	string screenshot_prefix;
};



struct gg__FTConfig {
	string font_path;
	string custom_bold_font_path;
	f32 scale;
	int font_size;
	Array_u8 bytes_normal;
	Array_u8 bytes_bold;
	Array_u8 bytes_mono;
	Array_u8 bytes_italic;
};



struct time__TimeParseError {
	Error Error;
	int code;
};



struct time__StopWatchOptions {
	bool auto_start;
};



struct time__StopWatch {
	u64 elapsed;
	u64 start;
	u64 end;
};



struct time__InternalTimeBase {
	u32 numer;
	u32 denom;
};



struct eventbus__Registry {
	Array_eventbus__EventHandler events;
};



struct eventbus__EventHandler {
	string name;
	eventbus__EventHandlerFn handler;
	voidptr receiver;
	bool once;
};


typedef sokol__gfx__ColorState Array_fixed_sokol__gfx__ColorState_4 [4];
typedef sokol__gfx__Buffer Array_fixed_sokol__gfx__Buffer_8 [8];
typedef sokol__gfx__Image Array_fixed_sokol__gfx__Image_8 [8];
typedef sokol__gfx__ShaderAttrDesc Array_fixed_sokol__gfx__ShaderAttrDesc_16 [16];
typedef sokol__gfx__ShaderUniformBlockDesc Array_fixed_sokol__gfx__ShaderUniformBlockDesc_4 [4];
typedef sokol__gfx__ShaderImageDesc Array_fixed_sokol__gfx__ShaderImageDesc_12 [12];
typedef sokol__gfx__ShaderUniformDesc Array_fixed_sokol__gfx__ShaderUniformDesc_16 [16];
typedef sokol__gfx__PassAttachmentDesc Array_fixed_sokol__gfx__PassAttachmentDesc_4 [4];
typedef sokol__gfx__ColorAttachmentAction Array_fixed_sokol__gfx__ColorAttachmentAction_4 [4];
typedef sokol__gfx__Range Array_fixed_sokol__gfx__Range_16 [16];
typedef sokol__gfx__BufferLayoutDesc Array_fixed_sokol__gfx__BufferLayoutDesc_8 [8];
typedef sokol__gfx__VertexAttrDesc Array_fixed_sokol__gfx__VertexAttrDesc_16 [16];

struct stbi__Image {
	int width;
	int height;
	int nr_channels;
	bool ok;
	voidptr data;
	string ext;
};


typedef char Array_fixed_C__char_1024 [1024];

struct mapnode {
	voidptr* children;
	int len;
	Array_fixed_string_11 keys;
	Array_fixed_voidptr_11 values;
};



struct StrIntpData {
	string str;
	u32 fmt;
	StrIntpMem d;
};



struct ui__Stack {
	ui__CachedSizes cache;
	string id;
	int offset_x;
	int offset_y;
	int x;
	int y;
	int width;
	int height;
	int z_index;
	ui__Layout parent;
	ui__UI* ui;
	ui__VerticalAlignment vertical_alignment;
	ui__HorizontalAlignment horizontal_alignment;
	Array_f32 spacings;
	bool stretch;
	ui__Direction direction;
	ui__Margins margins;
	int real_x;
	int real_y;
	int real_width;
	int real_height;
	int adj_width;
	int adj_height;
	int fixed_width;
	int fixed_height;
	string title;
	Array_ui__Widget children;
	Array_ui__Widget drawing_children;
	Array_f32 widths;
	Array_f32 heights;
	ui__VerticalAlignments vertical_alignments;
	ui__HorizontalAlignments horizontal_alignments;
	ui__Alignments alignments;
	bool hidden;
	gx__Color bg_color;
	f32 bg_radius;
	bool is_root_layout;
	voidptr component;
	ui__ComponentInitFn component_init;
	bool has_scrollview;
	ui__ScrollView* scrollview;
	ui__ScrollViewChangedFn on_scroll_change;
	Array_string debug_ids;
};



struct gx__TextCfg {
	gx__Color color;
	int size;
	gx__HorizontalAlign align;
	gx__VerticalAlign vertical_align;
	int max_width;
	string family;
	bool bold;
	bool mono;
	bool italic;
};



struct ui__Dragger {
	bool activated;
	ui__Widget widget;
	f64 start_x;
	f64 start_y;
	f64 pos_x;
	f64 pos_y;
	time__Time time;
};



struct ui__ScrollView {
	ui__ScrollableWidget widget;
	gx__Color btn_color_x;
	gx__Color btn_color_y;
	int sb_w;
	int btn_x;
	int btn_w;
	int sb_h;
	int btn_y;
	int btn_h;
	int offset_x;
	int offset_y;
	bool active_x;
	bool active_y;
	int dragging;
	int drag_offset;
	int orig_offset;
	bool children_to_update;
	bool is_focused;
	int orig_x;
	int orig_y;
	int width;
	int height;
	int adj_width;
	int adj_height;
	int win_width;
	int win_height;
	ui__UI* ui;
	gg__Rect scissor_rect;
	ui__Layout parent;
	int delta_mouse;
};



struct ui__SyntaxChunk {
	gx__Color color;
	string font;
};



struct ui__TextView {
	string* text;
	int cursor_pos;
	int sel_start;
	int sel_end;
	int line_height;
	ui__TextLinesView tlv;
	ui__TextBox* tb;
	int left_margin;
	ui__SyntaxHighLighter* sh;
};



struct ui__TextStyleParams {
	string id;
	string font_name;
	gx__Color color;
	int size;
	ui__TextHorizontalAlign align;
	ui__TextVerticalAlign vertical_align;
};



struct ui__Color {
	int id;
	gx__Color color;
};



struct ui__TextStyle {
	string id;
	string font_name;
	gx__Color color;
	int size;
	ui__TextHorizontalAlign align;
	ui__TextVerticalAlign vertical_align;
	bool mono;
};



struct ui__CanvasLayoutParams {
	string id;
	int width;
	int height;
	int full_width;
	int full_height;
	int z_index;
	string text;
	gx__Color bg_color;
	f64 bg_radius;
	bool scrollview;
	ui__CanvasLayoutDrawFn on_draw;
	ui__CanvasLayoutMouseFn on_click;
	ui__CanvasLayoutMouseFn on_mouse_down;
	ui__CanvasLayoutMouseFn on_mouse_up;
	ui__CanvasLayoutScrollFn on_scroll;
	ui__CanvasLayoutMouseMoveFn on_mouse_move;
	ui__CanvasLayoutKeyFn on_key_down;
	ui__CanvasLayoutKeyFn on_char;
	ui__CanvasLayoutSizeFn full_size_fn;
	ui__ScrollViewChangedFn on_scroll_change;
	Array_ui__Widget children;
};



struct ui__ColumnParams {
	string id;
	int width;
	int height;
	ui__HorizontalAlignment alignment;
	f64 spacing;
	Array_f64 spacings;
	bool stretch;
	ui__Margin margin;
	f64 margin_;
	ui__Size widths;
	ui__Size heights;
	ui__HorizontalAlignments alignments;
	ui__Alignments align;
	gx__Color bg_color;
	f64 bg_radius;
	string title;
	bool scrollview;
	Array_ui__Widget children;
};



struct ui__RowParams {
	string id;
	int width;
	int height;
	ui__VerticalAlignment alignment;
	f64 spacing;
	Array_f64 spacings;
	bool stretch;
	f64 margin_;
	ui__Margin margin;
	ui__Size widths;
	ui__Size heights;
	ui__Alignments align;
	ui__VerticalAlignments alignments;
	gx__Color bg_color;
	f64 bg_radius;
	string title;
	bool scrollview;
	Array_ui__Widget children;
};



struct ui__StackParams {
	string id;
	int width;
	int height;
	ui__VerticalAlignment vertical_alignment;
	ui__HorizontalAlignment horizontal_alignment;
	Array_f32 spacings;
	f32 spacing;
	bool stretch;
	ui__Direction direction;
	ui__Margins margins;
	string title;
	Array_f32 widths;
	Array_f32 heights;
	ui__Alignments align;
	ui__VerticalAlignments vertical_alignments;
	ui__HorizontalAlignments horizontal_alignments;
	gx__Color bg_color;
	f32 bg_radius;
	bool scrollview;
	Array_ui__Widget children;
};



struct ui__Touch {
	ui__Pos pos;
	time__Time time;
};



struct gg__Image {
	int id;
	int width;
	int height;
	int nr_channels;
	bool ok;
	voidptr data;
	string ext;
	bool simg_ok;
	sokol__gfx__Image simg;
	string path;
};



struct ui__Dropdown {
	string id;
	string def_text;
	int width;
	int dropdown_height;
	ui__Layout parent;
	int x;
	int y;
	int offset_x;
	int offset_y;
	int z_index;
	ui__UI* ui;
	Array_ui__DropdownItem items;
	bool open;
	int selected_index;
	int hover_index;
	bool is_focused;
	ui__DropDownSelectionChangedFn on_selection_changed;
	bool hidden;
	gx__Color bg_color;
	voidptr component;
};



struct ui__WindowParams {
	int width;
	int height;
	string font_path;
	string title;
	bool always_on_top;
	voidptr state;
	gx__Color bg_color;
	ui__ClickFn on_click;
	ui__ClickFn on_mouse_down;
	ui__ClickFn on_mouse_up;
	ui__ClickFn on_files_droped;
	ui__ClickFn on_swipe;
	ui__KeyFn on_key_down;
	ui__KeyFn on_char;
	ui__ScrollFn on_scroll;
	ui__ResizeFn on_resize;
	ui__WindowFn on_iconify;
	ui__WindowFn on_restore;
	ui__WindowFn on_quit_request;
	ui__WindowFn on_suspend;
	ui__WindowFn on_resume;
	ui__MouseMoveFn on_mouse_move;
	ui__WindowFn on_init;
	ui__WindowFn on_draw;
	Array_ui__Widget children;
	string custom_bold_font_path;
	bool native_rendering;
	bool resizable;
	ui__WindowSizeType mode;
	bool immediate;
	int lines;
	bool native_message;
	bool enable_dragndrop;
	int max_dropped_files;
	int max_dropped_file_path_length;
};



struct gg__Event {
	u64 frame_count;
	sokol__sapp__EventType typ;
	gg__KeyCode key_code;
	u32 char_code;
	bool key_repeat;
	u32 modifiers;
	gg__MouseButton mouse_button;
	f32 mouse_x;
	f32 mouse_y;
	f32 mouse_dx;
	f32 mouse_dy;
	f32 scroll_x;
	f32 scroll_y;
	int num_touches;
	Array_fixed_gg__TouchPoint_8 touches;
	int window_width;
	int window_height;
	int framebuffer_width;
	int framebuffer_height;
};



struct os__FileMode {
	os__FileType typ;
	os__FilePermission owner;
	os__FilePermission group;
	os__FilePermission others;
};



struct os__Process {
	string filename;
	int pid;
	int code;
	os__ProcessState status;
	string err;
	Array_string args;
	bool env_is_custom;
	Array_string env;
	bool use_stdio_ctl;
	bool use_pgroup;
	Array_fixed_int_3 stdio_fd;
	voidptr wdata;
};



struct gg__PenConfig {
	gx__Color color;
	gg__PenLineType line_type;
	int thickness;
};



struct gg__Config {
	int width;
	int height;
	bool use_ortho;
	bool retina;
	bool resizable;
	voidptr user_data;
	int font_size;
	bool create_window;
	string window_title;
	bool borderless_window;
	bool always_on_top;
	gx__Color bg_color;
	gg__FNCb init_fn;
	gg__FNCb frame_fn;
	gg__FNCb native_frame_fn;
	gg__FNCb cleanup_fn;
	gg__FNFail fail_fn;
	gg__FNEvent event_fn;
	gg__FNEvent quit_fn;
	gg__FNKeyDown keydown_fn;
	gg__FNKeyUp keyup_fn;
	gg__FNChar char_fn;
	gg__FNMove move_fn;
	gg__FNClick click_fn;
	gg__FNUnClick unclick_fn;
	gg__FNEvent leave_fn;
	gg__FNEvent enter_fn;
	gg__FNEvent resized_fn;
	gg__FNEvent scroll_fn;
	bool fullscreen;
	f32 scale;
	int sample_count;
	int swap_interval;
	string font_path;
	string custom_bold_font_path;
	bool ui_mode;
	Array_u8 font_bytes_normal;
	Array_u8 font_bytes_bold;
	Array_u8 font_bytes_mono;
	Array_u8 font_bytes_italic;
	bool native_rendering;
	bool enable_dragndrop;
	int max_dropped_files;
	int max_dropped_file_path_length;
};



struct gg__DrawImageConfig {
	bool flip_x;
	bool flip_y;
	gg__Image* img;
	int img_id;
	gg__Rect img_rect;
	gg__Rect part_rect;
	int rotate;
	f32 z;
	gx__Color color;
};


typedef Array_fixed_sokol__gfx__Range_16 Array_fixed_Array_fixed_sokol__gfx__Range_16_6 [6];

struct ui__UI {
	gg__Context* gg;
	ui__Window* window;
	bool show_cursor;
	i64 last_type_time;
	clipboard__Clipboard* clipboard;
	Array_fixed_bool_3 btn_down;
	gg__Image cb_image;
	gg__Image circle_image;
	gg__Image selected_radio_image;
	gg__Image down_arrow;
	Map_string_gg__Image resource_cache;
	bool closed;
	int ticks;
	Map_string_ui__TextStyle text_styles;
	ui__FontSet fonts;
};



struct ui__TextLines {
	Array_string lines;
	int x;
	int y;
	int width;
	int height;
	gx__TextCfg text_cfg;
	f64 text_size;
};



struct ui__TextStyles {
	ui__TextStyle current;
	Map_string_ui__TextStyle hash;
};



struct ui__TouchInfo {
	ui__Touch start;
	ui__Touch move;
	ui__Touch end;
	int button;
};



struct ui__ButtonParams {
	string id;
	string text;
	string icon_path;
	ui__ButtonClickFn onclick;
	ui__ButtonKeyDownFn on_key_down;
	int height;
	int width;
	int z_index;
	bool movable;
	bool hoverable;
	string tooltip;
	ui__Side tooltip_side;
	gx__TextCfg text_cfg;
	f64 text_size;
	gx__Color* bg_color;
	ui__ColorThemeCfg theme;
	f64 radius;
	f64 padding;
};



struct ui__CheckBoxParams {
	string id;
	int x;
	int y;
	int z_index;
	string text;
	ui__CheckBowClickFn on_click;
	ui__CheckChangedFn on_check_changed;
	bool checked;
	bool disabled;
	gx__TextCfg text_cfg;
	f64 text_size;
};



struct ui__LabelParams {
	string id;
	int width;
	int height;
	int z_index;
	string text;
	gx__TextCfg text_cfg;
	f64 text_size;
};



struct ui__ListBoxParams {
	int x;
	int y;
	int width;
	int height;
	int z_index;
	ui__ListBoxSelectionChangedFn on_change;
	bool draw_lines;
	gx__Color col_border;
	gx__Color col_bkgrnd;
	gx__Color col_selected;
	int item_height;
	int text_offset_y;
	string id;
	gx__TextCfg text_cfg;
	f64 text_size;
	int selection;
	bool scrollview;
	Map_string_string items;
	bool files_droped;
};



struct ui__Menu {
	string id;
	int offset_x;
	int offset_y;
	bool hidden;
	ui__UI* ui;
	gx__TextCfg text_cfg;
	f64 text_size;
	voidptr component;
	int width;
	int height;
	string text;
	ui__Layout parent;
	int x;
	int y;
	int z_index;
	Array_ui__MenuItem items;
};



struct ui__MenuParams {
	string id;
	int width;
	int z_index;
	gx__TextCfg text_cfg;
	f64 text_size;
	string text;
	Array_ui__MenuItem items;
};



struct ui__Picture {
	string id;
	int offset_x;
	int offset_y;
	bool hidden;
	voidptr component;
	int width;
	int height;
	string text;
	ui__Layout parent;
	int x;
	int y;
	int z_index;
	bool movable;
	string path;
	ui__UI* ui;
	gg__Image image;
	ui__PictureClickFn on_click;
	bool use_cache;
	ui__TooltipMessage tooltip;
};



struct ui__PictureParams {
	string id;
	string path;
	int width;
	int height;
	int z_index;
	bool movable;
	ui__PictureClickFn on_click;
	bool use_cache;
	ui__Picture* ref;
	gg__Image image;
	string tooltip;
	ui__Side tooltip_side;
};



struct ui__RadioParams {
	string id;
	ui__RadioClickFn on_click;
	Array_string values;
	string title;
	int width;
	int z_index;
	gx__TextCfg text_cfg;
	f64 text_size;
	bool horizontal;
	bool compact;
};



struct ui__Rectangle {
	string id;
	gx__Color color;
	string text;
	int offset_x;
	int offset_y;
	int height;
	int width;
	ui__UI* ui;
	ui__Layout parent;
	gx__TextCfg text_cfg;
	f64 text_size;
	voidptr component;
	int x;
	int y;
	int z_index;
	int radius;
	bool border;
	gx__Color border_color;
	bool hidden;
};



struct ui__RectangleParams {
	string id;
	string text;
	int height;
	int width;
	int z_index;
	gx__Color color;
	int radius;
	bool border;
	gx__Color border_color;
	int x;
	int y;
	gx__TextCfg text_cfg;
	f64 text_size;
};



struct ui__TextBoxParams {
	string id;
	int width;
	int height;
	bool read_only;
	bool is_multiline;
	bool is_wordwrap;
	bool is_line_number;
	ui__TextBoxMode mode;
	bool is_sync;
	bool twosided_sel;
	int z_index;
	int min;
	int max;
	int val;
	string placeholder;
	string* placeholder_bind;
	int max_len;
	bool is_numeric;
	bool is_password;
	string* text;
	bool* is_error;
	bool is_focused;
	gx__Color bg_color;
	bool borderless;
	bool fitted_height;
	ui__TextBoxKeyDownFn on_key_down;
	ui__TextBoxCharFn on_char;
	voidptr on_change;
	voidptr on_enter;
	ui__TextBoxValidatedFn on_changed;
	ui__TextBoxValidatedFn on_entered;
	bool border_accentuated;
	gx__TextCfg text_cfg;
	f64 text_size;
	bool scrollview;
	ui__ScrollViewChangedFn on_scroll_change;
};



struct gg__StringToRender {
	int x;
	int y;
	string text;
	gx__TextCfg cfg;
};



struct ui__Label {
	string id;
	string text;
	ui__Layout parent;
	int x;
	int y;
	int offset_x;
	int offset_y;
	int width;
	int height;
	int z_index;
	int adj_width;
	int adj_height;
	ui__UI* ui;
	ui__TextStyles text_styles;
	f64 text_size;
	gx__TextCfg text_cfg;
	bool hidden;
	voidptr component;
};



struct ui__Radio {
	string id;
	int selected_index;
	Array_string values;
	string title;
	int height;
	int width;
	int real_height;
	int real_width;
	Array_int widths;
	int adj_height;
	int adj_width;
	int x;
	int y;
	int offset_x;
	int offset_y;
	int z_index;
	ui__Layout parent;
	bool is_focused;
	bool is_checked;
	ui__UI* ui;
	ui__TextStyles text_styles;
	f64 text_size;
	gx__TextCfg text_cfg;
	bool hidden;
	bool horizontal;
	bool compact;
	voidptr component;
	ui__RadioClickFn on_click;
};



struct ui__Button {
	int width_;
	int height_;
	string id;
	ui__ButtonState state;
	int height;
	int width;
	int z_index;
	int x;
	int y;
	int offset_x;
	int offset_y;
	int text_width;
	int text_height;
	gx__Color* bg_color;
	ui__Layout parent;
	bool is_focused;
	ui__UI* ui;
	ui__ButtonClickFn onclick;
	ui__ButtonKeyDownFn on_key_down;
	string text;
	string icon_path;
	gg__Image image;
	bool use_icon;
	f32 padding;
	f32 radius;
	bool hidden;
	bool movable;
	bool hoverable;
	bool to_hover;
	ui__TooltipMessage tooltip;
	ui__TextStyles text_styles;
	f64 text_size;
	gx__TextCfg text_cfg;
	ui__ColorThemeCfg theme_cfg;
	Map_int_gx__Color theme;
	voidptr component;
};



struct ui__CanvasLayout {
	string id;
	Array_ui__Widget children;
	Array_ui__Widget drawing_children;
	int width;
	int height;
	int x;
	int y;
	int offset_x;
	int offset_y;
	int z_index;
	bool is_focused;
	ui__UI* ui;
	bool hidden;
	gx__Color bg_color;
	f32 bg_radius;
	int adj_width;
	int adj_height;
	int full_width;
	int full_height;
	ui__TextStyles text_styles;
	voidptr component;
	ui__ComponentInitFn component_init;
	bool has_scrollview;
	ui__ScrollView* scrollview;
	ui__CanvasLayoutDrawFn draw_fn;
	ui__CanvasLayoutMouseFn click_fn;
	ui__CanvasLayoutMouseFn mouse_down_fn;
	ui__CanvasLayoutMouseFn mouse_up_fn;
	ui__CanvasLayoutScrollFn scroll_fn;
	ui__CanvasLayoutMouseMoveFn mouse_move_fn;
	ui__CanvasLayoutKeyFn key_down_fn;
	ui__CanvasLayoutKeyFn char_fn;
	ui__CanvasLayoutSizeFn full_size_fn;
	ui__ScrollViewChangedFn on_scroll_change;
	ui__Layout parent;
	Map_int_ui__XYPos pos_;
};



struct ui__ListBox {
	int height;
	int width;
	int x;
	int y;
	int offset_x;
	int offset_y;
	int z_index;
	ui__Layout parent;
	ui__UI* ui;
	Array_ui__ListItem items;
	int selection;
	int draw_count;
	ui__ListBoxSelectionChangedFn on_change;
	bool is_focused;
	bool draw_lines;
	gx__Color col_bkgrnd;
	gx__Color col_selected;
	gx__Color col_border;
	int item_height;
	int text_offset_y;
	string id;
	ui__TextStyles text_styles;
	f64 text_size;
	gx__TextCfg text_cfg;
	bool hidden;
	bool files_droped;
	int adj_width;
	int adj_height;
	voidptr component;
	bool has_scrollview;
	ui__ScrollView* scrollview;
	ui__ScrollViewChangedFn on_scroll_change;
};



struct ui__TextBox {
	string id;
	int height;
	int width;
	int x;
	int y;
	int offset_x;
	int offset_y;
	int z_index;
	ui__Layout parent;
	bool is_focused;
	bool is_typing;
	ui__UI* ui;
	string* text;
	string text_;
	int max_len;
	int line_height;
	int cursor_pos;
	int sel_start;
	int sel_end;
	string placeholder;
	string* placeholder_bind;
	bool is_multiline;
	ui__TextView tv;
	bool is_wordwrap;
	bool is_line_number;
	bool is_sync;
	bool twosided_sel;
	bool is_numeric;
	bool is_password;
	bool read_only;
	bool borderless;
	gx__Color bg_color;
	bool fitted_height;
	ui__TextBoxKeyDownFn on_key_down;
	ui__TextBoxCharFn on_char;
	bool is_selectable;
	bool sel_active;
	bool dragging;
	ui__SelectionDirection sel_direction;
	bool border_accentuated;
	bool* is_error;
	ui__TextBoxChangeFn on_change;
	ui__TextBoxEnterFn on_enter;
	ui__TextBoxValidatedFn on_changed;
	ui__TextBoxValidatedFn on_entered;
	ui__TextStyles text_styles;
	f64 text_size;
	gx__TextCfg text_cfg;
	bool hidden;
	voidptr component;
	bool has_scrollview;
	ui__ScrollView* scrollview;
	ui__ScrollViewChangedFn on_scroll_change;
};



struct ui__Tooltip {
	ui__TextLines TextLines;
	string id;
	bool active;
	gx__Color color;
	gx__Color bg_color;
	ui__Side side;
	ui__UI* ui;
};



struct gg__Context {
	bool render_text;
	Array_gg__Image image_cache;
	bool needs_refresh;
	int ticks;
	bool native_rendering;
	f32 scale;
	int width;
	int height;
	sokol__gfx__PassAction clear_pass;
	sokol__sapp__Desc window;
	sokol__sgl__Pipeline timage_pip;
	gg__Config config;
	voidptr user_data;
	gg__FT* ft;
	bool font_inited;
	bool ui_mode;
	u64 frame;
	u8 mbtn_mask;
	gg__MouseButtons mouse_buttons;
	int mouse_pos_x;
	int mouse_pos_y;
	int mouse_dx;
	int mouse_dy;
	int scroll_x;
	int scroll_y;
	gg__Modifier key_modifiers;
	bool key_repeat;
	Array_fixed_bool_512 pressed_keys;
	Array_fixed_bool_512 pressed_keys_edge;
};



struct ui__CheckBox {
	string id;
	int height;
	int width;
	int x;
	int y;
	int offset_x;
	int offset_y;
	int z_index;
	ui__Layout parent;
	bool is_focused;
	bool checked;
	ui__UI* ui;
	ui__CheckBowClickFn on_click;
	ui__CheckChangedFn on_check_changed;
	string text;
	bool disabled;
	ui__TextStyles text_styles;
	f64 text_size;
	gx__TextCfg text_cfg;
	bool hidden;
	voidptr component;
};



struct ui__Window {
	string id;
	ui__UI* ui;
	Array_ui__Widget children;
	ui__Window* child_window;
	ui__Window* parent_window;
	bool has_textbox;
	bool just_tabbed;
	voidptr state;
	string title;
	int width;
	int height;
	ui__ClickFn click_fn;
	ui__ClickFn mouse_down_fn;
	ui__ClickFn mouse_up_fn;
	ui__ClickFn files_droped_fn;
	ui__ClickFn swipe_fn;
	ui__MouseMoveFn mouse_move_fn;
	ui__ScrollFn scroll_fn;
	ui__KeyFn key_down_fn;
	ui__KeyFn char_fn;
	ui__ResizeFn resize_fn;
	ui__WindowFn iconified_fn;
	ui__WindowFn restored_fn;
	ui__WindowFn quit_requested_fn;
	ui__WindowFn suspended_fn;
	ui__WindowFn resumed_fn;
	ui__WindowFn on_init;
	ui__WindowFn on_draw;
	eventbus__EventBus* eventbus;
	bool resizable;
	ui__WindowSizeType mode;
	ui__Layout root_layout;
	f32 dpi_scale;
	int orig_width;
	int orig_height;
	ui__TouchInfo touch;
	gx__Color bg_color;
	gx__TextCfg text_cfg;
	Map_string_ui__ColorTheme color_themes;
	Map_string_ui__Widget widgets;
	Map_string_int widgets_counts;
	ui__Dragger dragger;
	ui__Tooltip tooltip;
	Array_ui__Widget widgets_tooltip;
	Array_ui__TooltipMessage tooltips;
	bool native_message;
	bool do_focus;
	string locked_focus;
	ui__EventMngr evt_mngr;
	Array_ui__SubWindow_ptr subwindows;
	bool immediate;
	Array_ui__Widget children_immediate;
	bool needs_refresh;
	ui__SettingsUI settings;
};


// #end sorted_symbols

// BEGIN_multi_return_structs
struct multi_return_u32_u32 {
	u32 arg0;
	u32 arg1;
};

struct multi_return_u32_u32_u32 {
	u32 arg0;
	u32 arg1;
	u32 arg2;
};

struct multi_return_strconv__ParserState_strconv__PrepNumber {
	strconv__ParserState arg0;
	strconv__PrepNumber arg1;
};

struct multi_return_u64_int {
	u64 arg0;
	int arg1;
};

struct multi_return_strconv__Dec32_bool {
	strconv__Dec32 arg0;
	bool arg1;
};

struct multi_return_strconv__Dec64_bool {
	strconv__Dec64 arg0;
	bool arg1;
};

struct multi_return_int_int {
	int arg0;
	int arg1;
};

struct multi_return_f64_f64_f64 {
	f64 arg0;
	f64 arg1;
	f64 arg2;
};

struct multi_return_bool_ref_ui__ScrollView {
	bool arg0;
	ui__ScrollView* arg1;
};

struct multi_return_int_f32 {
	int arg0;
	f32 arg1;
};

struct multi_return_Array_string_Array_int {
	Array_string arg0;
	Array_int arg1;
};

struct multi_return_int_int_int_int {
	int arg0;
	int arg1;
	int arg2;
	int arg3;
};

struct multi_return_bool_ui__Layout {
	bool arg0;
	ui__Layout arg1;
};

struct multi_return_Array_int_Array_int {
	Array_int arg0;
	Array_int arg1;
};

struct multi_return_ui__HorizontalAlignment_ui__VerticalAlignment {
	ui__HorizontalAlignment arg0;
	ui__VerticalAlignment arg1;
};

struct multi_return_string_string {
	string arg0;
	string arg1;
};

struct multi_return_string_int {
	string arg0;
	int arg1;
};

struct multi_return_int_bool {
	int arg0;
	bool arg1;
};

struct multi_return_u64_u64 {
	u64 arg0;
	u64 arg1;
};

struct multi_return_f64_int {
	f64 arg0;
	int arg1;
};

struct multi_return_i64_i64_i64 {
	i64 arg0;
	i64 arg1;
	i64 arg2;
};

struct multi_return_f64_f64 {
	f64 arg0;
	f64 arg1;
};

struct multi_return_int_int_int {
	int arg0;
	int arg1;
	int arg2;
};

struct multi_return_int_int_int_int_i64_bool {
	int arg0;
	int arg1;
	int arg2;
	int arg3;
	i64 arg4;
	bool arg5;
};

// END_multi_return_structs


typedef struct thread_arg_ui__UI_idle_loop {
	ui__UI* arg0;
EMPTY_STRUCT_DECLARATION;
} thread_arg_ui__UI_idle_loop;
void* ui__UI_idle_loop_thread_wrapper(thread_arg_ui__UI_idle_loop *arg);
static bool Array_string_contains(Array_string a, string v); // auto
static bool Array_int_contains(Array_int a, int v); // auto
static int Array_string_index(Array_string a, string v); // auto

// V alias definitions:

// V shared types:

// V Option_xxx definitions:
struct Option_int {
	byte state;
	IError err;
	byte data[sizeof(int) > 0 ? sizeof(int) : 1];
};

struct Option_f64 {
	byte state;
	IError err;
	byte data[sizeof(f64) > 0 ? sizeof(f64) : 1];
};

struct Option_u64 {
	byte state;
	IError err;
	byte data[sizeof(u64) > 0 ? sizeof(u64) : 1];
};

struct Option_i64 {
	byte state;
	IError err;
	byte data[sizeof(i64) > 0 ? sizeof(i64) : 1];
};

struct Option_rune {
	byte state;
	IError err;
	byte data[sizeof(rune) > 0 ? sizeof(rune) : 1];
};

struct Option_string {
	byte state;
	IError err;
	byte data[sizeof(string) > 0 ? sizeof(string) : 1];
};

struct Option_u8 {
	byte state;
	IError err;
	byte data[sizeof(u8) > 0 ? sizeof(u8) : 1];
};

struct Option_os__File {
	byte state;
	IError err;
	byte data[sizeof(os__File) > 0 ? sizeof(os__File) : 1];
};

struct Option_FILE_ptr {
	byte state;
	IError err;
	byte data[sizeof(FILE*) > 0 ? sizeof(FILE*) : 1];
};

struct Option_void {
	byte state;
	IError err;
	byte data[sizeof(u8) > 0 ? sizeof(u8) : 1];
};

struct Option_Array_u8 {
	byte state;
	IError err;
	byte data[sizeof(Array_u8) > 0 ? sizeof(Array_u8) : 1];
};

struct Option_Array_string {
	byte state;
	IError err;
	byte data[sizeof(Array_string) > 0 ? sizeof(Array_string) : 1];
};

struct Option_bool {
	byte state;
	IError err;
	byte data[sizeof(bool) > 0 ? sizeof(bool) : 1];
};

struct Option_os__SignalHandler {
	byte state;
	IError err;
	byte data[sizeof(os__SignalHandler) > 0 ? sizeof(os__SignalHandler) : 1];
};

struct Option_time__Time {
	byte state;
	IError err;
	byte data[sizeof(time__Time) > 0 ? sizeof(time__Time) : 1];
};

struct Option_multi_return_int_int_int {
	byte state;
	IError err;
	byte data[sizeof(multi_return_int_int_int) > 0 ? sizeof(multi_return_int_int_int) : 1];
};

struct Option_multi_return_int_int_int_int_i64_bool {
	byte state;
	IError err;
	byte data[sizeof(multi_return_int_int_int_int_i64_bool) > 0 ? sizeof(multi_return_int_int_int_int_i64_bool) : 1];
};

struct Option_stbi__Image {
	byte state;
	IError err;
	byte data[sizeof(stbi__Image) > 0 ? sizeof(stbi__Image) : 1];
};

struct Option_gg__FT_ptr {
	byte state;
	IError err;
	byte data[sizeof(gg__FT*) > 0 ? sizeof(gg__FT*) : 1];
};

struct Option_ui__TextStyle {
	byte state;
	IError err;
	byte data[sizeof(ui__TextStyle) > 0 ? sizeof(ui__TextStyle) : 1];
};

struct Option_f32 {
	byte state;
	IError err;
	byte data[sizeof(f32) > 0 ? sizeof(f32) : 1];
};

struct Option_ui__SettingsUI {
	byte state;
	IError err;
	byte data[sizeof(ui__SettingsUI) > 0 ? sizeof(ui__SettingsUI) : 1];
};

struct Option_multi_return_string_string {
	byte state;
	IError err;
	byte data[sizeof(multi_return_string_string) > 0 ? sizeof(multi_return_string_string) : 1];
};

struct Option_ui__Widget {
	byte state;
	IError err;
	byte data[sizeof(ui__Widget) > 0 ? sizeof(ui__Widget) : 1];
};


// V json forward decls:

// V definitions:
static char * v_typeof_interface_IError(int sidx);
static char * v_typeof_interface_ui__Widget(int sidx);
static char * v_typeof_interface_ui__DrawText(int sidx);
static char * v_typeof_interface_ui__ScrollableWidget(int sidx);
static char * v_typeof_interface_ui__Layout(int sidx);
static char * v_typeof_interface_ui__Focusable(int sidx);
static char * v_typeof_interface_ui__DrawTextWidget(int sidx);
static char * v_typeof_interface_ui__ColorThemeWidget(int sidx);
static char * v_typeof_interface_ui__ComponentChild(int sidx);
// end of definitions #endif
strings__Builder strings__new_builder(int initial_size);
void strings__Builder_write_ptr(strings__Builder* b, u8* ptr, int len);
void strings__Builder_write_rune(strings__Builder* b, rune r);
void strings__Builder_write_runes(strings__Builder* b, Array_rune runes);
void strings__Builder_write_b(strings__Builder* b, u8 data);
void strings__Builder_write_u8(strings__Builder* b, u8 data);
void strings__Builder_write_byte(strings__Builder* b, byte data);
Option_int strings__Builder_write(strings__Builder* b, Array_u8 data);
void strings__Builder_drain_builder(strings__Builder* b, strings__Builder* other, int other_new_cap);
u8 strings__Builder_byte_at(strings__Builder* b, int n);
void strings__Builder_write_string(strings__Builder* b, string s);
void strings__Builder_go_back(strings__Builder* b, int n);
string strings__Builder_spart(strings__Builder* b, int start_pos, int n);
string strings__Builder_cut_last(strings__Builder* b, int n);
string strings__Builder_cut_to(strings__Builder* b, int pos);
void strings__Builder_go_back_to(strings__Builder* b, int pos);
void strings__Builder_writeln(strings__Builder* b, string s);
string strings__Builder_last_n(strings__Builder* b, int n);
string strings__Builder_after(strings__Builder* b, int n);
string strings__Builder_str(strings__Builder* b);
void strings__Builder_ensure_cap(strings__Builder* b, int n);
void strings__Builder_free(strings__Builder* b);
int strings__levenshtein_distance(string a, string b);
f32 strings__levenshtein_distance_percentage(string a, string b);
f32 strings__dice_coefficient(string s1, string s2);
string strings__repeat(u8 c, int n);
string strings__repeat_string(string s, int n);
string strings__find_between_pair_u8(string input, u8 start, u8 end);
string strings__find_between_pair_rune(string input, rune start, rune end);
string strings__find_between_pair_string(string input, string start, string end);
u32 _const_math__bits__de_bruijn32 = 125613361; // precomputed
Array_u8 _const_math__bits__de_bruijn32tab; // inited later
u64 _const_math__bits__de_bruijn64 = 285870213051353865U; // precomputed
Array_u8 _const_math__bits__de_bruijn64tab; // inited later
u64 _const_math__bits__m0 = 6148914691236517205U; // precomputed
u64 _const_math__bits__m1 = 3689348814741910323U; // precomputed
u64 _const_math__bits__m2 = 1085102592571150095U; // precomputed
u64 _const_math__bits__m3 = 71777214294589695U; // precomputed
u64 _const_math__bits__m4 = 281470681808895U; // precomputed
u32 _const_math__bits__max_u32 = 4294967295; // precomputed
u64 _const_math__bits__max_u64 = 18446744073709551615U; // precomputed
int math__bits__leading_zeros_8(u8 x);
int math__bits__leading_zeros_16(u16 x);
int math__bits__leading_zeros_32(u32 x);
int math__bits__leading_zeros_64(u64 x);
int math__bits__trailing_zeros_8(u8 x);
int math__bits__trailing_zeros_16(u16 x);
int math__bits__trailing_zeros_32(u32 x);
int math__bits__trailing_zeros_64(u64 x);
int math__bits__ones_count_8(u8 x);
int math__bits__ones_count_16(u16 x);
int math__bits__ones_count_32(u32 x);
int math__bits__ones_count_64(u64 x);
u8 math__bits__rotate_left_8(u8 x, int k);
u16 math__bits__rotate_left_16(u16 x, int k);
u32 math__bits__rotate_left_32(u32 x, int k);
u64 math__bits__rotate_left_64(u64 x, int k);
u8 math__bits__reverse_8(u8 x);
u16 math__bits__reverse_16(u16 x);
u32 math__bits__reverse_32(u32 x);
u64 math__bits__reverse_64(u64 x);
u16 math__bits__reverse_bytes_16(u16 x);
u32 math__bits__reverse_bytes_32(u32 x);
u64 math__bits__reverse_bytes_64(u64 x);
int math__bits__len_8(u8 x);
int math__bits__len_16(u16 x);
int math__bits__len_32(u32 x);
int math__bits__len_64(u64 x);
multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry);
multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry);
multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow);
multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow);
u64 _const_math__bits__two32 = 4294967296U; // precomputed
u64 _const_math__bits__mask32 = 4294967295U; // precomputed
string _const_math__bits__overflow_error; // a string literal, inited later
string _const_math__bits__divide_error; // a string literal, inited later
multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y);
multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y);
multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y);
multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1);
u32 math__bits__rem_32(u32 hi, u32 lo, u32 y);
u64 math__bits__rem_64(u64 hi, u64 lo, u64 y);
multi_return_f64_int math__bits__normalize(f64 x);
Array_u8 _const_math__bits__ntz_8_tab; // inited later
Array_u8 _const_math__bits__pop_8_tab; // inited later
Array_u8 _const_math__bits__rev_8_tab; // inited later
Array_u8 _const_math__bits__len_8_tab; // inited later
u32 _const_strconv__single_plus_zero = 0; // precomputed
u32 _const_strconv__single_minus_zero = 2147483648; // precomputed
u32 _const_strconv__single_plus_infinity = 2139095040; // precomputed
u32 _const_strconv__single_minus_infinity = 4286578688; // precomputed
#define _const_strconv__digits 18
u64 _const_strconv__double_plus_zero = 0U; // precomputed
u64 _const_strconv__double_minus_zero = 9223372036854775808U; // precomputed
u64 _const_strconv__double_plus_infinity = 9218868437227405312U; // precomputed
u64 _const_strconv__double_minus_infinity = 18442240474082181120U; // precomputed
rune _const_strconv__c_dpoint = '.'; // precomputed
rune _const_strconv__c_plus = '+'; // precomputed
rune _const_strconv__c_minus = '-'; // precomputed
rune _const_strconv__c_zero = '0'; // precomputed
rune _const_strconv__c_nine = '9'; // precomputed
u32 _const_strconv__c_ten = 10; // precomputed
multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0);
multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0);
multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0);
multi_return_u32_u32_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0);
bool strconv__is_digit(u8 x);
bool strconv__is_space(u8 x);
bool strconv__is_exp(u8 x);
multi_return_strconv__ParserState_strconv__PrepNumber strconv__parser(string s);
u64 strconv__converter(strconv__PrepNumber* pn);
Option_f64 strconv__atof64(string s);
f64 strconv__atof_quick(string s);
Array_u64 _const_strconv__pos_exp; // inited later
Array_u64 _const_strconv__neg_exp; // inited later
#define _const_strconv__int_size 32
u64 _const_strconv__max_u64 = 18446744073709551615U; // precomputed
u8 strconv__byte_to_lower(u8 c);
Option_u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
multi_return_u64_int strconv__common_parse_uint2(string s, int _base, int _bit_size);
Option_u64 strconv__parse_uint(string s, int _base, int _bit_size);
Option_i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
Option_i64 strconv__parse_int(string _s, int base, int _bit_size);
Option_int strconv__atoi(string s);
bool strconv__underscore_ok(string s);
Array_u32 _const_strconv__ten_pow_table_32; // inited later
u32 _const_strconv__mantbits32 = 23; // precomputed
u32 _const_strconv__expbits32 = 8; // precomputed
#define _const_strconv__bias32 127
#define _const_strconv__maxexp32 255
string strconv__Dec32_get_string_32(strconv__Dec32 d, bool neg, int i_n_digit, int i_pad_digit);
multi_return_strconv__Dec32_bool strconv__f32_to_decimal_exact_int(u32 i_mant, u32 exp);
strconv__Dec32 strconv__f32_to_decimal(u32 mant, u32 exp);
string strconv__f32_to_str(f32 f, int n_digit);
string strconv__f32_to_str_pad(f32 f, int n_digit);
string strconv__Dec64_get_string_64(strconv__Dec64 d, bool neg, int i_n_digit, int i_pad_digit);
multi_return_strconv__Dec64_bool strconv__f64_to_decimal_exact_int(u64 i_mant, u64 exp);
strconv__Dec64 strconv__f64_to_decimal(u64 mant, u64 exp);
string strconv__f64_to_str(f64 f, int n_digit);
string strconv__f64_to_str_pad(f64 f, int n_digit);
Array_u64 _const_strconv__ten_pow_table_64; // inited later
u32 _const_strconv__mantbits64 = 52; // precomputed
u32 _const_strconv__expbits64 = 11; // precomputed
#define _const_strconv__bias64 1023
#define _const_strconv__maxexp64 2047
Array_f64 _const_strconv__dec_round; // inited later
string strconv__format_str(string s, strconv__BF_param p);
void strconv__format_str_sb(string s, strconv__BF_param p, strings__Builder* sb);
#define _const_strconv__max_size_f64_char 32
string _const_strconv__digit_pairs; // a string literal, inited later
void strconv__format_dec_sb(u64 d, strconv__BF_param p, strings__Builder* res);
string strconv__f64_to_str_lnd1(f64 f, int dec_digit);
string strconv__format_fl(f64 f, strconv__BF_param p);
string strconv__format_es(f64 f, strconv__BF_param p);
string strconv__remove_tail_zeros(string s);
string strconv__ftoa_64(f64 f);
string strconv__ftoa_long_64(f64 f);
string strconv__ftoa_32(f32 f);
string strconv__ftoa_long_32(f32 f);
string _const_strconv__base_digits; // a string literal, inited later
string strconv__format_int(i64 n, int radix);
string strconv__format_uint(u64 n, int radix);
#define _const_strconv__pow5_num_bits_32 61
#define _const_strconv__pow5_inv_num_bits_32 59
#define _const_strconv__pow5_num_bits_64 121
#define _const_strconv__pow5_inv_num_bits_64 122
Array_u64 _const_strconv__powers_of_10; // inited later
Array_u64 _const_strconv__pow5_split_32; // inited later
Array_u64 _const_strconv__pow5_inv_split_32; // inited later
Array_strconv__Uint128 _const_strconv__pow5_split_64; // inited later
Array_strconv__Uint128 _const_strconv__pow5_inv_split_64; // inited later
string strconv__f32_to_str_l(f32 f);
string strconv__f32_to_str_l_no_dot(f32 f);
string strconv__f64_to_str_l(f64 f);
string strconv__f64_to_str_l_no_dot(f64 f);
string strconv__fxx_to_str_l_parse(string s);
string strconv__fxx_to_str_l_parse_no_dot(string s);
int strconv__bool_to_int(bool b);
u32 strconv__bool_to_u32(bool b);
u64 strconv__bool_to_u64(bool b);
string strconv__get_string_special(bool neg, bool expZero, bool mantZero);
u32 strconv__mul_shift_32(u32 m, u64 mul, int ishift);
u32 strconv__mul_pow5_invdiv_pow2(u32 m, u32 q, int j);
u32 strconv__mul_pow5_div_pow2(u32 m, u32 i, int j);
u32 strconv__pow5_factor_32(u32 i_v);
bool strconv__multiple_of_power_of_five_32(u32 v, u32 p);
bool strconv__multiple_of_power_of_two_32(u32 v, u32 p);
u32 strconv__log10_pow2(int e);
u32 strconv__log10_pow5(int e);
int strconv__pow5_bits(int e);
u64 strconv__shift_right_128(strconv__Uint128 v, int shift);
u64 strconv__mul_shift_64(u64 m, strconv__Uint128 mul, int shift);
u32 strconv__pow5_factor_64(u64 v_i);
bool strconv__multiple_of_power_of_five_64(u64 v, u32 p);
bool strconv__multiple_of_power_of_two_64(u64 v, u32 p);
int strconv__dec_digits(u64 n);
void strconv__v_printf(string str, Array_voidptr pt);
string strconv__v_sprintf(string str, Array_voidptr pt);
void strconv__v_sprintf_panic(int idx, int len);
f64 strconv__fabs(f64 x);
string strconv__format_fl_old(f64 f, strconv__BF_param p);
string strconv__format_es_old(f64 f, strconv__BF_param p);
string strconv__remove_tail_zeros_old(string s);
string strconv__format_dec_old(u64 d, strconv__BF_param p);
array __new_array(int mylen, int cap, int elm_size);
array __new_array_with_default(int mylen, int cap, int elm_size, voidptr val);
array __new_array_with_array_default(int mylen, int cap, int elm_size, array val);
array __new_array_with_map_default(int mylen, int cap, int elm_size, map val);
array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array);
array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, voidptr c_array);
void array_ensure_cap(array* a, int required);
array array_repeat(array a, int count);
array array_repeat_to_depth(array a, int count, int depth);
void array_insert(array* a, int i, voidptr val);
void array_insert_many(array* a, int i, voidptr val, int size);
void array_prepend(array* a, voidptr val);
void array_prepend_many(array* a, voidptr val, int size);
void array_delete(array* a, int i);
void array_delete_many(array* a, int i, int size);
void array_clear(array* a);
void array_trim(array* a, int index);
void array_drop(array* a, int num);
voidptr array_get_unsafe(array a, int i);
voidptr array_get(array a, int i);
voidptr array_get_with_check(array a, int i);
voidptr array_first(array a);
voidptr array_last(array a);
voidptr array_pop(array* a);
void array_delete_last(array* a);
array array_slice(array a, int start, int _end);
array array_slice_ni(array a, int _start, int _end);
array array_slice2(array a, int start, int _end, bool end_max);
array array_clone_static_to_depth(array a, int depth);
array array_clone(array* a);
array array_clone_to_depth(array* a, int depth);
void array_set_unsafe(array* a, int i, voidptr val);
void array_set(array* a, int i, voidptr val);
void array_push(array* a, voidptr val);
void array_push_many(array* a3, voidptr val, int size);
void array_reverse_in_place(array* a);
array array_reverse(array a);
void array_free(array* a);
array array_filter(array a, bool (*predicate)(voidptr ));
bool array_any(array a, bool (*predicate)(voidptr ));
bool array_all(array a, bool (*predicate)(voidptr ));
array array_map(array a, voidptr (*callback)(voidptr ));
void array_sort(array* a, int (*callback)(voidptr , voidptr ));
void array_sort_with_compare(array* a, int (*callback)(voidptr , voidptr ));
bool array_contains(array a, voidptr value);
int array_index(array a, voidptr value);
void Array_string_free(Array_string* a);
string Array_string_str(Array_string a);
string Array_u8_hex(Array_u8 b);
int copy(Array_u8* dst, Array_u8 src);
int Array_int_reduce(Array_int a, int (*iter)(int , int ), int accum_start);
void array_grow_cap(array* a, int amount);
void array_grow_len(array* a, int amount);
Array_voidptr array_pointers(array a);
Array_u8 voidptr_vbytes(voidptr data, int len);
Array_u8 u8_vbytes(u8* data, int len);
array __new_array_noscan(int mylen, int cap, int elm_size);
void vhalt(void);
void _v_exit(int code);
string vcommithash(void);
void panic_debug(int line_no, string file, string mod, string fn_name, string s);
void panic_optional_not_set(string s);
void _v_panic(string s);
string c_error_number_str(int errnum);
void panic_error_number(string basestr, int errnum);
void eprintln(string s);
void eprint(string s);
void flush_stdout(void);
void flush_stderr(void);
void print(string s);
void println(string s);
void _writeln_to_fd(int fd, string s);
void _write_buf_to_fd(int fd, u8* buf, int buf_len);
i64  total_m = ((i64)(0)); // global4
u8* _v_malloc(int n);
u8* malloc_noscan(int n);
u8* v_realloc(u8* b, int n);
u8* realloc_data(u8* old_data, int old_size, int new_size);
u8* vcalloc(int n);
u8* vcalloc_noscan(int n);
void _v_free(voidptr ptr);
voidptr memdup(voidptr src, int sz);
voidptr memdup_noscan(voidptr src, int sz);
int v_fixed_index(int i, int len);
void print_backtrace(void);
bool isnil(voidptr v);
Array_VCastTypeIndexName  as_cast_type_indexes; // global4
voidptr __as_cast(voidptr obj, int obj_type, int expected_type);
void VAssertMetaInfo_free(VAssertMetaInfo* ami);
void __print_assert_failure(VAssertMetaInfo* i);
void v_segmentation_fault_handler(int signal);
void builtin_init(void);
bool print_backtrace_skipping_top_frames(int xskipframes);
bool print_backtrace_skipping_top_frames_bsd(int skipframes);
bool print_backtrace_skipping_top_frames_linux(int skipframes);
void break_if_debugger_attached(void);
string winapi_lasterr_str(void);
void panic_lasterr(void);
void gc_check_leaks(void);
int proc_pidpath(int , voidptr , int );
int vstrlen(byte* s);
int vstrlen_char(char* s);
voidptr vmemcpy(voidptr dest, const voidptr const_src, int n);
voidptr vmemmove(voidptr dest, const voidptr const_src, int n);
int vmemcmp(const voidptr const_s1, const voidptr const_s2, int n);
voidptr vmemset(voidptr s, int c, int n);
void vqsort(voidptr base, usize nmemb, usize size, int (*sort_cb)(const voidptr const_a, const voidptr const_b));
void chan_close(chan ch);
ChanState chan_try_pop(chan ch, voidptr obj);
ChanState chan_try_push(chan ch, voidptr obj);
string f64_str(f64 x);
string f64_strg(f64 x);
string float_literal_str(float_literal d);
string f64_strsci(f64 x, int digit_num);
string f64_strlong(f64 x);
string f32_str(f32 x);
string f32_strg(f32 x);
string f32_strsci(f32 x, int digit_num);
string f32_strlong(f32 x);
f32 f32_abs(f32 a);
f64 f64_abs(f64 a);
f32 f32_max(f32 a, f32 b);
f32 f32_min(f32 a, f32 b);
f64 f64_max(f64 a, f64 b);
f64 f64_min(f64 a, f64 b);
bool f32_eq_epsilon(f32 a, f32 b);
bool f64_eq_epsilon(f64 a, f64 b);
void float_test(void);
string ptr_str(voidptr ptr);
string isize_str(isize x);
string usize_str(usize x);
string char_str(char* cptr);
string _const_digit_pairs; // a string literal, inited later
string int_str_l(int nn, int max);
string i8_str(i8 n);
string i16_str(i16 n);
string u16_str(u16 n);
string int_str(int n);
string u32_str(u32 nn);
string int_literal_str(int_literal n);
string i64_str(i64 nn);
string u64_str(u64 nn);
string bool_str(bool b);
string u64_to_hex(u64 nn, u8 len);
string u64_to_hex_no_leading_zeros(u64 nn, u8 len);
string u8_hex(u8 nn);
string i8_hex(i8 nn);
string u16_hex(u16 nn);
string i16_hex(i16 nn);
string u32_hex(u32 nn);
string int_hex(int nn);
string int_hex2(int n);
string u64_hex(u64 nn);
string i64_hex(i64 nn);
string int_literal_hex(int_literal nn);
string voidptr_str(voidptr nn);
string byteptr_str(byteptr nn);
string charptr_str(charptr nn);
string u8_hex_full(u8 nn);
string i8_hex_full(i8 nn);
string u16_hex_full(u16 nn);
string i16_hex_full(i16 nn);
string u32_hex_full(u32 nn);
string int_hex_full(int nn);
string i64_hex_full(i64 nn);
string voidptr_hex_full(voidptr nn);
string int_literal_hex_full(int_literal nn);
string u64_hex_full(u64 nn);
string u8_str(u8 b);
string u8_ascii_str(u8 b);
string u8_str_escaped(u8 b);
bool u8_is_capital(u8 c);
Array_u8 Array_u8_clone(Array_u8 b);
string Array_u8_bytestr(Array_u8 b);
Option_rune Array_u8_byterune(Array_u8 b);
string u8_repeat(u8 b, int count);
bool fast_string_eq(string a, string b);
u64 map_hash_string(voidptr pkey);
u64 map_hash_int_1(voidptr pkey);
u64 map_hash_int_2(voidptr pkey);
u64 map_hash_int_4(voidptr pkey);
u64 map_hash_int_8(voidptr pkey);
void DenseArray_zeros_to_end(DenseArray* d);
#define _const_hashbits 24
#define _const_max_cached_hashbits 16
#define _const_init_log_capicity 5
#define _const_init_capicity 32
f64 _const_max_load_factor = 0.8; // precomputed
#define _const_init_even_index 30
#define _const_extra_metas_inc 4
u32 _const_hash_mask = 16777215; // precomputed
u32 _const_probe_inc = 16777216; // precomputed
DenseArray new_dense_array(int key_bytes, int value_bytes);
voidptr DenseArray_key(DenseArray* d, int i);
voidptr DenseArray_value(DenseArray* d, int i);
bool DenseArray_has_index(DenseArray* d, int i);
int DenseArray_expand(DenseArray* d);
bool map_eq_string(voidptr a, voidptr b);
bool map_eq_int_1(voidptr a, voidptr b);
bool map_eq_int_2(voidptr a, voidptr b);
bool map_eq_int_4(voidptr a, voidptr b);
bool map_eq_int_8(voidptr a, voidptr b);
void map_clone_string(voidptr dest, voidptr pkey);
void map_clone_int_1(voidptr dest, voidptr pkey);
void map_clone_int_2(voidptr dest, voidptr pkey);
void map_clone_int_4(voidptr dest, voidptr pkey);
void map_clone_int_8(voidptr dest, voidptr pkey);
void map_free_string(voidptr pkey);
void map_free_nop(voidptr _d1);
map new_map(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ));
map new_map_init(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
map map_move(map* m);
multi_return_u32_u32 map_key_to_index(map* m, voidptr pkey);
multi_return_u32_u32 map_meta_less(map* m, u32 _index, u32 _metas);
void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi);
void map_ensure_extra_metas(map* m, u32 probe_count);
void map_set(map* m, voidptr key, voidptr value);
void map_expand(map* m);
void map_rehash(map* m);
void map_cached_rehash(map* m, u32 old_cap);
voidptr map_get_and_set(map* m, voidptr key, voidptr zero);
voidptr map_get(map* m, voidptr key, voidptr zero);
voidptr map_get_check(map* m, voidptr key);
bool map_exists(map* m, voidptr key);
void DenseArray_delete(DenseArray* d, int i);
void map_delete(map* m, voidptr key);
array map_keys(map* m);
DenseArray DenseArray_clone(DenseArray* d);
map map_clone(map* m);
void map_free(map* m);
void IError_free(IError* ie);
string IError_str(IError err);
string Error_msg(Error err);
int Error_code(Error err);
string MessageError_msg(MessageError err);
int MessageError_code(MessageError err);
void MessageError_free(MessageError* err);
IError _const_none__; // inited later
string None___str(None__ _d1);
IError _v_error(string message);
IError error_with_code(string message, int code);
void opt_ok(voidptr data, Option* option, int size);
string none_str(none _d2);
#define _const_prealloc_block_size 16777216
VMemoryBlock*  g_memory_block; // global4
VMemoryBlock* vmemory_block_new(VMemoryBlock* prev, int at_least);
byte* vmemory_block_malloc(int n);
void prealloc_vinit(void);
void prealloc_vcleanup(void);
byte* prealloc_malloc(int n);
byte* prealloc_realloc(byte* old_data, int old_size, int new_size);
byte* prealloc_calloc(int n);
string rune_str(rune c);
string Array_rune_string(Array_rune ra);
string rune_repeat(rune c, int count);
Array_u8 rune_bytes(rune c);
int rune_length_in_bytes(rune c);
#define _const_degree 6
#define _const_mid_index 5
#define _const_max_len 11
u32 _const_children_bytes; // inited later
SortedMap new_sorted_map(int n, int value_bytes);
SortedMap new_sorted_map_init(int n, int value_bytes, string* keys, voidptr values);
mapnode* new_node(void);
void SortedMap_set(SortedMap* m, string key, voidptr value);
void mapnode_split_child(mapnode* n, int child_index, mapnode* y);
bool SortedMap_get(SortedMap m, string key, voidptr out);
bool SortedMap_exists(SortedMap m, string key);
int mapnode_find_key(mapnode* n, string k);
bool mapnode_remove_key(mapnode* n, string k);
void mapnode_remove_from_leaf(mapnode* n, int idx);
void mapnode_remove_from_non_leaf(mapnode* n, int idx);
void mapnode_fill(mapnode* n, int idx);
void mapnode_borrow_from_prev(mapnode* n, int idx);
void mapnode_borrow_from_next(mapnode* n, int idx);
void mapnode_merge(mapnode* n, int idx);
void SortedMap_delete(SortedMap* m, string key);
int mapnode_subkeys(mapnode* n, Array_string* keys, int at);
Array_string SortedMap_keys(SortedMap* m);
void mapnode_free(mapnode* n);
void SortedMap_free(SortedMap* m);
void SortedMap_print(SortedMap m);
Array_rune string_runes(string s);
string cstring_to_vstring(char* s);
string tos_clone(u8* s);
string tos(u8* s, int len);
string tos2(u8* s);
string tos3(char* s);
string tos4(u8* s);
string tos5(char* s);
string u8_vstring(u8* bp);
string u8_vstring_with_len(u8* bp, int len);
string char_vstring(char* cp);
string char_vstring_with_len(char* cp, int len);
string u8_vstring_literal(u8* bp);
string u8_vstring_literal_with_len(u8* bp, int len);
string char_vstring_literal(char* cp);
string char_vstring_literal_with_len(char* cp, int len);
string string_clone_static(string a);
string string_clone(string a);
string string_replace_once(string s, string rep, string with);
string string_replace(string s, string rep, string with);
string string_replace_each(string s, Array_string vals);
VV_LOCAL_SYMBOL int compare_14421781451463525574_RepIndex_by_idx(RepIndex* a, RepIndex* b) {
	if (a->idx < b->idx) return -1;
	else return 1;
}

bool string_bool(string s);
int string_int(string s);
i64 string_i64(string s);
i8 string_i8(string s);
i16 string_i16(string s);
f32 string_f32(string s);
f64 string_f64(string s);
u8 string_u8(string s);
u16 string_u16(string s);
u32 string_u32(string s);
u64 string_u64(string s);
Option_u64 string_parse_uint(string s, int _base, int _bit_size);
Option_i64 string_parse_int(string s, int _base, int _bit_size);
bool string__eq(string s, string a);
int string_compare(string s, string a);
bool string__lt(string s, string a);
string string__plus(string s, string a);
Array_string string_split_any(string s, string delim);
Array_string string_split(string s, string delim);
Array_string string_split_nth(string s, string delim, int nth);
Array_string string_split_into_lines(string s);
string string_substr2(string s, int start, int _end, bool end_max);
string string_substr(string s, int start, int end);
Option_string string_substr_with_check(string s, int start, int end);
string string_substr_ni(string s, int _start, int _end);
int string_index_(string s, string p);
Option_int string_index(string s, string p);
int string_index_kmp(string s, string p);
int string_index_any(string s, string chars);
int string_last_index_(string s, string p);
Option_int string_last_index(string s, string p);
int string_index_after(string s, string p, int start);
int string_index_u8(string s, u8 c);
int string_last_index_u8(string s, u8 c);
int string_count(string s, string substr);
bool string_contains(string s, string substr);
bool string_contains_any(string s, string chars);
bool string_contains_any_substr(string s, Array_string substrs);
bool string_starts_with(string s, string p);
bool string_ends_with(string s, string p);
string string_to_lower(string s);
bool string_is_lower(string s);
string string_to_upper(string s);
bool string_is_upper(string s);
string string_capitalize(string s);
bool string_is_capital(string s);
bool string_starts_with_capital(string s);
string string_title(string s);
bool string_is_title(string s);
string string_find_between(string s, string start, string end);
string string_trim_space(string s);
string string_trim(string s, string cutset);
string string_trim_left(string s, string cutset);
string string_trim_right(string s, string cutset);
string string_trim_string_left(string s, string str);
string string_trim_string_right(string s, string str);
string string_trim_prefix(string s, string str);
string string_trim_suffix(string s, string str);
int compare_strings(string* a, string* b);
int compare_strings_by_len(string* a, string* b);
int compare_lower_strings(string* a, string* b);
void Array_string_sort_ignore_case(Array_string* s);
void Array_string_sort_by_len(Array_string* s);
string string_str(string s);
byte string_at(string s, int idx);
Option_u8 string_at_with_check(string s, int idx);
bool u8_is_space(u8 c);
bool u8_is_digit(u8 c);
bool u8_is_hex_digit(u8 c);
bool u8_is_oct_digit(u8 c);
bool u8_is_bin_digit(u8 c);
bool u8_is_letter(u8 c);
bool u8_is_alnum(u8 c);
void string_free(string* s);
string string_before(string s, string sub);
string string_all_before(string s, string sub);
string string_all_before_last(string s, string sub);
string string_all_after(string s, string sub);
string string_all_after_last(string s, string sub);
string string_after(string s, string sub);
string string_after_char(string s, u8 sub);
string Array_string_join(Array_string a, string sep);
string Array_string_join_lines(Array_string s);
string string_reverse(string s);
string string_limit(string s, int max);
int string_hash(string s);
Array_u8 string_bytes(string s);
string string_repeat(string s, int count);
Array_string string_fields(string s);
string string_strip_margin(string s);
string string_strip_margin_custom(string s, u8 del);
bool string_match_glob(string name, string pattern);
Array_u8 byteptr_vbytes(byteptr data, int len);
string byteptr_vstring(byteptr bp);
string byteptr_vstring_with_len(byteptr bp, int len);
string charptr_vstring(charptr cp);
string charptr_vstring_with_len(charptr cp, int len);
string byteptr_vstring_literal(byteptr bp);
string byteptr_vstring_literal_with_len(byteptr bp, int len);
string charptr_vstring_literal(charptr cp);
string charptr_vstring_literal_with_len(charptr cp, int len);
string StrIntpType_str(StrIntpType x);
f32 fabs32(f32 x);
f64 fabs64(f64 x);
u64 abs64(i64 x);
u64 get_str_intp_u64_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, byte in_pad_ch, int in_base, bool in_upper_case);
u32 get_str_intp_u32_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, byte in_pad_ch, int in_base, bool in_upper_case);
void StrIntpData_process_str_intp_data(StrIntpData* data, strings__Builder* sb);
string str_intp(int data_len, voidptr in_data);
string _const_si_s_code; // a string literal, inited later
string _const_si_g32_code; // a string literal, inited later
string _const_si_g64_code; // a string literal, inited later
string str_intp_sq(string in_str);
string str_intp_rune(string in_str);
string str_intp_g32(string in_str);
string str_intp_g64(string in_str);
string str_intp_sub(string base_str, string in_str);
#define _const_cp_utf8 65001
u16* string_to_wide(string _str);
string string_from_wide(u16* _wstr);
string string_from_wide2(u16* _wstr, int len);
int utf8_getchar(void);
int utf8_char_len(u8 b);
string utf32_to_str(u32 code);
string utf32_to_str_no_malloc(u32 code, u8* buf);
int utf32_decode_to_buffer(u32 code, u8* buf);
int string_utf32_code(string _rune);
Option_rune Array_u8_utf8_to_utf32(Array_u8 _bytes);
int utf8_len(u8 c);
int utf8_str_len(string s);
int utf8_str_visible_length(string s);
bool ArrayFlags_is_empty(ArrayFlags* e);
bool ArrayFlags_has(ArrayFlags* e, ArrayFlags flag);
bool ArrayFlags_all(ArrayFlags* e, ArrayFlags flag);
void ArrayFlags_set(ArrayFlags* e, ArrayFlags flag);
void ArrayFlags_clear(ArrayFlags* e, ArrayFlags flag);
void ArrayFlags_toggle(ArrayFlags* e, ArrayFlags flag);
Array_string os__args_after(string cut_word);
Array_string os__args_before(string cut_word);
#define _const_os__o_rdonly 0
#define _const_os__o_wronly 1
#define _const_os__o_rdwr 2
#define _const_os__o_binary 0
#define _const_os__o_create 64
#define _const_os__o_excl 128
#define _const_os__o_noctty 256
#define _const_os__o_trunc 512
#define _const_os__o_append 1024
#define _const_os__o_nonblock 2048
#define _const_os__o_sync 1052672
string os__getenv(string key);
Option_string os__getenv_opt(string key);
int os__setenv(string name, string value, bool overwrite);
int os__unsetenv(string name);
char** os__unix_environ(void);
Map_string_string os__environ(void);
int os__fd_close(int fd);
void os__fd_write(int fd, string s);
Array_string os__fd_slurp(int fd);
multi_return_string_int os__fd_read(int fd, int maxbytes);
Option_os__File os__open_file(string path, string mode, Array_int options);
Option_os__File os__open(string path);
Option_os__File os__create(string path);
os__File os__stdin(void);
os__File os__stdout(void);
os__File os__stderr(void);
Option_int os__File_read(os__File* f, Array_u8* buf);
Option_int os__File_write(os__File* f, Array_u8 buf);
Option_int os__File_writeln(os__File* f, string s);
Option_int os__File_write_string(os__File* f, string s);
Option_int os__File_write_to(os__File* f, u64 pos, Array_u8 buf);
int os__File_write_ptr(os__File* f, voidptr data, int size);
Option_void os__File_write_full_buffer(os__File* f, voidptr buffer, usize buffer_len);
int os__File_write_ptr_at(os__File* f, voidptr data, int size, u64 pos);
Option_int os__fread(voidptr ptr, int item_size, int items, FILE* stream);
Array_u8 os__File_read_bytes(os__File* f, int size);
Array_u8 os__File_read_bytes_at(os__File* f, int size, u64 pos);
Option_int os__File_read_bytes_into_newline(os__File* f, Array_u8* buf);
Option_int os__File_read_bytes_into(os__File* f, u64 pos, Array_u8* buf);
Option_int os__File_read_from(os__File* f, u64 pos, Array_u8* buf);
Option_int os__File_read_into_ptr(os__File* f, u8* ptr, int max_size);
void os__File_flush(os__File* f);
string os__FileNotOpenedError_msg(os__FileNotOpenedError err);
string os__SizeOfTypeIs0Error_msg(os__SizeOfTypeIs0Error err);
IError os__error_file_not_opened(void);
IError os__error_size_of_type_0(void);
Option_void os__File_seek(os__File* f, i64 pos, os__SeekMode mode);
Option_i64 os__File_tell(os__File* f);
u32 os__FilePermission_bitmask(os__FilePermission p);
u32 os__FileMode_bitmask(os__FileMode m);
os__FileMode os__inode(string path);
Array_string _const_os__args; // inited later
Option_Array_u8 os__read_bytes(string path);
Option_string os__read_file(string path);
Option_void os__truncate(string path, u64 len);
void os__eprintln_unknown_file_size(void);
u64 os__file_size(string path);
Option_void os__mv(string src, string dst);
Option_void os__cp(string src, string dst);
Option_FILE_ptr os__vfopen(string path, string mode);
int os__fileno(voidptr cfile);
voidptr os__vpopen(string path);
multi_return_int_bool os__posix_wait4_to_exit_status(int waitret);
string os__posix_get_error_msg(int code);
int os__vpclose(voidptr f);
int os__system(string cmd);
bool os__exists(string path);
bool os__is_executable(string path);
bool os__is_writable(string path);
bool os__is_readable(string path);
Option_void os__rm(string path);
Option_void os__rmdir(string path);
void os__print_c_errno(void);
string os__get_raw_line(void);
Array_u8 os__get_raw_stdin(void);
string os__executable(void);
bool os__is_dir(string path);
bool os__is_link(string path);
Option_void os__chdir(string path);
int os__max_path_bufffer_size(void);
string os__getwd(void);
string os__real_path(string fpath);
void os__normalize_drive_letter(string path);
int os__fork(void);
int os__wait(void);
i64 os__file_last_mod_unix(string path);
void os__flush(void);
Option_void os__chmod(string path, int mode);
Option_void os__chown(string path, int owner, int group);
Option_os__File os__open_append(string path);
Option_void os__execvp(string cmdpath, Array_string cmdargs);
Option_void os__execve(string cmdpath, Array_string cmdargs, Array_string envs);
int os__is_atty(int fd);
Option_void os__write_file_array(string path, array buffer);
Option_Array_string os__glob(Array_string patterns);
VV_LOCAL_SYMBOL int compare_12251921909942893683_string(string* a, string* b) {
	if (string__lt(*a, *b)) return -1;
	else return 1;
}

IError os__last_error(void);
#define _const_os__max_path_len 4096
string _const_os__wd_at_startup; // inited later
#define _const_os__f_ok 0
#define _const_os__x_ok 1
#define _const_os__w_ok 2
#define _const_os__r_ok 4
void os__Result_free(os__Result* result);
Option_void os__cp_all(string src, string dst, bool overwrite);
Option_void os__mv_by_cp(string source, string target);
Option_Array_string os__read_lines(string path);
string os__sigint_to_signal_name(int si);
Option_void os__rmdir_all(string path);
bool os__is_dir_empty(string path);
string os__file_ext(string path);
string os__dir(string opath);
string os__base(string opath);
string os__file_name(string opath);
Option_string os__input_opt(string prompt);
string os__input(string prompt);
string os__get_line(void);
Array_string os__get_lines(void);
string os__get_lines_joined(void);
string os__get_raw_lines_joined(void);
string os__user_os(void);
string os__home_dir(void);
string os__expand_tilde_to_home(string path);
Option_void os__write_file(string path, string text);
string os__executable_fallback(void);
string os__ExecutableNotFoundError_msg(os__ExecutableNotFoundError err);
IError os__error_failed_to_find_executable(void);
Option_string os__find_abs_path_of_executable(string exepath);
bool os__exists_in_system_path(string prog);
bool os__is_file(string path);
bool os__is_abs_path(string path);
string os__join_path(string base, Array_string dirs);
string os__join_path_single(string base, string elem);
Array_string os__walk_ext(string path, string ext);
void os__impl_walk_ext(string path, string ext, Array_string* out);
void os__walk(string path, void (*f)(string ));
void os__walk_with_context(string path, voidptr context, void (*fcb)(voidptr , string ));
void os__log(string s);
Option_void os__mkdir_all(string opath);
string os__cache_dir(void);
string os__temp_dir(void);
string os__default_vmodules_path(void);
string os__vmodules_dir(void);
Array_string os__vmodules_paths(void);
string os__resource_abs_path(string path);
os__Result os__execute_or_panic(string cmd);
os__Result os__execute_or_exit(string cmd);
string os__quoted_path(string path);
Option_string os__config_dir(void);
#define _const_os__sys_write 4
#define _const_os__sys_open 5
#define _const_os__sys_close 6
#define _const_os__sys_mkdir 136
#define _const_os__sys_creat 8
#define _const_os__sys_open_nocancel 398
#define _const_os__sys_stat64 338
string _const_os__path_separator; // a string literal, inited later
string _const_os__path_delimiter; // a string literal, inited later
#define _const_os__stdin_value 0
#define _const_os__stdout_value 1
#define _const_os__stderr_value 2
#define _const_os__s_ifmt 61440
#define _const_os__s_ifdir 16384
#define _const_os__s_iflnk 40960
#define _const_os__s_isuid 2048
#define _const_os__s_isgid 1024
#define _const_os__s_isvtx 512
#define _const_os__s_irusr 256
#define _const_os__s_iwusr 128
#define _const_os__s_ixusr 64
#define _const_os__s_irgrp 32
#define _const_os__s_iwgrp 16
#define _const_os__s_ixgrp 8
#define _const_os__s_iroth 4
#define _const_os__s_iwoth 2
#define _const_os__s_ixoth 1
Array_string os__glob_match(string dir, string pattern, string next_pattern, Array_string* matches);
Option_void os__native_glob_pattern(string pattern, Array_string* matches);
Option_void os__utime(string path, int actime, int modtime);
os__Uname os__uname(void);
string os__hostname(void);
string os__loginname(void);
Array_string os__init_os_args(int argc, u8** argv);
Option_Array_string os__ls(string path);
Option_bool os__mkdir(string path);
os__Result os__execute(string cmd);
Option_void os__Command_start(os__Command* c);
string os__Command_read_line(os__Command* c);
Option_void os__Command_close(os__Command* c);
Option_bool os__symlink(string origin, string target);
Option_bool os__link(string origin, string target);
string os__get_error_msg(int code);
void os__File_close(os__File* f);
bool os__debugger_present(void);
Option_bool os__is_writable_folder(string folder);
int os__getpid(void);
int os__getppid(void);
int os__getuid(void);
int os__geteuid(void);
int os__getgid(void);
int os__getegid(void);
void os__posix_set_permission_bit(string path_s, u32 mode, bool enable);
void os__Process_signal_kill(os__Process* p);
void os__Process_signal_pgkill(os__Process* p);
void os__Process_signal_stop(os__Process* p);
void os__Process_signal_continue(os__Process* p);
void os__Process_wait(os__Process* p);
void os__Process_close(os__Process* p);
void os__Process_free(os__Process* p);
int os__Process__spawn(os__Process* p);
bool os__Process_is_alive(os__Process* p);
void os__Process_set_redirect_stdio(os__Process* p);
void os__Process_stdin_write(os__Process* p, string s);
string os__Process_stdout_slurp(os__Process* p);
string os__Process_stderr_slurp(os__Process* p);
string os__Process_stdout_read(os__Process* p);
string os__Process_stderr_read(os__Process* p);
void os__Process__check_redirection_call(os__Process* p, string fn_name);
void os__Process__signal_stop(os__Process* p);
void os__Process__signal_continue(os__Process* p);
void os__Process__signal_kill(os__Process* p);
void os__Process__signal_pgkill(os__Process* p);
void os__Process__wait(os__Process* p);
bool os__Process__is_alive(os__Process* p);
void os__Process_run(os__Process* p);
os__Process* os__new_process(string filename);
void os__Process_set_args(os__Process* p, Array_string pargs);
void os__Process_set_environment(os__Process* p, Map_string_string envs);
int os__Process_unix_spawn_process(os__Process* p);
void os__Process_unix_stop_process(os__Process* p);
void os__Process_unix_resume_process(os__Process* p);
void os__Process_unix_kill_process(os__Process* p);
void os__Process_unix_kill_pgroup(os__Process* p);
void os__Process_unix_wait(os__Process* p);
bool os__Process_unix_is_alive(os__Process* p);
int os__Process_win_spawn_process(os__Process* p);
void os__Process_win_stop_process(os__Process* p);
void os__Process_win_resume_process(os__Process* p);
void os__Process_win_kill_process(os__Process* p);
void os__Process_win_kill_pgroup(os__Process* p);
void os__Process_win_wait(os__Process* p);
bool os__Process_win_is_alive(os__Process* p);
void os__Process_win_write_string(os__Process* p, int idx, string s);
multi_return_string_int os__Process_win_read_string(os__Process* p, int idx, int maxbytes);
string os__Process_win_slurp(os__Process* p, int idx);
Option_os__SignalHandler os__signal_opt(os__Signal signum, void (*handler)(os__Signal ));
Option_void os__open_uri(string uri);
i64 time__portable_timegm(struct tm* t);
int time__days_from_civil(int oy, int m, int d);
string time__Time_format(time__Time t);
string time__Time_format_ss(time__Time t);
string time__Time_format_ss_milli(time__Time t);
string time__Time_format_ss_micro(time__Time t);
string time__Time_hhmm(time__Time t);
string time__Time_hhmmss(time__Time t);
string time__Time_hhmm12(time__Time t);
string time__Time_ymmdd(time__Time t);
string time__Time_ddmmy(time__Time t);
string time__Time_md(time__Time t);
string time__Time_clean(time__Time t);
string time__Time_clean12(time__Time t);
string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time);
string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date);
string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date);
string time__Time_utc_string(time__Time t);
bool time__Time__eq(time__Time t1, time__Time t2);
bool time__Time__lt(time__Time t1, time__Time t2);
time__Duration time__Time__minus(time__Time lhs, time__Time rhs);
Option_time__Time time__parse_rfc3339(string s);
Option_time__Time time__parse(string s);
Option_time__Time time__parse_iso8601(string s);
Option_time__Time time__parse_rfc2822(string s);
Option_multi_return_int_int_int time__parse_iso8601_date(string s);
Option_multi_return_int_int_int_int_i64_bool time__parse_iso8601_time(string s);
string time__TimeParseError_msg(time__TimeParseError err);
IError time__error_invalid_time(int code);
time__StopWatch time__new_stopwatch(time__StopWatchOptions opts);
void time__StopWatch_start(time__StopWatch* t);
void time__StopWatch_restart(time__StopWatch* t);
void time__StopWatch_stop(time__StopWatch* t);
void time__StopWatch_pause(time__StopWatch* t);
time__Duration time__StopWatch_elapsed(time__StopWatch t);
time__Time time__now(void);
time__Time time__utc(void);
time__Time time__new_time(time__Time t);
i64 time__ticks(void);
string time__Time_str(time__Time t);
time__Time time__convert_ctime(struct tm t, int microsecond);
string time__Time_strftime(time__Time t, string fmt);
string _const_time__days_string; // a string literal, inited later
Array_int _const_time__month_days; // inited later
string _const_time__months_string; // a string literal, inited later
i64 _const_time__absolute_zero_year; // inited later
#define _const_time__seconds_per_minute 60
#define _const_time__seconds_per_hour 3600
#define _const_time__seconds_per_day 86400
#define _const_time__seconds_per_week 604800
#define _const_time__days_per_400_years 146097
#define _const_time__days_per_100_years 36524
#define _const_time__days_per_4_years 1461
Array_int _const_time__days_before; // inited later
Array_string _const_time__long_days; // inited later
string time__Time_smonth(time__Time* t);
i64 time__Time_unix_time(time__Time* t);
i64 time__Time_unix_time_milli(time__Time* t);
time__Time time__Time_add(time__Time* t, time__Duration d);
time__Time time__Time_add_seconds(time__Time* t, int seconds);
time__Time time__Time_add_days(time__Time* t, int days);
time__Duration time__since(time__Time t);
string time__Time_relative(time__Time* t);
string time__Time_relative_short(time__Time* t);
int time__day_of_week(int y, int m, int d);
int time__Time_day_of_week(time__Time* t);
string time__Time_weekday_str(time__Time* t);
string time__Time_long_weekday_str(time__Time* t);
bool time__is_leap_year(int year);
Option_int time__days_in_month(int month, int year);
string time__Time_debug(time__Time* t);
time__Duration _const_time__nanosecond; // inited later
time__Duration _const_time__microsecond; // inited later
time__Duration _const_time__millisecond; // inited later
time__Duration _const_time__second; // inited later
time__Duration _const_time__minute; // inited later
time__Duration _const_time__hour; // inited later
time__Duration _const_time__infinite; // inited later
i64 time__Duration_nanoseconds(time__Duration d);
i64 time__Duration_microseconds(time__Duration d);
i64 time__Duration_milliseconds(time__Duration d);
f64 time__Duration_seconds(time__Duration d);
f64 time__Duration_minutes(time__Duration d);
f64 time__Duration_hours(time__Duration d);
string time__Duration_str(time__Duration d);
int time__offset(void);
u64 _const_time__start_time; // inited later
mach_timebase_info_data_t _const_time__time_base; // inited later
mach_timebase_info_data_t time__init_time_base(void);
u64 time__sys_mono_now_darwin(void);
u64 time__vpc_now_darwin(void);
time__Time time__darwin_now(void);
time__Time time__darwin_utc(void);
time__Time time__solaris_now(void);
time__Time time__solaris_utc(void);
i64 time__make_unix_time(struct tm t);
time__Time time__Time_local(time__Time* t);
u64 time__sys_mono_now(void);
u64 time__vpc_now(void);
time__Time time__linux_now(void);
time__Time time__linux_utc(void);
time__Time time__win_now(void);
time__Time time__win_utc(void);
struct timespec time__Duration_timespec(time__Duration d);
struct timespec time__zero_timespec(void);
void time__sleep(time__Duration duration);
int time__Duration_sys_milliseconds(time__Duration d);
time__Time time__unix(i64 abs);
time__Time time__unix2(i64 abs, int microsecond);
multi_return_int_int_int time__calculate_date_from_offset(i64 day_offset_);
multi_return_int_int_int time__calculate_time_from_offset(i64 second_offset_);
eventbus__EventBus* eventbus__new(void);
void eventbus__EventBus_publish(eventbus__EventBus* eb, string name, voidptr sender, voidptr args);
void eventbus__EventBus_clear_all(eventbus__EventBus* eb);
bool eventbus__EventBus_has_subscriber(eventbus__EventBus* eb, string name);
void eventbus__Publisher_publish(eventbus__Publisher* pb, string name, voidptr sender, voidptr args);
void eventbus__Publisher_clear_all(eventbus__Publisher* p);
void eventbus__Subscriber_subscribe(eventbus__Subscriber* s, string name, void (*handler)(voidptr receiver, voidptr args, voidptr sender));
void eventbus__Subscriber_subscribe_method(eventbus__Subscriber* s, string name, void (*handler)(voidptr receiver, voidptr args, voidptr sender), voidptr receiver);
void eventbus__Subscriber_unsubscribe_method(eventbus__Subscriber* s, string name, voidptr receiver);
void eventbus__Subscriber_unsubscribe_receiver(eventbus__Subscriber* s, voidptr receiver);
void eventbus__Subscriber_subscribe_once(eventbus__Subscriber* s, string name, void (*handler)(voidptr receiver, voidptr args, voidptr sender));
bool eventbus__Subscriber_is_subscribed(eventbus__Subscriber* s, string name);
bool eventbus__Subscriber_is_subscribed_method(eventbus__Subscriber* s, string name, voidptr receiver);
void eventbus__Subscriber_unsubscribe(eventbus__Subscriber* s, string name, void (*handler)(voidptr receiver, voidptr args, voidptr sender));
bool eventbus__Registry_check_subscriber(eventbus__Registry* r, string name);
clipboard__Clipboard* clipboard__new(void);
bool clipboard__Clipboard_copy(clipboard__Clipboard* cb, string text);
string clipboard__Clipboard_paste(clipboard__Clipboard* cb);
void clipboard__Clipboard_clear_all(clipboard__Clipboard* cb);
void clipboard__Clipboard_destroy(clipboard__Clipboard* cb);
bool clipboard__Clipboard_check_ownership(clipboard__Clipboard cb);
bool clipboard__Clipboard_is_available(clipboard__Clipboard* cb);


// added by module `clipboard`

#if defined(__has_include)

#if __has_include("/Users/rcqls/vlang/v/vlib/clipboard/clipboard_darwin.m")
#include "/Users/rcqls/vlang/v/vlib/clipboard/clipboard_darwin.m"
#else
#error VERROR_MESSAGE Header file "/Users/rcqls/vlang/v/vlib/clipboard/clipboard_darwin.m", needed for module `clipboard` was not found. Please install the corresponding development headers.
#endif

#else
#include "/Users/rcqls/vlang/v/vlib/clipboard/clipboard_darwin.m"
#endif



clipboard__Clipboard* clipboard__new_clipboard(void);
bool clipboard__Clipboard_check_availability(clipboard__Clipboard* cb);
void clipboard__Clipboard_clear(clipboard__Clipboard* cb);
void clipboard__Clipboard_free(clipboard__Clipboard* cb);
bool clipboard__Clipboard_has_ownership(clipboard__Clipboard* cb);
bool clipboard__Clipboard_set_text(clipboard__Clipboard* cb, string text);
string clipboard__Clipboard_get_text(clipboard__Clipboard* cb);
clipboard__Clipboard* clipboard__new_primary(void);
#define _const_fontstash__used_import 1
int _const_fontstash__invalid; // inited later
fontstash__Context* fontstash__create_internal(struct FONSparams* params);
void fontstash__delete_internal(fontstash__Context* s);
void fontstash__Context_set_error_callback(fontstash__Context* s, void (*callback)(voidptr , int , int ), voidptr uptr);
multi_return_int_int fontstash__Context_get_atlas_size(fontstash__Context* s);
int fontstash__Context_expand_atlas(fontstash__Context* s, int width, int height);
int fontstash__Context_reset_atlas(fontstash__Context* s, int width, int height);
int fontstash__Context_get_font_by_name(fontstash__Context* s, string name);
int fontstash__Context_add_fallback_font(fontstash__Context* s, int base, int fallback);
int fontstash__Context_add_font_mem(fontstash__Context* s, string name, Array_u8 data, bool free_data);
void fontstash__Context_push_state(fontstash__Context* s);
void fontstash__Context_pop_state(fontstash__Context* s);
void fontstash__Context_clear_state(fontstash__Context* s);
void fontstash__Context_set_size(fontstash__Context* s, f32 size);
void fontstash__Context_set_color(fontstash__Context* s, u32 color);
void fontstash__Context_set_spacing(fontstash__Context* s, f32 spacing);
void fontstash__Context_set_blur(fontstash__Context* s, f32 blur);
void fontstash__Context_set_align(fontstash__Context* s, int align);
void fontstash__Context_set_alignment(fontstash__Context* s, fontstash__Align align);
void fontstash__Context_set_font(fontstash__Context* s, int font_id);
f32 fontstash__Context_draw_text(fontstash__Context* s, f32 x, f32 y, string text);
f32 fontstash__Context_text_bounds(fontstash__Context* s, f32 x, f32 y, string text, f32* bounds);
void fontstash__Context_line_bounds(fontstash__Context* s, f32 y, f32* miny, f32* maxy);
void fontstash__Context_vert_metrics(fontstash__Context* s, f32* ascender, f32* descender, f32* lineh);
int fontstash__Context_text_iter_init(fontstash__Context* s, struct FONStextIter* iter, f32 x, f32 y, char* str, char* end);
int fontstash__Context_text_iter_next(fontstash__Context* s, struct FONStextIter* iter, struct FONSquad* quad);
u8* fontstash__Context_get_texture_data(fontstash__Context* s, int* width, int* height);
int fontstash__Context_validate_texture(fontstash__Context* s, int* dirty);
void fontstash__Context_draw_debug(fontstash__Context* s, f32 x, f32 y);
bool fontstash__Flags_is_empty(fontstash__Flags* e);
bool fontstash__Flags_has(fontstash__Flags* e, fontstash__Flags flag);
bool fontstash__Flags_all(fontstash__Flags* e, fontstash__Flags flag);
void fontstash__Flags_set(fontstash__Flags* e, fontstash__Flags flag);
void fontstash__Flags_clear(fontstash__Flags* e, fontstash__Flags flag);
void fontstash__Flags_toggle(fontstash__Flags* e, fontstash__Flags flag);
bool fontstash__Align_is_empty(fontstash__Align* e);
bool fontstash__Align_has(fontstash__Align* e, fontstash__Align flag);
bool fontstash__Align_all(fontstash__Align* e, fontstash__Align flag);
void fontstash__Align_set(fontstash__Align* e, fontstash__Align flag);
void fontstash__Align_clear(fontstash__Align* e, fontstash__Align flag);
void fontstash__Align_toggle(fontstash__Align* e, fontstash__Align flag);
f64 _const_math__internal__f64_epsilon = 2.220446049250313e-16; // precomputed
f64 _const_math__internal__sqrt_f64_epsilon = 3.725290298461914e-09; // precomputed
f64 _const_math__internal__root3_f64_epsilon = 6.055454452393343e-06; // precomputed
f64 _const_math__internal__root4_f64_epsilon = 0.0001220703125; // precomputed
f64 _const_math__internal__root5_f64_epsilon = 0.000740095979741405; // precomputed
f64 _const_math__internal__root6_f64_epsilon = 0.002460783300575925; // precomputed
f64 _const_math__internal__log_f64_epsilon = -36.04365338911715; // precomputed
f64 _const_math__internal__f64_min = 2.2250738585072014e-308; // precomputed
f64 _const_math__internal__sqrt_f64_min = 3.7291703656001034e-155; // precomputed
f64 _const_math__internal__root3_f64_min = 2.8126442852362996e-103; // precomputed
f64 _const_math__internal__root4_f64_min = 1.221338669755462e-77; // precomputed
f64 _const_math__internal__root5_f64_min = 2.9476022969691763e-62; // precomputed
f64 _const_math__internal__root6_f64_min = 5.303436890579822e-52; // precomputed
f64 _const_math__internal__log_f64_min = -708.3964185322641; // precomputed
f64 _const_math__internal__f64_max = 1.7976931348623157e+308; // precomputed
f64 _const_math__internal__sqrt_f64_max = 1.3407807929942596e+154; // precomputed
f64 _const_math__internal__root3_f64_max = 5.64380309412229e+102; // precomputed
f64 _const_math__internal__root4_f64_max = 1.157920892373162e+77; // precomputed
f64 _const_math__internal__root5_f64_max = 4.4765466227572707e+61; // precomputed
f64 _const_math__internal__root6_f64_max = 2.3756689782295612e+51; // precomputed
f64 _const_math__internal__log_f64_max = 709.782712893384; // precomputed
f64 _const_math__internal__f32_epsilon = 1.1920928955078125e-07; // precomputed
f64 _const_math__internal__sqrt_f32_epsilon = 0.00034526698300124393; // precomputed
f64 _const_math__internal__root3_f32_epsilon = 0.00492156660115185; // precomputed
f64 _const_math__internal__root4_f32_epsilon = 0.018581361171917516; // precomputed
f64 _const_math__internal__root5_f32_epsilon = 0.04123462221165294; // precomputed
f64 _const_math__internal__root6_f32_epsilon = 0.07015387801933583; // precomputed
f64 _const_math__internal__log_f32_epsilon = -15.942385152878742; // precomputed
f64 _const_math__internal__f32_min = 2.938735877055719e-39; // precomputed
f64 _const_math__internal__sqrt_f32_min = 2.710505431213761e-20; // precomputed
f64 _const_math__internal__root3_f32_min = 2.273736754432324e-13; // precomputed
f64 _const_math__internal__root4_f32_min = 3.2927225399135965e-10; // precomputed
f64 _const_math__internal__root5_f32_min = 2.5944428542140822e-08; // precomputed
f64 _const_math__internal__root6_f32_min = 4.768371582031254e-07; // precomputed
f64 _const_math__internal__log_f32_min = -87.3365447505531; // precomputed
f64 _const_math__internal__f32_max = 3.4028234663852886e+38; // precomputed
f64 _const_math__internal__sqrt_f32_max = 1.844674352395373e+19; // precomputed
f64 _const_math__internal__root3_f32_max = 6.981463519622324e+12; // precomputed
f64 _const_math__internal__root4_f32_max = 4.2949672319999986e+09; // precomputed
f64 _const_math__internal__root5_f32_max = 5.085900785596004e+07; // precomputed
f64 _const_math__internal__root6_f32_max = 2.642245923380775e+06; // precomputed
f64 _const_math__internal__log_f32_max = 88.72283905206835; // precomputed
f64 _const_math__internal__sflt_epsilon = 0.00048828125; // precomputed
f64 _const_math__internal__sqrt_sflt_epsilon = 0.02209708691207961; // precomputed
f64 _const_math__internal__root3_sflt_epsilon = 0.07874506561842959; // precomputed
f64 _const_math__internal__root4_sflt_epsilon = 0.14865088937534013; // precomputed
f64 _const_math__internal__root5_sflt_epsilon = 0.217637640824031; // precomputed
f64 _const_math__internal__root6_sflt_epsilon = 0.28061551207734325; // precomputed
f64 _const_math__internal__log_sflt_epsilon = -7.6246189861593985; // precomputed
#define _const_math__internal__max_int_fact_arg 170
f64 _const_math__internal__max_f64_fact_arg = 171.; // precomputed
f64 _const_math__internal__max_long_f64_fact_arg = 1755.5; // precomputed
void stbi__set_flip_vertically_on_load(bool val);
void stbi__set_flip_vertically_on_write(bool val);
void stbi__set_png_compression_level(int level);
void stbi__write_force_png_filter(int level);
void stbi__write_tga_with_rle(bool flag);
void stbi__Image_free(stbi__Image* img);
Option_stbi__Image stbi__load(string path);
Option_stbi__Image stbi__load_from_memory(u8* buf, int bufsize);
Option_void stbi__stbi_write_png(string path, int w, int h, int comp, u8* buf, int row_stride_in_bytes);
Option_void stbi__stbi_write_bmp(string path, int w, int h, int comp, u8* buf);
Option_void stbi__stbi_write_tga(string path, int w, int h, int comp, u8* buf);
Option_void stbi__stbi_write_jpg(string path, int w, int h, int comp, u8* buf, int quality);
#define _const_sokol__c__used_import 1
gx__Color _const_gx__black; // inited later
gx__Color _const_gx__gray; // inited later
gx__Color _const_gx__white; // inited later
gx__Color _const_gx__red; // inited later
gx__Color _const_gx__green; // inited later
gx__Color _const_gx__blue; // inited later
gx__Color _const_gx__yellow; // inited later
gx__Color _const_gx__magenta; // inited later
gx__Color _const_gx__cyan; // inited later
gx__Color _const_gx__orange; // inited later
gx__Color _const_gx__purple; // inited later
gx__Color _const_gx__indigo; // inited later
gx__Color _const_gx__pink; // inited later
gx__Color _const_gx__violet; // inited later
gx__Color _const_gx__dark_blue; // inited later
gx__Color _const_gx__dark_gray; // inited later
gx__Color _const_gx__dark_green; // inited later
gx__Color _const_gx__dark_red; // inited later
gx__Color _const_gx__light_blue; // inited later
gx__Color _const_gx__light_gray; // inited later
gx__Color _const_gx__light_green; // inited later
gx__Color _const_gx__light_red; // inited later
gx__Color gx__hex(int color);
gx__Color gx__rgb(u8 r, u8 g, u8 b);
gx__Color gx__rgba(u8 r, u8 g, u8 b, u8 a);
gx__Color gx__Color__plus(gx__Color a, gx__Color b);
gx__Color gx__Color__minus(gx__Color a, gx__Color b);
gx__Color gx__Color__mult(gx__Color c, gx__Color c2);
gx__Color gx__Color__div(gx__Color c, gx__Color c2);
gx__Color gx__Color_over(gx__Color a, gx__Color b);
bool gx__Color_eq(gx__Color c, gx__Color c2);
string gx__Color_str(gx__Color c);
int gx__Color_rgba8(gx__Color c);
int gx__Color_bgra8(gx__Color c);
int gx__Color_abgr8(gx__Color c);
Map_string_gx__Color _const_gx__string_colors; // inited later
gx__Color gx__color_from_string(string s);
string gx__Color_to_css_string(gx__Color c);
bool gx__Image_is_empty(gx__Image i);
#define _const_gx__used_import 1
gx__HorizontalAlign _const_gx__align_left; // inited later
gx__HorizontalAlign _const_gx__align_right; // inited later
string gx__TextCfg_to_css_string(gx__TextCfg* cfg);
f64 math__fabs(f64 x);
u64 _const_math__uvnan = 9221120237041090561U; // precomputed
u64 _const_math__uvinf = 9218868437227405312U; // precomputed
u64 _const_math__uvneginf = 18442240474082181120U; // precomputed
u64 _const_math__uvone = 4607182418800017408U; // precomputed
#define _const_math__mask 2047
#define _const_math__shift 52
#define _const_math__bias 1023
u64 _const_math__normalize_smallest_mask = 4503599627370496U; // precomputed
u64 _const_math__sign_mask = 9223372036854775808U; // precomputed
u64 _const_math__frac_mask = 4503599627370495U; // precomputed
f64 math__inf(int sign);
f64 math__nan(void);
bool math__is_nan(f64 f);
bool math__is_inf(f64 f, int sign);
bool math__is_finite(f64 f);
multi_return_f64_int math__normalize(f64 x);
f64 math__cbrt(f64 a);
f64 _const_math__e = 2.718281828459045; // precomputed
f64 _const_math__pi = 3.141592653589793; // precomputed
f64 _const_math__pi_2; // inited later
f64 _const_math__pi_4; // inited later
f64 _const_math__phi = 1.618033988749895; // precomputed
f64 _const_math__tau = 6.283185307179586; // precomputed
f64 _const_math__sqrt2 = 1.4142135623730951; // precomputed
f64 _const_math__sqrt_e = 1.6487212707001282; // precomputed
f64 _const_math__sqrt_pi = 1.772453850905516; // precomputed
f64 _const_math__sqrt_tau = 2.5066282746310007; // precomputed
f64 _const_math__sqrt_phi = 1.272019649514069; // precomputed
f64 _const_math__ln2 = 0.6931471805599453; // precomputed
f64 _const_math__log2_e; // inited later
f64 _const_math__ln10 = 2.302585092994046; // precomputed
f64 _const_math__log10_e; // inited later
f64 _const_math__max_f32 = 3.4028234663852886e+38; // precomputed
f64 _const_math__smallest_non_zero_f32 = 3.503246160812043e-46; // precomputed
f64 _const_math__max_f64 = 1.7976931348623157e+308; // precomputed
f64 _const_math__smallest_non_zero_f64 = 0; // precomputed
#define _const_math__max_i8 127
#define _const_math__min_i8 -128
#define _const_math__max_i16 32767
#define _const_math__min_i16 -32768
#define _const_math__max_i32 2147483647
#define _const_math__min_i32 -2147483648
i64 _const_math__min_i64; // inited later
i64 _const_math__max_i64; // inited later
#define _const_math__max_u8 255
#define _const_math__max_u16 65535
u32 _const_math__max_u32 = 4294967295; // precomputed
u64 _const_math__max_u64 = 18446744073709551615U; // precomputed
f64 math__mod(f64 x, f64 y);
f64 math__fmod(f64 x, f64 y);
i64 math__gcd(i64 a_, i64 b_);
multi_return_i64_i64_i64 math__egcd(i64 a, i64 b);
i64 math__lcm(i64 a, i64 b);
f64 _const_math__erx = 0.8450629115104675; // precomputed
f64 _const_math__efx = 0.1283791670955126; // precomputed
f64 _const_math__efx8 = 1.0270333367641007; // precomputed
f64 _const_math__pp0 = 0.12837916709551256; // precomputed
f64 _const_math__pp1 = -0.3250421072470015; // precomputed
f64 _const_math__pp2 = -0.02848174957559851; // precomputed
f64 _const_math__pp3 = -0.005770270296489442; // precomputed
f64 _const_math__pp4 = -2.3763016656650163e-05; // precomputed
f64 _const_math__qq1 = 0.39791722395915535; // precomputed
f64 _const_math__qq2 = 0.0650222499887673; // precomputed
f64 _const_math__qq3 = 0.005081306281875766; // precomputed
f64 _const_math__qq4 = 0.00013249473800432164; // precomputed
f64 _const_math__qq5 = -3.960228278775368e-06; // precomputed
f64 _const_math__pa0 = -0.0023621185607526594; // precomputed
f64 _const_math__pa1 = 0.41485611868374833; // precomputed
f64 _const_math__pa2 = -0.3722078760357013; // precomputed
f64 _const_math__pa3 = 0.31834661990116175; // precomputed
f64 _const_math__pa4 = -0.11089469428239668; // precomputed
f64 _const_math__pa5 = 0.035478304325618236; // precomputed
f64 _const_math__pa6 = -0.002166375594868791; // precomputed
f64 _const_math__qa1 = 0.10642088040084423; // precomputed
f64 _const_math__qa2 = 0.540397917702171; // precomputed
f64 _const_math__qa3 = 0.07182865441419627; // precomputed
f64 _const_math__qa4 = 0.12617121980876164; // precomputed
f64 _const_math__qa5 = 0.01363708391202905; // precomputed
f64 _const_math__qa6 = 0.011984499846799107; // precomputed
f64 _const_math__ra0 = -0.009864944034847148; // precomputed
f64 _const_math__ra1 = -0.6938585727071818; // precomputed
f64 _const_math__ra2 = -10.558626225323291; // precomputed
f64 _const_math__ra3 = -62.375332450326006; // precomputed
f64 _const_math__ra4 = -162.39666946257347; // precomputed
f64 _const_math__ra5 = -184.60509290671104; // precomputed
f64 _const_math__ra6 = -81.2874355063066; // precomputed
f64 _const_math__ra7 = -9.814329344169145; // precomputed
f64 _const_math__sa1 = 19.651271667439257; // precomputed
f64 _const_math__sa2 = 137.65775414351904; // precomputed
f64 _const_math__sa3 = 434.56587747522923; // precomputed
f64 _const_math__sa4 = 645.3872717332679; // precomputed
f64 _const_math__sa5 = 429.00814002756783; // precomputed
f64 _const_math__sa6 = 108.63500554177944; // precomputed
f64 _const_math__sa7 = 6.570249770319282; // precomputed
f64 _const_math__sa8 = -0.0604244152148581; // precomputed
f64 _const_math__rb0 = -0.0098649429247001; // precomputed
f64 _const_math__rb1 = -0.799283237680523; // precomputed
f64 _const_math__rb2 = -17.757954917754752; // precomputed
f64 _const_math__rb3 = -160.63638485582192; // precomputed
f64 _const_math__rb4 = -637.5664433683896; // precomputed
f64 _const_math__rb5 = -1025.0951316110772; // precomputed
f64 _const_math__rb6 = -483.5191916086514; // precomputed
f64 _const_math__sb1 = 30.33806074348246; // precomputed
f64 _const_math__sb2 = 325.7925129965739; // precomputed
f64 _const_math__sb3 = 1536.729586084437; // precomputed
f64 _const_math__sb4 = 3199.8582195085955; // precomputed
f64 _const_math__sb5 = 2553.0504064331644; // precomputed
f64 _const_math__sb6 = 474.52854120695537; // precomputed
f64 _const_math__sb7 = -22.44095244658582; // precomputed
f64 math__erf(f64 a);
f64 math__erfc(f64 a);
f64 _const_math__f64_max_exp = 1024.; // precomputed
f64 _const_math__f64_min_exp = -1021.; // precomputed
f64 _const_math__threshold = 709.782712893384; // precomputed
f64 _const_math__ln2_x56 = 38.816242111356935; // precomputed
f64 _const_math__ln2_halfx3 = 1.0397207708399179; // precomputed
f64 _const_math__ln2_half = 0.34657359027997264; // precomputed
f64 _const_math__ln2hi = 0.6931471803691238; // precomputed
f64 _const_math__ln2lo = 1.9082149292705877e-10; // precomputed
f64 _const_math__inv_ln2 = 1.4426950408889634; // precomputed
f64 _const_math__expm1_q1 = -0.03333333333333313; // precomputed
f64 _const_math__expm1_q2 = 0.0015873015872548146; // precomputed
f64 _const_math__expm1_q3 = -7.93650757867488e-05; // precomputed
f64 _const_math__expm1_q4 = 4.008217827329362e-06; // precomputed
f64 _const_math__expm1_q5 = -2.0109921818362437e-07; // precomputed
f64 math__exp(f64 x);
f64 math__exp2(f64 x);
f64 math__ldexp(f64 frac, int exp);
multi_return_f64_int math__frexp(f64 x);
f64 math__expm1(f64 x);
f64 math__expmulti(f64 hi, f64 lo, int k);
f64 math__factorial(f64 n);
f64 math__log_factorial(f64 n);
f64 math__log_factorial_asymptotic_expansion(int n);
i64 math__factoriali(int n);
f64 _const_math__log_sqrt_2pi = 0.9189385332046728; // precomputed
Array_f64 _const_math__bernoulli; // inited later
Array_f64 _const_math__factorials_table; // inited later
Array_f64 _const_math__log_factorials_table; // inited later
f64 math__floor(f64 x);
f64 math__ceil(f64 x);
f64 math__trunc(f64 x);
f64 math__round(f64 x);
f64 math__round_to_even(f64 x);
multi_return_f64_f64 math__stirling(f64 x);
f64 math__gamma(f64 a);
f64 math__log_gamma(f64 x);
multi_return_f64_int math__log_gamma_sign(f64 a);
f64 math__sin_pi(f64 x_);
Array_f64 _const_math__gamma_p; // inited later
Array_f64 _const_math__gamma_q; // inited later
Array_f64 _const_math__gamma_s; // inited later
Array_f64 _const_math__lgamma_a; // inited later
Array_f64 _const_math__lgamma_r; // inited later
Array_f64 _const_math__lgamma_s; // inited later
Array_f64 _const_math__lgamma_t; // inited later
Array_f64 _const_math__lgamma_u; // inited later
Array_f64 _const_math__lgamma_v; // inited later
Array_f64 _const_math__lgamma_w; // inited later
f64 math__hypot(f64 x, f64 y);
f64 math__acosh(f64 x);
f64 math__asinh(f64 x);
f64 math__atanh(f64 x);
f64 _const_math__morebits = 6.123233995736766e-17; // precomputed
f64 _const_math__tan3pio8 = 2.414213562373095; // precomputed
f64 math__xatan(f64 x);
f64 math__satan(f64 x);
f64 math__atan(f64 x);
f64 math__atan2(f64 y, f64 x);
f64 math__asin(f64 x_);
f64 math__acos(f64 x);
f64 math__log_n(f64 x, f64 b);
f64 math__log10(f64 x);
f64 math__log2(f64 x);
f64 math__log1p(f64 x);
f64 math__log_b(f64 x);
int math__ilog_b(f64 x);
int math__ilog_b_(f64 x_);
f64 math__log(f64 a);
f64 math__aprox_sin(f64 a);
f64 math__aprox_cos(f64 a);
f64 math__copysign(f64 x, f64 y);
f64 math__degrees(f64 radians);
Array_int math__digits(i64 num, math__DigitParams params);
int math__count_digits(i64 number);
multi_return_f64_f64 math__minmax(f64 a, f64 b);
f64 math__clamp(f64 x, f64 a, f64 b);
f64 math__sign(f64 n);
int math__signi(f64 n);
f64 math__radians(f64 degrees);
bool math__signbit(f64 x);
bool math__tolerance(f64 a, f64 b, f64 tol);
bool math__close(f64 a, f64 b);
bool math__veryclose(f64 a, f64 b);
bool math__alike(f64 a, f64 b);
bool math__is_odd_int(f64 x);
bool math__is_neg_int(f64 x);
int math__min_T_int(int a, int b);
f32 math__min_T_f32(f32 a, f32 b);
f32 math__max_T_f32(f32 a, f32 b);
int math__max_T_int(int a, int b);
f64 math__abs_T_f64(f64 a);
f32 math__abs_T_f32(f32 a);
int math__abs_T_int(int a);
f64 _const_math__modf_maxpowtwo = 4.503599627370496e+15; // precomputed
multi_return_f64_f64 math__modf(f64 f);
f32 math__nextafter32(f32 x, f32 y);
f64 math__nextafter(f64 x, f64 y);
f64 math__poly_n_eval(Array_f64 c, int n, f64 x);
f64 math__poly_n_1_eval(Array_f64 c, int n, f64 x);
f64 math__poly_eval(Array_f64 c, f64 x);
f64 math__poly_1_eval(Array_f64 c, f64 x);
multi_return_f64_f64 math__ChebSeries_eval_e(math__ChebSeries cs, f64 x);
f32 math__powf(f32 a, f32 b);
Array_f64 _const_math__pow10tab; // inited later
Array_f64 _const_math__pow10postab32; // inited later
Array_f64 _const_math__pow10negtab32; // inited later
f32 math__pure_v_but_overriden_by_c_powf(f32 a, f32 b);
f64 math__pow10(int n);
i64 math__powi(i64 a, i64 b);
f64 math__pow(f64 x, f64 y);
f64 math__q_rsqrt(f64 x);
f64 math__scalbn(f64 x, int n_);
f32 math__cosf(f32 a);
f32 math__sinf(f32 a);
Array_f64 _const_math__sin_data; // inited later
math__ChebSeries _const_math__sin_cs; // inited later
Array_f64 _const_math__cos_data; // inited later
math__ChebSeries _const_math__cos_cs; // inited later
f64 math__sin(f64 x);
f64 math__cos(f64 x);
f32 math__pure_v_but_overriden_by_c_cosf(f32 a);
f32 math__pure_v_but_overriden_by_c_sinf(f32 a);
multi_return_f64_f64 math__sincos(f64 x);
f64 math__sinh(f64 x_);
f64 math__cosh(f64 x);
f32 math__sqrtf(f32 a);
f64 math__sqrt(f64 a);
f32 math__pure_v_but_overriden_by_c_sqrtf(f32 a);
i64 math__sqrti(i64 a);
f32 math__tanf(f32 a);
Array_f64 _const_math__tan_p; // inited later
Array_f64 _const_math__tan_q; // inited later
f64 _const_math__tan_dp1 = 0.7853981554508209; // precomputed
f64 _const_math__tan_dp2 = 7.946627356147928e-09; // precomputed
f64 _const_math__tan_dp3 = 3.061616997868383e-17; // precomputed
f64 _const_math__tan_lossth = 1.073741824e+09; // precomputed
f64 math__tan(f64 a);
f32 math__pure_v_but_overriden_by_c_tanf(f32 a);
f64 math__cot(f64 a);
Array_f64 _const_math__tanh_p; // inited later
Array_f64 _const_math__tanh_q; // inited later
f64 math__tanh(f64 x);
u32 math__f32_bits(f32 f);
f32 math__f32_from_bits(u32 b);
u64 math__f64_bits(f64 f);
f64 math__f64_from_bits(u64 b);
f64 math__with_set_low_word(f64 f, u32 lo);
f64 math__with_set_high_word(f64 f, u32 hi);
u32 math__get_high_word(f64 f);
string os__font__default(void);
string os__font__get_path_variant(string font_path, os__font__Variant variant);
#define _const_sokol__gfx__version 1
#define _const_sokol__gfx__used_import 1
void sokol__gfx__setup(sokol__gfx__Desc* desc);
void sokol__gfx__shutdown(void);
bool sokol__gfx__is_valid(void);
void sokol__gfx__reset_state_cache(void);
sokol__gfx__Buffer sokol__gfx__make_buffer(sokol__gfx__BufferDesc* desc);
sokol__gfx__Image sokol__gfx__make_image(sokol__gfx__ImageDesc* desc);
sokol__gfx__Shader sokol__gfx__make_shader(sokol__gfx__ShaderDesc* desc);
sokol__gfx__Pipeline sokol__gfx__make_pipeline(sokol__gfx__PipelineDesc* desc);
sokol__gfx__Pass sokol__gfx__make_pass(sokol__gfx__PassDesc* desc);
void sokol__gfx__destroy_buffer(sokol__gfx__Buffer buf);
void sokol__gfx__destroy_image(sokol__gfx__Image img);
void sokol__gfx__destroy_shader(sokol__gfx__Shader shd);
void sokol__gfx__destroy_pipeline(sokol__gfx__Pipeline pip);
void sokol__gfx__destroy_pass(sokol__gfx__Pass pass);
void sokol__gfx__update_buffer(sokol__gfx__Buffer buf, sokol__gfx__Range* data);
void sokol__gfx__update_image(sokol__gfx__Image img, sokol__gfx__ImageData* data);
int sokol__gfx__append_buffer(sokol__gfx__Buffer buf, sokol__gfx__Range* data);
bool sokol__gfx__query_buffer_overflow(sokol__gfx__Buffer buf);
void sokol__gfx__begin_default_pass(sokol__gfx__PassAction* actions, int width, int height);
void sokol__gfx__begin_pass(sokol__gfx__Pass pass, sokol__gfx__PassAction* actions);
void sokol__gfx__apply_viewport(int x, int y, int width, int height, bool origin_top_left);
void sokol__gfx__apply_scissor_rect(int x, int y, int width, int height, bool origin_top_left);
void sokol__gfx__apply_pipeline(sokol__gfx__Pipeline pip);
void sokol__gfx__apply_bindings(sokol__gfx__Bindings* bindings);
void sokol__gfx__apply_uniforms(sokol__gfx__ShaderStage stage, int ub_index, sokol__gfx__Range* data);
void sokol__gfx__draw(int base_element, int num_elements, int num_instances);
void sokol__gfx__end_pass(void);
void sokol__gfx__commit(void);
sokol__gfx__Desc sokol__gfx__query_desc(void);
sokol__gfx__Backend sokol__gfx__query_backend(void);
sokol__gfx__Features sokol__gfx__query_features(void);
sokol__gfx__Limits sokol__gfx__query_limits(void);
sokol__gfx__PixelFormatInfo sokol__gfx__query_pixelformat(sokol__gfx__PixelFormat fmt);
sokol__gfx__ResourceState sokol__gfx__query_buffer_state(sokol__gfx__Buffer buf);
sokol__gfx__ResourceState sokol__gfx__query_image_state(sokol__gfx__Image img);
sokol__gfx__ResourceState sokol__gfx__query_shader_state(sokol__gfx__Shader shd);
sokol__gfx__ResourceState sokol__gfx__query_pipeline_state(sokol__gfx__Pipeline pip);
sokol__gfx__ResourceState sokol__gfx__query_pass_state(sokol__gfx__Pass pass);
sokol__gfx__BufferInfo sokol__gfx__query_buffer_info(sokol__gfx__Buffer buf);
sokol__gfx__ImageInfo sokol__gfx__query_image_info(sokol__gfx__Image img);
sokol__gfx__ShaderInfo sokol__gfx__query_shader_info(sokol__gfx__Shader shd);
sokol__gfx__PipelineInfo sokol__gfx__query_pipeline_info(sokol__gfx__Pipeline pip);
sokol__gfx__PassInfo sokol__gfx__query_pass_info(sokol__gfx__Pass pass);
sokol__gfx__BufferDesc sokol__gfx__query_buffer_defaults(sokol__gfx__Buffer* desc);
sokol__gfx__ImageDesc sokol__gfx__query_image_defaults(sokol__gfx__Image* desc);
sokol__gfx__ShaderDesc sokol__gfx__query_shader_defaults(sokol__gfx__Shader* desc);
sokol__gfx__PipelineDesc sokol__gfx__query_pipeline_defaults(sokol__gfx__Pipeline* desc);
sokol__gfx__PassDesc sokol__gfx__query_pass_defaults(sokol__gfx__Pass* desc);
sokol__gfx__Context sokol__gfx__setup_context(void);
void sokol__gfx__activate_context(sokol__gfx__Context ctx_id);
void sokol__gfx__discard_context(sokol__gfx__Context ctx_id);
void C__sg_pipeline_free(struct sg_pipeline* p);
void sokol__gfx__Bindings_set_vert_image(sokol__gfx__Bindings* b, int index, sokol__gfx__Image img);
void sokol__gfx__Bindings_set_frag_image(sokol__gfx__Bindings* b, int index, sokol__gfx__Image img);
void sokol__gfx__Bindings_update_vert_buffer(sokol__gfx__Bindings* b, int index, voidptr data, int element_size, int element_count);
int sokol__gfx__Bindings_append_vert_buffer(sokol__gfx__Bindings* b, int index, voidptr data, int element_size, int element_count);
void sokol__gfx__Bindings_update_index_buffer(sokol__gfx__Bindings* b, voidptr data, int element_size, int element_count);
int sokol__gfx__Bindings_append_index_buffer(sokol__gfx__Bindings* b, voidptr data, int element_size, int element_count);
sokol__gfx__ShaderDesc* C__sg_shader_desc_set_vert_src(struct sg_shader_desc* desc, string src);
sokol__gfx__ShaderDesc* C__sg_shader_desc_set_frag_src(struct sg_shader_desc* desc, string src);
sokol__gfx__ShaderDesc* C__sg_shader_desc_set_vert_image(struct sg_shader_desc* desc, int index, string name);
sokol__gfx__ShaderDesc* C__sg_shader_desc_set_frag_image(struct sg_shader_desc* desc, int index, string name);
sokol__gfx__ShaderDesc* C__sg_shader_desc_set_vert_uniform_block_size(struct sg_shader_desc* desc, int block_index, usize size);
sokol__gfx__ShaderDesc* C__sg_shader_desc_set_frag_uniform_block_size(struct sg_shader_desc* desc, int block_index, usize size);
sokol__gfx__ShaderDesc* C__sg_shader_desc_set_vert_uniform(struct sg_shader_desc* desc, int block_index, int uniform_index, string name, sokol__gfx__UniformType type, int array_count);
sokol__gfx__ShaderDesc* C__sg_shader_desc_set_frag_uniform(struct sg_shader_desc* desc, int block_index, int uniform_index, string name, sokol__gfx__UniformType type, int array_count);
sokol__gfx__Shader sokol__gfx__ShaderDesc_make_shader(sokol__gfx__ShaderDesc* desc);
sokol__gfx__ShaderStageDesc sokol__gfx__ShaderStageDesc_set_image(sokol__gfx__ShaderStageDesc* desc, int index, string name);
void sokol__gfx__Shader_free(sokol__gfx__Shader* s);
void sokol__gfx__Pass_free(sokol__gfx__Pass* p);
void sokol__gfx__Buffer_free(sokol__gfx__Buffer* b);
void sokol__gfx__Image_free(sokol__gfx__Image* i);
#define _const_sokol__gfx__sg_cubeface_num 6
#define _const_sokol__gfx__sg_max_mipmaps 16
sokol__gfx__PassAction sokol__gfx__create_clear_pass(f32 r, f32 g, f32 b, f32 a);
#define _const_sokol__f__used_import 2
#define _const_sokol__sgl__version 2
sokol__sgl__Context _const_sokol__sgl__context; // inited later
void sokol__sgl__setup(sokol__sgl__Desc* desc);
void sokol__sgl__shutdown(void);
sokol__sgl__SglError sokol__sgl__error(void);
sokol__sgl__SglError sokol__sgl__context_error(sokol__sgl__Context ctx);
f32 sokol__sgl__rad(f32 deg);
f32 sokol__sgl__deg(f32 rad);
sokol__sgl__Context sokol__sgl__make_context(sokol__sgl__ContextDesc* desc);
void sokol__sgl__destroy_context(sokol__sgl__Context ctx);
void sokol__sgl__set_context(sokol__sgl__Context ctx);
sokol__sgl__Context sokol__sgl__get_context(void);
sokol__sgl__Context sokol__sgl__default_context(void);
sokol__sgl__Pipeline sokol__sgl__make_pipeline(sokol__gfx__PipelineDesc* desc);
sokol__sgl__Pipeline sokol__sgl__context_make_pipeline(sokol__sgl__Context ctx, sokol__gfx__PipelineDesc* desc);
void sokol__sgl__destroy_pipeline(sokol__sgl__Pipeline pip);
void sokol__sgl__defaults(void);
void sokol__sgl__viewport(int x, int y, int w, int h, bool origin_top_left);
void sokol__sgl__scissor_rect(int x, int y, int w, int h, bool origin_top_left);
void sokol__sgl__enable_texture(void);
void sokol__sgl__disable_texture(void);
void sokol__sgl__texture(sokol__gfx__Image img);
void sokol__sgl__load_default_pipeline(void);
void sokol__sgl__default_pipeline(void);
void sokol__sgl__load_pipeline(sokol__sgl__Pipeline pip);
void sokol__sgl__push_pipeline(void);
void sokol__sgl__pop_pipeline(void);
void sokol__sgl__matrix_mode_modelview(void);
void sokol__sgl__matrix_mode_projection(void);
void sokol__sgl__matrix_mode_texture(void);
void sokol__sgl__load_identity(void);
void sokol__sgl__load_matrix(Array_f32 m);
void sokol__sgl__load_transpose_matrix(Array_f32 m);
void sokol__sgl__mult_matrix(Array_f32 m);
void sokol__sgl__mult_transpose_matrix(Array_f32 m);
void sokol__sgl__rotate(f32 angle_rad, f32 x, f32 y, f32 z);
void sokol__sgl__scale(f32 x, f32 y, f32 z);
void sokol__sgl__translate(f32 x, f32 y, f32 z);
void sokol__sgl__frustum(f32 l, f32 r, f32 b, f32 t, f32 n, f32 f);
void sokol__sgl__ortho(f32 l, f32 r, f32 b, f32 t, f32 n, f32 f);
void sokol__sgl__perspective(f32 fov_y, f32 aspect, f32 z_near, f32 z_far);
void sokol__sgl__lookat(f32 eye_x, f32 eye_y, f32 eye_z, f32 center_x, f32 center_y, f32 center_z, f32 up_x, f32 up_y, f32 up_z);
void sokol__sgl__push_matrix(void);
void sokol__sgl__pop_matrix(void);
void sokol__sgl__t2f(f32 u, f32 v);
void sokol__sgl__c3f(f32 r, f32 g, f32 b);
void sokol__sgl__c4f(f32 r, f32 g, f32 b, f32 a);
void sokol__sgl__c3b(u8 r, u8 g, u8 b);
void sokol__sgl__c4b(u8 r, u8 g, u8 b, u8 a);
void sokol__sgl__c1i(u32 rgba);
void sokol__sgl__point_size(f32 s);
void sokol__sgl__begin_points(void);
void sokol__sgl__begin_lines(void);
void sokol__sgl__begin_line_strip(void);
void sokol__sgl__begin_triangles(void);
void sokol__sgl__begin_triangle_strip(void);
void sokol__sgl__begin_quads(void);
void sokol__sgl__v2f(f32 x, f32 y);
void sokol__sgl__v3f(f32 x, f32 y, f32 z);
void sokol__sgl__v2f_t2f(f32 x, f32 y, f32 u, f32 v);
void sokol__sgl__v3f_t2f(f32 x, f32 y, f32 z, f32 u, f32 v);
void sokol__sgl__v2f_c3f(f32 x, f32 y, f32 r, f32 g, f32 b);
void sokol__sgl__v2f_c3b(f32 x, f32 y, u8 r, u8 g, u8 b);
void sokol__sgl__v2f_c4f(f32 x, f32 y, f32 r, f32 g, f32 b, f32 a);
void sokol__sgl__v2f_c4b(f32 x, f32 y, u8 r, u8 g, u8 b, u8 a);
void sokol__sgl__v2f_c1i(f32 x, f32 y, u32 rgba);
void sokol__sgl__v3f_c3f(f32 x, f32 y, f32 z, f32 r, f32 g, f32 b);
void sokol__sgl__v3f_c3b(f32 x, f32 y, f32 z, u8 r, u8 g, u8 b);
void sokol__sgl__v3f_c4f(f32 x, f32 y, f32 z, f32 r, f32 g, f32 b, f32 a);
void sokol__sgl__v3f_c4b(f32 x, f32 y, f32 z, u8 r, u8 g, u8 b, u8 a);
void sokol__sgl__v3f_c1i(f32 x, f32 y, f32 z, u32 rgba);
void sokol__sgl__v2f_t2f_c3f(f32 x, f32 y, f32 u, f32 v, f32 r, f32 g, f32 b);
void sokol__sgl__v2f_t2f_c3b(f32 x, f32 y, f32 u, f32 v, u8 r, u8 g, u8 b);
void sokol__sgl__v2f_t2f_c4f(f32 x, f32 y, f32 u, f32 v, f32 r, f32 g, f32 b, f32 a);
void sokol__sgl__v2f_t2f_c4b(f32 x, f32 y, f32 u, f32 v, u8 r, u8 g, u8 b, u8 a);
void sokol__sgl__v2f_t2f_c1i(f32 x, f32 y, f32 u, f32 v, u32 rgba);
void sokol__sgl__v3f_t2f_c3f(f32 x, f32 y, f32 z, f32 u, f32 v, f32 r, f32 g, f32 b);
void sokol__sgl__v3f_t2f_c3b(f32 x, f32 y, f32 z, f32 u, f32 v, u8 r, u8 g, u8 b);
void sokol__sgl__v3f_t2f_c4f(f32 x, f32 y, f32 z, f32 u, f32 v, f32 r, f32 g, f32 b, f32 a);
void sokol__sgl__v3f_t2f_c4b(f32 x, f32 y, f32 z, f32 u, f32 v, u8 r, u8 g, u8 b, u8 a);
void sokol__sgl__v3f_t2f_c1i(f32 x, f32 y, f32 z, f32 u, f32 v, u32 rgba);
void sokol__sgl__end(void);
void sokol__sgl__draw(void);
void sokol__sgl__context_draw(sokol__sgl__Context ctx);
#define _const_sokol__sapp__used_import 1
struct sapp_desc  g_desc = {0}; // global4
sokol__gfx__Desc sokol__sapp__create_desc(void);
bool sokol__sapp__isvalid(void);
int sokol__sapp__width(void);
int sokol__sapp__height(void);
int sokol__sapp__color_format(void);
int sokol__sapp__depth_format(void);
int sokol__sapp__sample_count(void);
bool sokol__sapp__high_dpi(void);
f32 sokol__sapp__dpi_scale(void);
void sokol__sapp__show_keyboard(bool visible);
bool sokol__sapp__keyboard_shown(void);
void sokol__sapp__show_mouse(bool visible);
bool sokol__sapp__mouse_shown(void);
void sokol__sapp__lock_mouse(bool locked);
bool sokol__sapp__mouse_locked(void);
voidptr sokol__sapp__userdata(void);
sokol__sapp__Desc sokol__sapp__query_desc(void);
void sokol__sapp__request_quit(void);
void sokol__sapp__cancel_quit(void);
void sokol__sapp__quit(void);
void sokol__sapp__consume_event(void);
u64 sokol__sapp__frame_count(void);
f64 sokol__sapp__frame_duration(void);
void sokol__sapp__set_clipboard_string(u8* str);
char* sokol__sapp__get_clipboard_string(void);
void sokol__sapp__run(sokol__sapp__Desc* desc);
bool sokol__sapp__gles2(void);
void sokol__sapp__html5_ask_leave_site(bool ask);
voidptr sokol__sapp__metal_get_device(void);
voidptr sokol__sapp__metal_get_renderpass_descriptor(void);
voidptr sokol__sapp__metal_get_drawable(void);
voidptr sokol__sapp__macos_get_window(void);
voidptr sokol__sapp__ios_get_window(void);
voidptr sokol__sapp__d3d11_get_device(void);
voidptr sokol__sapp__d3d11_get_device_context(void);
voidptr sokol__sapp__d3d11_get_render_target_view(void);
voidptr sokol__sapp__d3d11_get_depth_stencil_view(void);
voidptr sokol__sapp__win32_get_hwnd(void);
voidptr sokol__sapp__android_get_native_activity(void);
void sokol__sapp__toggle_fullscreen(void);
bool sokol__sapp__is_fullscreen(void);
int sokol__sapp__get_num_dropped_files(void);
string sokol__sapp__get_dropped_file_path(int index);
#define _const_sokol__sapp__max_touchpoints 8
#define _const_sokol__sapp__max_mousebuttons 3
#define _const_sokol__sapp__max_keycodes 512
#define _const_sokol__sapp__max_iconimages 8
string C__sapp_event_str(struct sapp_event* e);
Option_void sokol__sapp__screenshot(string path);
Option_void sokol__sapp__screenshot_ppm(string path);
Option_void sokol__sapp__screenshot_png(string path);
Option_void sokol__sapp__write_rgba_to_ppm(string path, int w, int h, int components, u8* pixels);
sokol__sapp__Screenshot* sokol__sapp__screenshot_window(void);
void sokol__sapp__Screenshot_free(sokol__sapp__Screenshot* ss);
void sokol__sapp__Screenshot_destroy(sokol__sapp__Screenshot* ss);
#define _const_sokol__sfons__used_import 4
fontstash__Context* sokol__sfons__create(int width, int height, int flags);
void sokol__sfons__destroy(fontstash__Context* ctx);
u32 sokol__sfons__rgba(u8 r, u8 g, u8 b, u8 a);
void sokol__sfons__flush(fontstash__Context* ctx);
#define _const_sokol__used_import 3
void gg__Context_draw_pixel(gg__Context* ctx, f32 x, f32 y, gx__Color c);
void gg__Context_draw_pixels(gg__Context* ctx, Array_f32 points, gx__Color c);
void gg__Context_draw_line(gg__Context* ctx, f32 x, f32 y, f32 x2, f32 y2, gx__Color c);
void gg__Context_draw_line_with_config(gg__Context* ctx, f32 x, f32 y, f32 x2, f32 y2, gg__PenConfig config);
void gg__Context_draw_poly_empty(gg__Context* ctx, Array_f32 points, gx__Color c);
void gg__Context_draw_convex_poly(gg__Context* ctx, Array_f32 points, gx__Color c);
void gg__Context_draw_rect_empty(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, gx__Color c);
void gg__Context_draw_rect_filled(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, gx__Color c);
void gg__Context_draw_rounded_rect_empty(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, f32 radius, gx__Color c);
void gg__Context_draw_rounded_rect_filled(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, f32 radius, gx__Color c);
void gg__Context_draw_triangle_empty(gg__Context* ctx, f32 x, f32 y, f32 x2, f32 y2, f32 x3, f32 y3, gx__Color c);
void gg__Context_draw_triangle_filled(gg__Context* ctx, f32 x, f32 y, f32 x2, f32 y2, f32 x3, f32 y3, gx__Color c);
void gg__Context_draw_square_empty(gg__Context* ctx, f32 x, f32 y, f32 s, gx__Color c);
void gg__Context_draw_square_filled(gg__Context* ctx, f32 x, f32 y, f32 s, gx__Color c);
Array_fixed_int_17 _const_gg__small_circle_segments = {0, 2, 4, 6, 6, 8, 8, 13, 10, 18, 12, 12, 10, 13, 16, 15, 16}; // fixed array const
int gg__radius_to_segments(f32 r);
void gg__Context_draw_circle_empty(gg__Context* ctx, f32 x, f32 y, f32 radius, gx__Color c);
void gg__Context_draw_circle_filled(gg__Context* ctx, f32 x, f32 y, f32 radius, gx__Color c);
void gg__Context_draw_circle_with_segments(gg__Context* ctx, f32 x, f32 y, f32 radius, int segments, gx__Color c);
void gg__Context_draw_circle_line(gg__Context* ctx, f32 x, f32 y, int radius, int segments, gx__Color c);
void gg__Context_draw_slice_empty(gg__Context* ctx, f32 x, f32 y, f32 outer_radius, f32 start_angle, f32 end_angle, int segments, gx__Color c);
void gg__Context_draw_slice_filled(gg__Context* ctx, f32 x, f32 y, f32 radius, f32 start_angle, f32 end_angle, int segments, gx__Color c);
void gg__Context_draw_arc_empty(gg__Context* ctx, f32 x, f32 y, f32 inner_radius, f32 thickness, f32 start_angle, f32 end_angle, int segments, gx__Color c);
void gg__Context_draw_arc_filled(gg__Context* ctx, f32 x, f32 y, f32 inner_radius, f32 thickness, f32 start_angle, f32 end_angle, int segments, gx__Color c);
void gg__Context_draw_ellipse_empty(gg__Context* ctx, f32 x, f32 y, f32 rw, f32 rh, gx__Color c);
void gg__Context_draw_ellipse_filled(gg__Context* ctx, f32 x, f32 y, f32 rw, f32 rh, gx__Color c);
void gg__Context_draw_cubic_bezier(gg__Context* ctx, Array_f32 points, gx__Color c);
void gg__Context_draw_cubic_bezier_in_steps(gg__Context* ctx, Array_f32 points, u32 steps, gx__Color c);
void gg__Context_set_pixel(gg__Context* ctx, f32 x, f32 y, gx__Color c);
void gg__Context_set_pixels(gg__Context* ctx, Array_f32 points, gx__Color c);
void gg__Context_draw_empty_poly(gg__Context* ctx, Array_f32 points, gx__Color c);
void gg__Context_draw_rect(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, gx__Color c);
void gg__Context_draw_empty_rect(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, gx__Color c);
void gg__Context_draw_empty_rounded_rect(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, f32 radius, gx__Color c);
void gg__Context_draw_rounded_rect(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, f32 radius, gx__Color c);
void gg__Context_draw_empty_triangle(gg__Context* ctx, f32 x, f32 y, f32 x2, f32 y2, f32 x3, f32 y3, gx__Color c);
void gg__Context_draw_triangle(gg__Context* ctx, f32 x, f32 y, f32 x2, f32 y2, f32 x3, f32 y3, gx__Color c);
void gg__Context_draw_empty_square(gg__Context* ctx, f32 x, f32 y, f32 s, gx__Color c);
void gg__Context_draw_square(gg__Context* ctx, f32 x, f32 y, f32 s, gx__Color c);
void gg__Context_draw_circle(gg__Context* ctx, f32 x, f32 y, f32 radius, gx__Color c);
void gg__Context_draw_empty_slice(gg__Context* ctx, f32 x, f32 y, f32 radius, f32 start_angle, f32 end_angle, int segments, gx__Color c);
void gg__Context_draw_slice(gg__Context* ctx, f32 x, f32 y, f32 radius, f32 start_angle, f32 end_angle, int segments, gx__Color c);
void gg__Context_draw_empty_arc(gg__Context* ctx, f32 x, f32 y, f32 inner_radius, f32 thickness, f32 start_angle, f32 end_angle, int segments, gx__Color c);
void gg__Context_draw_arc(gg__Context* ctx, f32 x, f32 y, f32 inner_radius, f32 thickness, f32 start_angle, f32 end_angle, int segments, gx__Color c);
void gg__Context_draw_empty_ellipse(gg__Context* ctx, f32 x, f32 y, f32 rw, f32 rh, gx__Color c);
void gg__Context_draw_ellipse(gg__Context* ctx, f32 x, f32 y, f32 rw, f32 rh, gx__Color c);
#define _const_gg__key_code_max 512
void gg__gg_init_sokol_window(voidptr user_data);
void gg__gg_frame_fn(voidptr user_data);
void gg__gg_event_fn(voidptr ce, voidptr user_data);
void gg__gg_cleanup_fn(voidptr user_data);
void gg__gg_fail_fn(char* msg, voidptr user_data);
gg__Context* gg__new_context(gg__Config cfg);
void gg__Context_run(gg__Context* ctx);
void gg__Context_quit(gg__Context* ctx);
void gg__Context_set_bg_color(gg__Context* ctx, gx__Color c);
void gg__Context_resize(gg__Context* ctx, int width, int height);
void gg__Context_refresh_ui(gg__Context* ctx);
void gg__Context_begin(gg__Context* ctx);
void gg__Context_end(gg__Context* ctx);
void gg__Context_set_scale(gg__Context* ctx);
gg__Size gg__Context_window_size(gg__Context* ctx);
f32 gg__dpi_scale(void);
bool gg__high_dpi(void);
gg__Size gg__screen_size(void);
gg__Size gg__window_size(void);
gg__Size gg__window_size_real_pixels(void);


// added by module `gg`

#if defined(__has_include)

#if __has_include("/Users/rcqls/vlang/v/vlib/gg/gg_darwin.m")
#include "/Users/rcqls/vlang/v/vlib/gg/gg_darwin.m"
#else
#error VERROR_MESSAGE Header file "/Users/rcqls/vlang/v/vlib/gg/gg_darwin.m", needed for module `gg` was not found. Please install the corresponding development headers.
#endif

#else
#include "/Users/rcqls/vlang/v/vlib/gg/gg_darwin.m"
#endif



gg__Image gg__Context_create_image(gg__Context* ctx, string file);
gg__Image* gg__Image_init_sokol_image(gg__Image* img);
void gg__Context_draw_image(gg__Context* ctx, f32 x, f32 y, f32 width, f32 height, gg__Image* img_);
int gg__Context_new_streaming_image(gg__Context* ctx, int w, int h, int channels, gg__StreamingImageConfig sicfg);
void gg__Context_update_pixel_data(gg__Context* ctx, int cached_image_idx, u8* buf);
void gg__Image_update_pixel_data(gg__Image* img, u8* buf);
gg__Image gg__Context_create_image_with_size(gg__Context* ctx, string file, int width, int height);
gg__Image gg__create_image(string file);
gg__Image gg__Context_create_image_from_memory(gg__Context* ctx, u8* buf, int bufsize);
gg__Image gg__Context_create_image_from_byte_array(gg__Context* ctx, Array_u8 b);
void gg__Context_draw_image_with_config(gg__Context* ctx, gg__DrawImageConfig config);
int gg__Context_cache_image(gg__Context* ctx, gg__Image _v_toheap_img);
gg__Image* gg__Context_get_cached_image_by_idx(gg__Context* ctx, int image_idx);
void gg__Context_remove_cached_image_by_idx(gg__Context* ctx, int image_idx);
void gg__Context_draw_image_part(gg__Context* ctx, gg__Rect img_rect, gg__Rect part_rect, gg__Image* img_);
void gg__Context_draw_image_flipped(gg__Context* ctx, f32 x, f32 y, f32 width, f32 height, gg__Image* img_);
void gg__Context_draw_image_by_id(gg__Context* ctx, f32 x, f32 y, f32 width, f32 height, int id);
void gg__Context_draw_image_3d(gg__Context* ctx, f32 x, f32 y, f32 z, f32 width, f32 height, gg__Image* img_);
gg__SSRecorderSettings* gg__new_gg_recorder_settings(void);
gg__SSRecorderSettings* _const_gg__recorder_settings; // inited later
Option_gg__FT_ptr gg__new_ft(gg__FTConfig c);
void gg__Context_set_cfg(gg__Context* ctx, gx__TextCfg cfg);
void gg__Context_draw_text(gg__Context* ctx, int x, int y, string text_, gx__TextCfg cfg);
void gg__Context_draw_text_def(gg__Context* ctx, int x, int y, string text);
void gg__FT_flush(gg__FT* ft);
int gg__Context_text_width(gg__Context* ctx, string s);
int gg__Context_text_height(gg__Context* ctx, string s);
multi_return_int_int gg__Context_text_size(gg__Context* ctx, string s);
void gg__Context_draw_text_default(gg__Context* ctx, int x, int y, string text);
void gg__Context_scissor_rect(gg__Context* ctx, int x, int y, int w, int h);
bool gg__Context_has_text_style(gg__Context* ctx);
void gg__Context_set_text_style(gg__Context* ctx, string font_name, string font_path, int size, gx__Color color, int align, int vertical_align);
bool gg__MouseButtons_is_empty(gg__MouseButtons* e);
bool gg__MouseButtons_has(gg__MouseButtons* e, gg__MouseButtons flag);
bool gg__MouseButtons_all(gg__MouseButtons* e, gg__MouseButtons flag);
void gg__MouseButtons_set(gg__MouseButtons* e, gg__MouseButtons flag);
void gg__MouseButtons_clear(gg__MouseButtons* e, gg__MouseButtons flag);
void gg__MouseButtons_toggle(gg__MouseButtons* e, gg__MouseButtons flag);
bool gg__Modifier_is_empty(gg__Modifier* e);
bool gg__Modifier_has(gg__Modifier* e, gg__Modifier flag);
bool gg__Modifier_all(gg__Modifier* e, gg__Modifier flag);
void gg__Modifier_set(gg__Modifier* e, gg__Modifier flag);
void gg__Modifier_clear(gg__Modifier* e, gg__Modifier flag);
void gg__Modifier_toggle(gg__Modifier* e, gg__Modifier flag);
f64 ui__linear(f64 x);
f64 ui__ease_in_quad(f64 x);
f64 ui__ease_out_quad(f64 x);
f64 ui__ease_in_out_quad(f64 x);
f64 ui__ease_in_cubic(f64 x);
f64 ui__ease_out_cubic(f64 x);
f64 ui__ease_in_out_cubic(f64 x);
f64 ui__ease_in_quart(f64 x);
f64 ui__ease_out_quart(f64 x);
f64 ui__ease_in_out_quart(f64 x);
f64 ui__ease_in_quint(f64 x);
f64 ui__ease_out_quint(f64 x);
f64 ui__ease_in_out_quint(f64 x);
ui__EasingFunction ui__easing(ui__EasingType easingtype);
void ui__debug_draw_bb_stack(ui__Stack* s);
void ui__debug_draw_bb_widget(ui__Widget* wi, ui__UI* ui);
void ui__debug_draw_bb_text(int x, int y, int w, int h, ui__UI* ui);
void ui__debug_show_cache(ui__Stack* s, int depth, string txt);
void ui__debug_show_size(ui__Stack* s, string t);
void ui__debug_show_sizes(ui__Stack* s, string t);
void ui__debug_set_children_sizes(ui__Stack* s, Array_int widths, Array_int heights, ui__CachedSizes c);
gx__TextCfg _const_ui__empty_text_cfg; // inited later
bool ui__is_empty_text_cfg(gx__TextCfg t);
multi_return_int_int ui__text_size_T_ui__Button(ui__Button* widget, string text);
multi_return_int_int ui__text_size_T_ui__Label(ui__Label* widget, string text);
multi_return_int_int ui__text_size_T_ui__Rectangle(ui__Rectangle* widget, string text);
multi_return_int_int ui__text_size_T_ui__TextBox(ui__TextBox* widget, string text);
int ui__text_width_T_ui__CheckBox(ui__CheckBox* w, string text);
int ui__text_width_T_ui__ListBox(ui__ListBox* w, string text);
int ui__text_width_T_ui__Radio(ui__Radio* w, string text);
int ui__text_width_T_ui__TextBox(ui__TextBox* w, string text);
int ui__text_height_T_ui__ListBox(ui__ListBox* w, string text);
int ui__text_height_T_ui__TextBox(ui__TextBox* w, string text);
void ui__draw_text_T_ui__Rectangle(ui__Rectangle* w, int x, int y, string text_);
void ui__init_text_cfg(ui__DrawText* w);
multi_return_int_int ui__get_text_size(ui__DrawText w, string text_);
void ui__set_text_cfg_color(ui__DrawText* w, gx__Color color);
void ui__set_text_cfg_size(ui__DrawText* w, int size);
void ui__set_text_cfg_style(ui__DrawText* w, bool bold, bool italic, bool mono);
void ui__set_text_cfg_align(ui__DrawText* w, gx__HorizontalAlign align);
void ui__set_text_cfg_vertical_align(ui__DrawText* w, gx__VerticalAlign align);
void ui__draw_text_lines(ui__DrawText w, int x, int y, Array_string lines);
void ui__update_text_size(ui__DrawText* w);
int ui__text_size_as_int(f64 size, int win_height);
bool ui__point_inside_T_ui__CanvasLayout(ui__CanvasLayout* w, f64 x, f64 y);
bool ui__point_inside_T_ui__Group(ui__Group* w, f64 x, f64 y);
bool ui__point_inside_T_ui__Stack(ui__Stack* w, f64 x, f64 y);
bool ui__point_inside_T_ui__Button(ui__Button* w, f64 x, f64 y);
bool ui__point_inside_T_ui__Canvas(ui__Canvas* w, f64 x, f64 y);
bool ui__point_inside_T_ui__CheckBox(ui__CheckBox* w, f64 x, f64 y);
bool ui__point_inside_T_ui__Grid(ui__Grid* w, f64 x, f64 y);
bool ui__point_inside_T_ui__ListBox(ui__ListBox* w, f64 x, f64 y);
bool ui__point_inside_T_ui__Menu(ui__Menu* w, f64 x, f64 y);
bool ui__point_inside_T_ui__Picture(ui__Picture* w, f64 x, f64 y);
bool ui__point_inside_T_ui__ProgressBar(ui__ProgressBar* w, f64 x, f64 y);
bool ui__point_inside_T_ui__Rectangle(ui__Rectangle* w, f64 x, f64 y);
bool ui__point_inside_T_ui__Slider(ui__Slider* w, f64 x, f64 y);
bool ui__point_inside_T_ui__Switch(ui__Switch* w, f64 x, f64 y);
bool ui__point_inside_T_ui__TextBox(ui__TextBox* w, f64 x, f64 y);
bool ui__point_inside_adj_T_ui__CanvasLayout(ui__CanvasLayout* w, f64 x, f64 y);
gx__Color ui__hsv_to_rgb(f64 h, f64 s, f64 v);
gx__Color ui__hsl_to_rgb(f64 h, f64 s, f64 l);
multi_return_f64_f64_f64 ui__rgb_to_hsv(gx__Color col);
multi_return_f64_f64_f64 ui__rgb_to_hsl(gx__Color col);
struct sg_image ui__create_texture(int w, int h, u8* buf);
void ui__destroy_texture(struct sg_image sg_img);
struct sg_image ui__create_dynamic_texture(int w, int h);
void ui__update_text_texture(struct sg_image sg_img, int w, int h, u8* buf);
void ui__CanvasLayout_draw_texture(ui__CanvasLayout* c, struct sg_image simg);
int ui__compare_sorted_widget(ui__SortedWidget* a, ui__SortedWidget* b);
void ui__Stack_sorted_drawing_children(ui__Stack* s);
void ui__CanvasLayout_sorted_drawing_children(ui__CanvasLayout* c);
ui__EventNames _const_ui__events; // inited later
void ui__EventMngr_add_receiver(ui__EventMngr* em, ui__Widget widget, Array_string evt_types);
void ui__EventMngr_rm_receiver(ui__EventMngr* em, ui__Widget widget, Array_string evt_types);
void ui__EventMngr_point_inside_receivers_mouse_event(ui__EventMngr* em, ui__MouseEvent e, string evt_type);
void ui__EventMngr_point_inside_receivers_scroll(ui__EventMngr* em, ui__ScrollEvent e);
void ui__EventMngr_sorted_receivers(ui__EventMngr* em, string evt_type);
bool ui__Window_is_top_widget(ui__Window _v_toheap_w, ui__Widget widget, string evt_type);
Array_string ui__Window_point_inside_receivers(ui__Window _v_toheap_w, string evt_type);
int ui__get_num_dropped_files(void);
string ui__get_dropped_file_path(int i);
gg__Rect ui__intersection_rect(gg__Rect r1, gg__Rect r2);
bool ui__is_empty_intersection(gg__Rect r1, gg__Rect r2);
gg__Rect ui__union_rect(gg__Rect r1, gg__Rect r2);
void ui__offset_start(ui__Widget* w);
void ui__offset_end(ui__Widget* w);
void ui__drag_register(ui__Widget w, ui__UI* ui, ui__MouseEvent* e);
void ui__drag_child(ui__Window* window, f64 x, f64 y);
void ui__drop_child(ui__Window* window);
void ui__set_offset(ui__Widget* w, int ox, int oy);
ui__Widget ui__at(int x, int y, ui__Widget w);
#define _const_ui__scrollbar_size 10
gx__Color _const_ui__scroolbar_thumb_color; // inited later
gx__Color _const_ui__scrollbar_background_color; // inited later
gx__Color _const_ui__scrollbar_button_color; // inited later
gx__Color _const_ui__scrollbar_focused_button_color; // inited later
#define _const_ui__scrollview_delta_key 5
ui__ScrollView* _const_ui__null_scrollview; // inited later
multi_return_bool_ref_ui__ScrollView ui__scrollview(ui__Widget w);
bool ui__has_scrollview(ui__ScrollableWidget w);
bool ui__has_scrollview_or_parent_scrollview(ui__ScrollableWidget w);
bool ui__scrollview_is_active(ui__ScrollableWidget* w);
void ui__scrollview_need_update(ui__ScrollableWidget* w);
void ui__scrollview_add_T_ui__CanvasLayout(ui__CanvasLayout* w);
void ui__scrollview_add_T_ui__Stack(ui__Stack* w);
void ui__scrollview_add_T_ui__ListBox(ui__ListBox* w);
void ui__scrollview_add_T_ui__TextBox(ui__TextBox* w);
void ui__scrollview_widget_set_orig_xy(ui__Widget w);
void ui__scrollview_set_orig_xy_T_ui__Stack(ui__Stack* w);
void ui__scrollview_set_orig_xy_T_ui__CanvasLayout(ui__CanvasLayout* w);
void ui__scrollview_set_orig_xy_T_ui__ListBox(ui__ListBox* w);
void ui__scrollview_set_orig_xy_T_ui__TextBox(ui__TextBox* w);
void ui__scrollview_delegate_parent_scrollview_T_ui__CanvasLayout(ui__CanvasLayout* w);
void ui__scrollview_delegate_parent_scrollview_T_ui__Stack(ui__Stack* w);
void ui__scrollview_update_T_ui__TextBox(ui__TextBox* w);
void ui__scrollview_update_T_ui__CanvasLayout(ui__CanvasLayout* w);
void ui__scrollview_update_T_ui__Stack(ui__Stack* w);
void ui__scrollview_update_T_ui__ListBox(ui__ListBox* w);
void ui__scrollview_draw_begin_T_ui__CanvasLayout(ui__CanvasLayout* w);
void ui__scrollview_draw_begin_T_ui__Stack(ui__Stack* w);
void ui__scrollview_draw_begin_T_ui__ListBox(ui__ListBox* w);
void ui__scrollview_draw_begin_T_ui__TextBox(ui__TextBox* w);
void ui__scrollview_draw_end_T_ui__CanvasLayout(ui__CanvasLayout* w);
void ui__scrollview_draw_end_T_ui__Stack(ui__Stack* w);
void ui__scrollview_draw_end_T_ui__ListBox(ui__ListBox* w);
void ui__scrollview_draw_end_T_ui__TextBox(ui__TextBox* w);
void ui__scrollview_reset_T_ui__TextBox(ui__TextBox* w);
void ui__ScrollView_init(ui__ScrollView* sv, ui__Layout parent);
void ui__ScrollView_cleanup(ui__ScrollView* sv);
void ui__ScrollView_free(ui__ScrollView* sv);
multi_return_int_int ui__ScrollView_parent_offset(ui__ScrollView* sv);
multi_return_int_int ui__ScrollView_orig_xy(ui__ScrollView* sv);
gg__Rect ui__ScrollView_parent_scissor_rect(ui__ScrollView* sv);
void ui__ScrollView_update(ui__ScrollView* sv);
bool ui__ScrollView_is_active(ui__ScrollView* sv);
bool ui__ScrollView_children_point_inside(ui__ScrollView* sv, f64 x, f64 y, ui__ScrollViewPart mode);
bool ui__ScrollView_point_inside(ui__ScrollView* sv, f64 x, f64 y, ui__ScrollViewPart mode);
void ui__ScrollView_change_value(ui__ScrollView* sv, ui__ScrollViewPart mode);
void ui__ScrollView_clip(ui__ScrollView* sv);
void ui__ScrollView_draw(ui__ScrollView* sv);
void ui__ScrollView_set(ui__ScrollView* sv, int val, ui__ScrollViewPart mode);
void ui__ScrollView_scroll_to_end_y(ui__ScrollView* sv);
void ui__ScrollView_inc(ui__ScrollView* sv, int delta, ui__ScrollViewPart mode);
void ui__scrollview_scroll(ui__ScrollView* sv, ui__ScrollEvent* e, voidptr zzz);
void ui__scrollview_click(ui__ScrollView* sv, ui__MouseEvent* e, voidptr zzz);
void ui__scrollview_mouse_down(ui__ScrollView* sv, ui__MouseEvent* e, voidptr zzz);
void ui__scrollview_mouse_up(ui__ScrollView* sv, ui__MouseEvent* e, voidptr zzz);
void ui__scrollview_mouse_move(ui__ScrollView* sv, ui__MouseMoveEvent* e, voidptr zzz);
void ui__scrollview_key_down(ui__ScrollView* sv, ui__KeyEvent* e, voidptr zzz);
multi_return_int_f32 ui__ScrollView_coef_x(ui__ScrollView* sv);
multi_return_int_f32 ui__ScrollView_coef_y(ui__ScrollView* sv);
f64 _const_ui__stretch = -10000; // precomputed
f64 _const_ui__compact = 0; // precomputed
f64 _const_ui__fit = 0; // precomputed
#define _const_ui__z_index_hidden -10000
Array_f32 ui__Size_as_f32_array(ui__Size size, int len);
int ui__relative_size_from_parent(int size, int parent_free_size);
bool ui__is_children_have_widget(Array_ui__Widget children);
void ui__CachedSizes_free(ui__CachedSizes* c);
ui__Margins ui__margins(f64 m, ui__Margin ms);
Array_f32 ui__spacings(f64 sp, Array_f64 sps, int len);
f32 ui__relative_size(f32 size, int w, int h);
string _const_ui__word_wrap_id; // a string literal, inited later
multi_return_int_int ui__text_xminmax_from_pos_T_ui__TextBox(ui__TextBox* w, string text, int x1, int x2);
int ui__text_pos_from_x_T_ui__TextBox(ui__TextBox* w, string text, int x);
string ui__word_wrap_join(Array_string lines, Array_int ind);
int ui__text_lines_pos_at(Array_string lines, int i, int j);
multi_return_int_int ui__text_lines_row_column_at(Array_string lines, int pos);
Array_string ui__word_wrap_to_lines(string s, int max_line_length);
Array_string ui__word_wrap_text_to_lines(string s, int max_line_length);
multi_return_int_int ui__text_lines_size(Array_string lines, ui__UI* ui);
#define _const_ui__tooltip_margin 5
void ui__Tooltip_free(ui__Tooltip* t);
void ui__TooltipMessage_free(ui__TooltipMessage* t);
void ui__start_tooltip(ui__Widget* w, string id, ui__TooltipMessage msg, ui__UI* wui);
void ui__stop_tooltip(string id, ui__UI* wui);
void ui__draw_tooltip(ui__Window _v_toheap_win);
void ui__Window_append_tooltip(ui__Window* w, ui__Widget child, ui__TooltipMessage tooltip);
void ui__Window_update_tooltip(ui__Window* w, ui__MouseMoveEvent* e);
void ui__Window_add_message_dialog(ui__Window* win);
void ui__message_dialog_click(voidptr app, ui__Button* b);
void ui__Window_message(ui__Window* win, string s);
ui__SyntaxHighLighter* ui__syntaxhighlighter(void);
void ui__SyntaxHighLighter_init(ui__SyntaxHighLighter* sh, ui__TextView* tv);
void ui__SyntaxHighLighter_set_lang(ui__SyntaxHighLighter* sh, string ext);
bool ui__SyntaxHighLighter_is_lang_loaded(ui__SyntaxHighLighter* sh);
void ui__SyntaxHighLighter_load_default_style(ui__SyntaxHighLighter* sh);
void ui__SyntaxHighLighter_load_v(ui__SyntaxHighLighter* sh);
void ui__SyntaxHighLighter_load_c(ui__SyntaxHighLighter* sh);
void ui__SyntaxHighLighter_parse_chunks(ui__SyntaxHighLighter* sh, int j, int y, string line);
bool ui__SyntaxHighLighter_parse_chunk_oneline_comment(ui__SyntaxHighLighter* sh, string typ, string comment_sep, string line_trim);
bool ui__SyntaxHighLighter_parse_chunk_multiline_comment(ui__SyntaxHighLighter* sh, string typ, string comment_start, string comment_stop, string line_trim);
void ui__SyntaxHighLighter_parse_chunk_between_one_rune(ui__SyntaxHighLighter* sh, string typ, rune sep);
void ui__SyntaxHighLighter_parse_chunk_keyword(ui__SyntaxHighLighter* sh, string typ);
void ui__SyntaxHighLighter_add_chunk(ui__SyntaxHighLighter* sh, string typ, int y, int start, int end);
void ui__SyntaxHighLighter_draw_chunks(ui__SyntaxHighLighter* sh);
void ui__SyntaxHighLighter_reset_chunks(ui__SyntaxHighLighter* sh);
bool ui__is_alpha(u8 r);
bool ui__is_whitespace(u8 r);
bool ui__is_alpha_underscore(int r);
bool ui__is_alpha_and_symbols(int r);
#define _const_ui__textview_margin 10
void ui__TextView_init(ui__TextView* tv, ui__TextBox* tb);
multi_return_int_int ui__TextView_size(ui__TextView* tv);
void ui__TextView_info(ui__TextView* tv);
bool ui__TextView_is_wordwrap(ui__TextView* tv);
void ui__TextView_set_wordwrap(ui__TextView* tv, bool state);
void ui__TextView_switch_wordwrap(ui__TextView* tv);
string ui__TextView_line(ui__TextView* tv, int j);
string ui__TextView_current_line(ui__TextView* tv);
string ui__TextView_sel_start_line(ui__TextView* tv);
string ui__TextView_sel_end_line(ui__TextView* tv);
bool ui__TextView_is_sel_active(ui__TextView* tv);
void ui__TextView_sync_text_pos(ui__TextView* tv);
void ui__TextView_sync_text_lines(ui__TextView* tv);
void ui__TextView_visible_lines(ui__TextView* tv);
void ui__TextView_refresh_visible_lines(ui__TextView* tv);
void ui__TextView_update_all_visible_lines(ui__TextView* tv);
void ui__TextView_update_lines(ui__TextView* tv);
void ui__TextView_update_left_margin(ui__TextView* tv);
void ui__TextView_scroll_changed(ui__TextView* tv);
void ui__TextView_draw_textlines(ui__TextView* tv);
void ui__TextView_draw_visible_line(ui__TextView* tv, int j, int y, string text);
void ui__TextView_draw_selection(ui__TextView* tv);
void ui__TextView_draw_line_number(ui__TextView* tv, int i, int y);
void ui__TextView_insert(ui__TextView* tv, string s);
void ui__TextView_delete_cur_char(ui__TextView* tv);
void ui__TextView_delete_prev_char(ui__TextView* tv);
void ui__TextView_delete_selection(ui__TextView* tv);
void ui__TextView_start_selection(ui__TextView* tv, int x, int y);
void ui__TextView_end_selection(ui__TextView* tv, int x, int y);
void ui__TextView_extend_selection(ui__TextView* tv, int x, int y);
void ui__TextView_cancel_selection(ui__TextView* tv);
void ui__TextView_move_cursor(ui__TextView* tv, ui__Side side);
void ui__TextView_cursor_allways_visible(ui__TextView* tv);
void ui__TextView_key_char(ui__TextView* tv, ui__KeyEvent* e);
void ui__TextView_key_down(ui__TextView* tv, ui__KeyEvent* e);
void ui__TextView_do_indent(ui__TextView* tv, bool shift);
void ui__TextView_do_select_all(ui__TextView* tv);
void ui__TextView_do_copy(ui__TextView* tv);
void ui__TextView_do_paste(ui__TextView* tv);
void ui__TextView_do_cut(ui__TextView* tv);
void ui__TextView_do_zoom_down(ui__TextView* tv);
void ui__TextView_do_zoom_up(ui__TextView* tv);
void ui__TextView_do_logview(ui__TextView* tv, ui__LogViewParams cfg);
int ui__TextView_cursor_y(ui__TextView* tv);
int ui__TextView_cursor_x(ui__TextView* tv);
multi_return_int_int ui__TextView_cursor_xy(ui__TextView* tv);
void ui__TextView_cursor_adjust_after_newline(ui__TextView* tv);
void ui__TextView_scroll_x_to_cursor(ui__TextView* tv, bool end);
void ui__TextView_scroll_y_to_cursor(ui__TextView* tv, bool end);
void ui__TextView_scroll_y_to_end(ui__TextView* tv);
void ui__TextView_word_wrap_text(ui__TextView* tv);
Array_string ui__TextView_word_wrap_line(ui__TextView* tv, string s);
int ui__TextView_text_pos_at(ui__TextView* tv, int i, int j);
multi_return_int_int ui__TextView_text_line_at(ui__TextView* tv, int pos);
multi_return_int_int ui__TextView_ordered_pos_selection(ui__TextView* tv);
multi_return_int_int_int_int ui__TextView_ordered_lines_selection(ui__TextView* tv);
multi_return_int_int ui__TextView_text_xminmax_from_pos(ui__TextView* tv, string text, int x1, int x2);
int ui__TextView_text_pos_from_x(ui__TextView* tv, string text, int x);
string ui__TextView_fix_tab_char(ui__TextView* tv, string txt);
void ui__TextView_draw_text(ui__TextView* tv, int x, int y, string text);
void ui__TextView_draw_styled_text(ui__TextView* tv, int x, int y, string text, ui__TextStyleParams ts);
int ui__TextView_text_width(ui__TextView* tv, string text);
f64 ui__TextView_text_width_additive(ui__TextView* tv, string text);
int ui__TextView_text_height(ui__TextView* tv, string text);
multi_return_int_int ui__TextView_text_size(ui__TextView* tv, string text);
void ui__TextView_update_line_height(ui__TextView* tv);
void ui__TextView_update_style(ui__TextView* tv, ui__TextStyleParams ts);
void ui__TextView_load_style(ui__TextView* tv);
void ui__TextView_test_textwidth(ui__TextView* tv, string text);
gx__Color _const_ui__no_color; // inited later
ui__ColorThemeCfg _const_ui__no_theme; // inited later
ui__ColorTheme ui__color_theme(Array_ui__Color items);
void ui__Window_register_color_theme(ui__Window* w, string name, ui__ColorTheme theme);
void ui__Window_register_default_color_themes(ui__Window* w);
gx__Color ui__color(Map_int_gx__Color theme, int id);
void ui__set_color(Map_int_gx__Color* theme, int id, gx__Color color);
void ui__update_colors_from(Map_int_gx__Color* theme, Map_int_gx__Color theme2, Array_int ids);
Map_int_gx__Color ui__theme(ui__ColorThemeWidget w);
void ui__component_connect(voidptr comp, Array_ui__ComponentChild children);
string _const_ui__no_string; // a string literal, inited later
void ui__DrawTextWidget_add_font(ui__DrawTextWidget* w, string font_name, string font_path);
void ui__DrawTextWidget_init_style(ui__DrawTextWidget* w, ui__TextStyleParams ts);
ui__TextStyle ui__DrawTextWidget_text_style(ui__DrawTextWidget w, ui__TextStyleParams ts);
void ui__DrawTextWidget_add_style(ui__DrawTextWidget* w, ui__TextStyle ts);
void ui__DrawTextWidget_update_style(ui__DrawTextWidget* w, ui__TextStyleParams ts);
void ui__DrawTextWidget_update_text_size(ui__DrawTextWidget* w, f64 size);
ui__TextStyle ui__DrawTextWidget_style_by_id(ui__DrawTextWidget w, string id);
ui__TextStyle ui__DrawTextWidget_current_style(ui__DrawTextWidget w);
void ui__DrawTextWidget_set_current_style(ui__DrawTextWidget* w, ui__TextStyleParams ts);
void ui__DrawTextWidget_load_style(ui__DrawTextWidget w);
void ui__DrawTextWidget_load_style_(ui__DrawTextWidget w, ui__TextStyle ts);
int ui__DrawTextWidget_font_size(ui__DrawTextWidget w);
void ui__DrawTextWidget_draw_text(ui__DrawTextWidget w, int x, int y, string text);
void ui__DrawTextWidget_draw_styled_text(ui__DrawTextWidget w, int x, int y, string text, ui__TextStyleParams ts);
multi_return_int_int ui__DrawTextWidget_text_size(ui__DrawTextWidget w, string text);
int ui__DrawTextWidget_text_width(ui__DrawTextWidget w, string text);
f64 ui__DrawTextWidget_text_width_additive(ui__DrawTextWidget w, string text);
int ui__DrawTextWidget_text_height(ui__DrawTextWidget w, string text);
ui__TextStyle ui__TextStyles_style(ui__TextStyles* t, string id);
void ui__UI_add_font(ui__UI* ui, string font_name, string font_path);
void ui__UI_add_style(ui__UI* ui, ui__TextStyle ts);
void ui__UI_update_style(ui__UI* u, ui__TextStyleParams ts);
Array_string ui__font_path_list(void);
ui__FontSearcher ui__new_font_searcher(void);
string ui__FontSearcher_search(ui__FontSearcher a, string word);
string ui__font_default(void);
void ui__Window_add_font(ui__Window* w, string id, string font_path);
void ui__Window_init_styles(ui__Window* w);
bool ui__Focusable_has_focusable(ui__Focusable f);
void ui__Focusable_set_focus(ui__Focusable* f);
void ui__Focusable_force_focus(ui__Focusable* f);
void ui__Focusable_lock_focus(ui__Focusable f);
void ui__Focusable_unlock_focus(ui__Focusable f);
void ui__Layout_set_children_depth(ui__Layout* l, int z_index);
void ui__Layout_incr_children_depth(ui__Layout* l, int z_inc);
bool ui__Layout_has_child_id(ui__Layout* l, string widget_id);
bool ui__Layout_has_child(ui__Layout* l, ui__Widget* widget);
void ui__Layout_unfocus_all(ui__Layout layout);
bool ui__Layout_set_focus_next(ui__Layout layout);
bool ui__Layout_set_focus_prev(ui__Layout layout);
bool ui__Layout_set_focus_first(ui__Layout layout);
bool ui__Layout_set_focus_last(ui__Layout layout);
bool ui__Layout_has_scrollview(ui__Layout l);
bool ui__Layout_has_scrollview_or_parent_scrollview(ui__Layout l);
void ui__Layout_debug_show_children_tree(ui__Layout l, int level);
int ui__Widget_get_depth(ui__Widget* w);
void ui__Widget_set_depth(ui__Widget* w, int z_index);
string ui__Widget_id(ui__Widget* child);
bool ui__Widget_has_parent_deactivated(ui__Widget* w);
gg__Rect ui__Widget_bounds(ui__Widget* w);
gg__Rect ui__Widget_scaled_bounds(ui__Widget* w);
multi_return_bool_ui__Layout ui__Widget_subwindow_parent(ui__Widget w);
bool ui__Widget_is_layout_with_children(ui__Widget w);
bool ui__shift_key(ui__KeyMod mods);
bool ui__ctl_key(ui__KeyMod mods);
bool ui__alt_key(ui__KeyMod mods);
bool ui__super_key(ui__KeyMod mods);
bool ui__ctl_shift_key(ui__KeyMod mods);
bool ui__ctl_alt_key(ui__KeyMod mods);
bool ui__super_alt_key(ui__KeyMod mods);
ui__CanvasLayout* ui__canvas_layout(ui__CanvasLayoutParams c);
ui__CanvasLayout* ui__canvas_plus(ui__CanvasLayoutParams c);
void ui__CanvasLayout_init(ui__CanvasLayout* c, ui__Layout parent);
void ui__CanvasLayout_cleanup(ui__CanvasLayout* c);
void ui__CanvasLayout_free(ui__CanvasLayout* c);
void ui__CanvasLayout_init_size(ui__CanvasLayout* c);
void ui__canvas_layout_click(ui__CanvasLayout* c, ui__MouseEvent* e, ui__Window* window);
void ui__canvas_layout_mouse_down(ui__CanvasLayout* c, ui__MouseEvent* e, ui__Window* window);
void ui__canvas_layout_mouse_up(ui__CanvasLayout* c, ui__MouseEvent* e, ui__Window* window);
void ui__canvas_layout_mouse_move(ui__CanvasLayout* c, ui__MouseMoveEvent* e, ui__Window* window);
void ui__canvas_layout_scroll(ui__CanvasLayout* c, ui__ScrollEvent* e, ui__Window* window);
void ui__canvas_layout_key_down(ui__CanvasLayout* c, ui__KeyEvent* e, ui__Window* window);
void ui__canvas_layout_char(ui__CanvasLayout* c, ui__KeyEvent* e, ui__Window* window);
void ui__CanvasLayout_update_layout(ui__CanvasLayout* c);
void ui__CanvasLayout_set_adjusted_size(ui__CanvasLayout* c, ui__UI* gui);
void ui__CanvasLayout_set_children_pos(ui__CanvasLayout* c);
void ui__CanvasLayout_set_child_relative_pos(ui__CanvasLayout* c, string id, int x, int y);
void ui__CanvasLayout_set_pos(ui__CanvasLayout* c, int x, int y);
multi_return_int_int ui__CanvasLayout_adj_size(ui__CanvasLayout* c);
multi_return_int_int ui__CanvasLayout_size(ui__CanvasLayout* c);
multi_return_int_int ui__CanvasLayout_full_size(ui__CanvasLayout* c);
multi_return_int_int ui__CanvasLayout_propose_size(ui__CanvasLayout* c, int w, int h);
void ui__CanvasLayout_set_drawing_children(ui__CanvasLayout* c);
void ui__CanvasLayout_draw(ui__CanvasLayout* c);
void ui__CanvasLayout_set_visible(ui__CanvasLayout* c, bool state);
bool ui__CanvasLayout_point_inside(ui__CanvasLayout* c, f64 x, f64 y);
ui__UI* ui__CanvasLayout_get_ui(ui__CanvasLayout* c);
void ui__CanvasLayout_resize(ui__CanvasLayout* c, int width, int height);
voidptr ui__CanvasLayout_get_state(ui__CanvasLayout* c);
eventbus__Subscriber* ui__CanvasLayout_get_subscriber(ui__CanvasLayout* c);
Array_ui__Widget ui__CanvasLayout_get_children(ui__CanvasLayout* c);
int ui__CanvasLayout_child_index_by_id(ui__CanvasLayout* c, string id);
void ui__CanvasLayout_draw_text_def(ui__CanvasLayout* c, int x, int y, string text);
void ui__CanvasLayout_draw_text(ui__CanvasLayout* c, int x, int y, string text);
void ui__CanvasLayout_draw_styled_text(ui__CanvasLayout* c, int x, int y, string text, ui__TextStyleParams ts);
void ui__CanvasLayout_draw_triangle_empty(ui__CanvasLayout* c, f32 x, f32 y, f32 x2, f32 y2, f32 x3, f32 y3, gx__Color color);
void ui__CanvasLayout_draw_triangle_filled(ui__CanvasLayout* c, f32 x, f32 y, f32 x2, f32 y2, f32 x3, f32 y3, gx__Color color);
void ui__CanvasLayout_draw_square_empty(ui__CanvasLayout* c, f32 x, f32 y, f32 s, gx__Color color);
void ui__CanvasLayout_draw_square_filled(ui__CanvasLayout* c, f32 x, f32 y, f32 s, gx__Color color);
void ui__CanvasLayout_draw_rect_empty(ui__CanvasLayout* c, f32 x, f32 y, f32 w, f32 h, gx__Color color);
void ui__CanvasLayout_draw_rect_filled(ui__CanvasLayout* c, f32 x, f32 y, f32 w, f32 h, gx__Color color);
void ui__CanvasLayout_draw_rounded_rect_filled(ui__CanvasLayout* c, f32 x, f32 y, f32 w, f32 h, f32 radius, gx__Color color);
void ui__CanvasLayout_draw_rounded_rect_empty(ui__CanvasLayout* c, f32 x, f32 y, f32 w, f32 h, f32 radius, gx__Color border_color);
void ui__CanvasLayout_draw_circle_line(ui__CanvasLayout* c, f32 x, f32 y, int r, int segments, gx__Color color);
void ui__CanvasLayout_draw_circle_empty(ui__CanvasLayout* c, f32 x, f32 y, f32 r, gx__Color color);
void ui__CanvasLayout_draw_circle_filled(ui__CanvasLayout* c, f32 x, f32 y, f32 r, gx__Color color);
void ui__CanvasLayout_draw_slice_empty(ui__CanvasLayout* c, f32 x, f32 y, f32 r, f32 start_angle, f32 end_angle, int segments, gx__Color color);
void ui__CanvasLayout_draw_slice_filled(ui__CanvasLayout* c, f32 x, f32 y, f32 r, f32 start_angle, f32 end_angle, int segments, gx__Color color);
void ui__CanvasLayout_draw_arc_empty(ui__CanvasLayout* c, f32 x, f32 y, f32 inner_radius, f32 thickness, f32 start_angle, f32 end_angle, int segments, gx__Color color);
void ui__CanvasLayout_draw_arc_filled(ui__CanvasLayout* c, f32 x, f32 y, f32 inner_radius, f32 thickness, f32 start_angle, f32 end_angle, int segments, gx__Color color);
void ui__CanvasLayout_draw_line(ui__CanvasLayout* c, f32 x, f32 y, f32 x2, f32 y2, gx__Color color);
void ui__CanvasLayout_draw_convex_poly(ui__CanvasLayout* c, Array_f32 points, gx__Color color);
void ui__CanvasLayout_draw_empty_poly(ui__CanvasLayout* c, Array_f32 points, gx__Color color);
ui__Stack* ui__column(ui__ColumnParams c);
ui__Group* ui__group(ui__GroupParams c);
void ui__Group_init(ui__Group* g, ui__Layout parent);
void ui__Group_cleanup(ui__Group* g);
void ui__Group_free(ui__Group* g);
void ui__Group_decode_size(ui__Group* g);
void ui__Group_set_pos(ui__Group* g, int x, int y);
void ui__Group_calculate_child_positions(ui__Group* g);
void ui__Group_draw(ui__Group* g);
bool ui__Group_point_inside(ui__Group* g, f64 x, f64 y);
void ui__Group_set_visible(ui__Group* g, bool state);
ui__UI* ui__Group_get_ui(ui__Group* g);
void ui__Group_resize(ui__Group* g, int width, int height);
voidptr ui__Group_get_state(ui__Group* g);
eventbus__Subscriber* ui__Group_get_subscriber(ui__Group* g);
void ui__Group_set_adjusted_size(ui__Group* g, int i, ui__UI* ui);
multi_return_int_int ui__Group_adj_size(ui__Group* g);
multi_return_int_int ui__Group_propose_size(ui__Group* g, int w, int h);
multi_return_int_int ui__Group_size(ui__Group* g);
Array_ui__Widget ui__Group_get_children(ui__Group* g);
void ui__Group_update_layout(ui__Group* g);
ui__Stack* ui__row(ui__RowParams c);
ui__Stack* _const_ui__empty_stack; // inited later
gg__Rect _const_ui__scrollview_empty_rect; // inited later
ui__Stack* ui__stack(ui__StackParams c);
void ui__Stack_init(ui__Stack* s, ui__Layout parent);
void ui__Stack_cleanup(ui__Stack* s);
void ui__Stack_free(ui__Stack* s);
void ui__Stack_update_layout(ui__Stack* s);
void ui__Stack_update_layout_without_pos(ui__Stack* s);
void ui__Stack_init_size(ui__Stack* s);
void ui__Stack_set_children_sizes(ui__Stack* s);
multi_return_Array_int_Array_int ui__Stack_children_sizes(ui__Stack* s);
void ui__Stack_set_cache_sizes(ui__Stack* s);
void ui__Stack_default_sizes(ui__Stack* s);
multi_return_int_int ui__Stack_adj_size(ui__Stack* s);
multi_return_int_int ui__Stack_propose_size(ui__Stack* s, int w, int h);
multi_return_int_int ui__Stack_size(ui__Stack* s);
multi_return_int_int ui__Stack_free_size(ui__Stack* s);
void ui__Stack_set_adjusted_size(ui__Stack* s, int i, bool force, ui__UI* gui);
void ui__Stack_update_pos(ui__Stack* s);
void ui__Stack_set_pos(ui__Stack* s, int x, int y);
void ui__Stack_set_children_pos(ui__Stack* s);
void ui__Stack_set_child_pos(ui__Stack* s, ui__Widget* child, int i, int x, int y);
eventbus__Subscriber* ui__Stack_get_subscriber(ui__Stack* s);
void ui__Stack_set_children_visible(ui__Stack* s, bool state, Array_int children);
void ui__Stack_set_children_depth(ui__Stack* s, int z_index, Array_int children);
void ui__Stack_set_drawing_children(ui__Stack* s);
void ui__Stack_draw(ui__Stack* s);
int ui__Stack_margin(ui__Stack* s, ui__Side side);
int ui__Stack_spacing(ui__Stack* s, int i);
int ui__Stack_total_spacing(ui__Stack* s);
ui__UI* ui__Stack_get_ui(ui__Stack* s);
voidptr ui__Stack_get_state(ui__Stack* s);
bool ui__Stack_point_inside(ui__Stack* s, f64 x, f64 y);
void ui__Stack_set_visible(ui__Stack* s, bool state);
void ui__Stack_resize(ui__Stack* s, int width, int height);
Array_ui__Widget ui__Stack_get_children(ui__Stack* s);
void ui__Stack_set_children(ui__Stack* s, Array_ui__Widget c);
ui__VerticalAlignment ui__Stack_get_vertical_alignment(ui__Stack* s, int i);
ui__HorizontalAlignment ui__Stack_get_horizontal_alignment(ui__Stack* s, int i);
void ui__Stack_set_child_pos_aligned(ui__Stack* s, ui__Widget* child, int i, int x, int y);
multi_return_ui__HorizontalAlignment_ui__VerticalAlignment ui__Stack_get_alignments(ui__Stack* s, int i);
void ui__Stack_add(ui__Stack* s, ui__ChildrenParams cfg_);
void ui__Stack_remove(ui__Stack* s, ui__ChildrenParams cfg);
void ui__Stack_move(ui__Stack* s, ui__ChildrenParams cfg);
void ui__Stack_update_widths(ui__Stack* s, ui__ChildrenParams cfg, ui__ChildUpdateType mode);
void ui__Stack_update_heights(ui__Stack* s, ui__ChildrenParams cfg, ui__ChildUpdateType mode);
void ui__Stack_update_spacings(ui__Stack* s, ui__ChildrenParams cfg, ui__ChildUpdateType mode);
ui__Widget ui__Stack_child(ui__Stack* s, Array_int from);
void ui__Stack_transpose(ui__Stack* s, bool size);
void ui__Stack_register_child(ui__Stack* s, ui__Widget child);
int ui__Stack_child_index_by_id(ui__Stack* s, string id);
Array_fixed_byte_3811 _const_ui__bytes_check_png = {((byte)(137)), 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 16, 0, 0, 0, 16, 8, 6, 0, 0, 0, 31, 243, 255, 97, 0, 0, 0, 4, 103, 65, 77, 65, 0, 0, 177, 142, 124, 251, 81, 147, 0, 0, 0, 32, 99, 72, 82, 77, 0, 0, 135, 14, 0, 0, 140, 18, 0, 1, 10, 118, 0, 0, 124, 199, 0, 0, 108, 171, 0, 1, 10, 41, 0, 0, 60, 174, 0, 0, 22, 177, 136, 240, 182, 122, 0, 0, 10, 169, 105, 67, 67, 80, 73, 67, 67, 32, 80, 114, 111, 102, 105, 108, 101, 0, 0, 72, 199, 173, 150, 103, 84, 83, 217, 22, 199, 207, 189, 233, 141, 22, 64, 64, 74, 232, 189, 119, 144, 94, 67, 17, 164, 131, 168, 132, 36, 64, 40, 33, 36, 4, 20, 27, 34, 131, 35, 56, 22, 68, 68, 64, 29, 209, 65, 138, 130, 131, 82, 100, 16, 21, 11, 182, 65, 65, 193, 238, 128, 136, 128, 50, 78, 44, 216, 80, 51, 23, 120, 196, 153, 15, 239, 195, 91, 235, 237, 181, 118, 206, 111, 237, 181, 207, 62, 123, 223, 156, 179, 214, 31, 0, 242, 29, 6, 143, 151, 14, 203, 0, 144, 193, 205, 230, 135, 249, 121, 210, 98, 98, 227, 104, 184, 103, 0, 2, 48, 80, 0, 246, 64, 137, 193, 20, 240, 60, 66, 67, 131, 0, 98, 11, 235, 191, 237, 253, 16, 146, 141, 216, 109, 211, 217, 90, 224, 127, 51, 89, 22, 91, 192, 4, 0, 10, 69, 56, 145, 37, 96, 102, 32, 124, 10, 241, 46, 38, 143, 159, 13, 0, 138, 135, 196, 181, 115, 179, 121, 179, 92, 134, 176, 60, 31, 105, 16, 225, 186, 89, 78, 158, 231, 174, 89, 78, 156, 231, 91, 115, 57, 17, 97, 94, 8, 63, 3, 0, 79, 102, 48, 248, 201, 0, 144, 68, 72, 156, 150, 195, 76, 70, 234, 144, 145, 105, 129, 5, 151, 197, 225, 34, 236, 142, 176, 43, 51, 133, 193, 66, 56, 31, 97, 147, 140, 140, 204, 89, 62, 134, 176, 65, 226, 63, 234, 36, 255, 171, 102, 162, 164, 38, 131, 145, 44, 225, 249, 89, 230, 12, 239, 205, 17, 240, 210, 25, 107, 192, 255, 219, 50, 210, 133, 11, 103, 104, 35, 78, 78, 225, 251, 135, 205, 158, 55, 251, 221, 210, 50, 3, 37, 204, 77, 92, 26, 178, 192, 28, 214, 124, 79, 179, 156, 34, 244, 143, 92, 96, 166, 192, 43, 110, 129, 89, 12, 239, 64, 201, 222, 244, 165, 65, 11, 156, 196, 241, 165, 75, 234, 100, 211, 35, 22, 152, 159, 25, 38, 169, 207, 22, 248, 132, 47, 48, 131, 255, 253, 44, 97, 90, 164, 135, 228, 92, 54, 93, 82, 51, 47, 37, 34, 122, 129, 115, 56, 81, 75, 23, 88, 144, 22, 30, 248, 61, 199, 75, 18, 231, 11, 195, 36, 61, 39, 241, 125, 37, 51, 102, 8, 254, 49, 23, 135, 46, 201, 207, 78, 137, 240, 151, 204, 200, 248, 222, 27, 91, 16, 35, 233, 129, 197, 246, 246, 145, 196, 185, 145, 146, 28, 94, 182, 167, 164, 62, 47, 61, 84, 146, 207, 78, 247, 147, 196, 5, 57, 225, 146, 189, 217, 200, 101, 251, 190, 55, 84, 242, 125, 82, 25, 1, 161, 11, 12, 56, 32, 24, 48, 0, 51, 155, 189, 58, 123, 182, 97, 175, 76, 222, 26, 62, 39, 57, 37, 155, 230, 129, 188, 24, 54, 141, 206, 101, 154, 153, 208, 172, 44, 172, 44, 0, 152, 125, 127, 243, 127, 175, 232, 230, 220, 187, 130, 148, 101, 191, 199, 138, 144, 187, 230, 42, 18, 139, 197, 109, 223, 99, 254, 151, 0, 104, 113, 6, 128, 88, 249, 61, 166, 223, 0, 128, 212, 32, 0, 87, 30, 51, 133, 252, 156, 249, 24, 122, 246, 7, 3, 136, 64, 26, 200, 3, 101, 160, 142, 220, 31, 3, 96, 10, 172, 128, 29, 112, 6, 238, 192, 7, 4, 128, 16, 16, 1, 98, 193, 74, 192, 4, 41, 32, 3, 240, 65, 46, 88, 7, 54, 129, 34, 80, 2, 118, 130, 61, 160, 18, 28, 4, 135, 65, 29, 56, 14, 90, 64, 59, 232, 2, 231, 193, 101, 112, 29, 220, 2, 131, 224, 33, 24, 6, 99, 224, 37, 16, 129, 247, 96, 6, 130, 32, 28, 68, 129, 168, 144, 50, 164, 1, 233, 66, 198, 144, 21, 228, 0, 185, 66, 62, 80, 16, 20, 6, 197, 66, 9, 80, 50, 196, 133, 132, 208, 58, 104, 51, 84, 2, 149, 66, 149, 208, 33, 168, 30, 250, 21, 58, 13, 157, 135, 174, 66, 253, 208, 125, 104, 4, 154, 132, 222, 64, 159, 97, 20, 76, 134, 229, 97, 53, 88, 15, 54, 135, 29, 96, 15, 56, 16, 142, 128, 87, 192, 201, 112, 22, 156, 7, 23, 194, 219, 225, 10, 184, 6, 62, 6, 183, 193, 231, 225, 235, 240, 32, 60, 12, 191, 132, 167, 81, 0, 69, 66, 41, 162, 52, 81, 166, 40, 7, 148, 23, 42, 4, 21, 135, 74, 66, 241, 81, 27, 80, 197, 168, 114, 84, 13, 170, 9, 213, 137, 234, 69, 221, 70, 13, 163, 166, 80, 159, 208, 88, 52, 21, 77, 67, 155, 162, 157, 209, 254, 232, 72, 52, 19, 157, 133, 222, 128, 222, 134, 174, 68, 215, 161, 219, 208, 23, 209, 183, 209, 35, 104, 17, 250, 27, 134, 130, 81, 197, 24, 99, 156, 48, 116, 76, 12, 38, 25, 147, 139, 41, 194, 148, 99, 106, 49, 173, 152, 75, 152, 65, 204, 24, 230, 61, 22, 139, 85, 196, 234, 99, 237, 177, 254, 216, 88, 108, 42, 118, 45, 118, 27, 118, 63, 182, 25, 123, 14, 219, 143, 29, 197, 78, 227, 112, 56, 101, 156, 49, 206, 5, 23, 130, 99, 224, 178, 113, 69, 184, 125, 184, 99, 184, 179, 184, 1, 220, 24, 238, 35, 158, 132, 215, 192, 91, 225, 125, 241, 113, 120, 46, 190, 0, 95, 142, 111, 192, 119, 227, 7, 240, 227, 248, 25, 130, 12, 65, 151, 224, 68, 8, 33, 176, 8, 107, 8, 59, 8, 71, 8, 157, 132, 155, 132, 49, 194, 12, 81, 150, 168, 79, 116, 33, 70, 16, 83, 137, 155, 136, 21, 196, 38, 226, 37, 226, 35, 226, 91, 18, 137, 164, 69, 114, 36, 45, 35, 113, 72, 249, 164, 10, 210, 9, 210, 21, 210, 8, 233, 19, 89, 142, 108, 68, 246, 34, 199, 147, 133, 228, 237, 228, 163, 228, 115, 228, 251, 228, 183, 20, 10, 69, 143, 226, 78, 137, 163, 100, 83, 182, 83, 234, 41, 23, 40, 79, 40, 31, 165, 168, 82, 102, 82, 116, 41, 150, 212, 70, 169, 42, 169, 54, 169, 1, 169, 87, 210, 4, 105, 93, 105, 15, 233, 149, 210, 121, 210, 229, 210, 39, 165, 111, 74, 79, 201, 16, 100, 244, 100, 188, 100, 24, 50, 27, 100, 170, 100, 78, 203, 220, 149, 153, 150, 165, 202, 90, 202, 134, 200, 102, 200, 110, 147, 109, 144, 189, 42, 59, 33, 135, 147, 211, 147, 243, 145, 99, 201, 21, 202, 29, 150, 187, 32, 55, 74, 69, 81, 181, 169, 94, 84, 38, 117, 51, 245, 8, 245, 18, 117, 76, 30, 43, 175, 47, 79, 151, 79, 149, 47, 145, 63, 46, 223, 39, 47, 82, 144, 83, 176, 81, 136, 82, 88, 173, 80, 165, 112, 70, 97, 88, 17, 165, 168, 167, 72, 87, 76, 87, 220, 161, 216, 162, 56, 164, 248, 121, 145, 218, 34, 143, 69, 236, 69, 91, 23, 53, 45, 26, 88, 244, 65, 105, 177, 146, 187, 18, 91, 169, 88, 169, 89, 105, 80, 233, 179, 50, 77, 217, 71, 57, 77, 121, 151, 114, 187, 242, 99, 21, 180, 138, 145, 202, 50, 149, 92, 149, 3, 42, 151, 84, 166, 22, 203, 47, 118, 94, 204, 92, 92, 188, 184, 101, 241, 3, 85, 88, 213, 72, 53, 76, 117, 173, 234, 97, 213, 27, 170, 211, 106, 234, 106, 126, 106, 60, 181, 125, 106, 23, 212, 166, 212, 21, 213, 221, 213, 83, 213, 203, 212, 187, 213, 39, 53, 168, 26, 174, 26, 28, 141, 50, 141, 179, 26, 47, 104, 10, 52, 15, 90, 58, 173, 130, 118, 145, 38, 210, 84, 213, 244, 215, 20, 106, 30, 210, 236, 211, 156, 209, 210, 215, 138, 212, 42, 208, 106, 214, 122, 172, 77, 212, 118, 208, 78, 210, 46, 211, 238, 209, 22, 233, 104, 232, 4, 235, 172, 211, 105, 212, 121, 160, 75, 208, 117, 208, 77, 209, 221, 171, 219, 171, 251, 65, 79, 95, 47, 90, 111, 139, 94, 187, 222, 132, 190, 146, 62, 93, 63, 79, 191, 81, 255, 145, 1, 197, 192, 205, 32, 203, 160, 198, 224, 142, 33, 214, 208, 193, 48, 205, 112, 191, 225, 45, 35, 216, 200, 214, 40, 197, 168, 202, 232, 166, 49, 108, 108, 103, 204, 49, 222, 111, 220, 111, 130, 49, 113, 52, 225, 154, 212, 152, 220, 53, 37, 155, 122, 152, 230, 152, 54, 154, 142, 152, 41, 154, 5, 153, 21, 152, 181, 155, 189, 50, 215, 49, 143, 51, 223, 101, 222, 107, 254, 205, 194, 214, 34, 221, 226, 136, 197, 67, 75, 57, 203, 0, 203, 2, 203, 78, 203, 55, 86, 70, 86, 76, 171, 42, 171, 59, 214, 20, 107, 95, 235, 141, 214, 29, 214, 175, 109, 140, 109, 216, 54, 7, 108, 238, 217, 82, 109, 131, 109, 183, 216, 246, 216, 126, 181, 179, 183, 227, 219, 53, 217, 77, 218, 235, 216, 39, 216, 87, 219, 223, 117, 144, 119, 8, 117, 216, 230, 112, 197, 17, 227, 232, 233, 184, 209, 177, 203, 241, 147, 147, 157, 83, 182, 83, 139, 211, 95, 206, 166, 206, 105, 206, 13, 206, 19, 75, 244, 151, 176, 151, 28, 89, 50, 234, 162, 229, 194, 112, 57, 228, 50, 236, 74, 115, 77, 112, 253, 217, 117, 216, 77, 211, 141, 225, 86, 227, 246, 212, 93, 219, 157, 229, 94, 235, 62, 238, 97, 232, 145, 234, 113, 204, 227, 149, 167, 133, 39, 223, 179, 213, 243, 131, 151, 147, 215, 122, 175, 115, 222, 40, 111, 63, 239, 98, 239, 62, 31, 57, 159, 72, 159, 74, 159, 39, 190, 90, 190, 201, 190, 141, 190, 34, 63, 91, 191, 181, 126, 231, 252, 49, 254, 129, 254, 187, 252, 239, 210, 213, 232, 76, 122, 61, 93, 20, 96, 31, 176, 62, 224, 98, 32, 57, 48, 60, 176, 50, 240, 105, 144, 81, 16, 63, 168, 51, 24, 14, 14, 8, 222, 29, 252, 104, 169, 238, 82, 238, 210, 246, 16, 16, 66, 15, 217, 29, 242, 56, 84, 63, 52, 43, 244, 183, 101, 216, 101, 161, 203, 170, 150, 61, 15, 179, 12, 91, 23, 214, 27, 78, 13, 95, 21, 222, 16, 254, 62, 194, 51, 98, 71, 196, 195, 72, 131, 72, 97, 100, 79, 148, 116, 84, 124, 84, 125, 212, 135, 104, 239, 232, 210, 232, 225, 24, 243, 152, 245, 49, 215, 99, 85, 98, 57, 177, 29, 113, 184, 184, 168, 184, 218, 184, 233, 229, 62, 203, 247, 44, 31, 139, 183, 141, 47, 138, 31, 90, 161, 191, 98, 245, 138, 171, 43, 85, 86, 166, 175, 60, 179, 74, 122, 21, 99, 213, 201, 4, 76, 66, 116, 66, 67, 194, 23, 70, 8, 163, 134, 49, 157, 72, 79, 172, 78, 20, 49, 189, 152, 123, 153, 47, 89, 238, 172, 50, 214, 36, 219, 133, 93, 202, 30, 79, 114, 73, 42, 77, 154, 72, 118, 73, 222, 157, 60, 153, 226, 150, 82, 158, 50, 197, 241, 226, 84, 114, 94, 167, 250, 167, 30, 76, 253, 144, 22, 146, 118, 52, 77, 156, 30, 157, 222, 156, 129, 207, 72, 200, 56, 205, 149, 227, 166, 113, 47, 102, 170, 103, 174, 206, 236, 231, 25, 243, 138, 120, 195, 89, 78, 89, 123, 178, 68, 252, 64, 126, 173, 0, 18, 172, 16, 116, 100, 203, 35, 66, 231, 134, 208, 64, 248, 131, 112, 36, 199, 53, 167, 42, 231, 99, 110, 84, 238, 201, 213, 178, 171, 185, 171, 111, 172, 49, 90, 179, 117, 205, 120, 158, 111, 222, 47, 107, 209, 107, 153, 107, 123, 214, 105, 174, 219, 180, 110, 100, 189, 199, 250, 67, 27, 160, 13, 137, 27, 122, 54, 106, 111, 44, 220, 56, 150, 239, 151, 95, 183, 137, 184, 41, 109, 211, 239, 5, 22, 5, 165, 5, 239, 54, 71, 111, 238, 44, 84, 43, 204, 47, 28, 253, 193, 239, 135, 198, 34, 169, 34, 126, 209, 221, 45, 206, 91, 14, 254, 136, 254, 145, 243, 99, 223, 86, 235, 173, 251, 182, 126, 43, 102, 21, 95, 43, 177, 40, 41, 47, 249, 178, 141, 185, 237, 218, 79, 150, 63, 85, 252, 36, 222, 158, 180, 189, 111, 135, 221, 142, 3, 59, 177, 59, 185, 59, 135, 118, 185, 237, 170, 43, 149, 45, 205, 43, 29, 221, 29, 188, 187, 173, 140, 86, 86, 92, 246, 110, 207, 170, 61, 87, 203, 109, 202, 15, 238, 37, 238, 21, 238, 29, 174, 8, 170, 232, 216, 167, 179, 111, 231, 190, 47, 149, 41, 149, 131, 85, 158, 85, 205, 213, 170, 213, 91, 171, 63, 236, 103, 237, 31, 56, 224, 126, 160, 233, 160, 218, 193, 146, 131, 159, 127, 230, 252, 124, 239, 144, 223, 161, 182, 26, 189, 154, 242, 195, 216, 195, 57, 135, 159, 31, 137, 58, 210, 251, 139, 195, 47, 245, 181, 42, 181, 37, 181, 95, 143, 114, 143, 14, 215, 133, 213, 93, 172, 183, 175, 175, 111, 80, 109, 216, 209, 8, 55, 10, 27, 39, 143, 197, 31, 187, 117, 220, 251, 120, 71, 147, 105, 211, 161, 102, 197, 230, 146, 19, 224, 132, 240, 196, 139, 95, 19, 126, 29, 106, 9, 108, 233, 57, 233, 112, 178, 233, 148, 238, 169, 234, 86, 106, 107, 113, 27, 212, 182, 166, 77, 212, 158, 210, 62, 220, 17, 219, 209, 127, 58, 224, 116, 79, 167, 115, 103, 235, 111, 102, 191, 29, 237, 210, 236, 170, 58, 163, 112, 102, 71, 55, 177, 187, 176, 91, 124, 54, 239, 236, 244, 57, 222, 185, 169, 243, 201, 231, 71, 123, 86, 245, 60, 188, 16, 115, 225, 206, 197, 101, 23, 251, 46, 5, 94, 186, 114, 217, 247, 242, 133, 94, 143, 222, 179, 87, 92, 174, 116, 93, 117, 186, 122, 250, 154, 195, 181, 246, 235, 118, 215, 219, 110, 216, 222, 104, 253, 221, 246, 247, 214, 62, 187, 190, 182, 155, 246, 55, 59, 110, 57, 222, 234, 236, 95, 210, 223, 61, 224, 54, 112, 254, 182, 247, 237, 203, 119, 232, 119, 174, 15, 46, 29, 236, 31, 138, 28, 186, 119, 55, 254, 238, 240, 61, 214, 189, 137, 251, 233, 247, 95, 63, 200, 121, 48, 243, 48, 255, 17, 230, 81, 241, 99, 153, 199, 229, 79, 84, 159, 212, 252, 97, 248, 71, 243, 176, 221, 240, 153, 17, 239, 145, 27, 79, 195, 159, 62, 28, 101, 142, 190, 124, 38, 120, 246, 101, 172, 240, 57, 229, 121, 249, 184, 198, 120, 253, 132, 213, 68, 215, 164, 239, 228, 173, 23, 203, 95, 140, 189, 228, 189, 156, 153, 42, 250, 83, 246, 207, 234, 87, 6, 175, 78, 253, 229, 254, 215, 13, 81, 140, 104, 236, 53, 255, 181, 248, 205, 182, 183, 202, 111, 143, 190, 179, 121, 215, 51, 29, 58, 253, 228, 125, 198, 251, 153, 15, 197, 31, 149, 63, 214, 125, 114, 248, 212, 251, 57, 250, 243, 248, 76, 238, 23, 220, 151, 138, 175, 134, 95, 59, 191, 5, 126, 123, 36, 206, 16, 139, 121, 12, 62, 99, 78, 10, 160, 16, 135, 147, 146, 0, 120, 115, 20, 0, 74, 44, 0, 84, 68, 55, 19, 151, 207, 235, 227, 57, 131, 230, 53, 253, 28, 129, 255, 198, 243, 26, 122, 206, 236, 0, 104, 66, 150, 89, 41, 52, 43, 249, 78, 34, 90, 90, 15, 209, 214, 148, 115, 0, 132, 32, 107, 132, 59, 128, 173, 173, 37, 254, 31, 19, 36, 89, 91, 205, 215, 146, 106, 4, 0, 167, 41, 22, 191, 201, 4, 128, 128, 248, 23, 63, 177, 120, 38, 84, 44, 254, 90, 141, 52, 123, 7, 128, 238, 137, 121, 93, 62, 107, 88, 68, 191, 55, 81, 207, 11, 106, 227, 6, 190, 229, 231, 255, 91, 29, 3, 240, 55, 74, 247, 10, 138, 238, 200, 114, 131, 0, 0, 0, 9, 112, 72, 89, 115, 0, 0, 14, 196, 0, 0, 14, 196, 1, 149, 43, 14, 27, 0, 0, 2, 4, 105, 84, 88, 116, 88, 77, 76, 58, 99, 111, 109, 46, 97, 100, 111, 98, 101, 46, 120, 109, 112, 0, 0, 0, 0, 0, 60, 120, 58, 120, 109, 112, 109, 101, 116, 97, 32, 120, 109, 108, 110, 115, 58, 120, 61, 34, 97, 100, 111, 98, 101, 58, 110, 115, 58, 109, 101, 116, 97, 47, 34, 32, 120, 58, 120, 109, 112, 116, 107, 61, 34, 88, 77, 80, 32, 67, 111, 114, 101, 32, 53, 46, 52, 46, 48, 34, 62, 10, 32, 32, 32, 60, 114, 100, 102, 58, 82, 68, 70, 32, 120, 109, 108, 110, 115, 58, 114, 100, 102, 61, 34, 104, 116, 116, 112, 58, 47, 47, 119, 119, 119, 46, 119, 51, 46, 111, 114, 103, 47, 49, 57, 57, 57, 47, 48, 50, 47, 50, 50, 45, 114, 100, 102, 45, 115, 121, 110, 116, 97, 120, 45, 110, 115, 35, 34, 62, 10, 32, 32, 32, 32, 32, 32, 60, 114, 100, 102, 58, 68, 101, 115, 99, 114, 105, 112, 116, 105, 111, 110, 32, 114, 100, 102, 58, 97, 98, 111, 117, 116, 61, 34, 34, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 120, 109, 108, 110, 115, 58, 101, 120, 105, 102, 61, 34, 104, 116, 116, 112, 58, 47, 47, 110, 115, 46, 97, 100, 111, 98, 101, 46, 99, 111, 109, 47, 101, 120, 105, 102, 47, 49, 46, 48, 47, 34, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 120, 109, 108, 110, 115, 58, 116, 105, 102, 102, 61, 34, 104, 116, 116, 112, 58, 47, 47, 110, 115, 46, 97, 100, 111, 98, 101, 46, 99, 111, 109, 47, 116, 105, 102, 102, 47, 49, 46, 48, 47, 34, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 60, 101, 120, 105, 102, 58, 80, 105, 120, 101, 108, 89, 68, 105, 109, 101, 110, 115, 105, 111, 110, 62, 49, 53, 50, 60, 47, 101, 120, 105, 102, 58, 80, 105, 120, 101, 108, 89, 68, 105, 109, 101, 110, 115, 105, 111, 110, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 60, 101, 120, 105, 102, 58, 80, 105, 120, 101, 108, 88, 68, 105, 109, 101, 110, 115, 105, 111, 110, 62, 50, 50, 48, 60, 47, 101, 120, 105, 102, 58, 80, 105, 120, 101, 108, 88, 68, 105, 109, 101, 110, 115, 105, 111, 110, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 60, 116, 105, 102, 102, 58, 79, 114, 105, 101, 110, 116, 97, 116, 105, 111, 110, 62, 49, 60, 47, 116, 105, 102, 102, 58, 79, 114, 105, 101, 110, 116, 97, 116, 105, 111, 110, 62, 10, 32, 32, 32, 32, 32, 32, 60, 47, 114, 100, 102, 58, 68, 101, 115, 99, 114, 105, 112, 116, 105, 111, 110, 62, 10, 32, 32, 32, 60, 47, 114, 100, 102, 58, 82, 68, 70, 62, 10, 60, 47, 120, 58, 120, 109, 112, 109, 101, 116, 97, 62, 10, 233, 63, 32, 177, 0, 0, 1, 148, 73, 68, 65, 84, 56, 79, 149, 147, 177, 175, 193, 80, 24, 197, 207, 171, 65, 98, 40, 18, 36, 54, 131, 201, 102, 53, 8, 179, 197, 98, 105, 68, 24, 108, 93, 25, 76, 254, 2, 137, 69, 194, 210, 196, 42, 86, 210, 177, 145, 144, 24, 172, 6, 131, 8, 131, 16, 34, 97, 161, 232, 115, 63, 183, 120, 201, 243, 94, 253, 146, 38, 223, 57, 105, 79, 239, 185, 183, 253, 50, 110, 224, 3, 142, 199, 35, 42, 149, 10, 6, 131, 1, 36, 73, 194, 199, 1, 173, 86, 11, 181, 90, 141, 102, 81, 20, 33, 208, 100, 145, 217, 108, 134, 102, 179, 201, 21, 16, 141, 70, 173, 7, 92, 175, 87, 52, 26, 13, 28, 14, 7, 210, 126, 191, 31, 153, 76, 198, 122, 64, 183, 219, 69, 191, 223, 231, 10, 200, 231, 243, 240, 122, 189, 214, 2, 86, 171, 21, 20, 69, 225, 10, 136, 199, 227, 116, 49, 254, 13, 184, 92, 46, 180, 244, 205, 102, 67, 218, 227, 241, 208, 219, 77, 40, 96, 191, 223, 211, 141, 191, 209, 235, 245, 160, 105, 26, 87, 64, 54, 155, 165, 254, 38, 2, 59, 146, 84, 42, 133, 66, 161, 128, 237, 118, 203, 237, 59, 187, 221, 14, 245, 122, 29, 231, 243, 153, 116, 36, 18, 65, 34, 145, 160, 217, 196, 166, 235, 122, 249, 116, 58, 97, 185, 92, 98, 177, 88, 32, 22, 139, 65, 16, 238, 205, 88, 248, 104, 52, 162, 217, 237, 118, 163, 84, 42, 193, 229, 114, 145, 54, 17, 146, 201, 36, 31, 65, 187, 108, 110, 214, 112, 56, 68, 167, 211, 161, 153, 145, 78, 167, 17, 8, 4, 184, 122, 98, 107, 183, 219, 229, 233, 116, 138, 249, 124, 78, 198, 120, 60, 134, 211, 233, 164, 47, 110, 189, 94, 147, 23, 14, 135, 33, 203, 242, 99, 101, 175, 208, 167, 204, 186, 22, 139, 69, 76, 38, 19, 110, 63, 113, 56, 28, 168, 86, 171, 8, 6, 131, 220, 249, 9, 69, 178, 94, 172, 159, 207, 231, 35, 243, 21, 246, 195, 188, 123, 152, 241, 88, 19, 235, 199, 86, 97, 183, 219, 185, 3, 132, 66, 33, 58, 161, 63, 97, 21, 94, 81, 85, 213, 184, 109, 172, 145, 203, 229, 140, 91, 37, 238, 190, 195, 48, 190, 1, 231, 96, 208, 15, 105, 22, 68, 122, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130}; // fixed array const
Array_fixed_byte_818 _const_ui__bytes_circle_png = {((byte)(137)), 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 16, 0, 0, 0, 16, 8, 6, 0, 0, 0, 31, 243, 255, 97, 0, 0, 0, 6, 98, 75, 71, 68, 0, 0, 0, 0, 0, 0, 249, 67, 187, 127, 0, 0, 0, 9, 112, 72, 89, 115, 0, 0, 14, 196, 0, 0, 14, 196, 1, 149, 43, 14, 27, 0, 0, 0, 7, 116, 73, 77, 69, 7, 228, 1, 13, 12, 55, 42, 204, 173, 146, 223, 0, 0, 2, 191, 73, 68, 65, 84, 56, 203, 117, 147, 75, 111, 27, 55, 20, 133, 15, 47, 57, 154, 135, 60, 178, 37, 57, 66, 97, 189, 90, 163, 25, 196, 72, 22, 113, 146, 110, 211, 191, 94, 100, 209, 192, 13, 220, 54, 139, 52, 242, 171, 133, 109, 196, 11, 91, 178, 28, 69, 51, 36, 103, 72, 222, 46, 218, 20, 72, 91, 159, 237, 193, 249, 112, 54, 159, 96, 102, 2, 160, 0, 36, 0, 114, 239, 125, 207, 90, 219, 109, 154, 166, 227, 189, 143, 1, 64, 74, 105, 163, 40, 90, 197, 113, 188, 148, 82, 46, 1, 172, 0, 24, 0, 78, 48, 115, 11, 64, 198, 204, 219, 90, 235, 161, 214, 122, 66, 68, 59, 66, 136, 190, 16, 34, 3, 0, 102, 174, 66, 224, 5, 115, 184, 74, 211, 244, 34, 77, 211, 15, 66, 136, 57, 128, 74, 1, 72, 152, 185, 95, 150, 229, 110, 93, 215, 123, 81, 20, 21, 243, 249, 124, 124, 51, 191, 238, 149, 85, 153, 2, 64, 59, 107, 235, 193, 131, 193, 109, 191, 191, 125, 105, 140, 233, 133, 16, 226, 118, 187, 13, 33, 196, 181, 2, 144, 107, 173, 71, 117, 93, 239, 5, 14, 79, 95, 31, 252, 88, 8, 224, 171, 135, 223, 22, 27, 155, 155, 91, 145, 84, 18, 119, 119, 203, 102, 118, 52, 91, 211, 217, 105, 255, 217, 254, 139, 172, 174, 107, 16, 145, 205, 178, 204, 168, 16, 66, 207, 24, 51, 113, 206, 21, 111, 222, 28, 20, 143, 31, 63, 121, 56, 153, 76, 123, 66, 8, 137, 191, 211, 201, 59, 24, 143, 166, 253, 243, 243, 63, 58, 7, 63, 189, 198, 139, 231, 223, 85, 198, 152, 219, 36, 73, 110, 201, 24, 211, 101, 230, 157, 147, 211, 163, 241, 163, 71, 123, 223, 76, 38, 211, 126, 8, 65, 50, 243, 231, 61, 152, 25, 33, 120, 57, 157, 126, 221, 43, 138, 98, 247, 244, 236, 100, 204, 204, 59, 198, 152, 46, 53, 77, 147, 175, 215, 235, 126, 85, 85, 189, 225, 112, 212, 115, 206, 145, 82, 10, 68, 4, 33, 4, 132, 16, 32, 34, 40, 165, 224, 156, 163, 209, 112, 212, 93, 151, 159, 250, 101, 89, 110, 55, 77, 211, 33, 239, 125, 162, 141, 206, 24, 72, 163, 40, 82, 82, 254, 243, 252, 63, 145, 82, 34, 138, 34, 5, 22, 137, 214, 58, 245, 222, 199, 4, 8, 120, 239, 225, 189, 3, 0, 16, 209, 189, 128, 191, 58, 1, 231, 29, 156, 119, 0, 4, 72, 74, 178, 68, 84, 49, 195, 48, 7, 239, 189, 191, 23, 224, 189, 71, 8, 193, 3, 108, 164, 148, 90, 74, 178, 212, 106, 181, 86, 89, 154, 46, 66, 240, 11, 99, 141, 113, 206, 241, 125, 0, 231, 28, 27, 171, 77, 8, 97, 145, 165, 217, 188, 213, 106, 173, 40, 142, 227, 101, 158, 111, 94, 37, 113, 122, 249, 219, 236, 221, 185, 148, 100, 173, 181, 220, 52, 13, 152, 25, 204, 12, 231, 28, 172, 181, 76, 146, 234, 247, 179, 119, 231, 89, 186, 113, 153, 231, 249, 85, 28, 199, 75, 34, 162, 219, 36, 137, 47, 158, 237, 63, 63, 62, 158, 157, 28, 254, 242, 246, 231, 35, 109, 170, 21, 4, 234, 16, 130, 11, 33, 56, 102, 174, 181, 169, 86, 191, 190, 61, 156, 157, 158, 156, 29, 238, 63, 221, 63, 142, 227, 248, 130, 136, 150, 130, 153, 59, 204, 60, 168, 170, 106, 183, 105, 220, 222, 171, 87, 63, 20, 166, 214, 227, 141, 188, 221, 179, 181, 77, 1, 32, 110, 197, 230, 211, 199, 245, 34, 203, 54, 46, 95, 190, 252, 254, 88, 73, 249, 62, 203, 178, 223, 133, 16, 215, 95, 202, 100, 244, 208, 53, 110, 178, 188, 91, 238, 220, 220, 220, 108, 27, 173, 51, 0, 72, 210, 180, 26, 60, 24, 44, 182, 182, 182, 62, 40, 165, 62, 203, 180, 0, 80, 138, 127, 233, 220, 241, 222, 119, 173, 181, 93, 231, 220, 23, 58, 43, 165, 254, 87, 231, 63, 1, 43, 35, 163, 127, 2, 249, 125, 174, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130}; // fixed array const
Array_fixed_byte_946 _const_ui__bytes_selected_radio_linux_png = {((byte)(137)), 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 16, 0, 0, 0, 16, 8, 6, 0, 0, 0, 31, 243, 255, 97, 0, 0, 0, 6, 98, 75, 71, 68, 0, 255, 0, 255, 0, 255, 160, 189, 167, 147, 0, 0, 0, 9, 112, 72, 89, 115, 0, 0, 14, 196, 0, 0, 14, 196, 1, 149, 43, 14, 27, 0, 0, 0, 7, 116, 73, 77, 69, 7, 228, 1, 13, 12, 52, 27, 182, 94, 193, 38, 0, 0, 3, 63, 73, 68, 65, 84, 56, 203, 109, 211, 203, 110, 27, 85, 28, 7, 224, 223, 57, 103, 46, 158, 51, 30, 199, 151, 196, 73, 236, 56, 184, 193, 49, 164, 8, 37, 64, 80, 37, 144, 202, 146, 34, 94, 128, 53, 18, 123, 118, 188, 1, 98, 195, 91, 128, 144, 216, 3, 43, 164, 168, 11, 170, 180, 2, 5, 218, 230, 214, 4, 112, 162, 70, 141, 47, 177, 227, 120, 102, 206, 92, 206, 249, 179, 98, 81, 196, 247, 14, 31, 35, 34, 14, 192, 2, 80, 0, 16, 104, 173, 171, 73, 146, 84, 178, 44, 43, 105, 173, 93, 0, 16, 66, 36, 182, 109, 79, 93, 215, 29, 11, 33, 198, 0, 166, 0, 20, 128, 156, 17, 145, 3, 64, 18, 209, 124, 28, 199, 205, 56, 142, 87, 57, 231, 13, 198, 88, 141, 49, 38, 1, 128, 136, 34, 99, 104, 68, 100, 46, 60, 207, 59, 243, 60, 239, 57, 99, 108, 8, 32, 178, 0, 20, 136, 168, 22, 134, 225, 90, 154, 166, 27, 182, 109, 119, 135, 195, 97, 107, 48, 236, 87, 195, 40, 244, 0, 192, 151, 126, 92, 95, 168, 95, 213, 106, 243, 231, 74, 169, 170, 49, 198, 245, 125, 31, 140, 177, 190, 5, 32, 136, 227, 120, 37, 77, 211, 13, 67, 102, 235, 193, 238, 47, 93, 6, 44, 173, 119, 186, 197, 185, 185, 178, 45, 44, 129, 201, 100, 156, 29, 30, 29, 206, 248, 233, 73, 237, 237, 183, 182, 101, 154, 166, 224, 156, 39, 82, 74, 101, 25, 99, 170, 74, 169, 213, 60, 207, 187, 143, 30, 237, 118, 219, 237, 91, 171, 27, 27, 183, 203, 100, 140, 67, 0, 7, 8, 190, 244, 77, 107, 229, 21, 185, 191, 255, 196, 221, 125, 248, 0, 219, 239, 188, 27, 41, 165, 174, 10, 133, 194, 149, 165, 148, 170, 16, 81, 227, 217, 201, 81, 107, 185, 209, 88, 236, 116, 214, 231, 116, 158, 21, 46, 70, 161, 56, 232, 141, 193, 0, 220, 110, 87, 197, 82, 85, 242, 245, 245, 46, 146, 52, 89, 58, 57, 125, 214, 122, 173, 251, 250, 153, 82, 170, 103, 101, 89, 22, 204, 102, 179, 90, 20, 69, 213, 78, 103, 61, 32, 210, 238, 254, 217, 149, 248, 250, 251, 199, 172, 52, 23, 128, 136, 240, 237, 207, 199, 248, 226, 147, 77, 241, 106, 179, 236, 52, 27, 205, 226, 31, 79, 126, 175, 133, 97, 56, 111, 89, 86, 137, 107, 173, 11, 177, 138, 37, 1, 158, 47, 165, 109, 11, 240, 47, 191, 249, 21, 165, 106, 5, 239, 111, 182, 240, 222, 230, 42, 252, 74, 5, 95, 125, 247, 27, 179, 5, 184, 239, 75, 27, 196, 10, 113, 28, 123, 90, 107, 151, 3, 12, 90, 107, 104, 157, 131, 49, 134, 44, 77, 209, 187, 12, 177, 92, 47, 99, 239, 239, 9, 30, 247, 38, 88, 89, 44, 227, 244, 226, 6, 121, 158, 129, 115, 142, 92, 231, 200, 117, 14, 128, 193, 18, 130, 39, 156, 243, 136, 8, 42, 207, 243, 76, 67, 155, 55, 111, 149, 68, 127, 48, 193, 90, 171, 6, 2, 112, 210, 27, 96, 107, 173, 68, 105, 150, 25, 109, 120, 6, 144, 18, 66, 196, 66, 240, 132, 59, 142, 51, 149, 158, 55, 50, 70, 143, 166, 55, 211, 25, 152, 157, 126, 118, 175, 173, 117, 116, 69, 59, 15, 79, 177, 179, 123, 2, 166, 38, 244, 233, 135, 109, 3, 102, 167, 215, 211, 235, 153, 49, 102, 36, 61, 57, 116, 28, 103, 106, 185, 174, 59, 14, 130, 185, 139, 130, 235, 157, 63, 61, 124, 90, 187, 179, 125, 199, 121, 163, 211, 46, 127, 94, 146, 206, 96, 60, 230, 0, 161, 94, 173, 152, 229, 133, 197, 84, 165, 201, 245, 193, 209, 254, 11, 233, 21, 207, 131, 32, 184, 112, 93, 119, 204, 136, 168, 25, 69, 81, 71, 41, 181, 245, 227, 79, 63, 108, 45, 45, 215, 187, 237, 118, 123, 105, 97, 126, 177, 232, 216, 142, 13, 48, 164, 105, 146, 245, 135, 151, 179, 94, 239, 175, 23, 253, 203, 225, 241, 71, 247, 62, 222, 115, 93, 119, 79, 74, 121, 202, 136, 168, 68, 68, 245, 40, 138, 214, 178, 44, 223, 184, 127, 127, 167, 171, 210, 184, 85, 12, 252, 106, 146, 38, 30, 0, 184, 142, 171, 110, 174, 103, 35, 41, 139, 231, 119, 239, 126, 112, 108, 9, 113, 32, 165, 252, 147, 49, 214, 127, 57, 147, 138, 155, 121, 150, 175, 142, 39, 227, 198, 96, 48, 152, 87, 113, 44, 1, 160, 224, 121, 81, 125, 161, 62, 42, 151, 203, 207, 45, 203, 250, 55, 211, 8, 64, 200, 254, 211, 185, 164, 181, 174, 36, 73, 82, 201, 243, 252, 165, 206, 150, 101, 253, 111, 231, 127, 0, 37, 201, 192, 194, 193, 83, 41, 228, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130}; // fixed array const
Array_fixed_byte_3558 _const_ui__bytes_darwin_circle_png = {((byte)(137)), 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 12, 0, 0, 0, 12, 8, 6, 0, 0, 0, 86, 117, 92, 231, 0, 0, 10, 171, 105, 67, 67, 80, 73, 67, 67, 32, 80, 114, 111, 102, 105, 108, 101, 0, 0, 72, 137, 149, 150, 7, 84, 147, 201, 22, 199, 231, 251, 210, 27, 45, 116, 41, 161, 55, 233, 210, 165, 215, 80, 4, 233, 96, 35, 36, 1, 66, 9, 49, 33, 40, 216, 16, 17, 87, 112, 45, 136, 136, 128, 186, 162, 75, 85, 112, 81, 1, 89, 84, 68, 17, 219, 162, 160, 216, 117, 65, 68, 64, 89, 55, 22, 68, 69, 205, 251, 128, 71, 216, 125, 239, 188, 247, 206, 251, 159, 115, 51, 191, 115, 115, 231, 206, 157, 249, 102, 206, 185, 0, 144, 239, 50, 120, 188, 84, 88, 6, 128, 52, 110, 6, 63, 212, 215, 131, 22, 29, 19, 75, 195, 189, 0, 16, 128, 129, 2, 176, 3, 202, 12, 166, 128, 231, 30, 18, 18, 8, 16, 205, 141, 127, 215, 199, 123, 72, 52, 162, 59, 166, 211, 185, 254, 253, 255, 255, 42, 89, 22, 91, 192, 4, 0, 10, 65, 56, 158, 37, 96, 166, 33, 124, 26, 177, 118, 38, 143, 159, 1, 0, 138, 135, 248, 117, 214, 100, 240, 166, 185, 24, 97, 121, 62, 82, 32, 194, 53, 211, 156, 56, 203, 237, 211, 28, 63, 203, 183, 103, 98, 194, 67, 61, 17, 126, 1, 0, 158, 204, 96, 240, 19, 1, 32, 137, 16, 63, 45, 147, 153, 136, 228, 33, 35, 187, 5, 22, 92, 22, 135, 139, 176, 27, 194, 46, 204, 36, 6, 11, 225, 28, 132, 23, 166, 165, 165, 79, 243, 113, 132, 13, 227, 255, 146, 39, 241, 111, 57, 227, 37, 57, 25, 140, 68, 9, 207, 238, 101, 70, 120, 47, 142, 128, 151, 202, 200, 250, 63, 143, 227, 127, 43, 45, 85, 56, 183, 134, 14, 98, 228, 36, 190, 95, 232, 244, 122, 211, 231, 150, 146, 30, 32, 97, 110, 252, 146, 224, 57, 230, 176, 102, 107, 154, 230, 36, 161, 95, 196, 28, 51, 5, 158, 177, 115, 204, 98, 120, 5, 72, 230, 166, 46, 9, 156, 227, 4, 142, 15, 93, 146, 39, 131, 30, 62, 199, 252, 244, 80, 73, 126, 182, 192, 59, 108, 142, 25, 252, 249, 181, 132, 41, 17, 238, 146, 117, 217, 116, 73, 206, 236, 164, 240, 168, 57, 206, 228, 68, 46, 153, 99, 65, 74, 88, 192, 124, 140, 167, 196, 207, 23, 134, 74, 106, 78, 224, 251, 72, 246, 152, 38, 248, 203, 190, 56, 116, 73, 124, 70, 82, 184, 159, 100, 143, 140, 249, 218, 216, 130, 104, 73, 13, 44, 182, 151, 183, 196, 207, 141, 144, 196, 240, 50, 60, 36, 249, 121, 169, 33, 146, 120, 118, 170, 175, 196, 47, 200, 12, 147, 204, 205, 64, 46, 219, 252, 220, 16, 201, 249, 36, 51, 252, 67, 230, 24, 112, 64, 16, 96, 0, 102, 6, 123, 109, 198, 116, 193, 158, 233, 188, 44, 62, 39, 49, 41, 131, 230, 142, 188, 24, 54, 141, 206, 101, 154, 45, 164, 89, 89, 88, 89, 0, 48, 253, 254, 102, 63, 175, 232, 214, 204, 187, 130, 84, 100, 231, 125, 249, 200, 93, 115, 17, 137, 197, 226, 230, 121, 159, 95, 23, 0, 77, 78, 0, 16, 203, 230, 125, 6, 117, 0, 72, 245, 3, 112, 245, 41, 83, 200, 207, 156, 245, 161, 167, 127, 48, 128, 8, 164, 129, 60, 80, 1, 26, 200, 253, 49, 4, 166, 192, 10, 216, 2, 39, 224, 6, 188, 129, 63, 8, 6, 225, 32, 6, 172, 4, 76, 144, 4, 210, 0, 31, 172, 1, 235, 193, 102, 144, 15, 10, 193, 110, 176, 15, 148, 129, 195, 224, 40, 168, 1, 39, 64, 19, 104, 1, 237, 224, 34, 184, 2, 110, 128, 219, 160, 31, 60, 6, 3, 96, 24, 188, 6, 34, 240, 17, 76, 65, 16, 132, 131, 40, 16, 21, 82, 129, 52, 33, 61, 200, 4, 178, 130, 236, 33, 23, 200, 27, 10, 132, 66, 161, 24, 40, 14, 74, 132, 184, 144, 16, 90, 15, 109, 129, 10, 161, 34, 168, 12, 58, 2, 213, 66, 191, 64, 103, 161, 139, 208, 53, 168, 23, 122, 8, 13, 66, 99, 208, 59, 232, 11, 140, 130, 201, 176, 60, 172, 14, 235, 195, 230, 176, 61, 236, 14, 7, 192, 225, 240, 10, 56, 17, 94, 13, 103, 195, 121, 240, 78, 184, 20, 174, 132, 143, 195, 205, 240, 69, 248, 6, 220, 15, 15, 192, 175, 225, 9, 20, 64, 145, 80, 138, 40, 45, 148, 41, 202, 30, 229, 137, 10, 70, 197, 162, 18, 80, 124, 212, 70, 84, 1, 170, 4, 85, 137, 106, 64, 181, 161, 186, 81, 119, 80, 3, 168, 113, 212, 103, 52, 22, 77, 69, 211, 208, 166, 104, 39, 180, 31, 58, 2, 205, 68, 175, 70, 111, 68, 239, 64, 151, 161, 107, 208, 205, 232, 203, 232, 59, 232, 65, 180, 8, 253, 29, 67, 193, 168, 97, 76, 48, 142, 24, 58, 38, 26, 147, 136, 89, 131, 201, 199, 148, 96, 170, 48, 103, 48, 93, 152, 126, 204, 48, 230, 35, 22, 139, 85, 196, 26, 96, 237, 176, 126, 216, 24, 108, 50, 118, 29, 118, 7, 246, 32, 182, 17, 219, 129, 237, 197, 14, 97, 39, 112, 56, 156, 10, 206, 4, 231, 140, 11, 198, 49, 112, 25, 184, 124, 220, 1, 220, 113, 220, 5, 92, 31, 110, 24, 247, 9, 79, 194, 107, 226, 173, 240, 62, 248, 88, 60, 23, 159, 139, 47, 193, 215, 225, 207, 227, 251, 240, 35, 248, 41, 130, 12, 65, 143, 224, 72, 8, 38, 176, 8, 89, 132, 93, 132, 99, 132, 54, 194, 45, 194, 48, 97, 138, 40, 75, 52, 32, 58, 19, 195, 137, 201, 196, 205, 196, 82, 98, 3, 177, 139, 248, 132, 248, 158, 68, 34, 105, 147, 28, 72, 75, 73, 28, 82, 14, 169, 148, 116, 146, 116, 149, 52, 72, 250, 76, 150, 35, 27, 147, 61, 201, 203, 201, 66, 242, 78, 114, 53, 185, 131, 252, 144, 252, 158, 66, 161, 232, 83, 220, 40, 177, 148, 12, 202, 78, 74, 45, 229, 18, 229, 25, 229, 147, 20, 85, 202, 76, 138, 46, 197, 146, 218, 36, 85, 46, 213, 44, 213, 39, 245, 70, 154, 32, 173, 39, 237, 46, 189, 82, 58, 91, 186, 68, 250, 148, 244, 45, 233, 113, 25, 130, 140, 190, 140, 167, 12, 67, 102, 163, 76, 185, 204, 89, 153, 251, 50, 19, 178, 84, 89, 75, 217, 96, 217, 52, 217, 29, 178, 117, 178, 215, 100, 71, 229, 112, 114, 250, 114, 222, 114, 44, 185, 60, 185, 163, 114, 151, 228, 134, 168, 40, 170, 14, 213, 147, 202, 164, 110, 161, 30, 163, 118, 81, 135, 229, 177, 242, 6, 242, 116, 249, 100, 249, 66, 249, 19, 242, 61, 242, 34, 5, 57, 133, 69, 10, 145, 10, 107, 21, 202, 21, 206, 41, 12, 40, 162, 20, 245, 21, 233, 138, 169, 138, 187, 20, 155, 20, 239, 41, 126, 81, 82, 87, 114, 87, 98, 43, 109, 87, 106, 80, 234, 83, 154, 84, 94, 160, 236, 166, 204, 86, 46, 80, 110, 84, 238, 87, 254, 162, 66, 83, 241, 86, 73, 81, 217, 163, 210, 162, 242, 84, 21, 173, 106, 172, 186, 84, 117, 141, 234, 33, 213, 46, 213, 241, 5, 242, 11, 156, 22, 48, 23, 20, 44, 104, 90, 240, 72, 13, 86, 51, 86, 11, 85, 91, 167, 118, 84, 237, 166, 218, 132, 186, 134, 186, 175, 58, 79, 253, 128, 250, 37, 245, 113, 13, 69, 13, 55, 141, 100, 141, 98, 141, 243, 26, 99, 154, 84, 77, 23, 77, 142, 102, 177, 230, 5, 205, 87, 52, 5, 154, 59, 45, 149, 86, 74, 187, 76, 19, 105, 169, 105, 249, 105, 9, 181, 142, 104, 245, 104, 77, 105, 27, 104, 71, 104, 231, 106, 55, 106, 63, 213, 33, 234, 216, 235, 36, 232, 20, 235, 116, 234, 136, 116, 53, 117, 131, 116, 215, 235, 214, 235, 62, 210, 35, 232, 217, 235, 37, 233, 237, 215, 235, 214, 155, 212, 55, 208, 143, 210, 223, 166, 223, 162, 63, 106, 160, 108, 64, 55, 200, 54, 168, 55, 120, 98, 72, 49, 116, 53, 92, 109, 88, 105, 120, 215, 8, 107, 100, 111, 148, 98, 116, 208, 232, 182, 49, 108, 108, 99, 156, 100, 92, 110, 124, 203, 4, 54, 177, 53, 225, 152, 28, 52, 233, 93, 136, 89, 232, 176, 144, 187, 176, 114, 225, 125, 83, 178, 169, 187, 105, 166, 105, 189, 233, 160, 153, 162, 89, 160, 89, 174, 89, 139, 217, 27, 115, 93, 243, 88, 243, 61, 230, 221, 230, 223, 45, 108, 44, 82, 45, 142, 89, 60, 182, 148, 179, 244, 183, 204, 181, 108, 179, 124, 103, 101, 108, 197, 180, 42, 183, 186, 107, 77, 177, 246, 177, 222, 100, 221, 106, 253, 118, 145, 201, 34, 246, 162, 67, 139, 30, 216, 80, 109, 130, 108, 182, 217, 116, 218, 124, 179, 181, 179, 229, 219, 54, 216, 142, 217, 233, 218, 197, 217, 85, 216, 221, 183, 151, 183, 15, 177, 223, 97, 127, 213, 1, 227, 224, 225, 176, 201, 161, 221, 225, 179, 163, 173, 99, 134, 99, 147, 227, 159, 78, 166, 78, 41, 78, 117, 78, 163, 139, 13, 22, 179, 23, 31, 91, 60, 228, 172, 237, 204, 112, 62, 226, 60, 224, 66, 115, 137, 115, 249, 201, 101, 192, 85, 203, 149, 225, 90, 233, 250, 220, 77, 199, 141, 229, 86, 229, 54, 226, 110, 228, 158, 236, 126, 220, 253, 141, 135, 133, 7, 223, 227, 140, 199, 164, 167, 163, 231, 6, 207, 14, 47, 148, 151, 175, 87, 129, 87, 143, 183, 156, 119, 132, 119, 153, 247, 51, 31, 109, 159, 68, 159, 122, 31, 145, 175, 141, 239, 58, 223, 14, 63, 140, 95, 128, 223, 30, 191, 251, 116, 117, 58, 147, 94, 75, 23, 249, 219, 249, 111, 240, 191, 28, 64, 14, 8, 11, 40, 11, 120, 30, 104, 28, 200, 15, 108, 11, 130, 131, 252, 131, 246, 6, 61, 89, 162, 183, 132, 187, 164, 37, 24, 4, 211, 131, 247, 6, 63, 13, 49, 8, 89, 29, 242, 235, 82, 236, 210, 144, 165, 229, 75, 95, 134, 90, 134, 174, 15, 237, 14, 163, 134, 173, 10, 171, 11, 251, 24, 238, 17, 190, 43, 252, 113, 132, 97, 132, 48, 162, 51, 82, 58, 114, 121, 100, 109, 228, 100, 148, 87, 84, 81, 212, 64, 180, 121, 244, 134, 232, 27, 49, 170, 49, 156, 152, 214, 88, 92, 108, 100, 108, 85, 236, 196, 50, 239, 101, 251, 150, 13, 47, 183, 89, 158, 191, 252, 222, 10, 131, 21, 107, 87, 92, 91, 169, 186, 50, 117, 229, 185, 85, 210, 171, 24, 171, 78, 197, 97, 226, 162, 226, 234, 226, 190, 50, 130, 25, 149, 140, 137, 120, 122, 124, 69, 188, 136, 233, 201, 220, 207, 124, 205, 114, 99, 21, 179, 198, 216, 206, 236, 34, 246, 72, 130, 115, 66, 81, 194, 104, 162, 115, 226, 222, 196, 177, 36, 215, 164, 146, 164, 113, 142, 39, 167, 140, 243, 54, 217, 47, 249, 112, 242, 100, 74, 112, 74, 117, 138, 56, 53, 42, 181, 49, 13, 159, 22, 151, 118, 150, 43, 199, 77, 225, 94, 78, 215, 72, 95, 155, 222, 203, 51, 225, 229, 243, 6, 86, 59, 174, 222, 183, 90, 196, 15, 224, 87, 9, 32, 193, 10, 65, 107, 134, 60, 210, 232, 220, 20, 26, 10, 183, 10, 7, 51, 93, 50, 203, 51, 63, 173, 137, 92, 115, 106, 173, 236, 90, 238, 218, 155, 89, 198, 89, 219, 179, 70, 178, 125, 178, 127, 94, 135, 94, 199, 92, 215, 185, 94, 107, 253, 230, 245, 131, 27, 220, 55, 28, 217, 8, 109, 140, 223, 216, 185, 73, 103, 83, 222, 166, 225, 28, 223, 156, 154, 205, 196, 205, 41, 155, 127, 203, 181, 200, 45, 202, 253, 176, 37, 106, 75, 91, 158, 122, 94, 78, 222, 208, 86, 223, 173, 245, 249, 82, 249, 252, 252, 251, 219, 156, 182, 29, 254, 1, 253, 3, 231, 135, 158, 237, 214, 219, 15, 108, 255, 94, 192, 42, 184, 94, 104, 81, 88, 82, 248, 117, 7, 115, 199, 245, 31, 45, 127, 44, 253, 81, 188, 51, 97, 103, 207, 46, 219, 93, 135, 118, 99, 119, 115, 119, 223, 219, 227, 186, 167, 166, 72, 182, 40, 187, 104, 104, 111, 208, 222, 230, 98, 90, 113, 65, 241, 135, 125, 171, 246, 93, 43, 89, 84, 114, 120, 63, 113, 191, 112, 255, 64, 105, 96, 105, 235, 1, 221, 3, 187, 15, 124, 45, 75, 42, 235, 47, 247, 40, 111, 172, 80, 171, 216, 94, 49, 121, 144, 117, 176, 239, 144, 219, 161, 134, 195, 234, 135, 11, 15, 127, 249, 137, 243, 211, 131, 35, 190, 71, 154, 43, 245, 43, 75, 142, 98, 143, 102, 30, 125, 121, 44, 242, 88, 247, 207, 246, 63, 215, 86, 169, 86, 21, 86, 125, 171, 230, 86, 15, 212, 132, 214, 92, 174, 181, 171, 173, 173, 83, 171, 219, 85, 15, 215, 11, 235, 199, 142, 47, 63, 126, 251, 132, 215, 137, 214, 6, 211, 134, 35, 141, 138, 141, 133, 39, 193, 73, 225, 201, 87, 191, 196, 253, 114, 175, 41, 160, 169, 243, 148, 253, 169, 134, 211, 122, 167, 43, 206, 80, 207, 20, 52, 67, 205, 89, 205, 162, 150, 164, 150, 129, 214, 152, 214, 222, 179, 254, 103, 59, 219, 156, 218, 206, 252, 106, 246, 107, 117, 187, 86, 123, 249, 57, 133, 115, 187, 206, 19, 207, 231, 157, 23, 95, 200, 190, 48, 209, 193, 235, 24, 191, 152, 120, 113, 168, 115, 85, 231, 227, 75, 209, 151, 238, 94, 94, 122, 185, 167, 43, 160, 235, 234, 21, 159, 43, 151, 186, 221, 187, 47, 92, 117, 190, 218, 126, 205, 241, 218, 217, 235, 246, 215, 91, 110, 216, 222, 104, 190, 105, 115, 243, 204, 111, 54, 191, 157, 233, 177, 237, 105, 190, 101, 119, 171, 245, 182, 195, 237, 182, 222, 197, 189, 231, 251, 92, 251, 46, 222, 241, 186, 115, 229, 46, 253, 238, 141, 254, 37, 253, 189, 247, 34, 238, 61, 184, 191, 252, 254, 192, 3, 214, 131, 209, 135, 169, 15, 223, 62, 202, 124, 52, 245, 56, 231, 9, 230, 73, 193, 83, 153, 167, 37, 207, 212, 158, 85, 254, 110, 244, 123, 227, 128, 237, 192, 185, 65, 175, 193, 155, 207, 195, 158, 63, 30, 98, 14, 189, 126, 33, 120, 241, 117, 56, 239, 37, 229, 101, 201, 136, 230, 72, 237, 168, 213, 104, 251, 152, 207, 216, 237, 87, 203, 94, 13, 191, 230, 189, 158, 26, 207, 255, 67, 246, 143, 138, 55, 134, 111, 78, 255, 233, 246, 231, 77, 81, 180, 104, 248, 45, 255, 173, 248, 221, 142, 247, 42, 239, 171, 63, 44, 250, 208, 57, 17, 50, 241, 236, 99, 218, 199, 169, 201, 130, 79, 42, 159, 106, 62, 219, 127, 238, 254, 18, 245, 101, 100, 106, 205, 87, 220, 215, 210, 111, 70, 223, 218, 190, 7, 124, 127, 34, 78, 19, 139, 121, 12, 62, 99, 166, 21, 64, 33, 6, 39, 36, 0, 240, 174, 26, 0, 74, 12, 0, 84, 164, 111, 38, 46, 155, 237, 143, 103, 4, 205, 246, 244, 51, 4, 254, 19, 207, 246, 208, 51, 178, 5, 160, 1, 25, 166, 91, 161, 233, 150, 239, 84, 14, 0, 250, 110, 72, 238, 14, 0, 130, 145, 49, 220, 13, 192, 214, 214, 18, 251, 167, 4, 9, 214, 86, 179, 185, 164, 234, 1, 192, 105, 137, 197, 239, 210, 1, 32, 32, 246, 213, 87, 44, 158, 10, 17, 139, 191, 85, 32, 197, 222, 5, 224, 252, 232, 108, 95, 62, 45, 44, 210, 191, 55, 80, 47, 10, 170, 98, 251, 190, 231, 228, 128, 127, 209, 63, 0, 74, 247, 10, 138, 245, 28, 149, 144, 0, 0, 2, 11, 105, 84, 88, 116, 88, 77, 76, 58, 99, 111, 109, 46, 97, 100, 111, 98, 101, 46, 120, 109, 112, 0, 0, 0, 0, 0, 60, 120, 58, 120, 109, 112, 109, 101, 116, 97, 32, 120, 109, 108, 110, 115, 58, 120, 61, 34, 97, 100, 111, 98, 101, 58, 110, 115, 58, 109, 101, 116, 97, 47, 34, 32, 120, 58, 120, 109, 112, 116, 107, 61, 34, 88, 77, 80, 32, 67, 111, 114, 101, 32, 53, 46, 52, 46, 48, 34, 62, 10, 32, 32, 32, 60, 114, 100, 102, 58, 82, 68, 70, 32, 120, 109, 108, 110, 115, 58, 114, 100, 102, 61, 34, 104, 116, 116, 112, 58, 47, 47, 119, 119, 119, 46, 119, 51, 46, 111, 114, 103, 47, 49, 57, 57, 57, 47, 48, 50, 47, 50, 50, 45, 114, 100, 102, 45, 115, 121, 110, 116, 97, 120, 45, 110, 115, 35, 34, 62, 10, 32, 32, 32, 32, 32, 32, 60, 114, 100, 102, 58, 68, 101, 115, 99, 114, 105, 112, 116, 105, 111, 110, 32, 114, 100, 102, 58, 97, 98, 111, 117, 116, 61, 34, 34, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 120, 109, 108, 110, 115, 58, 116, 105, 102, 102, 61, 34, 104, 116, 116, 112, 58, 47, 47, 110, 115, 46, 97, 100, 111, 98, 101, 46, 99, 111, 109, 47, 116, 105, 102, 102, 47, 49, 46, 48, 47, 34, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 60, 116, 105, 102, 102, 58, 82, 101, 115, 111, 108, 117, 116, 105, 111, 110, 85, 110, 105, 116, 62, 50, 60, 47, 116, 105, 102, 102, 58, 82, 101, 115, 111, 108, 117, 116, 105, 111, 110, 85, 110, 105, 116, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 60, 116, 105, 102, 102, 58, 67, 111, 109, 112, 114, 101, 115, 115, 105, 111, 110, 62, 49, 60, 47, 116, 105, 102, 102, 58, 67, 111, 109, 112, 114, 101, 115, 115, 105, 111, 110, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 60, 116, 105, 102, 102, 58, 79, 114, 105, 101, 110, 116, 97, 116, 105, 111, 110, 62, 49, 60, 47, 116, 105, 102, 102, 58, 79, 114, 105, 101, 110, 116, 97, 116, 105, 111, 110, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 60, 116, 105, 102, 102, 58, 80, 104, 111, 116, 111, 109, 101, 116, 114, 105, 99, 73, 110, 116, 101, 114, 112, 114, 101, 116, 97, 116, 105, 111, 110, 62, 50, 60, 47, 116, 105, 102, 102, 58, 80, 104, 111, 116, 111, 109, 101, 116, 114, 105, 99, 73, 110, 116, 101, 114, 112, 114, 101, 116, 97, 116, 105, 111, 110, 62, 10, 32, 32, 32, 32, 32, 32, 60, 47, 114, 100, 102, 58, 68, 101, 115, 99, 114, 105, 112, 116, 105, 111, 110, 62, 10, 32, 32, 32, 60, 47, 114, 100, 102, 58, 82, 68, 70, 62, 10, 60, 47, 120, 58, 120, 109, 112, 109, 101, 116, 97, 62, 10, 15, 69, 42, 147, 0, 0, 0, 223, 73, 68, 65, 84, 40, 21, 133, 82, 59, 10, 133, 64, 12, 28, 227, 231, 8, 130, 133, 133, 104, 43, 54, 122, 32, 175, 32, 120, 7, 45, 188, 133, 199, 177, 210, 78, 208, 198, 66, 240, 12, 130, 207, 236, 123, 89, 120, 162, 152, 38, 217, 201, 36, 217, 236, 172, 113, 156, 134, 159, 237, 251, 142, 174, 235, 48, 142, 163, 66, 162, 40, 66, 154, 166, 112, 28, 71, 40, 176, 36, 234, 251, 30, 85, 85, 97, 93, 87, 129, 148, 119, 93, 23, 101, 89, 170, 66, 6, 12, 158, 48, 12, 3, 138, 162, 0, 79, 184, 51, 34, 66, 93, 215, 170, 200, 56, 73, 71, 158, 231, 88, 150, 229, 142, 171, 49, 158, 212, 182, 45, 136, 175, 242, 70, 230, 170, 109, 219, 212, 126, 52, 207, 179, 238, 242, 22, 76, 211, 4, 122, 35, 93, 243, 20, 4, 193, 21, 123, 60, 135, 97, 8, 74, 146, 4, 190, 239, 63, 146, 36, 193, 75, 179, 38, 100, 154, 166, 122, 103, 203, 210, 146, 8, 71, 123, 126, 86, 214, 194, 182, 237, 239, 14, 113, 28, 163, 105, 26, 120, 158, 167, 73, 18, 112, 103, 22, 148, 187, 179, 41, 225, 36, 121, 253, 26, 124, 231, 44, 203, 254, 190, 198, 7, 214, 237, 83, 207, 108, 11, 4, 150, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130}; // fixed array const
Array_fixed_byte_4411 _const_ui__bytes_selected_radio_png = {((byte)(137)), 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 32, 0, 0, 0, 32, 8, 6, 0, 0, 0, 115, 122, 122, 244, 0, 0, 10, 171, 105, 67, 67, 80, 73, 67, 67, 32, 80, 114, 111, 102, 105, 108, 101, 0, 0, 72, 137, 149, 150, 7, 84, 147, 201, 22, 199, 231, 251, 210, 27, 45, 116, 41, 161, 55, 233, 210, 165, 215, 80, 4, 233, 96, 35, 36, 1, 66, 9, 49, 33, 40, 216, 16, 17, 87, 112, 45, 136, 136, 128, 186, 162, 75, 85, 112, 81, 1, 89, 84, 68, 17, 219, 162, 160, 216, 117, 65, 68, 64, 89, 55, 22, 68, 69, 205, 251, 128, 71, 216, 125, 239, 188, 247, 206, 251, 159, 115, 51, 191, 115, 115, 231, 206, 157, 249, 102, 206, 185, 0, 144, 239, 50, 120, 188, 84, 88, 6, 128, 52, 110, 6, 63, 212, 215, 131, 22, 29, 19, 75, 195, 189, 0, 16, 128, 129, 2, 176, 3, 202, 12, 166, 128, 231, 30, 18, 18, 8, 16, 205, 141, 127, 215, 199, 123, 72, 52, 162, 59, 166, 211, 185, 254, 253, 255, 255, 42, 89, 22, 91, 192, 4, 0, 10, 65, 56, 158, 37, 96, 166, 33, 124, 26, 177, 118, 38, 143, 159, 1, 0, 138, 135, 248, 117, 214, 100, 240, 166, 185, 24, 97, 121, 62, 82, 32, 194, 53, 211, 156, 56, 203, 237, 211, 28, 63, 203, 183, 103, 98, 194, 67, 61, 17, 126, 1, 0, 158, 204, 96, 240, 19, 1, 32, 137, 16, 63, 45, 147, 153, 136, 228, 33, 35, 187, 5, 22, 92, 22, 135, 139, 176, 27, 194, 46, 204, 36, 6, 11, 225, 28, 132, 23, 166, 165, 165, 79, 243, 113, 132, 13, 227, 255, 146, 39, 241, 111, 57, 227, 37, 57, 25, 140, 68, 9, 207, 238, 101, 70, 120, 47, 142, 128, 151, 202, 200, 250, 63, 143, 227, 127, 43, 45, 85, 56, 183, 134, 14, 98, 228, 36, 190, 95, 232, 244, 122, 211, 231, 150, 146, 30, 32, 97, 110, 252, 146, 224, 57, 230, 176, 102, 107, 154, 230, 36, 161, 95, 196, 28, 51, 5, 158, 177, 115, 204, 98, 120, 5, 72, 230, 166, 46, 9, 156, 227, 4, 142, 15, 93, 146, 39, 131, 30, 62, 199, 252, 244, 80, 73, 126, 182, 192, 59, 108, 142, 25, 252, 249, 181, 132, 41, 17, 238, 146, 117, 217, 116, 73, 206, 236, 164, 240, 168, 57, 206, 228, 68, 46, 153, 99, 65, 74, 88, 192, 124, 140, 167, 196, 207, 23, 134, 74, 106, 78, 224, 251, 72, 246, 152, 38, 248, 203, 190, 56, 116, 73, 124, 70, 82, 184, 159, 100, 143, 140, 249, 218, 216, 130, 104, 73, 13, 44, 182, 151, 183, 196, 207, 141, 144, 196, 240, 50, 60, 36, 249, 121, 169, 33, 146, 120, 118, 170, 175, 196, 47, 200, 12, 147, 204, 205, 64, 46, 219, 252, 220, 16, 201, 249, 36, 51, 252, 67, 230, 24, 112, 64, 16, 96, 0, 102, 6, 123, 109, 198, 116, 193, 158, 233, 188, 44, 62, 39, 49, 41, 131, 230, 142, 188, 24, 54, 141, 206, 101, 154, 45, 164, 89, 89, 88, 89, 0, 48, 253, 254, 102, 63, 175, 232, 214, 204, 187, 130, 84, 100, 231, 125, 249, 200, 93, 115, 17, 137, 197, 226, 230, 121, 159, 95, 23, 0, 77, 78, 0, 16, 203, 230, 125, 6, 117, 0, 72, 245, 3, 112, 245, 41, 83, 200, 207, 156, 245, 161, 167, 127, 48, 128, 8, 164, 129, 60, 80, 1, 26, 200, 253, 49, 4, 166, 192, 10, 216, 2, 39, 224, 6, 188, 129, 63, 8, 6, 225, 32, 6, 172, 4, 76, 144, 4, 210, 0, 31, 172, 1, 235, 193, 102, 144, 15, 10, 193, 110, 176, 15, 148, 129, 195, 224, 40, 168, 1, 39, 64, 19, 104, 1, 237, 224, 34, 184, 2, 110, 128, 219, 160, 31, 60, 6, 3, 96, 24, 188, 6, 34, 240, 17, 76, 65, 16, 132, 131, 40, 16, 21, 82, 129, 52, 33, 61, 200, 4, 178, 130, 236, 33, 23, 200, 27, 10, 132, 66, 161, 24, 40, 14, 74, 132, 184, 144, 16, 90, 15, 109, 129, 10, 161, 34, 168, 12, 58, 2, 213, 66, 191, 64, 103, 161, 139, 208, 53, 168, 23, 122, 8, 13, 66, 99, 208, 59, 232, 11, 140, 130, 201, 176, 60, 172, 14, 235, 195, 230, 176, 61, 236, 14, 7, 192, 225, 240, 10, 56, 17, 94, 13, 103, 195, 121, 240, 78, 184, 20, 174, 132, 143, 195, 205, 240, 69, 248, 6, 220, 15, 15, 192, 175, 225, 9, 20, 64, 145, 80, 138, 40, 45, 148, 41, 202, 30, 229, 137, 10, 70, 197, 162, 18, 80, 124, 212, 70, 84, 1, 170, 4, 85, 137, 106, 64, 181, 161, 186, 81, 119, 80, 3, 168, 113, 212, 103, 52, 22, 77, 69, 211, 208, 166, 104, 39, 180, 31, 58, 2, 205, 68, 175, 70, 111, 68, 239, 64, 151, 161, 107, 208, 205, 232, 203, 232, 59, 232, 65, 180, 8, 253, 29, 67, 193, 168, 97, 76, 48, 142, 24, 58, 38, 26, 147, 136, 89, 131, 201, 199, 148, 96, 170, 48, 103, 48, 93, 152, 126, 204, 48, 230, 35, 22, 139, 85, 196, 26, 96, 237, 176, 126, 216, 24, 108, 50, 118, 29, 118, 7, 246, 32, 182, 17, 219, 129, 237, 197, 14, 97, 39, 112, 56, 156, 10, 206, 4, 231, 140, 11, 198, 49, 112, 25, 184, 124, 220, 1, 220, 113, 220, 5, 92, 31, 110, 24, 247, 9, 79, 194, 107, 226, 173, 240, 62, 248, 88, 60, 23, 159, 139, 47, 193, 215, 225, 207, 227, 251, 240, 35, 248, 41, 130, 12, 65, 143, 224, 72, 8, 38, 176, 8, 89, 132, 93, 132, 99, 132, 54, 194, 45, 194, 48, 97, 138, 40, 75, 52, 32, 58, 19, 195, 137, 201, 196, 205, 196, 82, 98, 3, 177, 139, 248, 132, 248, 158, 68, 34, 105, 147, 28, 72, 75, 73, 28, 82, 14, 169, 148, 116, 146, 116, 149, 52, 72, 250, 76, 150, 35, 27, 147, 61, 201, 203, 201, 66, 242, 78, 114, 53, 185, 131, 252, 144, 252, 158, 66, 161, 232, 83, 220, 40, 177, 148, 12, 202, 78, 74, 45, 229, 18, 229, 25, 229, 147, 20, 85, 202, 76, 138, 46, 197, 146, 218, 36, 85, 46, 213, 44, 213, 39, 245, 70, 154, 32, 173, 39, 237, 46, 189, 82, 58, 91, 186, 68, 250, 148, 244, 45, 233, 113, 25, 130, 140, 190, 140, 167, 12, 67, 102, 163, 76, 185, 204, 89, 153, 251, 50, 19, 178, 84, 89, 75, 217, 96, 217, 52, 217, 29, 178, 117, 178, 215, 100, 71, 229, 112, 114, 250, 114, 222, 114, 44, 185, 60, 185, 163, 114, 151, 228, 134, 168, 40, 170, 14, 213, 147, 202, 164, 110, 161, 30, 163, 118, 81, 135, 229, 177, 242, 6, 242, 116, 249, 100, 249, 66, 249, 19, 242, 61, 242, 34, 5, 57, 133, 69, 10, 145, 10, 107, 21, 202, 21, 206, 41, 12, 40, 162, 20, 245, 21, 233, 138, 169, 138, 187, 20, 155, 20, 239, 41, 126, 81, 82, 87, 114, 87, 98, 43, 109, 87, 106, 80, 234, 83, 154, 84, 94, 160, 236, 166, 204, 86, 46, 80, 110, 84, 238, 87, 254, 162, 66, 83, 241, 86, 73, 81, 217, 163, 210, 162, 242, 84, 21, 173, 106, 172, 186, 84, 117, 141, 234, 33, 213, 46, 213, 241, 5, 242, 11, 156, 22, 48, 23, 20, 44, 104, 90, 240, 72, 13, 86, 51, 86, 11, 85, 91, 167, 118, 84, 237, 166, 218, 132, 186, 134, 186, 175, 58, 79, 253, 128, 250, 37, 245, 113, 13, 69, 13, 55, 141, 100, 141, 98, 141, 243, 26, 99, 154, 84, 77, 23, 77, 142, 102, 177, 230, 5, 205, 87, 52, 5, 154, 59, 45, 149, 86, 74, 187, 76, 19, 105, 169, 105, 249, 105, 9, 181, 142, 104, 245, 104, 77, 105, 27, 104, 71, 104, 231, 106, 55, 106, 63, 213, 33, 234, 216, 235, 36, 232, 20, 235, 116, 234, 136, 116, 53, 117, 131, 116, 215, 235, 214, 235, 62, 210, 35, 232, 217, 235, 37, 233, 237, 215, 235, 214, 155, 212, 55, 208, 143, 210, 223, 166, 223, 162, 63, 106, 160, 108, 64, 55, 200, 54, 168, 55, 120, 98, 72, 49, 116, 53, 92, 109, 88, 105, 120, 215, 8, 107, 100, 111, 148, 98, 116, 208, 232, 182, 49, 108, 108, 99, 156, 100, 92, 110, 124, 203, 4, 54, 177, 53, 225, 152, 28, 52, 233, 93, 136, 89, 232, 176, 144, 187, 176, 114, 225, 125, 83, 178, 169, 187, 105, 166, 105, 189, 233, 160, 153, 162, 89, 160, 89, 174, 89, 139, 217, 27, 115, 93, 243, 88, 243, 61, 230, 221, 230, 223, 45, 108, 44, 82, 45, 142, 89, 60, 182, 148, 179, 244, 183, 204, 181, 108, 179, 124, 103, 101, 108, 197, 180, 42, 183, 186, 107, 77, 177, 246, 177, 222, 100, 221, 106, 253, 118, 145, 201, 34, 246, 162, 67, 139, 30, 216, 80, 109, 130, 108, 182, 217, 116, 218, 124, 179, 181, 179, 229, 219, 54, 216, 142, 217, 233, 218, 197, 217, 85, 216, 221, 183, 151, 183, 15, 177, 223, 97, 127, 213, 1, 227, 224, 225, 176, 201, 161, 221, 225, 179, 163, 173, 99, 134, 99, 147, 227, 159, 78, 166, 78, 41, 78, 117, 78, 163, 139, 13, 22, 179, 23, 31, 91, 60, 228, 172, 237, 204, 112, 62, 226, 60, 224, 66, 115, 137, 115, 249, 201, 101, 192, 85, 203, 149, 225, 90, 233, 250, 220, 77, 199, 141, 229, 86, 229, 54, 226, 110, 228, 158, 236, 126, 220, 253, 141, 135, 133, 7, 223, 227, 140, 199, 164, 167, 163, 231, 6, 207, 14, 47, 148, 151, 175, 87, 129, 87, 143, 183, 156, 119, 132, 119, 153, 247, 51, 31, 109, 159, 68, 159, 122, 31, 145, 175, 141, 239, 58, 223, 14, 63, 140, 95, 128, 223, 30, 191, 251, 116, 117, 58, 147, 94, 75, 23, 249, 219, 249, 111, 240, 191, 28, 64, 14, 8, 11, 40, 11, 120, 30, 104, 28, 200, 15, 108, 11, 130, 131, 252, 131, 246, 6, 61, 89, 162, 183, 132, 187, 164, 37, 24, 4, 211, 131, 247, 6, 63, 13, 49, 8, 89, 29, 242, 235, 82, 236, 210, 144, 165, 229, 75, 95, 134, 90, 134, 174, 15, 237, 14, 163, 134, 173, 10, 171, 11, 251, 24, 238, 17, 190, 43, 252, 113, 132, 97, 132, 48, 162, 51, 82, 58, 114, 121, 100, 109, 228, 100, 148, 87, 84, 81, 212, 64, 180, 121, 244, 134, 232, 27, 49, 170, 49, 156, 152, 214, 88, 92, 108, 100, 108, 85, 236, 196, 50, 239, 101, 251, 150, 13, 47, 183, 89, 158, 191, 252, 222, 10, 131, 21, 107, 87, 92, 91, 169, 186, 50, 117, 229, 185, 85, 210, 171, 24, 171, 78, 197, 97, 226, 162, 226, 234, 226, 190, 50, 130, 25, 149, 140, 137, 120, 122, 124, 69, 188, 136, 233, 201, 220, 207, 124, 205, 114, 99, 21, 179, 198, 216, 206, 236, 34, 246, 72, 130, 115, 66, 81, 194, 104, 162, 115, 226, 222, 196, 177, 36, 215, 164, 146, 164, 113, 142, 39, 167, 140, 243, 54, 217, 47, 249, 112, 242, 100, 74, 112, 74, 117, 138, 56, 53, 42, 181, 49, 13, 159, 22, 151, 118, 150, 43, 199, 77, 225, 94, 78, 215, 72, 95, 155, 222, 203, 51, 225, 229, 243, 6, 86, 59, 174, 222, 183, 90, 196, 15, 224, 87, 9, 32, 193, 10, 65, 107, 134, 60, 210, 232, 220, 20, 26, 10, 183, 10, 7, 51, 93, 50, 203, 51, 63, 173, 137, 92, 115, 106, 173, 236, 90, 238, 218, 155, 89, 198, 89, 219, 179, 70, 178, 125, 178, 127, 94, 135, 94, 199, 92, 215, 185, 94, 107, 253, 230, 245, 131, 27, 220, 55, 28, 217, 8, 109, 140, 223, 216, 185, 73, 103, 83, 222, 166, 225, 28, 223, 156, 154, 205, 196, 205, 41, 155, 127, 203, 181, 200, 45, 202, 253, 176, 37, 106, 75, 91, 158, 122, 94, 78, 222, 208, 86, 223, 173, 245, 249, 82, 249, 252, 252, 251, 219, 156, 182, 29, 254, 1, 253, 3, 231, 135, 158, 237, 214, 219, 15, 108, 255, 94, 192, 42, 184, 94, 104, 81, 88, 82, 248, 117, 7, 115, 199, 245, 31, 45, 127, 44, 253, 81, 188, 51, 97, 103, 207, 46, 219, 93, 135, 118, 99, 119, 115, 119, 223, 219, 227, 186, 167, 166, 72, 182, 40, 187, 104, 104, 111, 208, 222, 230, 98, 90, 113, 65, 241, 135, 125, 171, 246, 93, 43, 89, 84, 114, 120, 63, 113, 191, 112, 255, 64, 105, 96, 105, 235, 1, 221, 3, 187, 15, 124, 45, 75, 42, 235, 47, 247, 40, 111, 172, 80, 171, 216, 94, 49, 121, 144, 117, 176, 239, 144, 219, 161, 134, 195, 234, 135, 11, 15, 127, 249, 137, 243, 211, 131, 35, 190, 71, 154, 43, 245, 43, 75, 142, 98, 143, 102, 30, 125, 121, 44, 242, 88, 247, 207, 246, 63, 215, 86, 169, 86, 21, 86, 125, 171, 230, 86, 15, 212, 132, 214, 92, 174, 181, 171, 173, 173, 83, 171, 219, 85, 15, 215, 11, 235, 199, 142, 47, 63, 126, 251, 132, 215, 137, 214, 6, 211, 134, 35, 141, 138, 141, 133, 39, 193, 73, 225, 201, 87, 191, 196, 253, 114, 175, 41, 160, 169, 243, 148, 253, 169, 134, 211, 122, 167, 43, 206, 80, 207, 20, 52, 67, 205, 89, 205, 162, 150, 164, 150, 129, 214, 152, 214, 222, 179, 254, 103, 59, 219, 156, 218, 206, 252, 106, 246, 107, 117, 187, 86, 123, 249, 57, 133, 115, 187, 206, 19, 207, 231, 157, 23, 95, 200, 190, 48, 209, 193, 235, 24, 191, 152, 120, 113, 168, 115, 85, 231, 227, 75, 209, 151, 238, 94, 94, 122, 185, 167, 43, 160, 235, 234, 21, 159, 43, 151, 186, 221, 187, 47, 92, 117, 190, 218, 126, 205, 241, 218, 217, 235, 246, 215, 91, 110, 216, 222, 104, 190, 105, 115, 243, 204, 111, 54, 191, 157, 233, 177, 237, 105, 190, 101, 119, 171, 245, 182, 195, 237, 182, 222, 197, 189, 231, 251, 92, 251, 46, 222, 241, 186, 115, 229, 46, 253, 238, 141, 254, 37, 253, 189, 247, 34, 238, 61, 184, 191, 252, 254, 192, 3, 214, 131, 209, 135, 169, 15, 223, 62, 202, 124, 52, 245, 56, 231, 9, 230, 73, 193, 83, 153, 167, 37, 207, 212, 158, 85, 254, 110, 244, 123, 227, 128, 237, 192, 185, 65, 175, 193, 155, 207, 195, 158, 63, 30, 98, 14, 189, 126, 33, 120, 241, 117, 56, 239, 37, 229, 101, 201, 136, 230, 72, 237, 168, 213, 104, 251, 152, 207, 216, 237, 87, 203, 94, 13, 191, 230, 189, 158, 26, 207, 255, 67, 246, 143, 138, 55, 134, 111, 78, 255, 233, 246, 231, 77, 81, 180, 104, 248, 45, 255, 173, 248, 221, 142, 247, 42, 239, 171, 63, 44, 250, 208, 57, 17, 50, 241, 236, 99, 218, 199, 169, 201, 130, 79, 42, 159, 106, 62, 219, 127, 238, 254, 18, 245, 101, 100, 106, 205, 87, 220, 215, 210, 111, 70, 223, 218, 190, 7, 124, 127, 34, 78, 19, 139, 121, 12, 62, 99, 166, 21, 64, 33, 6, 39, 36, 0, 240, 174, 26, 0, 74, 12, 0, 84, 164, 111, 38, 46, 155, 237, 143, 103, 4, 205, 246, 244, 51, 4, 254, 19, 207, 246, 208, 51, 178, 5, 160, 1, 25, 166, 91, 161, 233, 150, 239, 84, 14, 0, 250, 110, 72, 238, 14, 0, 130, 145, 49, 220, 13, 192, 214, 214, 18, 251, 167, 4, 9, 214, 86, 179, 185, 164, 234, 1, 192, 105, 137, 197, 239, 210, 1, 32, 32, 246, 213, 87, 44, 158, 10, 17, 139, 191, 85, 32, 197, 222, 5, 224, 252, 232, 108, 95, 62, 45, 44, 210, 191, 55, 80, 47, 10, 170, 98, 251, 190, 231, 228, 128, 127, 209, 63, 0, 74, 247, 10, 138, 245, 28, 149, 144, 0, 0, 2, 11, 105, 84, 88, 116, 88, 77, 76, 58, 99, 111, 109, 46, 97, 100, 111, 98, 101, 46, 120, 109, 112, 0, 0, 0, 0, 0, 60, 120, 58, 120, 109, 112, 109, 101, 116, 97, 32, 120, 109, 108, 110, 115, 58, 120, 61, 34, 97, 100, 111, 98, 101, 58, 110, 115, 58, 109, 101, 116, 97, 47, 34, 32, 120, 58, 120, 109, 112, 116, 107, 61, 34, 88, 77, 80, 32, 67, 111, 114, 101, 32, 53, 46, 52, 46, 48, 34, 62, 10, 32, 32, 32, 60, 114, 100, 102, 58, 82, 68, 70, 32, 120, 109, 108, 110, 115, 58, 114, 100, 102, 61, 34, 104, 116, 116, 112, 58, 47, 47, 119, 119, 119, 46, 119, 51, 46, 111, 114, 103, 47, 49, 57, 57, 57, 47, 48, 50, 47, 50, 50, 45, 114, 100, 102, 45, 115, 121, 110, 116, 97, 120, 45, 110, 115, 35, 34, 62, 10, 32, 32, 32, 32, 32, 32, 60, 114, 100, 102, 58, 68, 101, 115, 99, 114, 105, 112, 116, 105, 111, 110, 32, 114, 100, 102, 58, 97, 98, 111, 117, 116, 61, 34, 34, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 120, 109, 108, 110, 115, 58, 116, 105, 102, 102, 61, 34, 104, 116, 116, 112, 58, 47, 47, 110, 115, 46, 97, 100, 111, 98, 101, 46, 99, 111, 109, 47, 116, 105, 102, 102, 47, 49, 46, 48, 47, 34, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 60, 116, 105, 102, 102, 58, 82, 101, 115, 111, 108, 117, 116, 105, 111, 110, 85, 110, 105, 116, 62, 50, 60, 47, 116, 105, 102, 102, 58, 82, 101, 115, 111, 108, 117, 116, 105, 111, 110, 85, 110, 105, 116, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 60, 116, 105, 102, 102, 58, 67, 111, 109, 112, 114, 101, 115, 115, 105, 111, 110, 62, 49, 60, 47, 116, 105, 102, 102, 58, 67, 111, 109, 112, 114, 101, 115, 115, 105, 111, 110, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 60, 116, 105, 102, 102, 58, 79, 114, 105, 101, 110, 116, 97, 116, 105, 111, 110, 62, 49, 60, 47, 116, 105, 102, 102, 58, 79, 114, 105, 101, 110, 116, 97, 116, 105, 111, 110, 62, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 60, 116, 105, 102, 102, 58, 80, 104, 111, 116, 111, 109, 101, 116, 114, 105, 99, 73, 110, 116, 101, 114, 112, 114, 101, 116, 97, 116, 105, 111, 110, 62, 50, 60, 47, 116, 105, 102, 102, 58, 80, 104, 111, 116, 111, 109, 101, 116, 114, 105, 99, 73, 110, 116, 101, 114, 112, 114, 101, 116, 97, 116, 105, 111, 110, 62, 10, 32, 32, 32, 32, 32, 32, 60, 47, 114, 100, 102, 58, 68, 101, 115, 99, 114, 105, 112, 116, 105, 111, 110, 62, 10, 32, 32, 32, 60, 47, 114, 100, 102, 58, 82, 68, 70, 62, 10, 60, 47, 120, 58, 120, 109, 112, 109, 101, 116, 97, 62, 10, 15, 69, 42, 147, 0, 0, 4, 52, 73, 68, 65, 84, 88, 9, 181, 151, 215, 78, 228, 64, 16, 69, 107, 26, 147, 115, 206, 153, 87, 224, 5, 248, 49, 132, 248, 5, 36, 196, 79, 240, 57, 136, 39, 144, 144, 200, 32, 114, 20, 57, 195, 176, 167, 180, 101, 245, 120, 199, 30, 239, 238, 80, 146, 229, 182, 219, 93, 247, 214, 237, 234, 234, 118, 230, 242, 242, 50, 43, 41, 236, 238, 238, 78, 174, 174, 174, 228, 230, 230, 70, 104, 63, 60, 60, 200, 203, 203, 139, 142, 172, 168, 168, 144, 154, 154, 26, 169, 171, 171, 147, 134, 134, 6, 105, 110, 110, 214, 118, 10, 183, 146, 41, 68, 224, 236, 236, 76, 142, 142, 142, 228, 228, 228, 68, 157, 2, 84, 85, 85, 37, 128, 150, 149, 149, 41, 198, 219, 219, 155, 146, 121, 122, 122, 82, 98, 16, 236, 236, 236, 148, 238, 238, 110, 105, 111, 111, 79, 228, 17, 75, 224, 241, 241, 81, 182, 183, 183, 229, 240, 240, 80, 58, 58, 58, 164, 181, 181, 85, 170, 171, 171, 165, 180, 180, 84, 156, 115, 122, 101, 50, 25, 117, 158, 205, 102, 229, 235, 235, 75, 175, 247, 247, 119, 97, 236, 197, 197, 133, 156, 158, 158, 74, 79, 79, 143, 12, 15, 15, 235, 216, 124, 76, 242, 18, 96, 224, 206, 206, 142, 70, 216, 213, 213, 165, 242, 150, 151, 151, 235, 115, 16, 4, 82, 82, 82, 146, 151, 192, 231, 231, 167, 124, 124, 124, 8, 138, 188, 190, 190, 170, 26, 199, 199, 199, 250, 60, 52, 52, 164, 129, 68, 73, 4, 209, 23, 200, 189, 190, 190, 174, 18, 2, 94, 89, 89, 169, 23, 114, 3, 78, 244, 68, 110, 209, 219, 120, 84, 48, 37, 140, 4, 211, 132, 106, 144, 88, 91, 91, 19, 8, 50, 45, 190, 229, 16, 32, 242, 205, 205, 77, 233, 239, 239, 23, 192, 153, 107, 8, 152, 236, 249, 128, 125, 103, 180, 33, 1, 81, 8, 163, 154, 41, 199, 51, 190, 81, 143, 41, 53, 11, 9, 48, 111, 200, 14, 195, 222, 222, 94, 101, 14, 56, 206, 162, 209, 218, 224, 124, 119, 35, 137, 82, 128, 49, 158, 139, 54, 121, 2, 70, 109, 109, 109, 152, 19, 206, 156, 88, 7, 209, 91, 166, 19, 249, 223, 128, 155, 47, 187, 51, 22, 31, 40, 137, 79, 124, 3, 14, 150, 153, 18, 56, 63, 63, 215, 140, 237, 235, 235, 11, 193, 97, 93, 44, 195, 151, 145, 0, 131, 169, 6, 19, 11, 9, 12, 14, 14, 74, 99, 99, 163, 174, 111, 228, 42, 182, 225, 147, 164, 4, 3, 44, 35, 16, 80, 209, 126, 21, 35, 153, 154, 154, 210, 132, 75, 19, 57, 89, 190, 188, 188, 44, 27, 27, 27, 202, 115, 100, 100, 68, 38, 38, 38, 194, 194, 20, 71, 30, 223, 228, 21, 9, 190, 180, 180, 164, 203, 52, 184, 190, 190, 214, 34, 67, 9, 77, 51, 231, 43, 43, 43, 50, 55, 55, 167, 149, 209, 7, 106, 107, 107, 147, 153, 153, 25, 37, 226, 191, 247, 219, 150, 19, 96, 81, 216, 192, 118, 40, 128, 44, 105, 192, 87, 87, 87, 101, 122, 122, 250, 15, 112, 64, 144, 116, 118, 118, 86, 149, 241, 65, 163, 109, 35, 1, 38, 216, 142, 13, 133, 77, 196, 10, 76, 116, 128, 61, 83, 68, 230, 231, 231, 181, 210, 217, 187, 232, 157, 101, 198, 55, 148, 227, 56, 131, 0, 88, 96, 130, 237, 40, 153, 204, 11, 29, 92, 113, 134, 244, 7, 7, 7, 113, 221, 225, 123, 148, 32, 63, 226, 204, 112, 192, 4, 219, 81, 185, 200, 206, 36, 112, 156, 249, 107, 55, 206, 185, 189, 103, 19, 75, 50, 176, 192, 4, 219, 25, 163, 164, 1, 63, 209, 103, 184, 142, 245, 137, 20, 176, 73, 50, 214, 110, 90, 99, 251, 77, 50, 176, 192, 4, 219, 81, 161, 140, 64, 18, 137, 241, 241, 113, 221, 35, 146, 28, 211, 199, 114, 164, 38, 196, 25, 24, 70, 0, 108, 71, 50, 176, 28, 172, 35, 110, 32, 108, 89, 231, 73, 133, 138, 236, 230, 27, 150, 116, 156, 25, 14, 152, 96, 59, 54, 137, 251, 251, 123, 221, 169, 232, 76, 178, 209, 209, 81, 89, 88, 88, 208, 179, 66, 244, 59, 34, 167, 64, 37, 69, 207, 24, 48, 88, 174, 96, 130, 29, 176, 30, 57, 118, 177, 29, 19, 93, 161, 122, 48, 54, 54, 38, 139, 139, 139, 57, 165, 152, 57, 159, 156, 156, 44, 88, 138, 13, 28, 44, 170, 32, 231, 2, 61, 146, 237, 238, 238, 134, 219, 37, 7, 7, 228, 254, 9, 163, 152, 113, 92, 219, 223, 223, 215, 105, 39, 177, 117, 55, 108, 106, 106, 146, 189, 189, 61, 225, 84, 203, 71, 133, 166, 226, 95, 200, 225, 19, 223, 96, 128, 5, 38, 166, 4, 234, 235, 235, 117, 115, 96, 159, 102, 167, 227, 42, 38, 9, 124, 153, 95, 48, 216, 136, 192, 12, 9, 208, 96, 62, 248, 233, 48, 18, 197, 82, 194, 34, 135, 0, 190, 193, 240, 207, 132, 170, 0, 4, 40, 141, 252, 68, 32, 15, 103, 122, 54, 148, 255, 85, 194, 34, 199, 23, 62, 241, 13, 6, 88, 102, 57, 231, 46, 182, 72, 6, 109, 109, 109, 41, 56, 76, 121, 214, 138, 245, 251, 56, 110, 3, 147, 238, 140, 97, 169, 161, 162, 69, 14, 56, 135, 93, 48, 124, 203, 33, 64, 7, 201, 65, 157, 230, 87, 236, 249, 249, 89, 229, 162, 98, 249, 75, 212, 234, 184, 239, 8, 80, 187, 0, 7, 152, 132, 51, 217, 57, 11, 70, 193, 25, 159, 247, 207, 136, 14, 246, 106, 6, 35, 221, 192, 192, 128, 180, 180, 180, 232, 81, 218, 234, 132, 79, 194, 128, 45, 114, 214, 57, 199, 60, 162, 38, 225, 80, 210, 151, 29, 255, 102, 177, 4, 236, 131, 219, 219, 91, 45, 26, 20, 14, 212, 225, 88, 77, 5, 179, 159, 14, 190, 99, 47, 225, 162, 188, 82, 225, 236, 91, 190, 183, 108, 55, 127, 209, 123, 65, 2, 54, 128, 233, 176, 223, 114, 218, 40, 132, 212, 24, 170, 16, 33, 181, 29, 114, 84, 87, 218, 105, 236, 27, 141, 198, 164, 204, 130, 59, 242, 161, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130}; // fixed array const
Array_fixed_byte_163 _const_ui__bytes_arrow_png = {((byte)(137)), 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 48, 0, 0, 0, 48, 8, 6, 0, 0, 0, 87, 2, 249, 135, 0, 0, 0, 6, 98, 75, 71, 68, 0, 255, 0, 255, 0, 255, 160, 189, 167, 147, 0, 0, 0, 88, 73, 68, 65, 84, 104, 129, 237, 213, 49, 10, 128, 80, 16, 3, 209, 28, 61, 229, 222, 90, 171, 216, 88, 168, 160, 95, 2, 243, 32, 253, 116, 145, 0, 0, 0, 0, 0, 192, 83, 35, 105, 123, 105, 179, 184, 253, 224, 27, 113, 87, 243, 226, 230, 19, 171, 56, 62, 172, 226, 248, 176, 138, 227, 195, 42, 142, 15, 171, 56, 62, 172, 226, 248, 176, 138, 227, 99, 244, 227, 73, 1, 0, 0, 0, 0, 190, 180, 3, 241, 255, 99, 199, 80, 201, 152, 44, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130}; // fixed array const
#define _const_ui__dummy_name_for_vfmt_align_________ 0
int ui__SettingsUI_int(ui__SettingsUI* c, Array_string k);
void ui__SettingsUI_int_for(ui__SettingsUI* c, int val, Array_string k);
Array_int ui__SettingsUI_ints(ui__SettingsUI* c, Array_string k);
void ui__SettingsUI_ints_for(ui__SettingsUI* c, Array_int val, Array_string k);
f32 ui__SettingsUI_f32(ui__SettingsUI* c, Array_string k);
Array_f32 ui__SettingsUI_f32s(ui__SettingsUI* c, Array_string k);
void ui__SettingsUI_f32_for(ui__SettingsUI* c, f32 val, Array_string k);
void ui__SettingsUI_f32s_for(ui__SettingsUI* c, Array_f32 val, Array_string k);
bool ui__SettingsUI_bool(ui__SettingsUI* c, Array_string k);
void ui__SettingsUI_bool_for(ui__SettingsUI* c, bool val, Array_string k);
Array_bool ui__SettingsUI_bools(ui__SettingsUI* c, Array_string k);
void ui__SettingsUI_bools_for(ui__SettingsUI* c, Array_bool val, Array_string k);
string ui__SettingsUI_string(ui__SettingsUI* c, Array_string k);
void ui__SettingsUI_string_for(ui__SettingsUI* c, string val, Array_string k);
Array_string ui__SettingsUI_strings(ui__SettingsUI* c, Array_string k);
void ui__SettingsUI_strings_for(ui__SettingsUI* c, Array_string val, Array_string k);
gx__Color ui__SettingsUI_color(ui__SettingsUI* c, Array_string k);
void ui__SettingsUI_color_for(ui__SettingsUI* c, gx__Color val, Array_string k);
Array_gx__Color ui__SettingsUI_colors(ui__SettingsUI* c, Array_string k);
void ui__SettingsUI_colors_for(ui__SettingsUI* c, Array_gx__Color val, Array_string k);
Option_ui__SettingsUI ui__load_settings(string path);
Option_void ui__save_settings(string path, ui__SettingsUI s);
void ui__Window_load_settings(ui__Window* w);
void ui__Window_save_settings(ui__Window* w);
string _const_ui__version; // a string literal, inited later
#define _const_ui__cursor_show_delay 100
void ui__UI_idle_loop(ui__UI* gui);
void ui__UI_load_icos(ui__UI* gui);
void ui__UI_free(ui__UI* gui);
void ui__run(ui__Window* window);
void ui__open_url(string url);
bool ui__confirm(string s);


// added by module `ui`

#if defined(__has_include)

#if __has_include("/Users/rcqls/.vmodules/ui/ui_darwin.m")
#include "/Users/rcqls/.vmodules/ui/ui_darwin.m"
#else
#error VERROR_MESSAGE Header file "/Users/rcqls/.vmodules/ui/ui_darwin.m", needed for module `ui` was not found. Please install the corresponding development headers.
#endif

#else
#include "/Users/rcqls/.vmodules/ui/ui_darwin.m"
#endif



void ui__message_box(string s);
void ui__notify(string title, string msg);
string ui__bundle_path(void);
void ui__wait_events(void);
gx__Color _const_ui__button_bg_color; // inited later
gx__Color _const_ui__button_border_color; // inited later
gx__Color _const_ui__button_focus_border_color; // inited later
#define _const_ui__button_horizontal_padding 26
#define _const_ui__button_vertical_padding 8
ui__Button* ui__button(ui__ButtonParams c);
void ui__Button_init(ui__Button* b, ui__Layout parent);
void ui__Button_cleanup(ui__Button* b);
void ui__Button_free(ui__Button* b);
void ui__Button_init_style(ui__Button* b);
void ui__btn_key_down(ui__Button* b, ui__KeyEvent* e, ui__Window* window);
void ui__btn_click(ui__Button* b, ui__MouseEvent* e, ui__Window* window);
void ui__btn_mouse_down(ui__Button* b, ui__MouseEvent* e, ui__Window* window);
void ui__btn_mouse_up(ui__Button* b, ui__MouseEvent* e, ui__Window* window);
void ui__btn_mouse_move(ui__Button* b, ui__MouseMoveEvent* e, ui__Window* window);
void ui__Button_set_pos(ui__Button* b, int x, int y);
multi_return_int_int ui__Button_size(ui__Button* b);
multi_return_int_int ui__Button_propose_size(ui__Button* b, int w, int h);
void ui__Button_draw(ui__Button* b);
void ui__Button_set_text(ui__Button* b, string text);
void ui__Button_set_text_size(ui__Button* b);
bool ui__Button_point_inside(ui__Button* b, f64 x, f64 y);
void ui__Button_set_visible(ui__Button* b, bool state);
void ui__Button_focus(ui__Button* b);
void ui__Button_unfocus(ui__Button* b);
void ui__Button_set_theme(ui__Button* b, ui__ColorThemeCfg theme_cfg);
void ui__Button_update_theme(ui__Button* b);
ui__Canvas* ui__canvas(ui__CanvasParams c);
void ui__Canvas_init(ui__Canvas* c, ui__Layout parent);
void ui__Canvas_cleanup(ui__Canvas* c);
void ui__Canvas_free(ui__Canvas* c);
void ui__Canvas_set_pos(ui__Canvas* c, int x, int y);
multi_return_int_int ui__Canvas_size(ui__Canvas* c);
multi_return_int_int ui__Canvas_propose_size(ui__Canvas* c, int w, int h);
void ui__Canvas_draw(ui__Canvas* c);
void ui__Canvas_set_visible(ui__Canvas* c, bool state);
bool ui__Canvas_point_inside(ui__Canvas* c, f64 x, f64 y);
#define _const_ui__check_mark_size 14
gx__Color _const_ui__cb_border_color; // inited later
ui__CheckBox* ui__checkbox(ui__CheckBoxParams c);
void ui__CheckBox_init(ui__CheckBox* cb, ui__Layout parent);
void ui__CheckBox_cleanup(ui__CheckBox* cb);
void ui__CheckBox_free(ui__CheckBox* cb);
void ui__CheckBox_init_style(ui__CheckBox* cb);
void ui__cb_key_down(ui__CheckBox* cb, ui__KeyEvent* e, ui__Window* window);
void ui__cb_click(ui__CheckBox* cb, ui__MouseEvent* e, ui__Window* window);
void ui__CheckBox_set_pos(ui__CheckBox* cb, int x, int y);
multi_return_int_int ui__CheckBox_size(ui__CheckBox* cb);
multi_return_int_int ui__CheckBox_propose_size(ui__CheckBox* cb, int w, int h);
void ui__CheckBox_draw(ui__CheckBox* cb);
bool ui__CheckBox_point_inside(ui__CheckBox* cb, f64 x, f64 y);
void ui__CheckBox_mouse_move(ui__CheckBox* cb, ui__MouseEvent e);
void ui__CheckBox_set_visible(ui__CheckBox* cb, bool state);
void ui__CheckBox_focus(ui__CheckBox* cb);
void ui__CheckBox_unfocus(ui__CheckBox* cb);
gx__Color _const_ui__dropdown_color; // inited later
gx__Color _const_ui__dropdown_border_color; // inited later
gx__Color _const_ui__dropdown_focus_color; // inited later
gx__Color _const_ui__dropdown_drawer_color; // inited later
ui__Dropdown* ui__dropdown(ui__DropdownParams c);
void ui__Dropdown_init(ui__Dropdown* dd, ui__Layout parent);
void ui__Dropdown_cleanup(ui__Dropdown* dd);
void ui__Dropdown_free(ui__Dropdown* dd);
void ui__Dropdown_set_pos(ui__Dropdown* dd, int x, int y);
multi_return_int_int ui__Dropdown_size(ui__Dropdown* dd);
multi_return_int_int ui__Dropdown_propose_size(ui__Dropdown* dd, int w, int h);
void ui__Dropdown_draw(ui__Dropdown* dd);
void ui__Dropdown_draw_open(ui__Dropdown* dd);
void ui__Dropdown_add_item(ui__Dropdown* dd, string text);
void ui__Dropdown_open_drawer(ui__Dropdown* dd);
void ui__dd_key_down(ui__Dropdown* dd, ui__KeyEvent* e, voidptr zzz);
void ui__dd_click(ui__Dropdown* dd, ui__MouseEvent* e, voidptr zzz);
void ui__dd_mouse_down(ui__Dropdown* dd, ui__MouseEvent* e, voidptr zzz);
void ui__dd_mouse_move(ui__Dropdown* dd, ui__MouseMoveEvent* e, voidptr zzz);
void ui__Dropdown_set_visible(ui__Dropdown* dd, bool state);
void ui__Dropdown_focus(ui__Dropdown* dd);
void ui__Dropdown_unfocus(ui__Dropdown* dd);
bool ui__Dropdown_point_inside(ui__Dropdown* dd, f64 x, f64 y);
ui__DropdownItem ui__Dropdown_selected(ui__Dropdown* dd);
ui__Grid* ui__grid(ui__GridParams c);
void ui__Grid_init(ui__Grid* gv, ui__Layout parent);
void ui__Grid_cleanup(ui__Grid* g);
void ui__Grid_free(ui__Grid* g);
void ui__Grid_draw(ui__Grid* gv);
int ui__min_text_width(ui__Grid _v_toheap_gv);
int ui__check_cells(ui__Grid _v_toheap_gv);
void ui__Grid_set_visible(ui__Grid* gv, bool state);
void ui__Grid_set_pos(ui__Grid* gv, int x, int y);
multi_return_int_int ui__Grid_size(ui__Grid* gv);
multi_return_int_int ui__Grid_propose_size(ui__Grid* gv, int w, int h);
bool ui__Grid_point_inside(ui__Grid* gv, f64 x, f64 y);
ui__Label* ui__label(ui__LabelParams c);
void ui__Label_init(ui__Label* l, ui__Layout parent);
void ui__Label_cleanup(ui__Label* l);
void ui__Label_free(ui__Label* l);
void ui__Label_init_style(ui__Label* l);
void ui__Label_set_pos(ui__Label* l, int x, int y);
multi_return_int_int ui__Label_adj_size(ui__Label* l);
void ui__Label_init_size(ui__Label* l);
multi_return_int_int ui__Label_size(ui__Label* l);
multi_return_int_int ui__Label_propose_size(ui__Label* l, int w, int h);
void ui__Label_draw(ui__Label* l);
void ui__Label_set_visible(ui__Label* l, bool state);
bool ui__Label_point_inside(ui__Label* l, f64 x, f64 y);
void ui__Label_set_text(ui__Label* l, string s);
#define _const_ui___item_height 20
gx__Color _const_ui___col_list_bkgrnd; // inited later
gx__Color _const_ui___col_item_select; // inited later
gx__Color _const_ui___col_border; // inited later
#define _const_ui___text_offset_y 3
#define _const_ui___text_offset_x 5
ui__ListBox* ui__listbox(ui__ListBoxParams c);
void ui__ListBox_init(ui__ListBox* lb, ui__Layout parent);
void ui__ListBox_cleanup(ui__ListBox* lb);
void ui__ListBox_free(ui__ListBox* lb);
void ui__ListItem_free(ui__ListItem* item);
void ui__ListBox_init_style(ui__ListBox* lb);
void ui__ListBox_init_items(ui__ListBox* lb);
void ui__ListBox_add_item(ui__ListBox* lb, string id, string text);
int ui__ListBox_get_draw_to(ui__ListBox* lb, string text);
void ui__ListBox_append_item(ui__ListBox* lb, string id, string text, int draw_to);
bool ui__ListBox_is_selected(ui__ListBox* lb);
Array_string ui__ListBox_ids(ui__ListBox* lb);
Array_string ui__ListBox_values(ui__ListBox* lb);
Array_int ui__ListBox_indices(ui__ListBox* lb);
Option_multi_return_string_string ui__ListBox_selected(ui__ListBox* lb);
Option_int ui__ListBox_selected_inx(ui__ListBox* lb);
void ui__ListBox_set_text(ui__ListBox* lb, string id, string text);
void ui__ListBox_remove_item(ui__ListBox* lb, string id);
void ui__ListBox_remove_inx(ui__ListBox* lb, int i);
void ui__ListBox_clear(ui__ListBox* lb);
void ui__ListBox_draw_item(ui__ListBox* lb, ui__ListItem _v_toheap_li, bool selected);
multi_return_int_int ui__ListBox_visible_items(ui__ListBox* lb);
void ui__ListBox_draw(ui__ListBox* lb);
bool ui__ListBox_point_inside(ui__ListBox* lb, f64 x, f64 y);
bool ui__ListItem_point_inside(ui__ListItem* li, f64 x, f64 y);
void ui__on_change(ui__ListBox* lb, ui__MouseEvent* e, ui__Window* window);
void ui__on_files_droped(ui__ListBox* lb, ui__MouseEvent* e, ui__Window* window);
void ui__on_key_up(ui__ListBox* lb, ui__KeyEvent* e, ui__Window* window);
void ui__ListBox_set_pos(ui__ListBox* lb, int x, int y);
void ui__ListBox_set_visible(ui__ListBox* lb, bool state);
void ui__ListBox_focus(ui__ListBox* lb);
void ui__ListBox_unfocus(ui__ListBox* lb);
multi_return_int_int ui__ListBox_adj_size(ui__ListBox* lb);
void ui__ListBox_update_adj_size(ui__ListBox* lb);
void ui__ListBox_init_size(ui__ListBox* lb);
multi_return_int_int ui__ListBox_size(ui__ListBox* lb);
multi_return_int_int ui__ListBox_propose_size(ui__ListBox* lb, int w, int h);
void ui__ListBox_resize(ui__ListBox* lb, int width, int height);
void ui__ListBox_set_children_pos(ui__ListBox* lb);
#define _const_ui__menu_height 30
gx__Color _const_ui__menu_color; // inited later
gx__Color _const_ui__menu_border_color; // inited later
ui__Menu* ui__menu(ui__MenuParams c);
void ui__Menu_init(ui__Menu* m, ui__Layout parent);
void ui__Menu_cleanup(ui__Menu* m);
void ui__Menu_free(ui__Menu* m);
void ui__menu_click(ui__Menu* m, ui__MouseEvent* e, ui__Window* window);
void ui__Menu_set_pos(ui__Menu* m, int x, int y);
void ui__Menu_update_height(ui__Menu* m);
multi_return_int_int ui__Menu_size(ui__Menu* m);
multi_return_int_int ui__Menu_propose_size(ui__Menu* m, int w, int h);
void ui__Menu_draw(ui__Menu* m);
void ui__Menu_add_item(ui__Menu* m, string text, void (*action)(ui__Menu* m, ui__MenuItem* item, voidptr state));
void ui__Menu_set_visible(ui__Menu* m, bool state);
bool ui__Menu_point_inside(ui__Menu* m, f64 x, f64 y);
void ui__Menu_set_text(ui__Menu* m, string s);
ui__Picture* ui__picture(ui__PictureParams _v_toheap_c);
void ui__Picture_init(ui__Picture* pic, ui__Layout parent);
void ui__Picture_cleanup(ui__Picture* p);
void ui__Picture_free(ui__Picture* p);
void ui__pic_click(ui__Picture* pic, ui__MouseEvent* e, ui__Window* window);
void ui__pic_mouse_down(ui__Picture* pic, ui__MouseEvent* e, ui__Window* window);
void ui__Picture_set_pos(ui__Picture* pic, int x, int y);
multi_return_int_int ui__Picture_size(ui__Picture* pic);
multi_return_int_int ui__Picture_propose_size(ui__Picture* pic, int w, int h);
void ui__Picture_draw(ui__Picture* pic);
void ui__Picture_set_visible(ui__Picture* pic, bool state);
bool ui__Picture_point_inside(ui__Picture* pic, f64 x, f64 y);
gx__Color _const_ui__progress_bar_color; // inited later
gx__Color _const_ui__progress_bar_border_color; // inited later
gx__Color _const_ui__progress_bar_background_color; // inited later
gx__Color _const_ui__progress_bar_background_border_color; // inited later
ui__ProgressBar* ui__progressbar(ui__ProgressBarParams c);
void ui__ProgressBar_init(ui__ProgressBar* pb, ui__Layout parent);
void ui__ProgressBar_cleanup(ui__ProgressBar* pb);
void ui__ProgressBar_free(ui__ProgressBar* pb);
void ui__ProgressBar_set_pos(ui__ProgressBar* pb, int x, int y);
multi_return_int_int ui__ProgressBar_size(ui__ProgressBar* pb);
multi_return_int_int ui__ProgressBar_propose_size(ui__ProgressBar* pb, int w, int h);
void ui__ProgressBar_draw(ui__ProgressBar* pb);
bool ui__ProgressBar_point_inside(ui__ProgressBar* pb, f64 x, f64 y);
void ui__ProgressBar_set_visible(ui__ProgressBar* pb, bool state);
gx__Color _const_ui__radio_focus_color; // inited later
ui__Radio* ui__radio(ui__RadioParams c);
void ui__Radio_init(ui__Radio* r, ui__Layout parent);
void ui__Radio_cleanup(ui__Radio* r);
void ui__Radio_free(ui__Radio* r);
void ui__Radio_init_style(ui__Radio* r);
void ui__radio_key_down(ui__Radio* r, ui__KeyEvent* e, ui__Window* window);
void ui__radio_click(ui__Radio* r, ui__MouseEvent* e, ui__Window* window);
void ui__Radio_set_pos(ui__Radio* r, int x, int y);
multi_return_int_int ui__Radio_size(ui__Radio* r);
multi_return_int_int ui__Radio_propose_size(ui__Radio* r, int w, int h);
void ui__Radio_set_size_from_values(ui__Radio* r);
void ui__Radio_update_size(ui__Radio* r);
void ui__Radio_draw(ui__Radio* r);
bool ui__Radio_point_inside(ui__Radio* r, f64 x, f64 y);
void ui__Radio_set_visible(ui__Radio* r, bool state);
void ui__Radio_focus(ui__Radio* r);
void ui__Radio_unfocus(ui__Radio* r);
string ui__Radio_selected_value(ui__Radio* r);
void ui__Radio_select_next_value(ui__Radio* r);
void ui__Radio_select_prev_value(ui__Radio* r);
ui__Rectangle* ui__rectangle(ui__RectangleParams c);
ui__Rectangle* ui__spacing(ui__RectangleParams c);
void ui__Rectangle_init(ui__Rectangle* r, ui__Layout parent);
void ui__Rectangle_cleanup(ui__Rectangle* r);
void ui__Rectangle_free(ui__Rectangle* r);
void ui__Rectangle_set_pos(ui__Rectangle* r, int x, int y);
multi_return_int_int ui__Rectangle_size(ui__Rectangle* r);
multi_return_int_int ui__Rectangle_propose_size(ui__Rectangle* r, int w, int h);
void ui__Rectangle_draw(ui__Rectangle* r);
void ui__Rectangle_set_visible(ui__Rectangle* r, bool state);
bool ui__Rectangle_point_inside(ui__Rectangle* r, f64 x, f64 y);
gx__Color _const_ui__thumb_color; // inited later
gx__Color _const_ui__slider_background_color; // inited later
gx__Color _const_ui__slider_background_border_color; // inited later
gx__Color _const_ui__slider_focused_background_border_color; // inited later
ui__Slider* ui__slider(ui__SliderParams c);
void ui__Slider_init(ui__Slider* s, ui__Layout parent);
void ui__Slider_cleanup(ui__Slider* s);
void ui__Slider_free(ui__Slider* s);
void ui__Slider_set_pos(ui__Slider* s, int x, int y);
void ui__Slider_set_thumb_size(ui__Slider* s);
multi_return_int_int ui__Slider_size(ui__Slider* s);
multi_return_int_int ui__Slider_propose_size(ui__Slider* s, int w, int h);
void ui__Slider_draw(ui__Slider* s);
void ui__Slider_draw_thumb(ui__Slider* s);
void ui__slider_key_down(ui__Slider* s, ui__KeyEvent* e, voidptr zzz);
bool ui__Slider_point_inside(ui__Slider* s, f64 x, f64 y);
bool ui__Slider_point_inside_thumb(ui__Slider* s, f64 x, f64 y);
void ui__slider_click(ui__Slider* s, ui__MouseEvent* e, voidptr zzz);
void ui__slider_mouse_down(ui__Slider* s, ui__MouseEvent* e, voidptr zzz);
void ui__slider_mouse_up(ui__Slider* s, ui__MouseEvent* e, voidptr zzz);
void ui__slider_mouse_move(ui__Slider* s, ui__MouseMoveEvent* e, voidptr zzz);
void ui__slider_touch_move(ui__Slider* s, ui__MouseMoveEvent* e, voidptr zzz);
void ui__Slider_change_value(ui__Slider* s, int x, int y);
void ui__Slider_set_visible(ui__Slider* s, bool state);
void ui__Slider_focus(ui__Slider* s);
void ui__Slider_unfocus(ui__Slider* s);
#define _const_ui__sw_decoration 20
#define _const_ui__sw_z_index 10000
#define _const_ui__sw_z_index_top 1000
#define _const_ui__sw_z_index_child 100
ui__SubWindow* ui__subwindow(ui__SubWindowParams c);
void ui__SubWindow_init(ui__SubWindow* s, ui__Layout parent);
void ui__SubWindow_cleanup(ui__SubWindow* s);
void ui__SubWindow_draw(ui__SubWindow* s);
void ui__SubWindow_free(ui__SubWindow* s);
void ui__sw_mouse_down(ui__SubWindow* s, ui__MouseEvent* e, ui__Window* window);
void ui__sw_mouse_up(ui__SubWindow* s, ui__MouseEvent* e, ui__Window* window);
void ui__sw_mouse_move(ui__SubWindow* s, ui__MouseMoveEvent* e, ui__Window* window);
void ui__SubWindow_update_layout(ui__SubWindow* s);
void ui__SubWindow_set_adjusted_size(ui__SubWindow* s, ui__UI* ui);
bool ui__SubWindow_point_inside_bar(ui__SubWindow* s, f64 x, f64 y);
bool ui__SubWindow_point_inside(ui__SubWindow* s, f64 x, f64 y);
void ui__SubWindow_set_pos(ui__SubWindow* s, int x, int y);
multi_return_int_int ui__SubWindow_propose_size(ui__SubWindow* s, int width, int height);
multi_return_int_int ui__SubWindow_size(ui__SubWindow* s);
void ui__SubWindow_set_visible(ui__SubWindow* s, bool state);
ui__UI* ui__SubWindow_get_ui(ui__SubWindow* s);
voidptr ui__SubWindow_get_state(ui__SubWindow* s);
eventbus__Subscriber* ui__SubWindow_get_subscriber(ui__SubWindow* s);
void ui__SubWindow_resize(ui__SubWindow* s, int w, int h);
Array_ui__Widget ui__SubWindow_get_children(ui__SubWindow* s);
void ui__SubWindow_set_children_depth(ui__SubWindow* s, int z_inc);
bool ui__SubWindow_is_top_subwindow(ui__SubWindow* s);
void ui__SubWindow_as_top_subwindow(ui__SubWindow* s);
void ui__SubWindow_update_depth(ui__SubWindow* s, bool top);
#define _const_ui__sw_height 20
#define _const_ui__sw_width 40
#define _const_ui__sw_dot_size 16
gx__Color _const_ui__sw_open_bg_color; // inited later
gx__Color _const_ui__sw_close_bg_color; // inited later
gx__Color _const_ui__sw_focus_bg_color; // inited later
ui__Switch* ui__switcher(ui__SwitchParams c);
void ui__Switch_init(ui__Switch* s, ui__Layout parent);
void ui__Switch_cleanup(ui__Switch* s);
void ui__Switch_free(ui__Switch* s);
void ui__Switch_set_pos(ui__Switch* s, int x, int y);
multi_return_int_int ui__Switch_size(ui__Switch* s);
multi_return_int_int ui__Switch_propose_size(ui__Switch* s, int w, int h);
void ui__Switch_draw(ui__Switch* s);
bool ui__Switch_point_inside(ui__Switch* s, f64 x, f64 y);
void ui__sw_key_down(ui__Switch* s, ui__KeyEvent* e, ui__Window* window);
void ui__sw_click(ui__Switch* s, ui__MouseEvent* e, ui__Window* w);
void ui__Switch_set_visible(ui__Switch* s, bool state);
void ui__Switch_focus(ui__Switch* s);
void ui__Switch_unfocus(ui__Switch* s);
gx__Color _const_ui__text_border_color; // inited later
gx__Color _const_ui__text_inner_border_color; // inited later
gx__Color _const_ui__text_border_accentuated_color; // inited later
#define _const_ui__textbox_padding_x 5
#define _const_ui__textbox_padding_y 2
gx__Color _const_ui__selection_color; // inited later
ui__TextBox* ui__textbox(ui__TextBoxParams c);
void ui__TextBox_init(ui__TextBox* tb, ui__Layout parent);
void ui__TextBox_cleanup(ui__TextBox* tb);
void ui__TextBox_free(ui__TextBox* tb);
void ui__TextBox_init_style(ui__TextBox* tb);
void ui__draw_inner_border(bool border_accentuated, gg__Context* gg, int x, int y, int width, int height, bool is_error);
void ui__TextBox_set_pos(ui__TextBox* t, int x, int y);
multi_return_int_int ui__TextBox_adj_size(ui__TextBox* tb);
multi_return_int_int ui__TextBox_size(ui__TextBox* tb);
#define _const_ui__max_textbox_height 25
multi_return_int_int ui__TextBox_propose_size(ui__TextBox* tb, int w, int h);
void ui__TextBox_update_line_height(ui__TextBox* tb);
void ui__TextBox_draw(ui__TextBox* tb);
int ui__TextBox_skip_index_from_end(ui__TextBox* tb, Array_rune ustr, ui__DrawTextWidget dtw);
int ui__TextBox_skip_index_from_start(ui__TextBox* tb, Array_rune ustr, ui__DrawTextWidget dtw);
bool ui__TextBox_is_sel_active(ui__TextBox* tb);
void ui__TextBox_draw_selection(ui__TextBox* tb);
void ui__TextBox_cancel_selection(ui__TextBox* tb);
void ui__TextBox_delete_selection(ui__TextBox* tb);
void ui__tb_key_down(ui__TextBox* tb, ui__KeyEvent* e, ui__Window* window);
void ui__tb_char(ui__TextBox* tb, ui__KeyEvent* e, ui__Window* window);
void ui__TextBox_set_sel(ui__TextBox* tb, int sel_start_i, int sel_end_i, ui__Key key);
bool ui__TextBox_point_inside(ui__TextBox* tb, f64 x, f64 y);
void ui__tb_mouse_down(ui__TextBox* tb, ui__MouseEvent* e, voidptr zzz);
void ui__tb_mouse_move(ui__TextBox* tb, ui__MouseMoveEvent* e, voidptr zzz);
void ui__tb_mouse_up(ui__TextBox* tb, ui__MouseEvent* e, voidptr zzz);
void ui__TextBox_set_visible(ui__TextBox* tb, bool state);
void ui__TextBox_focus(ui__TextBox* tb);
void ui__TextBox_unfocus(ui__TextBox* tb);
void ui__TextBox_hide(ui__TextBox* tb);
void ui__TextBox_set_text(ui__TextBox* tb, string s);
void ui__TextBox_insert(ui__TextBox* tb, string s);
void ui__TextBox_set_children_pos(ui__TextBox* tb);
ui__Transition* ui__transition(ui__TransitionParams c);
void ui__Transition_init(ui__Transition* t, ui__Layout parent);
void ui__Transition_cleanup(ui__Transition* t);
void ui__Transition_free(ui__Transition* t);
void ui__Transition_set_value(ui__Transition* t, int* animated_value);
void ui__Transition_set_pos(ui__Transition* t, int x, int y);
multi_return_int_int ui__Transition_propose_size(ui__Transition* t, int w, int h);
multi_return_int_int ui__Transition_size(ui__Transition* t);
void ui__Transition_draw(ui__Transition* t);
void ui__Transition_set_visible(ui__Transition* t, bool state);
bool ui__Transition_point_inside(ui__Transition* t, f64 x, f64 y);
gx__Color _const_ui__default_window_color; // inited later
#define _const_ui__default_font_size 13
ui__Window* ui__window(ui__WindowParams cfg);
ui__Window* ui__Window_child_window(ui__Window* parent_window, ui__WindowParams cfg);
void ui__gg_init(ui__Window* window);
void ui__gg_cleanup(ui__Window* window);
void ui__frame(ui__Window* w);
void ui__frame_immediate(ui__Window* w);
void ui__native_frame(ui__Window* w);
void ui__on_event(gg__Event* e, ui__Window* window);
void ui__window_resize(gg__Event event, ui__UI* ui);
void ui__window_key_down(gg__Event event, ui__UI* ui);
void ui__window_char(gg__Event event, ui__UI* ui);
void ui__window_mouse_down(gg__Event event, ui__UI* ui);
void ui__window_mouse_move(gg__Event event, ui__UI* ui);
void ui__window_mouse_up(gg__Event event, ui__UI* ui);
void ui__window_click(gg__Event event, ui__UI* ui);
void ui__window_scroll(gg__Event event, ui__UI* ui);
void ui__window_touch_down(gg__Event event, ui__UI* ui);
void ui__window_touch_move(gg__Event event, ui__UI* ui);
void ui__window_touch_up(gg__Event event, ui__UI* ui);
void ui__window_touch_tap(gg__Event event, ui__UI* ui);
void ui__window_touch_scroll(gg__Event event, ui__UI* ui);
void ui__window_touch_swipe(gg__Event event, ui__UI* ui);
void ui__window_touch_tap_and_swipe(gg__Event event, ui__UI* ui);
void ui__window_files_droped(gg__Event event, ui__UI* ui);
void ui__Window_set_title(ui__Window* w, string title);
void ui__Window_refresh(ui__Window* w);
bool ui__Window_mouse_inside(ui__Window* w, int x, int y, int width, int height);
void ui__Window_on_click(ui__Window* w, void (*func)(ui__MouseEvent e, ui__Window* window));
void ui__Window_on_mousemove(ui__Window* w, void (*func)(ui__MouseMoveEvent e, ui__Window* window));
void ui__Window_on_scroll(ui__Window* w, void (*func)(ui__ScrollEvent e, ui__Window* window));
ui__Widget ui__Window_child(ui__Window* w, Array_int from);
bool ui__Window_is_registred(ui__Window* w, ui__Widget* widget);
void ui__Window_free(ui__Window* w);
ui__UI* ui__Window_get_ui(ui__Window* w);
voidptr ui__Window_get_state(ui__Window* w);
multi_return_int_int ui__Window_size(ui__Window* w);
Array_ui__Widget ui__Window_get_children(ui__Window* w);
eventbus__Subscriber* ui__Window_get_subscriber(ui__Window* w);
void ui__Window_resize(ui__Window* window, int w, int h);
void ui__Window_update_layout(ui__Window* w);
void ui__Window_update_layout_without_pos(ui__Window* w);
void ui__Window_draw(ui__Window* w);
bool ui__Window_unlocked_focus(ui__Window* w);
void ui__Window_focus_next(ui__Window* w);
void ui__Window_focus_prev(ui__Window* w);
void ui__Window_always_on_top(ui__Window* w, bool val);
void ui__Window_set_cursor(ui__Window* w, ui__Cursor cursor);
void ui__Window_onmousedown(ui__Window* w, voidptr cb);
void ui__Window_close(ui__Window* w);
void ui__Window_register_child(ui__Window* w, ui__Widget child_);
ui__Button* ui__Window_button(ui__Window* w, string id);
ui__Label* ui__Window_label(ui__Window* w, string id);
ui__ListBox* ui__Window_listbox(ui__Window* w, string id);
ui__Dropdown* ui__Window_dropdown(ui__Window* w, string id);
ui__TextBox* ui__Window_textbox(ui__Window* w, string id);
ui__Radio* ui__Window_radio(ui__Window* w, string id);
ui__CheckBox* ui__Window_checkbox(ui__Window* w, string id);
ui__Stack* ui__Window_stack(ui__Window* w, string id);
ui__Group* ui__Window_group(ui__Window* w, string id);
ui__CanvasLayout* ui__Window_canvas_layout(ui__Window* w, string id);
ui__Menu* ui__Window_menu(ui__Window* w, string id);
ui__Rectangle* ui__Window_rectangle(ui__Window* w, string id);
ui__SubWindow* ui__Window_subwindow(ui__Window* w, string id);
bool ui__KeyMod_is_empty(ui__KeyMod* e);
bool ui__KeyMod_has(ui__KeyMod* e, ui__KeyMod flag);
bool ui__KeyMod_all(ui__KeyMod* e, ui__KeyMod flag);
void ui__KeyMod_set(ui__KeyMod* e, ui__KeyMod flag);
void ui__KeyMod_clear(ui__KeyMod* e, ui__KeyMod flag);
void ui__KeyMod_toggle(ui__KeyMod* e, ui__KeyMod flag);
bool ui__TextBoxMode_is_empty(ui__TextBoxMode* e);
bool ui__TextBoxMode_has(ui__TextBoxMode* e, ui__TextBoxMode flag);
bool ui__TextBoxMode_all(ui__TextBoxMode* e, ui__TextBoxMode flag);
void ui__TextBoxMode_set(ui__TextBoxMode* e, ui__TextBoxMode flag);
void ui__TextBoxMode_clear(ui__TextBoxMode* e, ui__TextBoxMode flag);
void ui__TextBoxMode_toggle(ui__TextBoxMode* e, ui__TextBoxMode flag);
#define _const_main__win_width 780
#define _const_main__win_height 395
#define _const_main__nr_cols 4
#define _const_main__cell_height 25
#define _const_main__cell_width 100
#define _const_main__table_width 400
void main__main(void);
void main__menu_click(void);
void main__btn_help_click(voidptr a, ui__Button* b);
void main__btn_add_click(main__State* app, voidptr x);
void main__draw(ui__CanvasLayout* c, main__State* app);

static string time__FormatTime_str(time__FormatTime it); // auto
static string time__FormatDate_str(time__FormatDate it); // auto
static string sokol__sapp__EventType_str(sokol__sapp__EventType it); // auto
static string ui__Direction_str(ui__Direction it); // auto
static string Array_ui__ChildSize_str(Array_ui__ChildSize a); // auto
static string indent_Array_ui__ChildSize_str(Array_ui__ChildSize a, int indent_count); // auto
static string Array_f32_str(Array_f32 a); // auto
static string indent_Array_f32_str(Array_f32 a, int indent_count); // auto
static string gx__TextCfg_str(gx__TextCfg it); // auto
static string indent_gx__TextCfg_str(gx__TextCfg it, int indent_count); // auto
static string multi_return_int_int_str(multi_return_int_int a); // auto
static string Array_int_str(Array_int a); // auto
static string indent_Array_int_str(Array_int a, int indent_count); // auto
static string ui__ChildSize_str(ui__ChildSize it); // auto
static string gx__HorizontalAlign_str(gx__HorizontalAlign it); // auto
static string gx__VerticalAlign_str(gx__VerticalAlign it); // auto
static bool Array_rune_arr_eq(Array_rune a, Array_rune b); // auto
static bool time__Duration_alias_eq(time__Duration a, time__Duration b); // auto
static bool gx__Color_struct_eq(gx__Color a, gx__Color b); // auto
static bool ui__ColorThemeCfg_sumtype_eq(ui__ColorThemeCfg a, ui__ColorThemeCfg b); // auto
static bool ui__ColorTheme_alias_eq(ui__ColorTheme a, ui__ColorTheme b); // auto
static bool Map_int_gx__Color_map_eq(Map_int_gx__Color a, Map_int_gx__Color b); // auto

// V interface table:
static IError I_None___to_Interface_IError(None__* x);
const int _IError_None___index = 0;
static IError I_Error_to_Interface_IError(Error* x);
const int _IError_Error_index = 1;
static IError I_MessageError_to_Interface_IError(MessageError* x);
const int _IError_MessageError_index = 2;
static IError I_os__FileNotOpenedError_to_Interface_IError(os__FileNotOpenedError* x);
const int _IError_os__FileNotOpenedError_index = 3;
static IError I_os__SizeOfTypeIs0Error_to_Interface_IError(os__SizeOfTypeIs0Error* x);
const int _IError_os__SizeOfTypeIs0Error_index = 4;
static IError I_os__ExecutableNotFoundError_to_Interface_IError(os__ExecutableNotFoundError* x);
const int _IError_os__ExecutableNotFoundError_index = 5;
static IError I_time__TimeParseError_to_Interface_IError(time__TimeParseError* x);
const int _IError_time__TimeParseError_index = 6;
// ^^^ number of types for interface IError: 7

// Methods wrapper for interface "IError"
static inline string None___msg_Interface_IError_method_wrapper(None__* err) {
	return Error_msg(err->Error);
}
static inline int None___code_Interface_IError_method_wrapper(None__* err) {
	return Error_code(err->Error);
}
static inline string Error_msg_Interface_IError_method_wrapper(Error* err) {
	return Error_msg(*err);
}
static inline int Error_code_Interface_IError_method_wrapper(Error* err) {
	return Error_code(*err);
}
static inline string MessageError_msg_Interface_IError_method_wrapper(MessageError* err) {
	return MessageError_msg(*err);
}
static inline int MessageError_code_Interface_IError_method_wrapper(MessageError* err) {
	return MessageError_code(*err);
}
static inline string os__FileNotOpenedError_msg_Interface_IError_method_wrapper(os__FileNotOpenedError* err) {
	return os__FileNotOpenedError_msg(*err);
}
static inline int os__FileNotOpenedError_code_Interface_IError_method_wrapper(os__FileNotOpenedError* err) {
	return Error_code(err->Error);
}
static inline string os__SizeOfTypeIs0Error_msg_Interface_IError_method_wrapper(os__SizeOfTypeIs0Error* err) {
	return os__SizeOfTypeIs0Error_msg(*err);
}
static inline int os__SizeOfTypeIs0Error_code_Interface_IError_method_wrapper(os__SizeOfTypeIs0Error* err) {
	return Error_code(err->Error);
}
static inline string os__ExecutableNotFoundError_msg_Interface_IError_method_wrapper(os__ExecutableNotFoundError* err) {
	return os__ExecutableNotFoundError_msg(*err);
}
static inline int os__ExecutableNotFoundError_code_Interface_IError_method_wrapper(os__ExecutableNotFoundError* err) {
	return Error_code(err->Error);
}
static inline string time__TimeParseError_msg_Interface_IError_method_wrapper(time__TimeParseError* err) {
	return time__TimeParseError_msg(*err);
}
static inline int time__TimeParseError_code_Interface_IError_method_wrapper(time__TimeParseError* err) {
	return Error_code(err->Error);
}

struct _IError_interface_methods {
	string (*_method_msg)(void* _);
	int (*_method_code)(void* _);
};

struct _IError_interface_methods IError_name_table[7] = {
	{
		._method_msg = (void*) None___msg_Interface_IError_method_wrapper,
		._method_code = (void*) None___code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) Error_msg_Interface_IError_method_wrapper,
		._method_code = (void*) Error_code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) MessageError_msg_Interface_IError_method_wrapper,
		._method_code = (void*) MessageError_code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) os__FileNotOpenedError_msg_Interface_IError_method_wrapper,
		._method_code = (void*) os__FileNotOpenedError_code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) os__SizeOfTypeIs0Error_msg_Interface_IError_method_wrapper,
		._method_code = (void*) os__SizeOfTypeIs0Error_code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) os__ExecutableNotFoundError_msg_Interface_IError_method_wrapper,
		._method_code = (void*) os__ExecutableNotFoundError_code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) time__TimeParseError_msg_Interface_IError_method_wrapper,
		._method_code = (void*) time__TimeParseError_code_Interface_IError_method_wrapper,
	},
};


// Casting functions for converting "None__" to interface "IError"
static inline IError I_None___to_Interface_IError(None__* x) {
	return (IError) {
		._None__ = x,
		._typ = _IError_None___index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x),
	};
}

// Casting functions for converting "Error" to interface "IError"
static inline IError I_Error_to_Interface_IError(Error* x) {
	return (IError) {
		._Error = x,
		._typ = _IError_Error_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x),
	};
}

// Casting functions for converting "MessageError" to interface "IError"
static inline IError I_MessageError_to_Interface_IError(MessageError* x) {
	return (IError) {
		._MessageError = x,
		._typ = _IError_MessageError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, MessageError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, MessageError, code)),
	};
}

// Casting functions for converting "os__FileNotOpenedError" to interface "IError"
static inline IError I_os__FileNotOpenedError_to_Interface_IError(os__FileNotOpenedError* x) {
	return (IError) {
		._os__FileNotOpenedError = x,
		._typ = _IError_os__FileNotOpenedError_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x),
	};
}

// Casting functions for converting "os__SizeOfTypeIs0Error" to interface "IError"
static inline IError I_os__SizeOfTypeIs0Error_to_Interface_IError(os__SizeOfTypeIs0Error* x) {
	return (IError) {
		._os__SizeOfTypeIs0Error = x,
		._typ = _IError_os__SizeOfTypeIs0Error_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x),
	};
}

// Casting functions for converting "os__ExecutableNotFoundError" to interface "IError"
static inline IError I_os__ExecutableNotFoundError_to_Interface_IError(os__ExecutableNotFoundError* x) {
	return (IError) {
		._os__ExecutableNotFoundError = x,
		._typ = _IError_os__ExecutableNotFoundError_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x),
	};
}

// Casting functions for converting "time__TimeParseError" to interface "IError"
static inline IError I_time__TimeParseError_to_Interface_IError(time__TimeParseError* x) {
	return (IError) {
		._time__TimeParseError = x,
		._typ = _IError_time__TimeParseError_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x + __offsetof_ptr(x, time__TimeParseError, code)),
	};
}

static ui__Widget I_ui__Stack_to_Interface_ui__Widget(ui__Stack* x);
const int _ui__Widget_ui__Stack_index = 0;
static ui__Widget I_ui__Group_to_Interface_ui__Widget(ui__Group* x);
const int _ui__Widget_ui__Group_index = 1;
static ui__Widget I_ui__CanvasLayout_to_Interface_ui__Widget(ui__CanvasLayout* x);
const int _ui__Widget_ui__CanvasLayout_index = 2;
static ui__Widget I_ui__ListBox_to_Interface_ui__Widget(ui__ListBox* x);
const int _ui__Widget_ui__ListBox_index = 3;
static ui__Widget I_ui__TextBox_to_Interface_ui__Widget(ui__TextBox* x);
const int _ui__Widget_ui__TextBox_index = 4;
static ui__Widget I_ui__Label_to_Interface_ui__Widget(ui__Label* x);
const int _ui__Widget_ui__Label_index = 5;
static ui__Widget I_ui__Button_to_Interface_ui__Widget(ui__Button* x);
const int _ui__Widget_ui__Button_index = 6;
static ui__Widget I_ui__Canvas_to_Interface_ui__Widget(ui__Canvas* x);
const int _ui__Widget_ui__Canvas_index = 7;
static ui__Widget I_ui__CheckBox_to_Interface_ui__Widget(ui__CheckBox* x);
const int _ui__Widget_ui__CheckBox_index = 8;
static ui__Widget I_ui__Dropdown_to_Interface_ui__Widget(ui__Dropdown* x);
const int _ui__Widget_ui__Dropdown_index = 9;
static ui__Widget I_ui__Grid_to_Interface_ui__Widget(ui__Grid* x);
const int _ui__Widget_ui__Grid_index = 10;
static ui__Widget I_ui__Menu_to_Interface_ui__Widget(ui__Menu* x);
const int _ui__Widget_ui__Menu_index = 11;
static ui__Widget I_ui__Picture_to_Interface_ui__Widget(ui__Picture* x);
const int _ui__Widget_ui__Picture_index = 12;
static ui__Widget I_ui__ProgressBar_to_Interface_ui__Widget(ui__ProgressBar* x);
const int _ui__Widget_ui__ProgressBar_index = 13;
static ui__Widget I_ui__Radio_to_Interface_ui__Widget(ui__Radio* x);
const int _ui__Widget_ui__Radio_index = 14;
static ui__Widget I_ui__Rectangle_to_Interface_ui__Widget(ui__Rectangle* x);
const int _ui__Widget_ui__Rectangle_index = 15;
static ui__Widget I_ui__Slider_to_Interface_ui__Widget(ui__Slider* x);
const int _ui__Widget_ui__Slider_index = 16;
static ui__Widget I_ui__SubWindow_to_Interface_ui__Widget(ui__SubWindow* x);
const int _ui__Widget_ui__SubWindow_index = 17;
static ui__Widget I_ui__Switch_to_Interface_ui__Widget(ui__Switch* x);
const int _ui__Widget_ui__Switch_index = 18;
static ui__Widget I_ui__Transition_to_Interface_ui__Widget(ui__Transition* x);
const int _ui__Widget_ui__Transition_index = 19;
// ^^^ number of types for interface ui__Widget: 20

// Methods wrapper for interface "ui__Widget"

struct _ui__Widget_interface_methods {
	void (*_method_init)(void* _, ui__Layout );
	void (*_method_set_pos)(void* _, int x, int y);
	multi_return_int_int (*_method_propose_size)(void* _, int w, int h);
	multi_return_int_int (*_method_size)(void* _);
	bool (*_method_point_inside)(void* _, f64 x, f64 y);
	void (*_method_set_visible)(void* _, bool );
	void (*_method_draw)(void* _);
	void (*_method_cleanup)(void* _);
};

struct _ui__Widget_interface_methods ui__Widget_name_table[20] = {
	{
		._method_init = (void*) ui__Stack_init,
		._method_cleanup = (void*) ui__Stack_cleanup,
		._method_propose_size = (void*) ui__Stack_propose_size,
		._method_size = (void*) ui__Stack_size,
		._method_set_pos = (void*) ui__Stack_set_pos,
		._method_draw = (void*) ui__Stack_draw,
		._method_point_inside = (void*) ui__Stack_point_inside,
		._method_set_visible = (void*) ui__Stack_set_visible,
	},
	{
		._method_init = (void*) ui__Group_init,
		._method_cleanup = (void*) ui__Group_cleanup,
		._method_set_pos = (void*) ui__Group_set_pos,
		._method_draw = (void*) ui__Group_draw,
		._method_point_inside = (void*) ui__Group_point_inside,
		._method_set_visible = (void*) ui__Group_set_visible,
		._method_propose_size = (void*) ui__Group_propose_size,
		._method_size = (void*) ui__Group_size,
	},
	{
		._method_init = (void*) ui__CanvasLayout_init,
		._method_cleanup = (void*) ui__CanvasLayout_cleanup,
		._method_set_pos = (void*) ui__CanvasLayout_set_pos,
		._method_size = (void*) ui__CanvasLayout_size,
		._method_propose_size = (void*) ui__CanvasLayout_propose_size,
		._method_draw = (void*) ui__CanvasLayout_draw,
		._method_set_visible = (void*) ui__CanvasLayout_set_visible,
		._method_point_inside = (void*) ui__CanvasLayout_point_inside,
	},
	{
		._method_init = (void*) ui__ListBox_init,
		._method_cleanup = (void*) ui__ListBox_cleanup,
		._method_draw = (void*) ui__ListBox_draw,
		._method_point_inside = (void*) ui__ListBox_point_inside,
		._method_set_pos = (void*) ui__ListBox_set_pos,
		._method_set_visible = (void*) ui__ListBox_set_visible,
		._method_size = (void*) ui__ListBox_size,
		._method_propose_size = (void*) ui__ListBox_propose_size,
	},
	{
		._method_init = (void*) ui__TextBox_init,
		._method_cleanup = (void*) ui__TextBox_cleanup,
		._method_set_pos = (void*) ui__TextBox_set_pos,
		._method_size = (void*) ui__TextBox_size,
		._method_propose_size = (void*) ui__TextBox_propose_size,
		._method_draw = (void*) ui__TextBox_draw,
		._method_point_inside = (void*) ui__TextBox_point_inside,
		._method_set_visible = (void*) ui__TextBox_set_visible,
	},
	{
		._method_init = (void*) ui__Label_init,
		._method_cleanup = (void*) ui__Label_cleanup,
		._method_set_pos = (void*) ui__Label_set_pos,
		._method_size = (void*) ui__Label_size,
		._method_propose_size = (void*) ui__Label_propose_size,
		._method_draw = (void*) ui__Label_draw,
		._method_set_visible = (void*) ui__Label_set_visible,
		._method_point_inside = (void*) ui__Label_point_inside,
	},
	{
		._method_init = (void*) ui__Button_init,
		._method_cleanup = (void*) ui__Button_cleanup,
		._method_set_pos = (void*) ui__Button_set_pos,
		._method_size = (void*) ui__Button_size,
		._method_propose_size = (void*) ui__Button_propose_size,
		._method_draw = (void*) ui__Button_draw,
		._method_point_inside = (void*) ui__Button_point_inside,
		._method_set_visible = (void*) ui__Button_set_visible,
	},
	{
		._method_init = (void*) ui__Canvas_init,
		._method_cleanup = (void*) ui__Canvas_cleanup,
		._method_set_pos = (void*) ui__Canvas_set_pos,
		._method_size = (void*) ui__Canvas_size,
		._method_propose_size = (void*) ui__Canvas_propose_size,
		._method_draw = (void*) ui__Canvas_draw,
		._method_set_visible = (void*) ui__Canvas_set_visible,
		._method_point_inside = (void*) ui__Canvas_point_inside,
	},
	{
		._method_init = (void*) ui__CheckBox_init,
		._method_cleanup = (void*) ui__CheckBox_cleanup,
		._method_set_pos = (void*) ui__CheckBox_set_pos,
		._method_size = (void*) ui__CheckBox_size,
		._method_propose_size = (void*) ui__CheckBox_propose_size,
		._method_draw = (void*) ui__CheckBox_draw,
		._method_point_inside = (void*) ui__CheckBox_point_inside,
		._method_set_visible = (void*) ui__CheckBox_set_visible,
	},
	{
		._method_init = (void*) ui__Dropdown_init,
		._method_cleanup = (void*) ui__Dropdown_cleanup,
		._method_set_pos = (void*) ui__Dropdown_set_pos,
		._method_size = (void*) ui__Dropdown_size,
		._method_propose_size = (void*) ui__Dropdown_propose_size,
		._method_draw = (void*) ui__Dropdown_draw,
		._method_set_visible = (void*) ui__Dropdown_set_visible,
		._method_point_inside = (void*) ui__Dropdown_point_inside,
	},
	{
		._method_init = (void*) ui__Grid_init,
		._method_cleanup = (void*) ui__Grid_cleanup,
		._method_draw = (void*) ui__Grid_draw,
		._method_set_visible = (void*) ui__Grid_set_visible,
		._method_set_pos = (void*) ui__Grid_set_pos,
		._method_size = (void*) ui__Grid_size,
		._method_propose_size = (void*) ui__Grid_propose_size,
		._method_point_inside = (void*) ui__Grid_point_inside,
	},
	{
		._method_init = (void*) ui__Menu_init,
		._method_cleanup = (void*) ui__Menu_cleanup,
		._method_set_pos = (void*) ui__Menu_set_pos,
		._method_size = (void*) ui__Menu_size,
		._method_propose_size = (void*) ui__Menu_propose_size,
		._method_draw = (void*) ui__Menu_draw,
		._method_set_visible = (void*) ui__Menu_set_visible,
		._method_point_inside = (void*) ui__Menu_point_inside,
	},
	{
		._method_init = (void*) ui__Picture_init,
		._method_cleanup = (void*) ui__Picture_cleanup,
		._method_set_pos = (void*) ui__Picture_set_pos,
		._method_size = (void*) ui__Picture_size,
		._method_propose_size = (void*) ui__Picture_propose_size,
		._method_draw = (void*) ui__Picture_draw,
		._method_set_visible = (void*) ui__Picture_set_visible,
		._method_point_inside = (void*) ui__Picture_point_inside,
	},
	{
		._method_init = (void*) ui__ProgressBar_init,
		._method_cleanup = (void*) ui__ProgressBar_cleanup,
		._method_set_pos = (void*) ui__ProgressBar_set_pos,
		._method_size = (void*) ui__ProgressBar_size,
		._method_propose_size = (void*) ui__ProgressBar_propose_size,
		._method_draw = (void*) ui__ProgressBar_draw,
		._method_point_inside = (void*) ui__ProgressBar_point_inside,
		._method_set_visible = (void*) ui__ProgressBar_set_visible,
	},
	{
		._method_init = (void*) ui__Radio_init,
		._method_cleanup = (void*) ui__Radio_cleanup,
		._method_set_pos = (void*) ui__Radio_set_pos,
		._method_size = (void*) ui__Radio_size,
		._method_propose_size = (void*) ui__Radio_propose_size,
		._method_draw = (void*) ui__Radio_draw,
		._method_point_inside = (void*) ui__Radio_point_inside,
		._method_set_visible = (void*) ui__Radio_set_visible,
	},
	{
		._method_init = (void*) ui__Rectangle_init,
		._method_cleanup = (void*) ui__Rectangle_cleanup,
		._method_set_pos = (void*) ui__Rectangle_set_pos,
		._method_size = (void*) ui__Rectangle_size,
		._method_propose_size = (void*) ui__Rectangle_propose_size,
		._method_draw = (void*) ui__Rectangle_draw,
		._method_set_visible = (void*) ui__Rectangle_set_visible,
		._method_point_inside = (void*) ui__Rectangle_point_inside,
	},
	{
		._method_init = (void*) ui__Slider_init,
		._method_cleanup = (void*) ui__Slider_cleanup,
		._method_set_pos = (void*) ui__Slider_set_pos,
		._method_size = (void*) ui__Slider_size,
		._method_propose_size = (void*) ui__Slider_propose_size,
		._method_draw = (void*) ui__Slider_draw,
		._method_point_inside = (void*) ui__Slider_point_inside,
		._method_set_visible = (void*) ui__Slider_set_visible,
	},
	{
		._method_init = (void*) ui__SubWindow_init,
		._method_cleanup = (void*) ui__SubWindow_cleanup,
		._method_draw = (void*) ui__SubWindow_draw,
		._method_point_inside = (void*) ui__SubWindow_point_inside,
		._method_set_pos = (void*) ui__SubWindow_set_pos,
		._method_propose_size = (void*) ui__SubWindow_propose_size,
		._method_size = (void*) ui__SubWindow_size,
		._method_set_visible = (void*) ui__SubWindow_set_visible,
	},
	{
		._method_init = (void*) ui__Switch_init,
		._method_cleanup = (void*) ui__Switch_cleanup,
		._method_set_pos = (void*) ui__Switch_set_pos,
		._method_size = (void*) ui__Switch_size,
		._method_propose_size = (void*) ui__Switch_propose_size,
		._method_draw = (void*) ui__Switch_draw,
		._method_point_inside = (void*) ui__Switch_point_inside,
		._method_set_visible = (void*) ui__Switch_set_visible,
	},
	{
		._method_init = (void*) ui__Transition_init,
		._method_cleanup = (void*) ui__Transition_cleanup,
		._method_set_pos = (void*) ui__Transition_set_pos,
		._method_propose_size = (void*) ui__Transition_propose_size,
		._method_size = (void*) ui__Transition_size,
		._method_draw = (void*) ui__Transition_draw,
		._method_set_visible = (void*) ui__Transition_set_visible,
		._method_point_inside = (void*) ui__Transition_point_inside,
	},
};


// Casting functions for converting "ui__Stack" to interface "ui__Widget"
static inline ui__Widget I_ui__Stack_to_Interface_ui__Widget(ui__Stack* x) {
	return (ui__Widget) {
		._ui__Stack = x,
		._typ = _ui__Widget_ui__Stack_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Stack, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__Stack, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__Stack, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__Stack, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__Stack, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__Stack, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Stack, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__Stack, parent)),
	};
}

// Casting functions for converting "ui__Group" to interface "ui__Widget"
static inline ui__Widget I_ui__Group_to_Interface_ui__Widget(ui__Group* x) {
	return (ui__Widget) {
		._ui__Group = x,
		._typ = _ui__Widget_ui__Group_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Group, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__Group, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__Group, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__Group, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__Group, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__Group, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Group, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__Group, parent)),
	};
}

// Casting functions for converting "ui__CanvasLayout" to interface "ui__Widget"
static inline ui__Widget I_ui__CanvasLayout_to_Interface_ui__Widget(ui__CanvasLayout* x) {
	return (ui__Widget) {
		._ui__CanvasLayout = x,
		._typ = _ui__Widget_ui__CanvasLayout_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, parent)),
	};
}

// Casting functions for converting "ui__ListBox" to interface "ui__Widget"
static inline ui__Widget I_ui__ListBox_to_Interface_ui__Widget(ui__ListBox* x) {
	return (ui__Widget) {
		._ui__ListBox = x,
		._typ = _ui__Widget_ui__ListBox_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__ListBox, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__ListBox, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__ListBox, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__ListBox, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__ListBox, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__ListBox, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__ListBox, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__ListBox, parent)),
	};
}

// Casting functions for converting "ui__TextBox" to interface "ui__Widget"
static inline ui__Widget I_ui__TextBox_to_Interface_ui__Widget(ui__TextBox* x) {
	return (ui__Widget) {
		._ui__TextBox = x,
		._typ = _ui__Widget_ui__TextBox_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__TextBox, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__TextBox, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__TextBox, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__TextBox, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__TextBox, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__TextBox, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__TextBox, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__TextBox, parent)),
	};
}

// Casting functions for converting "ui__Label" to interface "ui__Widget"
static inline ui__Widget I_ui__Label_to_Interface_ui__Widget(ui__Label* x) {
	return (ui__Widget) {
		._ui__Label = x,
		._typ = _ui__Widget_ui__Label_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Label, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__Label, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__Label, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__Label, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__Label, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__Label, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Label, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__Label, parent)),
	};
}

// Casting functions for converting "ui__Button" to interface "ui__Widget"
static inline ui__Widget I_ui__Button_to_Interface_ui__Widget(ui__Button* x) {
	return (ui__Widget) {
		._ui__Button = x,
		._typ = _ui__Widget_ui__Button_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Button, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__Button, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__Button, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__Button, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__Button, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__Button, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Button, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__Button, parent)),
	};
}

// Casting functions for converting "ui__Canvas" to interface "ui__Widget"
static inline ui__Widget I_ui__Canvas_to_Interface_ui__Widget(ui__Canvas* x) {
	return (ui__Widget) {
		._ui__Canvas = x,
		._typ = _ui__Widget_ui__Canvas_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Canvas, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__Canvas, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__Canvas, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__Canvas, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__Canvas, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__Canvas, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Canvas, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__Canvas, parent)),
	};
}

// Casting functions for converting "ui__CheckBox" to interface "ui__Widget"
static inline ui__Widget I_ui__CheckBox_to_Interface_ui__Widget(ui__CheckBox* x) {
	return (ui__Widget) {
		._ui__CheckBox = x,
		._typ = _ui__Widget_ui__CheckBox_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__CheckBox, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__CheckBox, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__CheckBox, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__CheckBox, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__CheckBox, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__CheckBox, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__CheckBox, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__CheckBox, parent)),
	};
}

// Casting functions for converting "ui__Dropdown" to interface "ui__Widget"
static inline ui__Widget I_ui__Dropdown_to_Interface_ui__Widget(ui__Dropdown* x) {
	return (ui__Widget) {
		._ui__Dropdown = x,
		._typ = _ui__Widget_ui__Dropdown_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Dropdown, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__Dropdown, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__Dropdown, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__Dropdown, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__Dropdown, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__Dropdown, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Dropdown, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__Dropdown, parent)),
	};
}

// Casting functions for converting "ui__Grid" to interface "ui__Widget"
static inline ui__Widget I_ui__Grid_to_Interface_ui__Widget(ui__Grid* x) {
	return (ui__Widget) {
		._ui__Grid = x,
		._typ = _ui__Widget_ui__Grid_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Grid, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__Grid, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__Grid, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__Grid, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__Grid, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__Grid, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Grid, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__Grid, parent)),
	};
}

// Casting functions for converting "ui__Menu" to interface "ui__Widget"
static inline ui__Widget I_ui__Menu_to_Interface_ui__Widget(ui__Menu* x) {
	return (ui__Widget) {
		._ui__Menu = x,
		._typ = _ui__Widget_ui__Menu_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Menu, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__Menu, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__Menu, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__Menu, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__Menu, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__Menu, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Menu, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__Menu, parent)),
	};
}

// Casting functions for converting "ui__Picture" to interface "ui__Widget"
static inline ui__Widget I_ui__Picture_to_Interface_ui__Widget(ui__Picture* x) {
	return (ui__Widget) {
		._ui__Picture = x,
		._typ = _ui__Widget_ui__Picture_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Picture, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__Picture, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__Picture, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__Picture, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__Picture, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__Picture, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Picture, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__Picture, parent)),
	};
}

// Casting functions for converting "ui__ProgressBar" to interface "ui__Widget"
static inline ui__Widget I_ui__ProgressBar_to_Interface_ui__Widget(ui__ProgressBar* x) {
	return (ui__Widget) {
		._ui__ProgressBar = x,
		._typ = _ui__Widget_ui__ProgressBar_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__ProgressBar, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__ProgressBar, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__ProgressBar, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__ProgressBar, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__ProgressBar, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__ProgressBar, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__ProgressBar, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__ProgressBar, parent)),
	};
}

// Casting functions for converting "ui__Radio" to interface "ui__Widget"
static inline ui__Widget I_ui__Radio_to_Interface_ui__Widget(ui__Radio* x) {
	return (ui__Widget) {
		._ui__Radio = x,
		._typ = _ui__Widget_ui__Radio_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Radio, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__Radio, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__Radio, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__Radio, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__Radio, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__Radio, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Radio, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__Radio, parent)),
	};
}

// Casting functions for converting "ui__Rectangle" to interface "ui__Widget"
static inline ui__Widget I_ui__Rectangle_to_Interface_ui__Widget(ui__Rectangle* x) {
	return (ui__Widget) {
		._ui__Rectangle = x,
		._typ = _ui__Widget_ui__Rectangle_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Rectangle, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__Rectangle, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__Rectangle, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__Rectangle, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__Rectangle, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__Rectangle, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Rectangle, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__Rectangle, parent)),
	};
}

// Casting functions for converting "ui__Slider" to interface "ui__Widget"
static inline ui__Widget I_ui__Slider_to_Interface_ui__Widget(ui__Slider* x) {
	return (ui__Widget) {
		._ui__Slider = x,
		._typ = _ui__Widget_ui__Slider_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Slider, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__Slider, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__Slider, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__Slider, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__Slider, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__Slider, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Slider, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__Slider, parent)),
	};
}

// Casting functions for converting "ui__SubWindow" to interface "ui__Widget"
static inline ui__Widget I_ui__SubWindow_to_Interface_ui__Widget(ui__SubWindow* x) {
	return (ui__Widget) {
		._ui__SubWindow = x,
		._typ = _ui__Widget_ui__SubWindow_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__SubWindow, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__SubWindow, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__SubWindow, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__SubWindow, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__SubWindow, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__SubWindow, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__SubWindow, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__SubWindow, parent)),
	};
}

// Casting functions for converting "ui__Switch" to interface "ui__Widget"
static inline ui__Widget I_ui__Switch_to_Interface_ui__Widget(ui__Switch* x) {
	return (ui__Widget) {
		._ui__Switch = x,
		._typ = _ui__Widget_ui__Switch_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Switch, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__Switch, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__Switch, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__Switch, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__Switch, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__Switch, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Switch, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__Switch, parent)),
	};
}

// Casting functions for converting "ui__Transition" to interface "ui__Widget"
static inline ui__Widget I_ui__Transition_to_Interface_ui__Widget(ui__Transition* x) {
	return (ui__Widget) {
		._ui__Transition = x,
		._typ = _ui__Widget_ui__Transition_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Transition, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__Transition, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__Transition, y)),
		.z_index = (int*)((char*)x + __offsetof_ptr(x, ui__Transition, z_index)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__Transition, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__Transition, offset_y)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Transition, hidden)),
		.parent = (ui__Layout*)((char*)x + __offsetof_ptr(x, ui__Transition, parent)),
	};
}

static ui__DrawText I_ui__Tooltip_to_Interface_ui__DrawText(ui__Tooltip* x);
const int _ui__DrawText_ui__Tooltip_index = 0;
static ui__DrawText I_ui__Button_to_Interface_ui__DrawText(ui__Button* x);
const int _ui__DrawText_ui__Button_index = 1;
static ui__DrawText I_ui__Menu_to_Interface_ui__DrawText(ui__Menu* x);
const int _ui__DrawText_ui__Menu_index = 2;
static ui__DrawText I_ui__Rectangle_to_Interface_ui__DrawText(ui__Rectangle* x);
const int _ui__DrawText_ui__Rectangle_index = 3;
static ui__DrawText I_ui__TextBox_to_Interface_ui__DrawText(ui__TextBox* x);
const int _ui__DrawText_ui__TextBox_index = 4;
static ui__DrawText I_ui__Label_to_Interface_ui__DrawText(ui__Label* x);
const int _ui__DrawText_ui__Label_index = 5;
static ui__DrawText I_voidptr_to_Interface_ui__DrawText(voidptr* x);
const int _ui__DrawText_voidptr_index = 6;
static ui__DrawText I_ui__Radio_to_Interface_ui__DrawText(ui__Radio* x);
const int _ui__DrawText_ui__Radio_index = 7;
static ui__DrawText I_ui__ListBox_to_Interface_ui__DrawText(ui__ListBox* x);
const int _ui__DrawText_ui__ListBox_index = 8;
static ui__DrawText I_ui__CheckBox_to_Interface_ui__DrawText(ui__CheckBox* x);
const int _ui__DrawText_ui__CheckBox_index = 9;
// ^^^ number of types for interface ui__DrawText: 10


// Casting functions for converting "ui__Tooltip" to interface "ui__DrawText"
static inline ui__DrawText I_ui__Tooltip_to_Interface_ui__DrawText(ui__Tooltip* x) {
	return (ui__DrawText) {
		._ui__Tooltip = x,
		._typ = _ui__DrawText_ui__Tooltip_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Tooltip, ui)),
		.text_cfg = (gx__TextCfg*)((char*)x + __offsetof_ptr(x, ui__Tooltip, TextLines) + __offsetof_ptr(x, ui__TextLines, text_cfg)),
		.text_size = (f64*)((char*)x + __offsetof_ptr(x, ui__Tooltip, TextLines) + __offsetof_ptr(x, ui__TextLines, text_size)),
	};
}

// Casting functions for converting "ui__Button" to interface "ui__DrawText"
static inline ui__DrawText I_ui__Button_to_Interface_ui__DrawText(ui__Button* x) {
	return (ui__DrawText) {
		._ui__Button = x,
		._typ = _ui__DrawText_ui__Button_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Button, ui)),
		.text_cfg = (gx__TextCfg*)((char*)x + __offsetof_ptr(x, ui__Button, text_cfg)),
		.text_size = (f64*)((char*)x + __offsetof_ptr(x, ui__Button, text_size)),
	};
}

// Casting functions for converting "ui__Menu" to interface "ui__DrawText"
static inline ui__DrawText I_ui__Menu_to_Interface_ui__DrawText(ui__Menu* x) {
	return (ui__DrawText) {
		._ui__Menu = x,
		._typ = _ui__DrawText_ui__Menu_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Menu, ui)),
		.text_cfg = (gx__TextCfg*)((char*)x + __offsetof_ptr(x, ui__Menu, text_cfg)),
		.text_size = (f64*)((char*)x + __offsetof_ptr(x, ui__Menu, text_size)),
	};
}

// Casting functions for converting "ui__Rectangle" to interface "ui__DrawText"
static inline ui__DrawText I_ui__Rectangle_to_Interface_ui__DrawText(ui__Rectangle* x) {
	return (ui__DrawText) {
		._ui__Rectangle = x,
		._typ = _ui__DrawText_ui__Rectangle_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Rectangle, ui)),
		.text_cfg = (gx__TextCfg*)((char*)x + __offsetof_ptr(x, ui__Rectangle, text_cfg)),
		.text_size = (f64*)((char*)x + __offsetof_ptr(x, ui__Rectangle, text_size)),
	};
}

// Casting functions for converting "ui__TextBox" to interface "ui__DrawText"
static inline ui__DrawText I_ui__TextBox_to_Interface_ui__DrawText(ui__TextBox* x) {
	return (ui__DrawText) {
		._ui__TextBox = x,
		._typ = _ui__DrawText_ui__TextBox_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__TextBox, ui)),
		.text_cfg = (gx__TextCfg*)((char*)x + __offsetof_ptr(x, ui__TextBox, text_cfg)),
		.text_size = (f64*)((char*)x + __offsetof_ptr(x, ui__TextBox, text_size)),
	};
}

// Casting functions for converting "ui__Label" to interface "ui__DrawText"
static inline ui__DrawText I_ui__Label_to_Interface_ui__DrawText(ui__Label* x) {
	return (ui__DrawText) {
		._ui__Label = x,
		._typ = _ui__DrawText_ui__Label_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Label, ui)),
		.text_cfg = (gx__TextCfg*)((char*)x + __offsetof_ptr(x, ui__Label, text_cfg)),
		.text_size = (f64*)((char*)x + __offsetof_ptr(x, ui__Label, text_size)),
	};
}

// Casting functions for converting "voidptr" to interface "ui__DrawText"
static inline ui__DrawText I_voidptr_to_Interface_ui__DrawText(voidptr* x) {
	return (ui__DrawText) {
		._voidptr = x,
		._typ = _ui__DrawText_voidptr_index,
		.ui = (ui__UI**)((char*)x/*.... ast.voidptr_type */),
		.text_cfg = (gx__TextCfg*)((char*)x/*.... ast.voidptr_type */),
		.text_size = (f64*)((char*)x/*.... ast.voidptr_type */),
	};
}

// Casting functions for converting "ui__Radio" to interface "ui__DrawText"
static inline ui__DrawText I_ui__Radio_to_Interface_ui__DrawText(ui__Radio* x) {
	return (ui__DrawText) {
		._ui__Radio = x,
		._typ = _ui__DrawText_ui__Radio_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Radio, ui)),
		.text_cfg = (gx__TextCfg*)((char*)x + __offsetof_ptr(x, ui__Radio, text_cfg)),
		.text_size = (f64*)((char*)x + __offsetof_ptr(x, ui__Radio, text_size)),
	};
}

// Casting functions for converting "ui__ListBox" to interface "ui__DrawText"
static inline ui__DrawText I_ui__ListBox_to_Interface_ui__DrawText(ui__ListBox* x) {
	return (ui__DrawText) {
		._ui__ListBox = x,
		._typ = _ui__DrawText_ui__ListBox_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__ListBox, ui)),
		.text_cfg = (gx__TextCfg*)((char*)x + __offsetof_ptr(x, ui__ListBox, text_cfg)),
		.text_size = (f64*)((char*)x + __offsetof_ptr(x, ui__ListBox, text_size)),
	};
}

// Casting functions for converting "ui__CheckBox" to interface "ui__DrawText"
static inline ui__DrawText I_ui__CheckBox_to_Interface_ui__DrawText(ui__CheckBox* x) {
	return (ui__DrawText) {
		._ui__CheckBox = x,
		._typ = _ui__DrawText_ui__CheckBox_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__CheckBox, ui)),
		.text_cfg = (gx__TextCfg*)((char*)x + __offsetof_ptr(x, ui__CheckBox, text_cfg)),
		.text_size = (f64*)((char*)x + __offsetof_ptr(x, ui__CheckBox, text_size)),
	};
}

static ui__ScrollableWidget I_ui__Stack_to_Interface_ui__ScrollableWidget(ui__Stack* x);
const int _ui__ScrollableWidget_ui__Stack_index = 0;
static ui__ScrollableWidget I_ui__CanvasLayout_to_Interface_ui__ScrollableWidget(ui__CanvasLayout* x);
const int _ui__ScrollableWidget_ui__CanvasLayout_index = 1;
static ui__ScrollableWidget I_ui__ListBox_to_Interface_ui__ScrollableWidget(ui__ListBox* x);
const int _ui__ScrollableWidget_ui__ListBox_index = 2;
static ui__ScrollableWidget I_ui__TextBox_to_Interface_ui__ScrollableWidget(ui__TextBox* x);
const int _ui__ScrollableWidget_ui__TextBox_index = 3;
// ^^^ number of types for interface ui__ScrollableWidget: 4

// Methods wrapper for interface "ui__ScrollableWidget"

struct _ui__ScrollableWidget_interface_methods {
	multi_return_int_int (*_method_adj_size)(void* _);
	multi_return_int_int (*_method_size)(void* _);
};

struct _ui__ScrollableWidget_interface_methods ui__ScrollableWidget_name_table[4] = {
	{
		._method_adj_size = (void*) ui__Stack_adj_size,
		._method_size = (void*) ui__Stack_size,
	},
	{
		._method_adj_size = (void*) ui__CanvasLayout_adj_size,
		._method_size = (void*) ui__CanvasLayout_size,
	},
	{
		._method_adj_size = (void*) ui__ListBox_adj_size,
		._method_size = (void*) ui__ListBox_size,
	},
	{
		._method_adj_size = (void*) ui__TextBox_adj_size,
		._method_size = (void*) ui__TextBox_size,
	},
};


// Casting functions for converting "ui__Stack" to interface "ui__ScrollableWidget"
static inline ui__ScrollableWidget I_ui__Stack_to_Interface_ui__ScrollableWidget(ui__Stack* x) {
	return (ui__ScrollableWidget) {
		._ui__Stack = x,
		._typ = _ui__ScrollableWidget_ui__Stack_index,
		.has_scrollview = (bool*)((char*)x + __offsetof_ptr(x, ui__Stack, has_scrollview)),
		.scrollview = (ui__ScrollView**)((char*)x + __offsetof_ptr(x, ui__Stack, scrollview)),
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Stack, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__Stack, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__Stack, y)),
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Stack, ui)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__Stack, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__Stack, offset_y)),
		.on_scroll_change = (ui__ScrollViewChangedFn*)((char*)x + __offsetof_ptr(x, ui__Stack, on_scroll_change)),
	};
}

// Casting functions for converting "ui__CanvasLayout" to interface "ui__ScrollableWidget"
static inline ui__ScrollableWidget I_ui__CanvasLayout_to_Interface_ui__ScrollableWidget(ui__CanvasLayout* x) {
	return (ui__ScrollableWidget) {
		._ui__CanvasLayout = x,
		._typ = _ui__ScrollableWidget_ui__CanvasLayout_index,
		.has_scrollview = (bool*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, has_scrollview)),
		.scrollview = (ui__ScrollView**)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, scrollview)),
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, y)),
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, ui)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, offset_y)),
		.on_scroll_change = (ui__ScrollViewChangedFn*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, on_scroll_change)),
	};
}

// Casting functions for converting "ui__ListBox" to interface "ui__ScrollableWidget"
static inline ui__ScrollableWidget I_ui__ListBox_to_Interface_ui__ScrollableWidget(ui__ListBox* x) {
	return (ui__ScrollableWidget) {
		._ui__ListBox = x,
		._typ = _ui__ScrollableWidget_ui__ListBox_index,
		.has_scrollview = (bool*)((char*)x + __offsetof_ptr(x, ui__ListBox, has_scrollview)),
		.scrollview = (ui__ScrollView**)((char*)x + __offsetof_ptr(x, ui__ListBox, scrollview)),
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__ListBox, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__ListBox, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__ListBox, y)),
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__ListBox, ui)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__ListBox, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__ListBox, offset_y)),
		.on_scroll_change = (ui__ScrollViewChangedFn*)((char*)x + __offsetof_ptr(x, ui__ListBox, on_scroll_change)),
	};
}

// Casting functions for converting "ui__TextBox" to interface "ui__ScrollableWidget"
static inline ui__ScrollableWidget I_ui__TextBox_to_Interface_ui__ScrollableWidget(ui__TextBox* x) {
	return (ui__ScrollableWidget) {
		._ui__TextBox = x,
		._typ = _ui__ScrollableWidget_ui__TextBox_index,
		.has_scrollview = (bool*)((char*)x + __offsetof_ptr(x, ui__TextBox, has_scrollview)),
		.scrollview = (ui__ScrollView**)((char*)x + __offsetof_ptr(x, ui__TextBox, scrollview)),
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__TextBox, id)),
		.x = (int*)((char*)x + __offsetof_ptr(x, ui__TextBox, x)),
		.y = (int*)((char*)x + __offsetof_ptr(x, ui__TextBox, y)),
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__TextBox, ui)),
		.offset_x = (int*)((char*)x + __offsetof_ptr(x, ui__TextBox, offset_x)),
		.offset_y = (int*)((char*)x + __offsetof_ptr(x, ui__TextBox, offset_y)),
		.on_scroll_change = (ui__ScrollViewChangedFn*)((char*)x + __offsetof_ptr(x, ui__TextBox, on_scroll_change)),
	};
}

static ui__Layout I_ui__Stack_to_Interface_ui__Layout(ui__Stack* x);
const int _ui__Layout_ui__Stack_index = 0;
static ui__Layout I_ui__Window_to_Interface_ui__Layout(ui__Window* x);
const int _ui__Layout_ui__Window_index = 1;
static ui__Layout I_ui__CanvasLayout_to_Interface_ui__Layout(ui__CanvasLayout* x);
const int _ui__Layout_ui__CanvasLayout_index = 2;
static ui__Layout I_ui__Group_to_Interface_ui__Layout(ui__Group* x);
const int _ui__Layout_ui__Group_index = 3;
static ui__Layout I_ui__SubWindow_to_Interface_ui__Layout(ui__SubWindow* x);
const int _ui__Layout_ui__SubWindow_index = 4;
// ^^^ number of types for interface ui__Layout: 5

// Methods wrapper for interface "ui__Layout"

struct _ui__Layout_interface_methods {
	ui__UI* (*_method_get_ui)(void* _);
	voidptr (*_method_get_state)(void* _);
	multi_return_int_int (*_method_size)(void* _);
	Array_ui__Widget (*_method_get_children)(void* _);
	eventbus__Subscriber* (*_method_get_subscriber)(void* _);
	void (*_method_resize)(void* _, int w, int h);
	void (*_method_update_layout)(void* _);
	void (*_method_draw)(void* _);
};

struct _ui__Layout_interface_methods ui__Layout_name_table[5] = {
	{
		._method_update_layout = (void*) ui__Stack_update_layout,
		._method_size = (void*) ui__Stack_size,
		._method_get_subscriber = (void*) ui__Stack_get_subscriber,
		._method_draw = (void*) ui__Stack_draw,
		._method_get_ui = (void*) ui__Stack_get_ui,
		._method_get_state = (void*) ui__Stack_get_state,
		._method_resize = (void*) ui__Stack_resize,
		._method_get_children = (void*) ui__Stack_get_children,
	},
	{
		._method_get_ui = (void*) ui__Window_get_ui,
		._method_get_state = (void*) ui__Window_get_state,
		._method_size = (void*) ui__Window_size,
		._method_get_children = (void*) ui__Window_get_children,
		._method_get_subscriber = (void*) ui__Window_get_subscriber,
		._method_resize = (void*) ui__Window_resize,
		._method_update_layout = (void*) ui__Window_update_layout,
		._method_draw = (void*) ui__Window_draw,
	},
	{
		._method_update_layout = (void*) ui__CanvasLayout_update_layout,
		._method_size = (void*) ui__CanvasLayout_size,
		._method_draw = (void*) ui__CanvasLayout_draw,
		._method_get_ui = (void*) ui__CanvasLayout_get_ui,
		._method_resize = (void*) ui__CanvasLayout_resize,
		._method_get_state = (void*) ui__CanvasLayout_get_state,
		._method_get_subscriber = (void*) ui__CanvasLayout_get_subscriber,
		._method_get_children = (void*) ui__CanvasLayout_get_children,
	},
	{
		._method_draw = (void*) ui__Group_draw,
		._method_get_ui = (void*) ui__Group_get_ui,
		._method_resize = (void*) ui__Group_resize,
		._method_get_state = (void*) ui__Group_get_state,
		._method_get_subscriber = (void*) ui__Group_get_subscriber,
		._method_size = (void*) ui__Group_size,
		._method_get_children = (void*) ui__Group_get_children,
		._method_update_layout = (void*) ui__Group_update_layout,
	},
	{
		._method_draw = (void*) ui__SubWindow_draw,
		._method_update_layout = (void*) ui__SubWindow_update_layout,
		._method_size = (void*) ui__SubWindow_size,
		._method_get_ui = (void*) ui__SubWindow_get_ui,
		._method_get_state = (void*) ui__SubWindow_get_state,
		._method_get_subscriber = (void*) ui__SubWindow_get_subscriber,
		._method_resize = (void*) ui__SubWindow_resize,
		._method_get_children = (void*) ui__SubWindow_get_children,
	},
};


// Casting functions for converting "ui__Stack" to interface "ui__Layout"
static inline ui__Layout I_ui__Stack_to_Interface_ui__Layout(ui__Stack* x) {
	return (ui__Layout) {
		._ui__Stack = x,
		._typ = _ui__Layout_ui__Stack_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Stack, id)),
	};
}

// Casting functions for converting "ui__Window" to interface "ui__Layout"
static inline ui__Layout I_ui__Window_to_Interface_ui__Layout(ui__Window* x) {
	return (ui__Layout) {
		._ui__Window = x,
		._typ = _ui__Layout_ui__Window_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Window, id)),
	};
}

// Casting functions for converting "ui__CanvasLayout" to interface "ui__Layout"
static inline ui__Layout I_ui__CanvasLayout_to_Interface_ui__Layout(ui__CanvasLayout* x) {
	return (ui__Layout) {
		._ui__CanvasLayout = x,
		._typ = _ui__Layout_ui__CanvasLayout_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, id)),
	};
}

// Casting functions for converting "ui__Group" to interface "ui__Layout"
static inline ui__Layout I_ui__Group_to_Interface_ui__Layout(ui__Group* x) {
	return (ui__Layout) {
		._ui__Group = x,
		._typ = _ui__Layout_ui__Group_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Group, id)),
	};
}

// Casting functions for converting "ui__SubWindow" to interface "ui__Layout"
static inline ui__Layout I_ui__SubWindow_to_Interface_ui__Layout(ui__SubWindow* x) {
	return (ui__Layout) {
		._ui__SubWindow = x,
		._typ = _ui__Layout_ui__SubWindow_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__SubWindow, id)),
	};
}

static ui__Focusable I_ui__TextBox_to_Interface_ui__Focusable(ui__TextBox* x);
const int _ui__Focusable_ui__TextBox_index = 0;
static ui__Focusable I_ui__Button_to_Interface_ui__Focusable(ui__Button* x);
const int _ui__Focusable_ui__Button_index = 1;
static ui__Focusable I_ui__CheckBox_to_Interface_ui__Focusable(ui__CheckBox* x);
const int _ui__Focusable_ui__CheckBox_index = 2;
static ui__Focusable I_ui__Dropdown_to_Interface_ui__Focusable(ui__Dropdown* x);
const int _ui__Focusable_ui__Dropdown_index = 3;
static ui__Focusable I_ui__ListBox_to_Interface_ui__Focusable(ui__ListBox* x);
const int _ui__Focusable_ui__ListBox_index = 4;
static ui__Focusable I_ui__Radio_to_Interface_ui__Focusable(ui__Radio* x);
const int _ui__Focusable_ui__Radio_index = 5;
static ui__Focusable I_ui__Slider_to_Interface_ui__Focusable(ui__Slider* x);
const int _ui__Focusable_ui__Slider_index = 6;
static ui__Focusable I_ui__Switch_to_Interface_ui__Focusable(ui__Switch* x);
const int _ui__Focusable_ui__Switch_index = 7;
// ^^^ number of types for interface ui__Focusable: 8

// Methods wrapper for interface "ui__Focusable"

struct _ui__Focusable_interface_methods {
	void (*_method_focus)(void* _);
	void (*_method_unfocus)(void* _);
};

struct _ui__Focusable_interface_methods ui__Focusable_name_table[8] = {
	{
		._method_focus = (void*) ui__TextBox_focus,
		._method_unfocus = (void*) ui__TextBox_unfocus,
	},
	{
		._method_focus = (void*) ui__Button_focus,
		._method_unfocus = (void*) ui__Button_unfocus,
	},
	{
		._method_focus = (void*) ui__CheckBox_focus,
		._method_unfocus = (void*) ui__CheckBox_unfocus,
	},
	{
		._method_focus = (void*) ui__Dropdown_focus,
		._method_unfocus = (void*) ui__Dropdown_unfocus,
	},
	{
		._method_focus = (void*) ui__ListBox_focus,
		._method_unfocus = (void*) ui__ListBox_unfocus,
	},
	{
		._method_focus = (void*) ui__Radio_focus,
		._method_unfocus = (void*) ui__Radio_unfocus,
	},
	{
		._method_focus = (void*) ui__Slider_focus,
		._method_unfocus = (void*) ui__Slider_unfocus,
	},
	{
		._method_focus = (void*) ui__Switch_focus,
		._method_unfocus = (void*) ui__Switch_unfocus,
	},
};


// Casting functions for converting "ui__TextBox" to interface "ui__Focusable"
static inline ui__Focusable I_ui__TextBox_to_Interface_ui__Focusable(ui__TextBox* x) {
	return (ui__Focusable) {
		._ui__TextBox = x,
		._typ = _ui__Focusable_ui__TextBox_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__TextBox, ui)),
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__TextBox, id)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__TextBox, hidden)),
		.is_focused = (bool*)((char*)x + __offsetof_ptr(x, ui__TextBox, is_focused)),
	};
}

// Casting functions for converting "ui__Button" to interface "ui__Focusable"
static inline ui__Focusable I_ui__Button_to_Interface_ui__Focusable(ui__Button* x) {
	return (ui__Focusable) {
		._ui__Button = x,
		._typ = _ui__Focusable_ui__Button_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Button, ui)),
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Button, id)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Button, hidden)),
		.is_focused = (bool*)((char*)x + __offsetof_ptr(x, ui__Button, is_focused)),
	};
}

// Casting functions for converting "ui__CheckBox" to interface "ui__Focusable"
static inline ui__Focusable I_ui__CheckBox_to_Interface_ui__Focusable(ui__CheckBox* x) {
	return (ui__Focusable) {
		._ui__CheckBox = x,
		._typ = _ui__Focusable_ui__CheckBox_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__CheckBox, ui)),
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__CheckBox, id)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__CheckBox, hidden)),
		.is_focused = (bool*)((char*)x + __offsetof_ptr(x, ui__CheckBox, is_focused)),
	};
}

// Casting functions for converting "ui__Dropdown" to interface "ui__Focusable"
static inline ui__Focusable I_ui__Dropdown_to_Interface_ui__Focusable(ui__Dropdown* x) {
	return (ui__Focusable) {
		._ui__Dropdown = x,
		._typ = _ui__Focusable_ui__Dropdown_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Dropdown, ui)),
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Dropdown, id)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Dropdown, hidden)),
		.is_focused = (bool*)((char*)x + __offsetof_ptr(x, ui__Dropdown, is_focused)),
	};
}

// Casting functions for converting "ui__ListBox" to interface "ui__Focusable"
static inline ui__Focusable I_ui__ListBox_to_Interface_ui__Focusable(ui__ListBox* x) {
	return (ui__Focusable) {
		._ui__ListBox = x,
		._typ = _ui__Focusable_ui__ListBox_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__ListBox, ui)),
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__ListBox, id)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__ListBox, hidden)),
		.is_focused = (bool*)((char*)x + __offsetof_ptr(x, ui__ListBox, is_focused)),
	};
}

// Casting functions for converting "ui__Radio" to interface "ui__Focusable"
static inline ui__Focusable I_ui__Radio_to_Interface_ui__Focusable(ui__Radio* x) {
	return (ui__Focusable) {
		._ui__Radio = x,
		._typ = _ui__Focusable_ui__Radio_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Radio, ui)),
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Radio, id)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Radio, hidden)),
		.is_focused = (bool*)((char*)x + __offsetof_ptr(x, ui__Radio, is_focused)),
	};
}

// Casting functions for converting "ui__Slider" to interface "ui__Focusable"
static inline ui__Focusable I_ui__Slider_to_Interface_ui__Focusable(ui__Slider* x) {
	return (ui__Focusable) {
		._ui__Slider = x,
		._typ = _ui__Focusable_ui__Slider_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Slider, ui)),
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Slider, id)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Slider, hidden)),
		.is_focused = (bool*)((char*)x + __offsetof_ptr(x, ui__Slider, is_focused)),
	};
}

// Casting functions for converting "ui__Switch" to interface "ui__Focusable"
static inline ui__Focusable I_ui__Switch_to_Interface_ui__Focusable(ui__Switch* x) {
	return (ui__Focusable) {
		._ui__Switch = x,
		._typ = _ui__Focusable_ui__Switch_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Switch, ui)),
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Switch, id)),
		.hidden = (bool*)((char*)x + __offsetof_ptr(x, ui__Switch, hidden)),
		.is_focused = (bool*)((char*)x + __offsetof_ptr(x, ui__Switch, is_focused)),
	};
}

static ui__DrawTextWidget I_ui__TextBox_to_Interface_ui__DrawTextWidget(ui__TextBox* x);
const int _ui__DrawTextWidget_ui__TextBox_index = 0;
static ui__DrawTextWidget I_ui__CanvasLayout_to_Interface_ui__DrawTextWidget(ui__CanvasLayout* x);
const int _ui__DrawTextWidget_ui__CanvasLayout_index = 1;
static ui__DrawTextWidget I_ui__Button_to_Interface_ui__DrawTextWidget(ui__Button* x);
const int _ui__DrawTextWidget_ui__Button_index = 2;
static ui__DrawTextWidget I_ui__CheckBox_to_Interface_ui__DrawTextWidget(ui__CheckBox* x);
const int _ui__DrawTextWidget_ui__CheckBox_index = 3;
static ui__DrawTextWidget I_ui__Label_to_Interface_ui__DrawTextWidget(ui__Label* x);
const int _ui__DrawTextWidget_ui__Label_index = 4;
static ui__DrawTextWidget I_ui__ListBox_to_Interface_ui__DrawTextWidget(ui__ListBox* x);
const int _ui__DrawTextWidget_ui__ListBox_index = 5;
static ui__DrawTextWidget I_ui__Radio_to_Interface_ui__DrawTextWidget(ui__Radio* x);
const int _ui__DrawTextWidget_ui__Radio_index = 6;
// ^^^ number of types for interface ui__DrawTextWidget: 7


// Casting functions for converting "ui__TextBox" to interface "ui__DrawTextWidget"
static inline ui__DrawTextWidget I_ui__TextBox_to_Interface_ui__DrawTextWidget(ui__TextBox* x) {
	return (ui__DrawTextWidget) {
		._ui__TextBox = x,
		._typ = _ui__DrawTextWidget_ui__TextBox_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__TextBox, id)),
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__TextBox, ui)),
		.text_styles = (ui__TextStyles*)((char*)x + __offsetof_ptr(x, ui__TextBox, text_styles)),
	};
}

// Casting functions for converting "ui__CanvasLayout" to interface "ui__DrawTextWidget"
static inline ui__DrawTextWidget I_ui__CanvasLayout_to_Interface_ui__DrawTextWidget(ui__CanvasLayout* x) {
	return (ui__DrawTextWidget) {
		._ui__CanvasLayout = x,
		._typ = _ui__DrawTextWidget_ui__CanvasLayout_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, id)),
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, ui)),
		.text_styles = (ui__TextStyles*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, text_styles)),
	};
}

// Casting functions for converting "ui__Button" to interface "ui__DrawTextWidget"
static inline ui__DrawTextWidget I_ui__Button_to_Interface_ui__DrawTextWidget(ui__Button* x) {
	return (ui__DrawTextWidget) {
		._ui__Button = x,
		._typ = _ui__DrawTextWidget_ui__Button_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Button, id)),
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Button, ui)),
		.text_styles = (ui__TextStyles*)((char*)x + __offsetof_ptr(x, ui__Button, text_styles)),
	};
}

// Casting functions for converting "ui__CheckBox" to interface "ui__DrawTextWidget"
static inline ui__DrawTextWidget I_ui__CheckBox_to_Interface_ui__DrawTextWidget(ui__CheckBox* x) {
	return (ui__DrawTextWidget) {
		._ui__CheckBox = x,
		._typ = _ui__DrawTextWidget_ui__CheckBox_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__CheckBox, id)),
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__CheckBox, ui)),
		.text_styles = (ui__TextStyles*)((char*)x + __offsetof_ptr(x, ui__CheckBox, text_styles)),
	};
}

// Casting functions for converting "ui__Label" to interface "ui__DrawTextWidget"
static inline ui__DrawTextWidget I_ui__Label_to_Interface_ui__DrawTextWidget(ui__Label* x) {
	return (ui__DrawTextWidget) {
		._ui__Label = x,
		._typ = _ui__DrawTextWidget_ui__Label_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Label, id)),
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Label, ui)),
		.text_styles = (ui__TextStyles*)((char*)x + __offsetof_ptr(x, ui__Label, text_styles)),
	};
}

// Casting functions for converting "ui__ListBox" to interface "ui__DrawTextWidget"
static inline ui__DrawTextWidget I_ui__ListBox_to_Interface_ui__DrawTextWidget(ui__ListBox* x) {
	return (ui__DrawTextWidget) {
		._ui__ListBox = x,
		._typ = _ui__DrawTextWidget_ui__ListBox_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__ListBox, id)),
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__ListBox, ui)),
		.text_styles = (ui__TextStyles*)((char*)x + __offsetof_ptr(x, ui__ListBox, text_styles)),
	};
}

// Casting functions for converting "ui__Radio" to interface "ui__DrawTextWidget"
static inline ui__DrawTextWidget I_ui__Radio_to_Interface_ui__DrawTextWidget(ui__Radio* x) {
	return (ui__DrawTextWidget) {
		._ui__Radio = x,
		._typ = _ui__DrawTextWidget_ui__Radio_index,
		.id = (string*)((char*)x + __offsetof_ptr(x, ui__Radio, id)),
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Radio, ui)),
		.text_styles = (ui__TextStyles*)((char*)x + __offsetof_ptr(x, ui__Radio, text_styles)),
	};
}

static ui__ColorThemeWidget I_ui__Button_to_Interface_ui__ColorThemeWidget(ui__Button* x);
const int _ui__ColorThemeWidget_ui__Button_index = 0;
// ^^^ number of types for interface ui__ColorThemeWidget: 1


// Casting functions for converting "ui__Button" to interface "ui__ColorThemeWidget"
static inline ui__ColorThemeWidget I_ui__Button_to_Interface_ui__ColorThemeWidget(ui__Button* x) {
	return (ui__ColorThemeWidget) {
		._ui__Button = x,
		._typ = _ui__ColorThemeWidget_ui__Button_index,
		.ui = (ui__UI**)((char*)x + __offsetof_ptr(x, ui__Button, ui)),
		.theme_cfg = (ui__ColorThemeCfg*)((char*)x + __offsetof_ptr(x, ui__Button, theme_cfg)),
		.theme = (Map_int_gx__Color*)((char*)x + __offsetof_ptr(x, ui__Button, theme)),
	};
}

static ui__ComponentChild I_ui__ProgressBar_to_Interface_ui__ComponentChild(ui__ProgressBar* x);
const int _ui__ComponentChild_ui__ProgressBar_index = 0;
static ui__ComponentChild I_voidptr_to_Interface_ui__ComponentChild(voidptr* x);
const int _ui__ComponentChild_voidptr_index = 1;
static ui__ComponentChild I_ui__Label_to_Interface_ui__ComponentChild(ui__Label* x);
const int _ui__ComponentChild_ui__Label_index = 2;
static ui__ComponentChild I_ui__Radio_to_Interface_ui__ComponentChild(ui__Radio* x);
const int _ui__ComponentChild_ui__Radio_index = 3;
static ui__ComponentChild I_ui__Button_to_Interface_ui__ComponentChild(ui__Button* x);
const int _ui__ComponentChild_ui__Button_index = 4;
static ui__ComponentChild I_ui__CanvasLayout_to_Interface_ui__ComponentChild(ui__CanvasLayout* x);
const int _ui__ComponentChild_ui__CanvasLayout_index = 5;
static ui__ComponentChild I_ui__Stack_to_Interface_ui__ComponentChild(ui__Stack* x);
const int _ui__ComponentChild_ui__Stack_index = 6;
static ui__ComponentChild I_ui__Group_to_Interface_ui__ComponentChild(ui__Group* x);
const int _ui__ComponentChild_ui__Group_index = 7;
static ui__ComponentChild I_ui__ListBox_to_Interface_ui__ComponentChild(ui__ListBox* x);
const int _ui__ComponentChild_ui__ListBox_index = 8;
static ui__ComponentChild I_ui__TextBox_to_Interface_ui__ComponentChild(ui__TextBox* x);
const int _ui__ComponentChild_ui__TextBox_index = 9;
static ui__ComponentChild I_ui__SubWindow_to_Interface_ui__ComponentChild(ui__SubWindow* x);
const int _ui__ComponentChild_ui__SubWindow_index = 10;
static ui__ComponentChild I_ui__Canvas_to_Interface_ui__ComponentChild(ui__Canvas* x);
const int _ui__ComponentChild_ui__Canvas_index = 11;
static ui__ComponentChild I_ui__CheckBox_to_Interface_ui__ComponentChild(ui__CheckBox* x);
const int _ui__ComponentChild_ui__CheckBox_index = 12;
static ui__ComponentChild I_ui__Dropdown_to_Interface_ui__ComponentChild(ui__Dropdown* x);
const int _ui__ComponentChild_ui__Dropdown_index = 13;
static ui__ComponentChild I_ui__Menu_to_Interface_ui__ComponentChild(ui__Menu* x);
const int _ui__ComponentChild_ui__Menu_index = 14;
static ui__ComponentChild I_ui__Picture_to_Interface_ui__ComponentChild(ui__Picture* x);
const int _ui__ComponentChild_ui__Picture_index = 15;
static ui__ComponentChild I_ui__Rectangle_to_Interface_ui__ComponentChild(ui__Rectangle* x);
const int _ui__ComponentChild_ui__Rectangle_index = 16;
static ui__ComponentChild I_ui__Slider_to_Interface_ui__ComponentChild(ui__Slider* x);
const int _ui__ComponentChild_ui__Slider_index = 17;
static ui__ComponentChild I_ui__Switch_to_Interface_ui__ComponentChild(ui__Switch* x);
const int _ui__ComponentChild_ui__Switch_index = 18;
// ^^^ number of types for interface ui__ComponentChild: 19


// Casting functions for converting "ui__ProgressBar" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__ProgressBar_to_Interface_ui__ComponentChild(ui__ProgressBar* x) {
	return (ui__ComponentChild) {
		._ui__ProgressBar = x,
		._typ = _ui__ComponentChild_ui__ProgressBar_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__ProgressBar, component)),
	};
}

// Casting functions for converting "voidptr" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_voidptr_to_Interface_ui__ComponentChild(voidptr* x) {
	return (ui__ComponentChild) {
		._voidptr = x,
		._typ = _ui__ComponentChild_voidptr_index,
		.component = (voidptr*)((char*)x/*.... ast.voidptr_type */),
	};
}

// Casting functions for converting "ui__Label" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__Label_to_Interface_ui__ComponentChild(ui__Label* x) {
	return (ui__ComponentChild) {
		._ui__Label = x,
		._typ = _ui__ComponentChild_ui__Label_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__Label, component)),
	};
}

// Casting functions for converting "ui__Radio" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__Radio_to_Interface_ui__ComponentChild(ui__Radio* x) {
	return (ui__ComponentChild) {
		._ui__Radio = x,
		._typ = _ui__ComponentChild_ui__Radio_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__Radio, component)),
	};
}

// Casting functions for converting "ui__Button" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__Button_to_Interface_ui__ComponentChild(ui__Button* x) {
	return (ui__ComponentChild) {
		._ui__Button = x,
		._typ = _ui__ComponentChild_ui__Button_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__Button, component)),
	};
}

// Casting functions for converting "ui__CanvasLayout" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__CanvasLayout_to_Interface_ui__ComponentChild(ui__CanvasLayout* x) {
	return (ui__ComponentChild) {
		._ui__CanvasLayout = x,
		._typ = _ui__ComponentChild_ui__CanvasLayout_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__CanvasLayout, component)),
	};
}

// Casting functions for converting "ui__Stack" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__Stack_to_Interface_ui__ComponentChild(ui__Stack* x) {
	return (ui__ComponentChild) {
		._ui__Stack = x,
		._typ = _ui__ComponentChild_ui__Stack_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__Stack, component)),
	};
}

// Casting functions for converting "ui__Group" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__Group_to_Interface_ui__ComponentChild(ui__Group* x) {
	return (ui__ComponentChild) {
		._ui__Group = x,
		._typ = _ui__ComponentChild_ui__Group_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__Group, component)),
	};
}

// Casting functions for converting "ui__ListBox" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__ListBox_to_Interface_ui__ComponentChild(ui__ListBox* x) {
	return (ui__ComponentChild) {
		._ui__ListBox = x,
		._typ = _ui__ComponentChild_ui__ListBox_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__ListBox, component)),
	};
}

// Casting functions for converting "ui__TextBox" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__TextBox_to_Interface_ui__ComponentChild(ui__TextBox* x) {
	return (ui__ComponentChild) {
		._ui__TextBox = x,
		._typ = _ui__ComponentChild_ui__TextBox_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__TextBox, component)),
	};
}

// Casting functions for converting "ui__SubWindow" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__SubWindow_to_Interface_ui__ComponentChild(ui__SubWindow* x) {
	return (ui__ComponentChild) {
		._ui__SubWindow = x,
		._typ = _ui__ComponentChild_ui__SubWindow_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__SubWindow, component)),
	};
}

// Casting functions for converting "ui__Canvas" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__Canvas_to_Interface_ui__ComponentChild(ui__Canvas* x) {
	return (ui__ComponentChild) {
		._ui__Canvas = x,
		._typ = _ui__ComponentChild_ui__Canvas_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__Canvas, component)),
	};
}

// Casting functions for converting "ui__CheckBox" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__CheckBox_to_Interface_ui__ComponentChild(ui__CheckBox* x) {
	return (ui__ComponentChild) {
		._ui__CheckBox = x,
		._typ = _ui__ComponentChild_ui__CheckBox_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__CheckBox, component)),
	};
}

// Casting functions for converting "ui__Dropdown" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__Dropdown_to_Interface_ui__ComponentChild(ui__Dropdown* x) {
	return (ui__ComponentChild) {
		._ui__Dropdown = x,
		._typ = _ui__ComponentChild_ui__Dropdown_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__Dropdown, component)),
	};
}

// Casting functions for converting "ui__Menu" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__Menu_to_Interface_ui__ComponentChild(ui__Menu* x) {
	return (ui__ComponentChild) {
		._ui__Menu = x,
		._typ = _ui__ComponentChild_ui__Menu_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__Menu, component)),
	};
}

// Casting functions for converting "ui__Picture" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__Picture_to_Interface_ui__ComponentChild(ui__Picture* x) {
	return (ui__ComponentChild) {
		._ui__Picture = x,
		._typ = _ui__ComponentChild_ui__Picture_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__Picture, component)),
	};
}

// Casting functions for converting "ui__Rectangle" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__Rectangle_to_Interface_ui__ComponentChild(ui__Rectangle* x) {
	return (ui__ComponentChild) {
		._ui__Rectangle = x,
		._typ = _ui__ComponentChild_ui__Rectangle_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__Rectangle, component)),
	};
}

// Casting functions for converting "ui__Slider" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__Slider_to_Interface_ui__ComponentChild(ui__Slider* x) {
	return (ui__ComponentChild) {
		._ui__Slider = x,
		._typ = _ui__ComponentChild_ui__Slider_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__Slider, component)),
	};
}

// Casting functions for converting "ui__Switch" to interface "ui__ComponentChild"
static inline ui__ComponentChild I_ui__Switch_to_Interface_ui__ComponentChild(ui__Switch* x) {
	return (ui__ComponentChild) {
		._ui__Switch = x,
		._typ = _ui__ComponentChild_ui__Switch_index,
		.component = (voidptr*)((char*)x + __offsetof_ptr(x, ui__Switch, component)),
	};
}

static inline bool I_ui__Widget_is_I_ui__ScrollableWidget(ui__Widget x) {
	return (x._typ == _ui__Widget_ui__CanvasLayout_index) || (x._typ == _ui__Widget_ui__Stack_index) || (x._typ == _ui__Widget_ui__ListBox_index) || (x._typ == _ui__Widget_ui__TextBox_index);
}
static inline ui__ScrollableWidget I_ui__Widget_as_I_ui__ScrollableWidget(ui__Widget x) {
	if (x._typ == _ui__Widget_ui__CanvasLayout_index) return I_ui__CanvasLayout_to_Interface_ui__ScrollableWidget(x._ui__CanvasLayout);
	if (x._typ == _ui__Widget_ui__Stack_index) return I_ui__Stack_to_Interface_ui__ScrollableWidget(x._ui__Stack);
	if (x._typ == _ui__Widget_ui__ListBox_index) return I_ui__ListBox_to_Interface_ui__ScrollableWidget(x._ui__ListBox);
	if (x._typ == _ui__Widget_ui__TextBox_index) return I_ui__TextBox_to_Interface_ui__ScrollableWidget(x._ui__TextBox);
	panic_debug(1, tos3("builtin.v"), tos3("builtin"), tos3("__as_cast"), string__plus(string__plus(tos3("`as_cast`: cannot convert "), tos3(v_typeof_interface_ui__Widget(x._typ))), tos3(" to ui.ScrollableWidget")));
	return (ui__ScrollableWidget){0};
}
static inline bool I_ui__Widget_is_I_ui__Layout(ui__Widget x) {
	return (x._typ == _ui__Widget_ui__CanvasLayout_index) || (x._typ == _ui__Widget_ui__Stack_index) || (x._typ == _ui__Widget_ui__Group_index) || (x._typ == _ui__Widget_ui__SubWindow_index);
}
static inline ui__Layout I_ui__Widget_as_I_ui__Layout(ui__Widget x) {
	if (x._typ == _ui__Widget_ui__CanvasLayout_index) return I_ui__CanvasLayout_to_Interface_ui__Layout(x._ui__CanvasLayout);
	if (x._typ == _ui__Widget_ui__Stack_index) return I_ui__Stack_to_Interface_ui__Layout(x._ui__Stack);
	if (x._typ == _ui__Widget_ui__Group_index) return I_ui__Group_to_Interface_ui__Layout(x._ui__Group);
	if (x._typ == _ui__Widget_ui__SubWindow_index) return I_ui__SubWindow_to_Interface_ui__Layout(x._ui__SubWindow);
	panic_debug(1, tos3("builtin.v"), tos3("builtin"), tos3("__as_cast"), string__plus(string__plus(tos3("`as_cast`: cannot convert "), tos3(v_typeof_interface_ui__Widget(x._typ))), tos3(" to ui.Layout")));
	return (ui__Layout){0};
}
static inline bool I_ui__Widget_is_I_ui__Focusable(ui__Widget x) {
	return (x._typ == _ui__Widget_ui__Radio_index) || (x._typ == _ui__Widget_ui__Button_index) || (x._typ == _ui__Widget_ui__ListBox_index) || (x._typ == _ui__Widget_ui__TextBox_index) || (x._typ == _ui__Widget_ui__CheckBox_index) || (x._typ == _ui__Widget_ui__Dropdown_index) || (x._typ == _ui__Widget_ui__Slider_index) || (x._typ == _ui__Widget_ui__Switch_index);
}
static inline ui__Focusable I_ui__Widget_as_I_ui__Focusable(ui__Widget x) {
	if (x._typ == _ui__Widget_ui__Radio_index) return I_ui__Radio_to_Interface_ui__Focusable(x._ui__Radio);
	if (x._typ == _ui__Widget_ui__Button_index) return I_ui__Button_to_Interface_ui__Focusable(x._ui__Button);
	if (x._typ == _ui__Widget_ui__ListBox_index) return I_ui__ListBox_to_Interface_ui__Focusable(x._ui__ListBox);
	if (x._typ == _ui__Widget_ui__TextBox_index) return I_ui__TextBox_to_Interface_ui__Focusable(x._ui__TextBox);
	if (x._typ == _ui__Widget_ui__CheckBox_index) return I_ui__CheckBox_to_Interface_ui__Focusable(x._ui__CheckBox);
	if (x._typ == _ui__Widget_ui__Dropdown_index) return I_ui__Dropdown_to_Interface_ui__Focusable(x._ui__Dropdown);
	if (x._typ == _ui__Widget_ui__Slider_index) return I_ui__Slider_to_Interface_ui__Focusable(x._ui__Slider);
	if (x._typ == _ui__Widget_ui__Switch_index) return I_ui__Switch_to_Interface_ui__Focusable(x._ui__Switch);
	panic_debug(1, tos3("builtin.v"), tos3("builtin"), tos3("__as_cast"), string__plus(string__plus(tos3("`as_cast`: cannot convert "), tos3(v_typeof_interface_ui__Widget(x._typ))), tos3(" to ui.Focusable")));
	return (ui__Focusable){0};
}
static inline bool I_ui__ScrollableWidget_is_I_ui__Widget(ui__ScrollableWidget x) {
	return (x._typ == _ui__ScrollableWidget_ui__CanvasLayout_index) || (x._typ == _ui__ScrollableWidget_ui__Stack_index) || (x._typ == _ui__ScrollableWidget_ui__ListBox_index) || (x._typ == _ui__ScrollableWidget_ui__TextBox_index);
}
static inline ui__Widget I_ui__ScrollableWidget_as_I_ui__Widget(ui__ScrollableWidget x) {
	if (x._typ == _ui__ScrollableWidget_ui__CanvasLayout_index) return I_ui__CanvasLayout_to_Interface_ui__Widget(x._ui__CanvasLayout);
	if (x._typ == _ui__ScrollableWidget_ui__Stack_index) return I_ui__Stack_to_Interface_ui__Widget(x._ui__Stack);
	if (x._typ == _ui__ScrollableWidget_ui__ListBox_index) return I_ui__ListBox_to_Interface_ui__Widget(x._ui__ListBox);
	if (x._typ == _ui__ScrollableWidget_ui__TextBox_index) return I_ui__TextBox_to_Interface_ui__Widget(x._ui__TextBox);
	panic_debug(1, tos3("builtin.v"), tos3("builtin"), tos3("__as_cast"), string__plus(string__plus(tos3("`as_cast`: cannot convert "), tos3(v_typeof_interface_ui__ScrollableWidget(x._typ))), tos3(" to ui.Widget")));
	return (ui__Widget){0};
}
static inline bool I_ui__Layout_is_I_ui__Widget(ui__Layout x) {
	return (x._typ == _ui__Layout_ui__CanvasLayout_index) || (x._typ == _ui__Layout_ui__Stack_index) || (x._typ == _ui__Layout_ui__Group_index) || (x._typ == _ui__Layout_ui__SubWindow_index);
}
static inline ui__Widget I_ui__Layout_as_I_ui__Widget(ui__Layout x) {
	if (x._typ == _ui__Layout_ui__CanvasLayout_index) return I_ui__CanvasLayout_to_Interface_ui__Widget(x._ui__CanvasLayout);
	if (x._typ == _ui__Layout_ui__Stack_index) return I_ui__Stack_to_Interface_ui__Widget(x._ui__Stack);
	if (x._typ == _ui__Layout_ui__Group_index) return I_ui__Group_to_Interface_ui__Widget(x._ui__Group);
	if (x._typ == _ui__Layout_ui__SubWindow_index) return I_ui__SubWindow_to_Interface_ui__Widget(x._ui__SubWindow);
	panic_debug(1, tos3("builtin.v"), tos3("builtin"), tos3("__as_cast"), string__plus(string__plus(tos3("`as_cast`: cannot convert "), tos3(v_typeof_interface_ui__Layout(x._typ))), tos3(" to ui.Widget")));
	return (ui__Widget){0};
}
static inline bool I_ui__Layout_is_I_ui__ScrollableWidget(ui__Layout x) {
	return (x._typ == _ui__Layout_ui__CanvasLayout_index) || (x._typ == _ui__Layout_ui__Stack_index);
}
static inline ui__ScrollableWidget I_ui__Layout_as_I_ui__ScrollableWidget(ui__Layout x) {
	if (x._typ == _ui__Layout_ui__CanvasLayout_index) return I_ui__CanvasLayout_to_Interface_ui__ScrollableWidget(x._ui__CanvasLayout);
	if (x._typ == _ui__Layout_ui__Stack_index) return I_ui__Stack_to_Interface_ui__ScrollableWidget(x._ui__Stack);
	panic_debug(1, tos3("builtin.v"), tos3("builtin"), tos3("__as_cast"), string__plus(string__plus(tos3("`as_cast`: cannot convert "), tos3(v_typeof_interface_ui__Layout(x._typ))), tos3(" to ui.ScrollableWidget")));
	return (ui__ScrollableWidget){0};
}


// V gowrappers:
void* ui__UI_idle_loop_thread_wrapper(thread_arg_ui__UI_idle_loop *arg) {
	ui__UI_idle_loop(arg->arg0);
	free(arg);
	return 0;
}

// V stringliterals:

// >> string literal consts
void vinit_string_literals(void){
	_const_math__bits__overflow_error = _SLIT("Overflow Error");
	_const_math__bits__divide_error = _SLIT("Divide Error");
	_const_strconv__digit_pairs = _SLIT("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	_const_strconv__base_digits = _SLIT("0123456789abcdefghijklmnopqrstuvwxyz");
	_const_digit_pairs = _SLIT("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	_const_si_s_code = _SLIT("0xfe10");
	_const_si_g32_code = _SLIT("0xfe0e");
	_const_si_g64_code = _SLIT("0xfe0f");
	_const_os__path_separator = _SLIT("/");
	_const_os__path_delimiter = _SLIT(":");
	_const_time__days_string = _SLIT("MonTueWedThuFriSatSun");
	_const_time__months_string = _SLIT("JanFebMarAprMayJunJulAugSepOctNovDec");
	_const_ui__word_wrap_id = _SLIT("\n");
	_const_ui__no_string = _SLIT("_none_");
	_const_ui__version = _SLIT("0.0.4");
}
// << string literal consts


// V auto str functions:
static string time__FormatTime_str(time__FormatTime it) { /* gen_str_for_enum */
	switch(it) {
		case time__FormatTime__hhmm12: return _SLIT("hhmm12");
		case time__FormatTime__hhmm24: return _SLIT("hhmm24");
		case time__FormatTime__hhmmss12: return _SLIT("hhmmss12");
		case time__FormatTime__hhmmss24: return _SLIT("hhmmss24");
		case time__FormatTime__hhmmss24_milli: return _SLIT("hhmmss24_milli");
		case time__FormatTime__hhmmss24_micro: return _SLIT("hhmmss24_micro");
		case time__FormatTime__no_time: return _SLIT("no_time");
		default: return _SLIT("unknown enum value");
	}
}
static string time__FormatDate_str(time__FormatDate it) { /* gen_str_for_enum */
	switch(it) {
		case time__FormatDate__ddmmyy: return _SLIT("ddmmyy");
		case time__FormatDate__ddmmyyyy: return _SLIT("ddmmyyyy");
		case time__FormatDate__mmddyy: return _SLIT("mmddyy");
		case time__FormatDate__mmddyyyy: return _SLIT("mmddyyyy");
		case time__FormatDate__mmmd: return _SLIT("mmmd");
		case time__FormatDate__mmmdd: return _SLIT("mmmdd");
		case time__FormatDate__mmmddyy: return _SLIT("mmmddyy");
		case time__FormatDate__mmmddyyyy: return _SLIT("mmmddyyyy");
		case time__FormatDate__no_date: return _SLIT("no_date");
		case time__FormatDate__yyyymmdd: return _SLIT("yyyymmdd");
		case time__FormatDate__yymmdd: return _SLIT("yymmdd");
		default: return _SLIT("unknown enum value");
	}
}
static string sokol__sapp__EventType_str(sokol__sapp__EventType it) { /* gen_str_for_enum */
	switch(it) {
		case sokol__sapp__EventType__invalid: return _SLIT("invalid");
		case sokol__sapp__EventType__key_down: return _SLIT("key_down");
		case sokol__sapp__EventType__key_up: return _SLIT("key_up");
		case sokol__sapp__EventType__char: return _SLIT("char");
		case sokol__sapp__EventType__mouse_down: return _SLIT("mouse_down");
		case sokol__sapp__EventType__mouse_up: return _SLIT("mouse_up");
		case sokol__sapp__EventType__mouse_scroll: return _SLIT("mouse_scroll");
		case sokol__sapp__EventType__mouse_move: return _SLIT("mouse_move");
		case sokol__sapp__EventType__mouse_enter: return _SLIT("mouse_enter");
		case sokol__sapp__EventType__mouse_leave: return _SLIT("mouse_leave");
		case sokol__sapp__EventType__touches_began: return _SLIT("touches_began");
		case sokol__sapp__EventType__touches_moved: return _SLIT("touches_moved");
		case sokol__sapp__EventType__touches_ended: return _SLIT("touches_ended");
		case sokol__sapp__EventType__touches_cancelled: return _SLIT("touches_cancelled");
		case sokol__sapp__EventType__resized: return _SLIT("resized");
		case sokol__sapp__EventType__iconified: return _SLIT("iconified");
		case sokol__sapp__EventType__restored: return _SLIT("restored");
		case sokol__sapp__EventType__focused: return _SLIT("focused");
		case sokol__sapp__EventType__unfocused: return _SLIT("unfocused");
		case sokol__sapp__EventType__suspended: return _SLIT("suspended");
		case sokol__sapp__EventType__resumed: return _SLIT("resumed");
		case sokol__sapp__EventType__update_cursor: return _SLIT("update_cursor");
		case sokol__sapp__EventType__quit_requested: return _SLIT("quit_requested");
		case sokol__sapp__EventType__clipboard_pasted: return _SLIT("clipboard_pasted");
		case sokol__sapp__EventType__files_droped: return _SLIT("files_droped");
		case sokol__sapp__EventType__num: return _SLIT("num");
		default: return _SLIT("unknown enum value");
	}
}
static string ui__Direction_str(ui__Direction it) { /* gen_str_for_enum */
	switch(it) {
		case ui__Direction__row: return _SLIT("row");
		case ui__Direction__column: return _SLIT("column");
		default: return _SLIT("unknown enum value");
	}
}
static string Array_ui__ChildSize_str(Array_ui__ChildSize a) { return indent_Array_ui__ChildSize_str(a, 0);}
static string indent_Array_ui__ChildSize_str(Array_ui__ChildSize a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		ui__ChildSize it = *(ui__ChildSize*)array_get(a, i);
		strings__Builder_write_string(&sb, _SLIT(""));
		string x = ui__ChildSize_str(  it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Array_f32_str(Array_f32 a) { return indent_Array_f32_str(a, 0);}
static string indent_Array_f32_str(Array_f32 a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		f32 it = *(f32*)array_get(a, i);
		string x = str_intp(1, _MOV((StrIntpData[]){{_SLIT0, 0xfe0e, {.d_f32 = it }}}));
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string gx__TextCfg_str(gx__TextCfg it) { return indent_gx__TextCfg_str(it, 0);}
static string Array_int_str(Array_int a) { return indent_Array_int_str(a, 0);}
static string indent_Array_int_str(Array_int a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		int it = *(int*)array_get(a, i);
		strings__Builder_write_string(&sb, _SLIT(""));
		string x = int_str(  it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string ui__ChildSize_str(ui__ChildSize it) { /* gen_str_for_enum */
	switch(it) {
		case ui__ChildSize__compact: return _SLIT("compact");
		case ui__ChildSize__fixed: return _SLIT("fixed");
		case ui__ChildSize__weighted: return _SLIT("weighted");
		case ui__ChildSize__stretch: return _SLIT("stretch");
		case ui__ChildSize__weighted_stretch: return _SLIT("weighted_stretch");
		default: return _SLIT("unknown enum value");
	}
}
static string gx__HorizontalAlign_str(gx__HorizontalAlign it) { /* gen_str_for_enum */
	switch(it) {
		case gx__HorizontalAlign__left: return _SLIT("left");
		case gx__HorizontalAlign__center: return _SLIT("center");
		case gx__HorizontalAlign__right: return _SLIT("right");
		default: return _SLIT("unknown enum value");
	}
}
static string gx__VerticalAlign_str(gx__VerticalAlign it) { /* gen_str_for_enum */
	switch(it) {
		case gx__VerticalAlign__top: return _SLIT("top");
		case gx__VerticalAlign__middle: return _SLIT("middle");
		case gx__VerticalAlign__bottom: return _SLIT("bottom");
		case gx__VerticalAlign__baseline: return _SLIT("baseline");
		default: return _SLIT("unknown enum value");
	}
}

// V dump functions:

static string indent_gx__TextCfg_str(gx__TextCfg it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t1 = gx__Color_str(it.color);
	string _t2 = gx__HorizontalAlign_str(it.align);
	string _t3 = gx__VerticalAlign_str(it.vertical_align);
	string res = str_intp( 39, _MOV((StrIntpData[]){
		{_SLIT("gx.TextCfg{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    color: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t1}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    size: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.size}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    align: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t2}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    vertical_align: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t3}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    max_width: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.max_width}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    family: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.family}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    bold: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.bold ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    mono: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.mono ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    italic: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.italic ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t3);
	string_free(&_t2);
	string_free(&_t1);
	string_free(&indents);
	return res;
}

static string multi_return_int_int_str(multi_return_int_int a) {
	strings__Builder sb = strings__new_builder(2 * 10);
	strings__Builder_write_string(&sb, _SLIT("("));
		strings__Builder_write_string(&sb, _SLIT(""));
	strings__Builder_write_string(&sb, int_str(  a.arg0));
	strings__Builder_write_string(&sb, _SLIT(", "));
		strings__Builder_write_string(&sb, _SLIT(""));
	strings__Builder_write_string(&sb, int_str(  a.arg1));
	strings__Builder_write_string(&sb, _SLIT(")"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}

static inline ui__Size f64_to_sumtype_ui__Size(f64* x) {
	f64* ptr = memdup(x, sizeof(f64));
	return (ui__Size){ ._f64 = ptr, ._typ = 16};
}

static inline ui__ColorThemeCfg string_to_sumtype_ui__ColorThemeCfg(string* x) {
	string* ptr = memdup(x, sizeof(string));
	return (ui__ColorThemeCfg){ ._string = ptr, ._typ = 20};
}

static inline ui__Size Array_f64_to_sumtype_ui__Size(Array_f64* x) {
	Array_f64* ptr = memdup(x, sizeof(Array_f64));
	return (ui__Size){ ._Array_f64 = ptr, ._typ = 166};
}

static bool Array_string_contains(Array_string a, string v) {
	for (int i = 0; i < a.len; ++i) {
		if (fast_string_eq(((string*)a.data)[i], v)) {
			return true;
		}
	}
	return false;
}

static bool Array_int_contains(Array_int a, int v) {
	for (int i = 0; i < a.len; ++i) {
		if (((int*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static int Array_string_index(Array_string a, string v) {
	string* pelem = a.data;
	for (int i = 0; i < a.len; ++i, ++pelem) {
		if (fast_string_eq(*pelem, v)) {
			return i;
		}
	}
	return -1;
}

static bool Array_rune_arr_eq(Array_rune a, Array_rune b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (*((rune*)((byte*)a.data+(i*a.element_size))) != *((rune*)((byte*)b.data+(i*b.element_size)))) {
			return false;
		}
	}
	return true;
}

static bool time__Duration_alias_eq(time__Duration a, time__Duration b) {
	return a == b;
}

static bool gx__Color_struct_eq(gx__Color a, gx__Color b) {
	return a.r == b.r
		&& a.g == b.g
		&& a.b == b.b
		&& a.a == b.a;
}

static bool Map_int_gx__Color_map_eq(Map_int_gx__Color a, Map_int_gx__Color b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.key_values.len; ++i) {
		if (!DenseArray_has_index(&a.key_values, i)) continue;
		voidptr k = DenseArray_key(&a.key_values, i);
		if (!map_exists(&b, k)) return false;
		gx__Color v = *(gx__Color*)map_get(&a, k, &(gx__Color[]){ 0 });
		if (!gx__Color_struct_eq(*(gx__Color*)map_get(&b, k, &(gx__Color[]){ 0 }), v)) {
			return false;
		}
	}
	return true;
}

static bool ui__ColorTheme_alias_eq(ui__ColorTheme a, ui__ColorTheme b) {
	return Map_int_gx__Color_map_eq(a, b);
}

static bool ui__ColorThemeCfg_sumtype_eq(ui__ColorThemeCfg a, ui__ColorThemeCfg b) {
	if (a._typ != b._typ) { return false; }
	if (a._typ == 212) {
		return ui__ColorTheme_alias_eq(*a._ui__ColorTheme, *b._ui__ColorTheme);
	}
	if (a._typ == 20) {
		return string__eq(*a._string, *b._string);
	}
	return false;
}


// V out

// >> typeof() support for sum types / interfaces
static char * v_typeof_interface_IError(int sidx) { /* IError */ 
	if (sidx == _IError_None___index) return "None__";
	if (sidx == _IError_Error_index) return "Error";
	if (sidx == _IError_MessageError_index) return "MessageError";
	if (sidx == _IError_os__FileNotOpenedError_index) return "os.FileNotOpenedError";
	if (sidx == _IError_os__SizeOfTypeIs0Error_index) return "os.SizeOfTypeIs0Error";
	if (sidx == _IError_os__ExecutableNotFoundError_index) return "os.ExecutableNotFoundError";
	if (sidx == _IError_time__TimeParseError_index) return "time.TimeParseError";
	return "unknown IError";
}

static int v_typeof_interface_idx_IError(int sidx) { /* IError */ 
	if (sidx == _IError_None___index) return 65610;
	if (sidx == _IError_Error_index) return 75;
	if (sidx == _IError_MessageError_index) return 76;
	if (sidx == _IError_os__FileNotOpenedError_index) return 65878;
	if (sidx == _IError_os__SizeOfTypeIs0Error_index) return 65879;
	if (sidx == _IError_os__ExecutableNotFoundError_index) return 65891;
	if (sidx == _IError_time__TimeParseError_index) return 465;
	return 29;
}
static char * v_typeof_interface_ui__Widget(int sidx) { /* ui.Widget */ 
	if (sidx == _ui__Widget_ui__Stack_index) return "ui.Stack";
	if (sidx == _ui__Widget_ui__Group_index) return "ui.Group";
	if (sidx == _ui__Widget_ui__CanvasLayout_index) return "ui.CanvasLayout";
	if (sidx == _ui__Widget_ui__ListBox_index) return "ui.ListBox";
	if (sidx == _ui__Widget_ui__TextBox_index) return "ui.TextBox";
	if (sidx == _ui__Widget_ui__Label_index) return "ui.Label";
	if (sidx == _ui__Widget_ui__Button_index) return "ui.Button";
	if (sidx == _ui__Widget_ui__Canvas_index) return "ui.Canvas";
	if (sidx == _ui__Widget_ui__CheckBox_index) return "ui.CheckBox";
	if (sidx == _ui__Widget_ui__Dropdown_index) return "ui.Dropdown";
	if (sidx == _ui__Widget_ui__Grid_index) return "ui.Grid";
	if (sidx == _ui__Widget_ui__Menu_index) return "ui.Menu";
	if (sidx == _ui__Widget_ui__Picture_index) return "ui.Picture";
	if (sidx == _ui__Widget_ui__ProgressBar_index) return "ui.ProgressBar";
	if (sidx == _ui__Widget_ui__Radio_index) return "ui.Radio";
	if (sidx == _ui__Widget_ui__Rectangle_index) return "ui.Rectangle";
	if (sidx == _ui__Widget_ui__Slider_index) return "ui.Slider";
	if (sidx == _ui__Widget_ui__SubWindow_index) return "ui.SubWindow";
	if (sidx == _ui__Widget_ui__Switch_index) return "ui.Switch";
	if (sidx == _ui__Widget_ui__Transition_index) return "ui.Transition";
	return "unknown ui.Widget";
}

static int v_typeof_interface_idx_ui__Widget(int sidx) { /* ui.Widget */ 
	if (sidx == _ui__Widget_ui__Stack_index) return 123;
	if (sidx == _ui__Widget_ui__Group_index) return 153;
	if (sidx == _ui__Widget_ui__CanvasLayout_index) return 101;
	if (sidx == _ui__Widget_ui__ListBox_index) return 160;
	if (sidx == _ui__Widget_ui__TextBox_index) return 161;
	if (sidx == _ui__Widget_ui__Label_index) return 65632;
	if (sidx == _ui__Widget_ui__Button_index) return 65636;
	if (sidx == _ui__Widget_ui__Canvas_index) return 65809;
	if (sidx == _ui__Widget_ui__CheckBox_index) return 65813;
	if (sidx == _ui__Widget_ui__Dropdown_index) return 65816;
	if (sidx == _ui__Widget_ui__Grid_index) return 65821;
	if (sidx == _ui__Widget_ui__Menu_index) return 65831;
	if (sidx == _ui__Widget_ui__Picture_index) return 65835;
	if (sidx == _ui__Widget_ui__ProgressBar_index) return 65629;
	if (sidx == _ui__Widget_ui__Radio_index) return 65633;
	if (sidx == _ui__Widget_ui__Rectangle_index) return 65840;
	if (sidx == _ui__Widget_ui__Slider_index) return 65844;
	if (sidx == _ui__Widget_ui__SubWindow_index) return 65763;
	if (sidx == _ui__Widget_ui__Switch_index) return 65848;
	if (sidx == _ui__Widget_ui__Transition_index) return 323;
	return 124;
}
static char * v_typeof_interface_ui__DrawText(int sidx) { /* ui.DrawText */ 
	if (sidx == _ui__DrawText_ui__Tooltip_index) return "ui.Tooltip";
	if (sidx == _ui__DrawText_ui__Button_index) return "ui.Button";
	if (sidx == _ui__DrawText_ui__Menu_index) return "ui.Menu";
	if (sidx == _ui__DrawText_ui__Rectangle_index) return "ui.Rectangle";
	if (sidx == _ui__DrawText_ui__TextBox_index) return "ui.TextBox";
	if (sidx == _ui__DrawText_ui__Label_index) return "ui.Label";
	if (sidx == _ui__DrawText_voidptr_index) return "voidptr";
	if (sidx == _ui__DrawText_ui__Radio_index) return "ui.Radio";
	if (sidx == _ui__DrawText_ui__ListBox_index) return "ui.ListBox";
	if (sidx == _ui__DrawText_ui__CheckBox_index) return "ui.CheckBox";
	return "unknown ui.DrawText";
}

static int v_typeof_interface_idx_ui__DrawText(int sidx) { /* ui.DrawText */ 
	if (sidx == _ui__DrawText_ui__Tooltip_index) return 177;
	if (sidx == _ui__DrawText_ui__Button_index) return 65636;
	if (sidx == _ui__DrawText_ui__Menu_index) return 65831;
	if (sidx == _ui__DrawText_ui__Rectangle_index) return 65840;
	if (sidx == _ui__DrawText_ui__TextBox_index) return 65697;
	if (sidx == _ui__DrawText_ui__Label_index) return 96;
	if (sidx == _ui__DrawText_voidptr_index) return 2;
	if (sidx == _ui__DrawText_ui__Radio_index) return 97;
	if (sidx == _ui__DrawText_ui__ListBox_index) return 160;
	if (sidx == _ui__DrawText_ui__CheckBox_index) return 277;
	return 131;
}
static char * v_typeof_interface_ui__ScrollableWidget(int sidx) { /* ui.ScrollableWidget */ 
	if (sidx == _ui__ScrollableWidget_ui__Stack_index) return "ui.Stack";
	if (sidx == _ui__ScrollableWidget_ui__CanvasLayout_index) return "ui.CanvasLayout";
	if (sidx == _ui__ScrollableWidget_ui__ListBox_index) return "ui.ListBox";
	if (sidx == _ui__ScrollableWidget_ui__TextBox_index) return "ui.TextBox";
	return "unknown ui.ScrollableWidget";
}

static int v_typeof_interface_idx_ui__ScrollableWidget(int sidx) { /* ui.ScrollableWidget */ 
	if (sidx == _ui__ScrollableWidget_ui__Stack_index) return 65659;
	if (sidx == _ui__ScrollableWidget_ui__CanvasLayout_index) return 65637;
	if (sidx == _ui__ScrollableWidget_ui__ListBox_index) return 65696;
	if (sidx == _ui__ScrollableWidget_ui__TextBox_index) return 65697;
	return 147;
}
static char * v_typeof_interface_ui__Layout(int sidx) { /* ui.Layout */ 
	if (sidx == _ui__Layout_ui__Stack_index) return "ui.Stack";
	if (sidx == _ui__Layout_ui__Window_index) return "ui.Window";
	if (sidx == _ui__Layout_ui__CanvasLayout_index) return "ui.CanvasLayout";
	if (sidx == _ui__Layout_ui__Group_index) return "ui.Group";
	if (sidx == _ui__Layout_ui__SubWindow_index) return "ui.SubWindow";
	return "unknown ui.Layout";
}

static int v_typeof_interface_idx_ui__Layout(int sidx) { /* ui.Layout */ 
	if (sidx == _ui__Layout_ui__Stack_index) return 123;
	if (sidx == _ui__Layout_ui__Window_index) return 95;
	if (sidx == _ui__Layout_ui__CanvasLayout_index) return 101;
	if (sidx == _ui__Layout_ui__Group_index) return 153;
	if (sidx == _ui__Layout_ui__SubWindow_index) return 227;
	return 148;
}
static char * v_typeof_sumtype_ui__Size(int sidx) { /* ui.Size */ 
	switch(sidx) {
		case 167: return "ui.Size";
		case 166: return "[]f64";
		case 16: return "f64";
		default: return "unknown ui.Size";
	}
}

static int v_typeof_sumtype_idx_ui__Size(int sidx) { /* ui.Size */ 
	switch(sidx) {
		case 167: return 167;
		case 166: return 166;
		case 16: return 16;
		default: return 167;
	}
}
static char * v_typeof_interface_ui__Focusable(int sidx) { /* ui.Focusable */ 
	if (sidx == _ui__Focusable_ui__TextBox_index) return "ui.TextBox";
	if (sidx == _ui__Focusable_ui__Button_index) return "ui.Button";
	if (sidx == _ui__Focusable_ui__CheckBox_index) return "ui.CheckBox";
	if (sidx == _ui__Focusable_ui__Dropdown_index) return "ui.Dropdown";
	if (sidx == _ui__Focusable_ui__ListBox_index) return "ui.ListBox";
	if (sidx == _ui__Focusable_ui__Radio_index) return "ui.Radio";
	if (sidx == _ui__Focusable_ui__Slider_index) return "ui.Slider";
	if (sidx == _ui__Focusable_ui__Switch_index) return "ui.Switch";
	return "unknown ui.Focusable";
}

static int v_typeof_interface_idx_ui__Focusable(int sidx) { /* ui.Focusable */ 
	if (sidx == _ui__Focusable_ui__TextBox_index) return 65697;
	if (sidx == _ui__Focusable_ui__Button_index) return 65636;
	if (sidx == _ui__Focusable_ui__CheckBox_index) return 65813;
	if (sidx == _ui__Focusable_ui__Dropdown_index) return 65816;
	if (sidx == _ui__Focusable_ui__ListBox_index) return 65696;
	if (sidx == _ui__Focusable_ui__Radio_index) return 65633;
	if (sidx == _ui__Focusable_ui__Slider_index) return 65844;
	if (sidx == _ui__Focusable_ui__Switch_index) return 65848;
	return 202;
}
static char * v_typeof_interface_ui__DrawTextWidget(int sidx) { /* ui.DrawTextWidget */ 
	if (sidx == _ui__DrawTextWidget_ui__TextBox_index) return "ui.TextBox";
	if (sidx == _ui__DrawTextWidget_ui__CanvasLayout_index) return "ui.CanvasLayout";
	if (sidx == _ui__DrawTextWidget_ui__Button_index) return "ui.Button";
	if (sidx == _ui__DrawTextWidget_ui__CheckBox_index) return "ui.CheckBox";
	if (sidx == _ui__DrawTextWidget_ui__Label_index) return "ui.Label";
	if (sidx == _ui__DrawTextWidget_ui__ListBox_index) return "ui.ListBox";
	if (sidx == _ui__DrawTextWidget_ui__Radio_index) return "ui.Radio";
	return "unknown ui.DrawTextWidget";
}

static int v_typeof_interface_idx_ui__DrawTextWidget(int sidx) { /* ui.DrawTextWidget */ 
	if (sidx == _ui__DrawTextWidget_ui__TextBox_index) return 65697;
	if (sidx == _ui__DrawTextWidget_ui__CanvasLayout_index) return 65637;
	if (sidx == _ui__DrawTextWidget_ui__Button_index) return 65636;
	if (sidx == _ui__DrawTextWidget_ui__CheckBox_index) return 65813;
	if (sidx == _ui__DrawTextWidget_ui__Label_index) return 65632;
	if (sidx == _ui__DrawTextWidget_ui__ListBox_index) return 65696;
	if (sidx == _ui__DrawTextWidget_ui__Radio_index) return 65633;
	return 204;
}
static char * v_typeof_sumtype_ui__ColorThemeCfg(int sidx) { /* ui.ColorThemeCfg */ 
	switch(sidx) {
		case 208: return "ui.ColorThemeCfg";
		case 212: return "ui.ColorTheme";
		case 20: return "string";
		default: return "unknown ui.ColorThemeCfg";
	}
}

static int v_typeof_sumtype_idx_ui__ColorThemeCfg(int sidx) { /* ui.ColorThemeCfg */ 
	switch(sidx) {
		case 208: return 208;
		case 212: return 212;
		case 20: return 20;
		default: return 208;
	}
}
static char * v_typeof_interface_ui__ColorThemeWidget(int sidx) { /* ui.ColorThemeWidget */ 
	if (sidx == _ui__ColorThemeWidget_ui__Button_index) return "ui.Button";
	return "unknown ui.ColorThemeWidget";
}

static int v_typeof_interface_idx_ui__ColorThemeWidget(int sidx) { /* ui.ColorThemeWidget */ 
	if (sidx == _ui__ColorThemeWidget_ui__Button_index) return 65636;
	return 214;
}
static char * v_typeof_interface_ui__ComponentChild(int sidx) { /* ui.ComponentChild */ 
	if (sidx == _ui__ComponentChild_ui__ProgressBar_index) return "ui.ProgressBar";
	if (sidx == _ui__ComponentChild_voidptr_index) return "voidptr";
	if (sidx == _ui__ComponentChild_ui__Label_index) return "ui.Label";
	if (sidx == _ui__ComponentChild_ui__Radio_index) return "ui.Radio";
	if (sidx == _ui__ComponentChild_ui__Button_index) return "ui.Button";
	if (sidx == _ui__ComponentChild_ui__CanvasLayout_index) return "ui.CanvasLayout";
	if (sidx == _ui__ComponentChild_ui__Stack_index) return "ui.Stack";
	if (sidx == _ui__ComponentChild_ui__Group_index) return "ui.Group";
	if (sidx == _ui__ComponentChild_ui__ListBox_index) return "ui.ListBox";
	if (sidx == _ui__ComponentChild_ui__TextBox_index) return "ui.TextBox";
	if (sidx == _ui__ComponentChild_ui__SubWindow_index) return "ui.SubWindow";
	if (sidx == _ui__ComponentChild_ui__Canvas_index) return "ui.Canvas";
	if (sidx == _ui__ComponentChild_ui__CheckBox_index) return "ui.CheckBox";
	if (sidx == _ui__ComponentChild_ui__Dropdown_index) return "ui.Dropdown";
	if (sidx == _ui__ComponentChild_ui__Menu_index) return "ui.Menu";
	if (sidx == _ui__ComponentChild_ui__Picture_index) return "ui.Picture";
	if (sidx == _ui__ComponentChild_ui__Rectangle_index) return "ui.Rectangle";
	if (sidx == _ui__ComponentChild_ui__Slider_index) return "ui.Slider";
	if (sidx == _ui__ComponentChild_ui__Switch_index) return "ui.Switch";
	return "unknown ui.ComponentChild";
}

static int v_typeof_interface_idx_ui__ComponentChild(int sidx) { /* ui.ComponentChild */ 
	if (sidx == _ui__ComponentChild_ui__ProgressBar_index) return 93;
	if (sidx == _ui__ComponentChild_voidptr_index) return 2;
	if (sidx == _ui__ComponentChild_ui__Label_index) return 96;
	if (sidx == _ui__ComponentChild_ui__Radio_index) return 97;
	if (sidx == _ui__ComponentChild_ui__Button_index) return 100;
	if (sidx == _ui__ComponentChild_ui__CanvasLayout_index) return 101;
	if (sidx == _ui__ComponentChild_ui__Stack_index) return 123;
	if (sidx == _ui__ComponentChild_ui__Group_index) return 153;
	if (sidx == _ui__ComponentChild_ui__ListBox_index) return 160;
	if (sidx == _ui__ComponentChild_ui__TextBox_index) return 161;
	if (sidx == _ui__ComponentChild_ui__SubWindow_index) return 227;
	if (sidx == _ui__ComponentChild_ui__Canvas_index) return 273;
	if (sidx == _ui__ComponentChild_ui__CheckBox_index) return 277;
	if (sidx == _ui__ComponentChild_ui__Dropdown_index) return 280;
	if (sidx == _ui__ComponentChild_ui__Menu_index) return 295;
	if (sidx == _ui__ComponentChild_ui__Picture_index) return 299;
	if (sidx == _ui__ComponentChild_ui__Rectangle_index) return 304;
	if (sidx == _ui__ComponentChild_ui__Slider_index) return 308;
	if (sidx == _ui__ComponentChild_ui__Switch_index) return 312;
	return 215;
}
// << typeof() support for sum types

// TypeDecl
strings__Builder strings__new_builder(int initial_size) {
	strings__Builder res = ((__new_array_with_default(0, initial_size, sizeof(u8), 0)));
	ArrayFlags_set(&res.flags, ArrayFlags__noslices);
	return res;
}

// Attr: [unsafe]
void strings__Builder_write_ptr(strings__Builder* b, u8* ptr, int len) {
	if (len == 0) {
		return;
	}
	array_push_many(b, ptr, len);
}

// Attr: [manualfree]
void strings__Builder_write_rune(strings__Builder* b, rune r) {
	Array_fixed_u8_5 buffer = {0};
	string res = utf32_to_str_no_malloc(((u32)(r)), &buffer[0]);
	if (res.len == 0) {
		return;
	}
	array_push_many(b, res.str, res.len);
}

void strings__Builder_write_runes(strings__Builder* b, Array_rune runes) {
	Array_fixed_u8_5 buffer = {0};
	for (int _t1 = 0; _t1 < runes.len; ++_t1) {
		rune r = ((rune*)runes.data)[_t1];
		string res = utf32_to_str_no_malloc(((u32)(r)), &buffer[0]);
		if (res.len == 0) {
			continue;
		}
		array_push_many(b, res.str, res.len);
	}
}

// Attr: [deprecated]
// Attr: [deprecated_after]
void strings__Builder_write_b(strings__Builder* b, u8 data) {
	array_push((array*)b, _MOV((u8[]){ data }));
}

void strings__Builder_write_u8(strings__Builder* b, u8 data) {
	array_push((array*)b, _MOV((u8[]){ data }));
}

void strings__Builder_write_byte(strings__Builder* b, byte data) {
	array_push((array*)b, _MOV((u8[]){ data }));
}

Option_int strings__Builder_write(strings__Builder* b, Array_u8 data) {
	if (data.len == 0) {
		Option_int _t1;
		opt_ok(&(int[]) { 0 }, (Option*)(&_t1), sizeof(int));
		return _t1;
	}
	_PUSH_MANY(b, (data), _t2, strings__Builder);
	Option_int _t3;
	opt_ok(&(int[]) { data.len }, (Option*)(&_t3), sizeof(int));
	return _t3;
}

// Attr: [manualfree]
void strings__Builder_drain_builder(strings__Builder* b, strings__Builder* other, int other_new_cap) {
	Option_int _t1 = strings__Builder_write(b, *other);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
  (*(int*)_t1.data);
	strings__Builder_free(other);
	*other = strings__new_builder(other_new_cap);
}

// Attr: [inline]
inline u8 strings__Builder_byte_at(strings__Builder* b, int n) {
	return (*(u8*)/*ee elem_sym */array_get(*(((Array_u8*)(b))), n));
}

// Attr: [inline]
inline void strings__Builder_write_string(strings__Builder* b, string s) {
	if (s.len == 0) {
		return;
	}
	array_push_many(b, s.str, s.len);
}

void strings__Builder_go_back(strings__Builder* b, int n) {
	array_trim(b, b->len - n);
}

// Attr: [inline]
inline string strings__Builder_spart(strings__Builder* b, int start_pos, int n) {
	{ // Unsafe block
		u8* x = malloc_noscan(n + 1);
		vmemcpy(x, ((u8*)(b->data)) + start_pos, n);
		x[n] = 0;
		return tos(x, n);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string strings__Builder_cut_last(strings__Builder* b, int n) {
	int cut_pos = b->len - n;
	string res = strings__Builder_spart(b, cut_pos, n);
	array_trim(b, cut_pos);
	return res;
}

string strings__Builder_cut_to(strings__Builder* b, int pos) {
	if (pos > b->len) {
		return _SLIT("");
	}
	return strings__Builder_cut_last(b, b->len - pos);
}

void strings__Builder_go_back_to(strings__Builder* b, int pos) {
	array_trim(b, pos);
}

// Attr: [inline]
inline void strings__Builder_writeln(strings__Builder* b, string s) {
	if (s.len > 0) {
		array_push_many(b, s.str, s.len);
	}
	array_push((array*)b, _MOV((u8[]){ ((u8)('\n')) }));
}

string strings__Builder_last_n(strings__Builder* b, int n) {
	if (n > b->len) {
		return _SLIT("");
	}
	return strings__Builder_spart(b, b->len - n, n);
}

string strings__Builder_after(strings__Builder* b, int n) {
	if (n >= b->len) {
		return _SLIT("");
	}
	return strings__Builder_spart(b, n, b->len - n);
}

string strings__Builder_str(strings__Builder* b) {
	array_push((array*)b, _MOV((u8[]){ ((u8)(0)) }));
	u8* bcopy = ((u8*)(memdup_noscan(b->data, b->len)));
	string s = u8_vstring_with_len(bcopy, b->len - 1);
	array_trim(b, 0);
	return s;
}

void strings__Builder_ensure_cap(strings__Builder* b, int n) {
	if (n <= b->cap) {
		return;
	}
	u8* new_data = vcalloc(n * b->element_size);
	if (b->data != ((voidptr)(0))) {
		vmemcpy(new_data, b->data, b->len * b->element_size);
		if (ArrayFlags_has(&b->flags, ArrayFlags__noslices)) {
			_v_free(b->data);
		}
	}
	{ // Unsafe block
		b->data = new_data;
		b->offset = 0;
		b->cap = n;
	}
}

// Attr: [unsafe]
void strings__Builder_free(strings__Builder* b) {
	if (b->data != 0) {
		_v_free(b->data);
		{ // Unsafe block
			b->data = ((voidptr)(0));
		}
	}
}

int strings__levenshtein_distance(string a, string b) {
	Array_int f = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(int), _MOV((int[1]){0})), b.len + 1, 0);
	for (int j = 0; j < f.len; ++j) {
		array_set(&f, j, &(int[]) { j });
	}
	for (int _t1 = 0; _t1 < a.len; ++_t1) {
		byte ca = a.str[_t1];
		int j = 1;
		int fj1 = (*(int*)/*ee elem_sym */array_get(f, 0));
		(*(int*)/*ee elem_sym */array_get(f, 0))++;
		for (int _t2 = 0; _t2 < b.len; ++_t2) {
			byte cb = b.str[_t2];
			int mn = ((*(int*)/*ee elem_sym */array_get(f, j)) + 1 <= (*(int*)/*ee elem_sym */array_get(f, j - 1)) + 1 ? ((*(int*)/*ee elem_sym */array_get(f, j)) + 1) : ((*(int*)/*ee elem_sym */array_get(f, j - 1)) + 1));
			if (cb != ca) {
				mn = (mn <= fj1 + 1 ? (mn) : (fj1 + 1));
			} else {
				mn = (mn <= fj1 ? (mn) : (fj1));
			}
			fj1 = (*(int*)/*ee elem_sym */array_get(f, j));
			array_set(&f, j, &(int[]) { mn });
			j++;
		}
	}
	return (*(int*)/*ee elem_sym */array_get(f, f.len - 1));
}

f32 strings__levenshtein_distance_percentage(string a, string b) {
	int d = strings__levenshtein_distance(a, b);
	int l = (a.len >= b.len ? (a.len) : (b.len));
	return (1.00 - ((f32)(d)) / ((f32)(l))) * 100.00;
}

f32 strings__dice_coefficient(string s1, string s2) {
	if (s1.len == 0 || s2.len == 0) {
		return 0.0;
	}
	if (string__eq(s1, s2)) {
		return 1.0;
	}
	if (s1.len < 2 || s2.len < 2) {
		return 0.0;
	}
	string a = (s1.len > s2.len ? (s1) : (s2));
	string b = (string__eq(a, s1) ? (s2) : (s1));
	Map_string_int first_bigrams = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	for (int i = 0; i < a.len - 1; ++i) {
		string bigram = string_substr(a, i, i + 2);
		int q = (_IN_MAP(ADDR(string, bigram), ADDR(map, first_bigrams)) ? ((*(int*)map_get(ADDR(map, first_bigrams), &(string[]){bigram}, &(int[]){ 0 })) + 1) : (1));
		map_set(&first_bigrams, &(string[]){bigram}, &(int[]) { q });
	}
	int intersection_size = 0;
	for (int i = 0; i < b.len - 1; ++i) {
		string bigram = string_substr(b, i, i + 2);
		int count = (_IN_MAP(ADDR(string, bigram), ADDR(map, first_bigrams)) ? ((*(int*)map_get(ADDR(map, first_bigrams), &(string[]){bigram}, &(int[]){ 0 }))) : (0));
		if (count > 0) {
			map_set(&first_bigrams, &(string[]){bigram}, &(int[]) { count - 1 });
			intersection_size++;
		}
	}
	return (2.0 * ((f32)(intersection_size))) / (((f32)(a.len)) + ((f32)(b.len)) - 2);
}

string strings__repeat(u8 c, int n) {
	if (n <= 0) {
		return _SLIT("");
	}
	u8* bytes = malloc_noscan(n + 1);
	{ // Unsafe block
		memset(bytes, c, n);
		bytes[n] = '0';
	}
	return u8_vstring_with_len(bytes, n);
}

string strings__repeat_string(string s, int n) {
	if (n <= 0 || s.len == 0) {
		return _SLIT("");
	}
	int slen = s.len;
	int blen = slen * n;
	u8* bytes = malloc_noscan(blen + 1);
	for (int bi = 0; bi < n; ++bi) {
		int bislen = bi * slen;
		for (int si = 0; si < slen; ++si) {
			{ // Unsafe block
				bytes[bislen + si] = string_at(s, si);
			}
		}
	}
	{ // Unsafe block
		bytes[blen] = '0';
	}
	return u8_vstring_with_len(bytes, blen);
}

string strings__find_between_pair_u8(string input, u8 start, u8 end) {
	int marks = 0;
	int start_index = -1;
	for (int i = 0; i < input.len; ++i) {
		byte b = input.str[i];
		if (b == start) {
			if (start_index == -1) {
				start_index = i + 1;
			}
			marks++;
			continue;
		}
		if (start_index > 0) {
			if (b == end) {
				marks--;
				if (marks == 0) {
					return string_substr(input, start_index, i);
				}
			}
		}
	}
	return _SLIT("");
}

string strings__find_between_pair_rune(string input, rune start, rune end) {
	int marks = 0;
	int start_index = -1;
	Array_rune runes = string_runes(input);
	for (int i = 0; i < runes.len; ++i) {
		rune r = ((rune*)runes.data)[i];
		if (r == start) {
			if (start_index == -1) {
				start_index = i + 1;
			}
			marks++;
			continue;
		}
		if (start_index > 0) {
			if (r == end) {
				marks--;
				if (marks == 0) {
					return Array_rune_string(array_slice(runes, start_index, i));
				}
			}
		}
	}
	return _SLIT("");
}

string strings__find_between_pair_string(string input, string start, string end) {
	int start_index = -1;
	int marks = 0;
	Array_rune start_runes = string_runes(start);
	Array_rune end_runes = string_runes(end);
	Array_rune runes = string_runes(input);
	int i = 0;
	for (; i < runes.len; i++) {
		Array_rune start_slice = array_slice_ni(runes, i, i + start_runes.len);
		if (Array_rune_arr_eq(start_slice, start_runes)) {
			i = i + start_runes.len - 1;
			if (start_index < 0) {
				start_index = i + 1;
			}
			marks++;
			continue;
		}
		if (start_index > 0) {
			Array_rune end_slice = array_slice_ni(runes, i, i + end_runes.len);
			if (Array_rune_arr_eq(end_slice, end_runes)) {
				marks--;
				if (marks == 0) {
					return Array_rune_string(array_slice(runes, start_index, i));
				}
				i = i + end_runes.len - 1;
				continue;
			}
		}
	}
	return _SLIT("");
}

int math__bits__leading_zeros_8(u8 x) {
	int _t1 = 8 - math__bits__len_8(x);
	return _t1;
}

int math__bits__leading_zeros_16(u16 x) {
	int _t1 = 16 - math__bits__len_16(x);
	return _t1;
}

int math__bits__leading_zeros_32(u32 x) {
	int _t1 = 32 - math__bits__len_32(x);
	return _t1;
}

int math__bits__leading_zeros_64(u64 x) {
	int _t1 = 64 - math__bits__len_64(x);
	return _t1;
}

int math__bits__trailing_zeros_8(u8 x) {
	int _t1 = ((int)((*(u8*)/*ee elem_sym */array_get(_const_math__bits__ntz_8_tab, x))));
	return _t1;
}

int math__bits__trailing_zeros_16(u16 x) {
	if (x == 0U) {
		int _t1 = 16;
		return _t1;
	}
	int _t2 = ((int)((*(u8*)/*ee elem_sym */array_get(_const_math__bits__de_bruijn32tab, ((u32)((x & -x))) * _const_math__bits__de_bruijn32 >> (32 - 5)))));
	return _t2;
}

int math__bits__trailing_zeros_32(u32 x) {
	if (x == 0U) {
		int _t1 = 32;
		return _t1;
	}
	int _t2 = ((int)((*(u8*)/*ee elem_sym */array_get(_const_math__bits__de_bruijn32tab, ((x & -x)) * _const_math__bits__de_bruijn32 >> (32 - 5)))));
	return _t2;
}

int math__bits__trailing_zeros_64(u64 x) {
	if (x == 0U) {
		int _t1 = 64;
		return _t1;
	}
	int _t2 = ((int)((*(u8*)/*ee elem_sym */array_get(_const_math__bits__de_bruijn64tab, ((x & -x)) * _const_math__bits__de_bruijn64 >> (64 - 6)))));
	return _t2;
}

int math__bits__ones_count_8(u8 x) {
	int _t1 = ((int)((*(u8*)/*ee elem_sym */array_get(_const_math__bits__pop_8_tab, x))));
	return _t1;
}

int math__bits__ones_count_16(u16 x) {
	int _t1 = ((int)((*(u8*)/*ee elem_sym */array_get(_const_math__bits__pop_8_tab, x >> 8U)) + (*(u8*)/*ee elem_sym */array_get(_const_math__bits__pop_8_tab, (x & ((u16)(0xffU)))))));
	return _t1;
}

int math__bits__ones_count_32(u32 x) {
	int _t1 = ((int)((*(u8*)/*ee elem_sym */array_get(_const_math__bits__pop_8_tab, x >> 24U)) + (*(u8*)/*ee elem_sym */array_get(_const_math__bits__pop_8_tab, (x >> 16U & 0xffU))) + (*(u8*)/*ee elem_sym */array_get(_const_math__bits__pop_8_tab, (x >> 8U & 0xffU))) + (*(u8*)/*ee elem_sym */array_get(_const_math__bits__pop_8_tab, (x & ((u32)(0xffU)))))));
	return _t1;
}

int math__bits__ones_count_64(u64 x) {
	u64 y = ((x >> ((u64)(1U)) & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) + ((x & ((_const_math__bits__m0 & _const_math__bits__max_u64))));
	y = ((y >> ((u64)(2U)) & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) + ((y & ((_const_math__bits__m1 & _const_math__bits__max_u64))));
	y = (((y >> 4U) + y) & ((_const_math__bits__m2 & _const_math__bits__max_u64)));
	y += y >> 8U;
	y += y >> 16U;
	y += y >> 32U;
	int _t1 = (((int)(y)) & ((1 << 7) - 1));
	return _t1;
}

// Attr: [inline]
inline u8 math__bits__rotate_left_8(u8 x, int k) {
	u8 n = ((u8)(8));
	u8 s = (((u8)(k)) & (n - ((u8)(1))));
	u8 _t1 = ((x << s) | (x >> (n - s)));
	return _t1;
}

// Attr: [inline]
inline u16 math__bits__rotate_left_16(u16 x, int k) {
	u16 n = ((u16)(16U));
	u16 s = (((u16)(k)) & (n - ((u16)(1U))));
	u16 _t1 = ((x << s) | (x >> (n - s)));
	return _t1;
}

// Attr: [inline]
inline u32 math__bits__rotate_left_32(u32 x, int k) {
	u32 n = ((u32)(32U));
	u32 s = (((u32)(k)) & (n - ((u32)(1U))));
	u32 _t1 = ((x << s) | (x >> (n - s)));
	return _t1;
}

// Attr: [inline]
inline u64 math__bits__rotate_left_64(u64 x, int k) {
	u64 n = ((u64)(64U));
	u64 s = (((u64)(k)) & (n - ((u64)(1U))));
	u64 _t1 = ((x << s) | (x >> (n - s)));
	return _t1;
}

// Attr: [inline]
inline u8 math__bits__reverse_8(u8 x) {
	u8 _t1 = (*(u8*)/*ee elem_sym */array_get(_const_math__bits__rev_8_tab, x));
	return _t1;
}

// Attr: [inline]
inline u16 math__bits__reverse_16(u16 x) {
	u16 _t1 = (((u16)((*(u8*)/*ee elem_sym */array_get(_const_math__bits__rev_8_tab, x >> 8U)))) | (((u16)((*(u8*)/*ee elem_sym */array_get(_const_math__bits__rev_8_tab, (x & ((u16)(0xffU))))))) << 8U));
	return _t1;
}

// Attr: [inline]
inline u32 math__bits__reverse_32(u32 x) {
	u64 y = ((((x >> ((u32)(1U)) & ((_const_math__bits__m0 & _const_math__bits__max_u32)))) | (((x & ((_const_math__bits__m0 & _const_math__bits__max_u32)))) << 1U)));
	y = ((((y >> ((u32)(2U)) & ((_const_math__bits__m1 & _const_math__bits__max_u32)))) | (((y & ((_const_math__bits__m1 & _const_math__bits__max_u32)))) << ((u32)(2U)))));
	y = ((((y >> ((u32)(4U)) & ((_const_math__bits__m2 & _const_math__bits__max_u32)))) | (((y & ((_const_math__bits__m2 & _const_math__bits__max_u32)))) << ((u32)(4U)))));
	u32 _t1 = math__bits__reverse_bytes_32(((u32)(y)));
	return _t1;
}

// Attr: [inline]
inline u64 math__bits__reverse_64(u64 x) {
	u64 y = ((((x >> ((u64)(1U)) & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) | (((x & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) << 1U)));
	y = ((((y >> ((u64)(2U)) & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) << 2U)));
	y = ((((y >> ((u64)(4U)) & ((_const_math__bits__m2 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m2 & _const_math__bits__max_u64)))) << 4U)));
	u64 _t1 = math__bits__reverse_bytes_64(y);
	return _t1;
}

// Attr: [inline]
inline u16 math__bits__reverse_bytes_16(u16 x) {
	u16 _t1 = ((x >> 8U) | (x << 8U));
	return _t1;
}

// Attr: [inline]
inline u32 math__bits__reverse_bytes_32(u32 x) {
	u64 y = ((((x >> ((u32)(8U)) & ((_const_math__bits__m3 & _const_math__bits__max_u32)))) | (((x & ((_const_math__bits__m3 & _const_math__bits__max_u32)))) << ((u32)(8U)))));
	u32 _t1 = ((u32)(((y >> 16U) | (y << 16U))));
	return _t1;
}

// Attr: [inline]
inline u64 math__bits__reverse_bytes_64(u64 x) {
	u64 y = ((((x >> ((u64)(8U)) & ((_const_math__bits__m3 & _const_math__bits__max_u64)))) | (((x & ((_const_math__bits__m3 & _const_math__bits__max_u64)))) << ((u64)(8U)))));
	y = ((((y >> ((u64)(16U)) & ((_const_math__bits__m4 & _const_math__bits__max_u64)))) | (((y & ((_const_math__bits__m4 & _const_math__bits__max_u64)))) << ((u64)(16U)))));
	u64 _t1 = ((y >> 32U) | (y << 32U));
	return _t1;
}

int math__bits__len_8(u8 x) {
	int _t1 = ((int)((*(u8*)/*ee elem_sym */array_get(_const_math__bits__len_8_tab, x))));
	return _t1;
}

int math__bits__len_16(u16 x) {
	u16 y = x;
	int n = 0;
	if (y >= 1 << 8) {
		y >>= 8U;
		n = 8;
	}
	int _t1 = n + ((int)((*(u8*)/*ee elem_sym */array_get(_const_math__bits__len_8_tab, y))));
	return _t1;
}

int math__bits__len_32(u32 x) {
	u32 y = x;
	int n = 0;
	if (y >= (1 << 16)) {
		y >>= 16U;
		n = 16;
	}
	if (y >= (1 << 8)) {
		y >>= 8U;
		n += 8;
	}
	int _t1 = n + ((int)((*(u8*)/*ee elem_sym */array_get(_const_math__bits__len_8_tab, y))));
	return _t1;
}

int math__bits__len_64(u64 x) {
	u64 y = x;
	int n = 0;
	if (y >= ((u64)(1U)) << ((u64)(32U))) {
		y >>= 32U;
		n = 32;
	}
	if (y >= ((u64)(1U)) << ((u64)(16U))) {
		y >>= 16U;
		n += 16;
	}
	if (y >= ((u64)(1U)) << ((u64)(8U))) {
		y >>= 8U;
		n += 8;
	}
	int _t1 = n + ((int)((*(u8*)/*ee elem_sym */array_get(_const_math__bits__len_8_tab, y))));
	return _t1;
}

multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry) {
	u64 sum64 = ((u64)(x)) + ((u64)(y)) + ((u64)(carry));
	u32 sum = ((u32)(sum64));
	u32 carry_out = ((u32)(sum64 >> 32U));
	return (multi_return_u32_u32){.arg0=sum, .arg1=carry_out};
}

multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry) {
	u64 sum = x + y + carry;
	u64 carry_out = ((((x & y)) | ((((x | y)) & ~sum)))) >> 63U;
	return (multi_return_u64_u64){.arg0=sum, .arg1=carry_out};
}

multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow) {
	u32 diff = x - y - borrow;
	u32 borrow_out = ((((~x & y)) | ((~((x ^ y)) & diff)))) >> 31U;
	return (multi_return_u32_u32){.arg0=diff, .arg1=borrow_out};
}

multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow) {
	u64 diff = x - y - borrow;
	u64 borrow_out = ((((~x & y)) | ((~((x ^ y)) & diff)))) >> 63U;
	return (multi_return_u64_u64){.arg0=diff, .arg1=borrow_out};
}

multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y) {
	u64 tmp = ((u64)(x)) * ((u64)(y));
	u32 hi = ((u32)(tmp >> 32U));
	u32 lo = ((u32)(tmp));
	return (multi_return_u32_u32){.arg0=hi, .arg1=lo};
}

multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y) {
	u64 x0 = (x & _const_math__bits__mask32);
	u64 x1 = x >> 32U;
	u64 y0 = (y & _const_math__bits__mask32);
	u64 y1 = y >> 32U;
	u64 w0 = x0 * y0;
	u64 t = x1 * y0 + (w0 >> 32U);
	u64 w1 = (t & _const_math__bits__mask32);
	u64 w2 = t >> 32U;
	w1 += x0 * y1;
	u64 hi = x1 * y1 + w2 + (w1 >> 32U);
	u64 lo = x * y;
	return (multi_return_u64_u64){.arg0=hi, .arg1=lo};
}

multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y) {
	if (y != 0U && y <= hi) {
		panic_debug(407, tos3("/Users/rcqls/vlang/v/vlib/math/bits/bits.v"), tos3("math.bits"), tos3("div_32"),  _const_math__bits__overflow_error);
		VUNREACHABLE();
	}
	u64 z = ((((u64)(hi)) << 32U) | ((u64)(lo)));
	u32 quo = ((u32)(z / ((u64)(y))));
	u32 rem = ((u32)(z % ((u64)(y))));
	return (multi_return_u32_u32){.arg0=quo, .arg1=rem};
}

multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1) {
	u64 y = y1;
	if (y == 0U) {
		panic_debug(422, tos3("/Users/rcqls/vlang/v/vlib/math/bits/bits.v"), tos3("math.bits"), tos3("div_64"),  _const_math__bits__overflow_error);
		VUNREACHABLE();
	}
	if (y <= hi) {
		panic_debug(425, tos3("/Users/rcqls/vlang/v/vlib/math/bits/bits.v"), tos3("math.bits"), tos3("div_64"),  _const_math__bits__overflow_error);
		VUNREACHABLE();
	}
	u32 s = ((u32)(math__bits__leading_zeros_64(y)));
	y <<= s;
	u64 yn1 = y >> 32U;
	u64 yn0 = (y & _const_math__bits__mask32);
	u64 ss1 = (hi << s);
	u32 xxx = 64 - s;
	u64 ss2 = lo >> xxx;
	if (xxx == 64U) {
		ss2 = 0U;
	}
	u64 un32 = (ss1 | ss2);
	u64 un10 = lo << s;
	u64 un1 = un10 >> 32U;
	u64 un0 = (un10 & _const_math__bits__mask32);
	u64 q1 = un32 / yn1;
	u64 rhat = un32 - (q1 * yn1);
	for (;;) {
		if (!((q1 >= _const_math__bits__two32) || (q1 * yn0) > ((_const_math__bits__two32 * rhat) + un1))) break;
		q1--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	u64 un21 = (un32 * _const_math__bits__two32) + (un1 - (q1 * y));
	u64 q0 = un21 / yn1;
	rhat = un21 - q0 * yn1;
	for (;;) {
		if (!((q0 >= _const_math__bits__two32) || (q0 * yn0) > ((_const_math__bits__two32 * rhat) + un0))) break;
		q0--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	u64 qq = ((q1 * _const_math__bits__two32) + q0);
	u64 rr = ((un21 * _const_math__bits__two32) + un0 - (q0 * y)) >> s;
	return (multi_return_u64_u64){.arg0=qq, .arg1=rr};
}

u32 math__bits__rem_32(u32 hi, u32 lo, u32 y) {
	u32 _t1 = ((u32)((((((u64)(hi)) << 32U) | ((u64)(lo)))) % ((u64)(y))));
	return _t1;
}

u64 math__bits__rem_64(u64 hi, u64 lo, u64 y) {
	multi_return_u64_u64 mr_16589 = math__bits__div_64(hi % y, lo, y);
	u64 rem = mr_16589.arg1;
	u64 _t1 = rem;
	return _t1;
}

multi_return_f64_int math__bits__normalize(f64 x) {
	f64 smallest_normal = 2.2250738585072014e-308;
	if (((x > 0.0 ? (x) : (-x))) < smallest_normal) {
		return (multi_return_f64_int){.arg0=x * (((u64)(1U)) << ((u64)(52U))), .arg1=-52};
	}
	return (multi_return_f64_int){.arg0=x, .arg1=0};
}

multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	r0 = ((s0 >> 1U) | (((s1 & ((u32)(1U)))) << 31U));
	r1 = ((s1 >> 1U) | (((s2 & ((u32)(1U)))) << 31U));
	r2 = s2 >> 1U;
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	r2 = ((s2 << 1U) | (((s1 & (((u32)(1U)) << 31U))) >> 31U));
	r1 = ((s1 << 1U) | (((s0 & (((u32)(1U)) << 31U))) >> 31U));
	r0 = s0 << 1U;
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0) {
	u64 w = ((u64)(0U));
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	w = ((u64)(s0)) + ((u64)(d0));
	r0 = ((u32)(w));
	w >>= 32U;
	w += ((u64)(s1)) + ((u64)(d1));
	r1 = ((u32)(w));
	w >>= 32U;
	w += ((u64)(s2)) + ((u64)(d2));
	r2 = ((u32)(w));
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

multi_return_u32_u32_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0) {
	u64 w = ((u64)(0U));
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	w = ((u64)(s0)) - ((u64)(d0));
	r0 = ((u32)(w));
	w >>= 32U;
	w += ((u64)(s1)) - ((u64)(d1));
	r1 = ((u32)(w));
	w >>= 32U;
	w += ((u64)(s2)) - ((u64)(d2));
	r2 = ((u32)(w));
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

bool strconv__is_digit(u8 x) {
	return (x >= _const_strconv__c_zero && x <= _const_strconv__c_nine) == true;
}

bool strconv__is_space(u8 x) {
	return x == '\t' || x == '\n' || x == '\v' || x == '\f' || x == '\r' || x == ' ';
}

bool strconv__is_exp(u8 x) {
	return (x == 'E' || x == 'e') == true;
}

multi_return_strconv__ParserState_strconv__PrepNumber strconv__parser(string s) {
	int digx = 0;
	strconv__ParserState result = strconv__ParserState__ok;
	bool expneg = false;
	int expexp = 0;
	int i = 0;
	strconv__PrepNumber pn = ((strconv__PrepNumber){.negative = 0,.exponent = 0,.mantissa = 0,});
	for (;;) {
		if (!(i < s.len && u8_is_space(string_at(s, i)))) break;
		i++;
	}
	if (string_at(s, i) == '-') {
		pn.negative = true;
		i++;
	}
	if (string_at(s, i) == '+') {
		i++;
	}
	for (;;) {
		if (!(i < s.len && u8_is_digit(string_at(s, i)))) break;
		if (digx < _const_strconv__digits) {
			pn.mantissa *= 10U;
			pn.mantissa += ((u64)(string_at(s, i) - _const_strconv__c_zero));
			digx++;
		} else if (pn.exponent < 2147483647) {
			pn.exponent++;
		}
		i++;
	}
	if ((i < s.len) && (string_at(s, i) == '.')) {
		i++;
		for (;;) {
			if (!(i < s.len && u8_is_digit(string_at(s, i)))) break;
			if (digx < _const_strconv__digits) {
				pn.mantissa *= 10U;
				pn.mantissa += ((u64)(string_at(s, i) - _const_strconv__c_zero));
				pn.exponent--;
				digx++;
			}
			i++;
		}
	}
	if ((i < s.len) && ((string_at(s, i) == 'e') || (string_at(s, i) == 'E'))) {
		i++;
		if (i < s.len) {
			if (string_at(s, i) == _const_strconv__c_plus) {
				i++;
			} else if (string_at(s, i) == _const_strconv__c_minus) {
				expneg = true;
				i++;
			}
			for (;;) {
				if (!(i < s.len && u8_is_digit(string_at(s, i)))) break;
				if (expexp < 214748364) {
					expexp *= 10;
					expexp += ((int)(string_at(s, i) - _const_strconv__c_zero));
				}
				i++;
			}
		}
	}
	if (expneg) {
		expexp = -expexp;
	}
	pn.exponent += expexp;
	if (pn.mantissa == 0U) {
		if (pn.negative) {
			result = strconv__ParserState__mzero;
		} else {
			result = strconv__ParserState__pzero;
		}
	} else if (pn.exponent > 309) {
		if (pn.negative) {
			result = strconv__ParserState__minf;
		} else {
			result = strconv__ParserState__pinf;
		}
	} else if (pn.exponent < -328) {
		if (pn.negative) {
			result = strconv__ParserState__mzero;
		} else {
			result = strconv__ParserState__pzero;
		}
	}
	if (i == 0 && s.len > 0) {
		return (multi_return_strconv__ParserState_strconv__PrepNumber){.arg0=strconv__ParserState__invalid_number, .arg1=pn};
	}
	return (multi_return_strconv__ParserState_strconv__PrepNumber){.arg0=result, .arg1=pn};
}

u64 strconv__converter(strconv__PrepNumber* pn) {
	int binexp = 92;
	u32 s2 = ((u32)(0U));
	u32 s1 = ((u32)(0U));
	u32 s0 = ((u32)(0U));
	u32 q2 = ((u32)(0U));
	u32 q1 = ((u32)(0U));
	u32 q0 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r0 = ((u32)(0U));
	u32 mask28 = ((u32)(((u64)(0xFU)) << 28U));
	u64 result = ((u64)(0U));
	s0 = ((u32)((pn->mantissa & ((u64)(0x00000000FFFFFFFFU)))));
	s1 = ((u32)(pn->mantissa >> 32U));
	s2 = ((u32)(0U));
	for (;;) {
		if (!(pn->exponent > 0)) break;
		multi_return_u32_u32_u32 mr_5500 = strconv__lsl96(s2, s1, s0);
		q2 = mr_5500.arg0;
		q1 = mr_5500.arg1;
		q0 = mr_5500.arg2;
		multi_return_u32_u32_u32 mr_5546 = strconv__lsl96(q2, q1, q0);
		r2 = mr_5546.arg0;
		r1 = mr_5546.arg1;
		r0 = mr_5546.arg2;
		multi_return_u32_u32_u32 mr_5602 = strconv__lsl96(r2, r1, r0);
		s2 = mr_5602.arg0;
		s1 = mr_5602.arg1;
		s0 = mr_5602.arg2;
		multi_return_u32_u32_u32 mr_5658 = strconv__add96(s2, s1, s0, q2, q1, q0);
		s2 = mr_5658.arg0;
		s1 = mr_5658.arg1;
		s0 = mr_5658.arg2;
		pn->exponent--;
		for (;;) {
			if (!(((s2 & mask28)) != 0U)) break;
			multi_return_u32_u32_u32 mr_5781 = strconv__lsr96(s2, s1, s0);
			q2 = mr_5781.arg0;
			q1 = mr_5781.arg1;
			q0 = mr_5781.arg2;
			binexp++;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	for (;;) {
		if (!(pn->exponent < 0)) break;
		for (;;) {
			if (!(!(((s2 & (((u32)(1U)) << 31U))) != 0U))) break;
			multi_return_u32_u32_u32 mr_5928 = strconv__lsl96(s2, s1, s0);
			q2 = mr_5928.arg0;
			q1 = mr_5928.arg1;
			q0 = mr_5928.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
		q2 = s2 / _const_strconv__c_ten;
		r1 = s2 % _const_strconv__c_ten;
		r2 = ((s1 >> 8U) | (r1 << 24U));
		q1 = r2 / _const_strconv__c_ten;
		r1 = r2 % _const_strconv__c_ten;
		r2 = (((((s1 & ((u32)(0xFFU)))) << 16U) | (s0 >> 16U)) | (r1 << 24U));
		r0 = r2 / _const_strconv__c_ten;
		r1 = r2 % _const_strconv__c_ten;
		q1 = ((q1 << 8U) | (((r0 & ((u32)(0x00FF0000U)))) >> 16U));
		q0 = r0 << 16U;
		r2 = (((s0 & ((u32)(0xFFFFU)))) | (r1 << 16U));
		q0 |= r2 / _const_strconv__c_ten;
		s2 = q2;
		s1 = q1;
		s0 = q0;
		pn->exponent++;
	}
	if (s2 != 0U || s1 != 0U || s0 != 0U) {
		for (;;) {
			if (!(((s2 & mask28)) == 0U)) break;
			multi_return_u32_u32_u32 mr_6663 = strconv__lsl96(s2, s1, s0);
			q2 = mr_6663.arg0;
			q1 = mr_6663.arg1;
			q0 = mr_6663.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	int nbit = 7;
	u32 check_round_bit = ((u32)(1U)) << ((u32)(nbit));
	u32 check_round_mask = ((u32)(0xFFFFFFFFU)) << ((u32)(nbit));
	if (((s1 & check_round_bit)) != 0U) {
		if (((s1 & ~check_round_mask)) != 0U) {
			multi_return_u32_u32_u32 mr_7745 = strconv__add96(s2, s1, s0, 0U, check_round_bit, 0U);
			s2 = mr_7745.arg0;
			s1 = mr_7745.arg1;
			s0 = mr_7745.arg2;
		} else {
			if (((s1 & (check_round_bit << ((u32)(1U))))) != 0U) {
				multi_return_u32_u32_u32 mr_7937 = strconv__add96(s2, s1, s0, 0U, check_round_bit, 0U);
				s2 = mr_7937.arg0;
				s1 = mr_7937.arg1;
				s0 = mr_7937.arg2;
			}
		}
		s1 = (s1 & check_round_mask);
		s0 = ((u32)(0U));
		if ((s2 & (mask28 << ((u32)(1U)))) != 0U) {
			multi_return_u32_u32_u32 mr_8141 = strconv__lsr96(s2, s1, s0);
			q2 = mr_8141.arg0;
			q1 = mr_8141.arg1;
			q0 = mr_8141.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	binexp += 1023;
	if (binexp > 2046) {
		if (pn->negative) {
			result = _const_strconv__double_minus_infinity;
		} else {
			result = _const_strconv__double_plus_infinity;
		}
	} else if (binexp < 1) {
		if (pn->negative) {
			result = _const_strconv__double_minus_zero;
		} else {
			result = _const_strconv__double_plus_zero;
		}
	} else if (s2 != 0U) {
		u64 q = ((u64)(0U));
		u64 binexs2 = ((u64)(binexp)) << 52U;
		q = (((((u64)((s2 & ~mask28))) << 24U) | ((((u64)(s1)) + ((u64)(128U))) >> 8U)) | binexs2);
		if (pn->negative) {
			q |= (((u64)(1U)) << 63U);
		}
		result = q;
	}
	return result;
}

Option_f64 strconv__atof64(string s) {
	if (s.len == 0) {
		return (Option_f64){ .state=2, .err=_v_error(_SLIT("expected a number found an empty string")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	strconv__Float64u res = ((strconv__Float64u){0});
	multi_return_strconv__ParserState_strconv__PrepNumber mr_9209 = strconv__parser(s);
	strconv__ParserState res_parsing = mr_9209.arg0;
	strconv__PrepNumber pn = mr_9209.arg1;
	switch (res_parsing) {
		case strconv__ParserState__ok: 
			{
				res.u = strconv__converter((voidptr)&/*qq*/pn);
				break;
			}
		case strconv__ParserState__pzero: 
			{
				res.u = _const_strconv__double_plus_zero;
				break;
			}
		case strconv__ParserState__mzero: 
			{
				res.u = _const_strconv__double_minus_zero;
				break;
			}
		case strconv__ParserState__pinf: 
			{
				res.u = _const_strconv__double_plus_infinity;
				break;
			}
		case strconv__ParserState__minf: 
			{
				res.u = _const_strconv__double_minus_infinity;
				break;
			}
		case strconv__ParserState__invalid_number: 
			{
				return (Option_f64){ .state=2, .err=_v_error(_SLIT("not a number")), .data={EMPTY_STRUCT_INITIALIZATION} };
				break;
			}
	}
	;
	Option_f64 _t3;
	opt_ok(&(f64[]) { res.f }, (Option*)(&_t3), sizeof(f64));
	return _t3;
}

f64 strconv__atof_quick(string s) {
	strconv__Float64u f = ((strconv__Float64u){0});
	f64 sign = ((f64)(1.0));
	int i = 0;
	for (;;) {
		if (!(i < s.len && string_at(s, i) == ' ')) break;
		i++;
	}
	if (i < s.len) {
		if (string_at(s, i) == '-') {
			sign = -1.0;
			i++;
		} else if (string_at(s, i) == '+') {
			i++;
		}
	}
	if (string_at(s, i) == 'i' && i + 2 < s.len && string_at(s, i + 1) == 'n' && string_at(s, i + 2) == 'f') {
		if (sign > 0.0) {
			f.u = _const_strconv__double_plus_infinity;
		} else {
			f.u = _const_strconv__double_minus_infinity;
		}
		return f.f;
	}
	for (;;) {
		if (!(i < s.len && string_at(s, i) == '0')) break;
		i++;
		if (i >= s.len) {
			if (sign > 0.0) {
				f.u = _const_strconv__double_plus_zero;
			} else {
				f.u = _const_strconv__double_minus_zero;
			}
			return f.f;
		}
	}
	for (;;) {
		if (!(i < s.len && (string_at(s, i) >= '0' && string_at(s, i) <= '9'))) break;
		f.f *= ((f64)(10.0));
		f.f += ((f64)(string_at(s, i) - '0'));
		i++;
	}
	if (i < s.len && string_at(s, i) == '.') {
		i++;
		f64 frac_mul = ((f64)(0.1));
		for (;;) {
			if (!(i < s.len && (string_at(s, i) >= '0' && string_at(s, i) <= '9'))) break;
			f.f += ((f64)(string_at(s, i) - '0')) * frac_mul;
			frac_mul *= ((f64)(0.1));
			i++;
		}
	}
	if (i < s.len && (string_at(s, i) == 'e' || string_at(s, i) == 'E')) {
		i++;
		int exp = 0;
		int exp_sign = 1;
		if (i < s.len) {
			if (string_at(s, i) == '-') {
				exp_sign = -1;
				i++;
			} else if (string_at(s, i) == '+') {
				i++;
			}
		}
		for (;;) {
			if (!(i < s.len && string_at(s, i) == '0')) break;
			i++;
		}
		for (;;) {
			if (!(i < s.len && (string_at(s, i) >= '0' && string_at(s, i) <= '9'))) break;
			exp *= 10;
			exp += ((int)(string_at(s, i) - '0'));
			i++;
		}
		if (exp_sign == 1) {
			if (exp > _const_strconv__pos_exp.len) {
				if (sign > 0) {
					f.u = _const_strconv__double_plus_infinity;
				} else {
					f.u = _const_strconv__double_minus_infinity;
				}
				return f.f;
			}
			strconv__Float64u tmp_mul = ((strconv__Float64u){.u = (*(u64*)/*ee elem_sym */array_get(_const_strconv__pos_exp, exp)),});
			f.f = f.f * tmp_mul.f;
		} else {
			if (exp > _const_strconv__neg_exp.len) {
				if (sign > 0) {
					f.u = _const_strconv__double_plus_zero;
				} else {
					f.u = _const_strconv__double_minus_zero;
				}
				return f.f;
			}
			strconv__Float64u tmp_mul = ((strconv__Float64u){.u = (*(u64*)/*ee elem_sym */array_get(_const_strconv__neg_exp, exp)),});
			f.f = f.f * tmp_mul.f;
		}
	}
	{ // Unsafe block
		f.f = f.f * sign;
		return f.f;
	}
	return 0;
}

u8 strconv__byte_to_lower(u8 c) {
	return (c | ('x' - 'X'));
}

Option_u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	multi_return_u64_int mr_820 = strconv__common_parse_uint2(s, _base, _bit_size);
	u64 result = mr_820.arg0;
	int err = mr_820.arg1;
	if (err != 0 && (error_on_non_digit || error_on_high_digit)) {

		if (err == (-1)) {
			return (Option_u64){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: wrong base "), 0xfe07, {.d_i32 = _base}}, {_SLIT(" for "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		else if (err == (-2)) {
			return (Option_u64){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: wrong bit size "), 0xfe07, {.d_i32 = _bit_size}}, {_SLIT(" for "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		else if (err == (-3)) {
			return (Option_u64){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: integer overflow "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		else {
			return (Option_u64){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: syntax error "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		};
	}
	Option_u64 _t5;
	opt_ok(&(u64[]) { result }, (Option*)(&_t5), sizeof(u64));
	return _t5;
}

multi_return_u64_int strconv__common_parse_uint2(string s, int _base, int _bit_size) {
	int bit_size = _bit_size;
	int base = _base;
	if (s.len < 1 || !strconv__underscore_ok(s)) {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=1};
	}
	bool base0 = base == 0;
	int start_index = 0;
	if (2 <= base && base <= 36) {
	} else if (base == 0) {
		base = 10;
		if (string_at(s, 0) == '0') {
			if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'b') {
				base = 2;
				start_index += 2;
			} else if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'o') {
				base = 8;
				start_index += 2;
			} else if (s.len >= 3 && strconv__byte_to_lower(string_at(s, 1)) == 'x') {
				base = 16;
				start_index += 2;
			} else if (s.len >= 2 && (string_at(s, 1) >= '0' && string_at(s, 1) <= '9')) {
				base = 10;
				start_index++;
			} else {
				base = 8;
				start_index++;
			}
		}
	} else {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=-1};
	}
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	} else if (bit_size < 0 || bit_size > 64) {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=-2};
	}
	u64 cutoff = _const_strconv__max_u64 / ((u64)(base)) + ((u64)(1U));
	u64 max_val = (bit_size == 64 ? (_const_strconv__max_u64) : ((((u64)(1U)) << ((u64)(bit_size))) - ((u64)(1U))));
	u64 n = ((u64)(0U));
	for (int i = start_index; i < s.len; ++i) {
		u8 c = string_at(s, i);
		u8 cl = strconv__byte_to_lower(c);
		u8 d = ((u8)(0));
		if (c == '_' && base0) {
			continue;
		} else if ('0' <= c && c <= '9') {
			d = c - '0';
		} else if ('a' <= cl && cl <= 'z') {
			d = cl - 'a' + 10;
		} else {
			return (multi_return_u64_int){.arg0=n, .arg1=i + 1};
		}
		if (d >= ((u8)(base))) {
			return (multi_return_u64_int){.arg0=n, .arg1=i + 1};
		}
		if (n >= cutoff) {
			return (multi_return_u64_int){.arg0=max_val, .arg1=-3};
		}
		n *= ((u64)(base));
		u64 n1 = n + ((u64)(d));
		if (n1 < n || n1 > max_val) {
			return (multi_return_u64_int){.arg0=max_val, .arg1=-3};
		}
		n = n1;
	}
	return (multi_return_u64_int){.arg0=n, .arg1=0};
}

Option_u64 strconv__parse_uint(string s, int _base, int _bit_size) {
	return strconv__common_parse_uint(s, _base, _bit_size, true, true);
}

Option_i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	string s = _s;
	int bit_size = _bit_size;
	if (s.len < 1) {
		Option_i64 _t1;
		opt_ok(&(i64[]) { ((i64)(0)) }, (Option*)(&_t1), sizeof(i64));
		return _t1;
	}
	bool neg = false;
	if (string_at(s, 0) == '+') {
		s = string_substr(s, 1, (s).len);
	} else if (string_at(s, 0) == '-') {
		neg = true;
		s = string_substr(s, 1, (s).len);
	}
	Option_u64 _t2 = strconv__common_parse_uint(s, base, bit_size, error_on_non_digit, error_on_high_digit);
	if (_t2.state != 0) { /*or block*/ 
		Option_i64 _t3;
		memcpy(&_t3, &_t2, sizeof(Option));
		return _t3;
	}
	
 	u64 un =  (*(u64*)_t2.data);
	if (un == 0U) {
		Option_i64 _t4;
		opt_ok(&(i64[]) { ((i64)(0)) }, (Option*)(&_t4), sizeof(i64));
		return _t4;
	}
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	}
	u64 cutoff = ((u64)(1U)) << ((u64)(bit_size - 1));
	if (!neg && un >= cutoff) {
		Option_i64 _t5;
		opt_ok(&(i64[]) { ((i64)(cutoff - ((u64)(1U)))) }, (Option*)(&_t5), sizeof(i64));
		return _t5;
	}
	if (neg && un > cutoff) {
		Option_i64 _t6;
		opt_ok(&(i64[]) { -((i64)(cutoff)) }, (Option*)(&_t6), sizeof(i64));
		return _t6;
	}
	Option_i64 _t8; /* if prepend */
	if (neg) {
		opt_ok(&(i64[]) { -((i64)(un)) }, (Option*)(&_t8), sizeof(i64));
	} else {
		opt_ok(&(i64[]) { ((i64)(un)) }, (Option*)(&_t8), sizeof(i64));
	}
	return  _t8;
}

Option_i64 strconv__parse_int(string _s, int base, int _bit_size) {
	return strconv__common_parse_int(_s, base, _bit_size, true, true);
}

Option_int strconv__atoi(string s) {
	if ((s).len == 0) {
		return (Option_int){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("strconv.atoi: parsing \""), 0xfe10, {.d_s = s}}, {_SLIT("\": invalid syntax "), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if ((_const_strconv__int_size == 32 && (0 < s.len && s.len < 10)) || (_const_strconv__int_size == 64 && (0 < s.len && s.len < 19))) {
		int start_idx = 0;
		if (string_at(s, 0) == '-' || string_at(s, 0) == '+') {
			start_idx++;
			if (s.len - start_idx < 1) {
				return (Option_int){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("strconv.atoi: parsing \""), 0xfe10, {.d_s = s}}, {_SLIT("\": invalid syntax "), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		int n = 0;
		for (int i = start_idx; i < s.len; ++i) {
			rune ch = string_at(s, i) - '0';
			if (ch > 9) {
				return (Option_int){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("strconv.atoi: parsing \""), 0xfe10, {.d_s = s}}, {_SLIT("\": invalid syntax "), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			n = n * 10 + ((int)(ch));
		}
		Option_int _t5; /* if prepend */
		if (string_at(s, 0) == '-') {
			opt_ok(&(int[]) { -n }, (Option*)(&_t5), sizeof(int));
		} else {
			opt_ok(&(int[]) { n }, (Option*)(&_t5), sizeof(int));
		}
		return  _t5;
	}
	Option_i64 _t6 = strconv__parse_int(s, 10, 0);
	if (_t6.state != 0) { /*or block*/ 
		Option_int _t7;
		memcpy(&_t7, &_t6, sizeof(Option));
		return _t7;
	}
	
 	i64 int64 =  (*(i64*)_t6.data);
	Option_int _t8;
	opt_ok(&(int[]) { ((int)(int64)) }, (Option*)(&_t8), sizeof(int));
	return _t8;
}

bool strconv__underscore_ok(string s) {
	rune saw = '^';
	int i = 0;
	if (s.len >= 1 && (string_at(s, 0) == '-' || string_at(s, 0) == '+')) {
		i++;
	}
	bool hex = false;
	if (s.len - i >= 2 && string_at(s, i) == '0' && (strconv__byte_to_lower(string_at(s, i + 1)) == 'b' || strconv__byte_to_lower(string_at(s, i + 1)) == 'o' || strconv__byte_to_lower(string_at(s, i + 1)) == 'x')) {
		saw = '0';
		hex = strconv__byte_to_lower(string_at(s, i + 1)) == 'x';
		i += 2;
	}
	for (; i < s.len; i++) {
		if (('0' <= string_at(s, i) && string_at(s, i) <= '9') || (hex && 'a' <= strconv__byte_to_lower(string_at(s, i)) && strconv__byte_to_lower(string_at(s, i)) <= 'f')) {
			saw = '0';
			continue;
		}
		if (string_at(s, i) == '_') {
			if (saw != '0') {
				return false;
			}
			saw = '_';
			continue;
		}
		if (saw == '_') {
			return false;
		}
		saw = '!';
	}
	return saw != '_';
}

// Attr: [direct_array_access]
string strconv__Dec32_get_string_32(strconv__Dec32 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = i_n_digit + 1;
	int pad_digit = i_pad_digit + 1;
	u32 out = d.m;
	int out_len = strconv__dec_digits(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = pad_digit - out_len;
	}
	Array_u8 buf = __new_array_with_default(((int)(out_len + 5 + 1 + 1)), 0, sizeof(u8), 0);
	int i = 0;
	if (neg) {
		if (buf.data != 0) {
			((u8*)buf.data)[i] = '-';
		}
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += ((u32*)_const_strconv__ten_pow_table_32.data)[out_len - n_digit - 1] * 5U;
		out /= ((u32*)_const_strconv__ten_pow_table_32.data)[out_len - n_digit];
		out_len = n_digit;
	}
	int y = i + out_len;
	int x = 0;
	for (;;) {
		if (!(x < (out_len - disp - 1))) break;
		((u8*)buf.data)[y - x] = '0' + ((u8)(out % 10U));
		out /= 10U;
		i++;
		x++;
	}
	if (i_n_digit == 0) {
		{ // Unsafe block
			((u8*)buf.data)[i] = 0;
			return tos(((u8*)(&((u8*)buf.data)[0])), i);
		}
	}
	if (out_len >= 1) {
		((u8*)buf.data)[y - x] = '.';
		x++;
		i++;
	}
	if (y - x >= 0) {
		((u8*)buf.data)[y - x] = '0' + ((u8)(out % 10U));
		i++;
	}
	for (;;) {
		if (!(fw_zeros > 0)) break;
		((u8*)buf.data)[i] = '0';
		i++;
		fw_zeros--;
	}
	((u8*)buf.data)[i] = 'e';
	i++;
	int exp = d.e + out_len_original - 1;
	if (exp < 0) {
		((u8*)buf.data)[i] = '-';
		i++;
		exp = -exp;
	} else {
		((u8*)buf.data)[i] = '+';
		i++;
	}
	int d1 = exp % 10;
	int d0 = exp / 10;
	((u8*)buf.data)[i] = '0' + ((u8)(d0));
	i++;
	((u8*)buf.data)[i] = '0' + ((u8)(d1));
	i++;
	((u8*)buf.data)[i] = 0;
	return tos(((u8*)(&((u8*)buf.data)[0])), i);
}

multi_return_strconv__Dec32_bool strconv__f32_to_decimal_exact_int(u32 i_mant, u32 exp) {
	strconv__Dec32 d = ((strconv__Dec32){.m = 0,.e = 0,});
	u32 e = exp - _const_strconv__bias32;
	if (e > _const_strconv__mantbits32) {
		return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=false};
	}
	u32 shift = _const_strconv__mantbits32 - e;
	u32 mant = (i_mant | 0x00800000U);
	d.m = mant >> shift;
	if ((d.m << shift) != mant) {
		return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=false};
	}
	for (;;) {
		if (!((d.m % 10U) == 0U)) break;
		d.m /= 10U;
		d.e++;
	}
	return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=true};
}

strconv__Dec32 strconv__f32_to_decimal(u32 mant, u32 exp) {
	int e2 = 0;
	u32 m2 = ((u32)(0U));
	if (exp == 0U) {
		e2 = 1 - _const_strconv__bias32 - ((int)(_const_strconv__mantbits32)) - 2;
		m2 = mant;
	} else {
		e2 = ((int)(exp)) - _const_strconv__bias32 - ((int)(_const_strconv__mantbits32)) - 2;
		m2 = ((((u32)(1U)) << _const_strconv__mantbits32) | mant);
	}
	bool even = ((m2 & 1U)) == 0U;
	bool accept_bounds = even;
	u32 mv = ((u32)(4 * m2));
	u32 mp = ((u32)(4 * m2 + 2U));
	u32 mm_shift = strconv__bool_to_u32(mant != 0U || exp <= 1U);
	u32 mm = ((u32)(4 * m2 - 1U - mm_shift));
	u32 vr = ((u32)(0U));
	u32 vp = ((u32)(0U));
	u32 vm = ((u32)(0U));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	u8 last_removed_digit = ((u8)(0));
	if (e2 >= 0) {
		u32 q = strconv__log10_pow2(e2);
		e10 = ((int)(q));
		int k = _const_strconv__pow5_inv_num_bits_32 + strconv__pow5_bits(((int)(q))) - 1;
		int i = -e2 + ((int)(q)) + k;
		vr = strconv__mul_pow5_invdiv_pow2(mv, q, i);
		vp = strconv__mul_pow5_invdiv_pow2(mp, q, i);
		vm = strconv__mul_pow5_invdiv_pow2(mm, q, i);
		if (q != 0U && (vp - 1U) / 10U <= vm / 10U) {
			int l = _const_strconv__pow5_inv_num_bits_32 + strconv__pow5_bits(((int)(q - 1U))) - 1;
			last_removed_digit = ((u8)(strconv__mul_pow5_invdiv_pow2(mv, q - 1U, -e2 + ((int)(q - 1U)) + l) % 10U));
		}
		if (q <= 9U) {
			if (mv % 5U == 0U) {
				vr_is_trailing_zeros = strconv__multiple_of_power_of_five_32(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__multiple_of_power_of_five_32(mm, q);
			} else if (strconv__multiple_of_power_of_five_32(mp, q)) {
				vp--;
			}
		}
	} else {
		u32 q = strconv__log10_pow5(-e2);
		e10 = ((int)(q)) + e2;
		int i = -e2 - ((int)(q));
		int k = strconv__pow5_bits(i) - _const_strconv__pow5_num_bits_32;
		int j = ((int)(q)) - k;
		vr = strconv__mul_pow5_div_pow2(mv, ((u32)(i)), j);
		vp = strconv__mul_pow5_div_pow2(mp, ((u32)(i)), j);
		vm = strconv__mul_pow5_div_pow2(mm, ((u32)(i)), j);
		if (q != 0U && ((vp - 1U) / 10U) <= vm / 10U) {
			j = ((int)(q)) - 1 - (strconv__pow5_bits(i + 1) - _const_strconv__pow5_num_bits_32);
			last_removed_digit = ((u8)(strconv__mul_pow5_div_pow2(mv, ((u32)(i + 1)), j) % 10U));
		}
		if (q <= 1U) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = mm_shift == 1U;
			} else {
				vp--;
			}
		} else if (q < 31U) {
			vr_is_trailing_zeros = strconv__multiple_of_power_of_two_32(mv, q - 1U);
		}
	}
	int removed = 0;
	u32 out = ((u32)(0U));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		for (;;) {
			if (!(vp / 10U > vm / 10U)) break;
			vm_is_trailing_zeros = vm_is_trailing_zeros && (vm % 10U) == 0U;
			vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
			last_removed_digit = ((u8)(vr % 10U));
			vr /= 10U;
			vp /= 10U;
			vm /= 10U;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			for (;;) {
				if (!(vm % 10U == 0U)) break;
				vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
				last_removed_digit = ((u8)(vr % 10U));
				vr /= 10U;
				vp /= 10U;
				vm /= 10U;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2U) == 0U) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		for (;;) {
			if (!(vp / 10U > vm / 10U)) break;
			last_removed_digit = ((u8)(vr % 10U));
			vr /= 10U;
			vp /= 10U;
			vm /= 10U;
			removed++;
		}
		out = vr + strconv__bool_to_u32(vr == vm || last_removed_digit >= 5);
	}
	return ((strconv__Dec32){.m = out,.e = e10 + removed,});
}

string strconv__f32_to_str(f32 f, int n_digit) {
	strconv__Uf32 u1 = ((strconv__Uf32){0});
	u1.f = f;
	u32 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits32 + _const_strconv__expbits32)) != 0U;
	u32 mant = (u & ((((u32)(1U)) << _const_strconv__mantbits32) - ((u32)(1U))));
	u32 exp = ((u >> _const_strconv__mantbits32) & ((((u32)(1U)) << _const_strconv__expbits32) - ((u32)(1U))));
	if ((exp == _const_strconv__maxexp32) || (exp == 0U && mant == 0U)) {
		return strconv__get_string_special(neg, exp == 0U, mant == 0U);
	}
	multi_return_strconv__Dec32_bool mr_8747 = strconv__f32_to_decimal_exact_int(mant, exp);
	strconv__Dec32 d = mr_8747.arg0;
	bool ok = mr_8747.arg1;
	if (!ok) {
		d = strconv__f32_to_decimal(mant, exp);
	}
	return strconv__Dec32_get_string_32(d, neg, n_digit, 0);
}

string strconv__f32_to_str_pad(f32 f, int n_digit) {
	strconv__Uf32 u1 = ((strconv__Uf32){0});
	u1.f = f;
	u32 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits32 + _const_strconv__expbits32)) != 0U;
	u32 mant = (u & ((((u32)(1U)) << _const_strconv__mantbits32) - ((u32)(1U))));
	u32 exp = ((u >> _const_strconv__mantbits32) & ((((u32)(1U)) << _const_strconv__expbits32) - ((u32)(1U))));
	if ((exp == _const_strconv__maxexp32) || (exp == 0U && mant == 0U)) {
		return strconv__get_string_special(neg, exp == 0U, mant == 0U);
	}
	multi_return_strconv__Dec32_bool mr_9521 = strconv__f32_to_decimal_exact_int(mant, exp);
	strconv__Dec32 d = mr_9521.arg0;
	bool ok = mr_9521.arg1;
	if (!ok) {
		d = strconv__f32_to_decimal(mant, exp);
	}
	return strconv__Dec32_get_string_32(d, neg, n_digit, n_digit);
}

// Attr: [direct_array_access]
string strconv__Dec64_get_string_64(strconv__Dec64 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = i_n_digit + 1;
	int pad_digit = i_pad_digit + 1;
	u64 out = d.m;
	int d_exp = d.e;
	int out_len = strconv__dec_digits(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = pad_digit - out_len;
	}
	Array_u8 buf = __new_array_with_default((out_len + 6 + 1 + 1 + fw_zeros), 0, sizeof(u8), 0);
	int i = 0;
	if (neg) {
		((u8*)buf.data)[i] = '-';
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += ((u64*)_const_strconv__ten_pow_table_64.data)[out_len - n_digit - 1] * 5U;
		out /= ((u64*)_const_strconv__ten_pow_table_64.data)[out_len - n_digit];
		if (d.m / ((u64*)_const_strconv__ten_pow_table_64.data)[out_len - n_digit] < out) {
			d_exp++;
			n_digit++;
		}
		out_len = n_digit;
	}
	int y = i + out_len;
	int x = 0;
	for (;;) {
		if (!(x < (out_len - disp - 1))) break;
		((u8*)buf.data)[y - x] = '0' + ((u8)(out % 10U));
		out /= 10U;
		i++;
		x++;
	}
	if (i_n_digit == 0) {
		{ // Unsafe block
			((u8*)buf.data)[i] = 0;
			return tos(((u8*)(&((u8*)buf.data)[0])), i);
		}
	}
	if (out_len >= 1) {
		((u8*)buf.data)[y - x] = '.';
		x++;
		i++;
	}
	if (y - x >= 0) {
		((u8*)buf.data)[y - x] = '0' + ((u8)(out % 10U));
		i++;
	}
	for (;;) {
		if (!(fw_zeros > 0)) break;
		((u8*)buf.data)[i] = '0';
		i++;
		fw_zeros--;
	}
	((u8*)buf.data)[i] = 'e';
	i++;
	int exp = d_exp + out_len_original - 1;
	if (exp < 0) {
		((u8*)buf.data)[i] = '-';
		i++;
		exp = -exp;
	} else {
		((u8*)buf.data)[i] = '+';
		i++;
	}
	int d2 = exp % 10;
	exp /= 10;
	int d1 = exp % 10;
	int d0 = exp / 10;
	if (d0 > 0) {
		((u8*)buf.data)[i] = '0' + ((u8)(d0));
		i++;
	}
	((u8*)buf.data)[i] = '0' + ((u8)(d1));
	i++;
	((u8*)buf.data)[i] = '0' + ((u8)(d2));
	i++;
	((u8*)buf.data)[i] = 0;
	return tos(((u8*)(&((u8*)buf.data)[0])), i);
}

multi_return_strconv__Dec64_bool strconv__f64_to_decimal_exact_int(u64 i_mant, u64 exp) {
	strconv__Dec64 d = ((strconv__Dec64){.m = 0,.e = 0,});
	u64 e = exp - _const_strconv__bias64;
	if (e > _const_strconv__mantbits64) {
		return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=false};
	}
	u64 shift = _const_strconv__mantbits64 - e;
	u64 mant = (i_mant | ((u64)(0x0010000000000000U)));
	d.m = mant >> shift;
	if ((d.m << shift) != mant) {
		return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=false};
	}
	for (;;) {
		if (!((d.m % 10U) == 0U)) break;
		d.m /= 10U;
		d.e++;
	}
	return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=true};
}

strconv__Dec64 strconv__f64_to_decimal(u64 mant, u64 exp) {
	int e2 = 0;
	u64 m2 = ((u64)(0U));
	if (exp == 0U) {
		e2 = 1 - _const_strconv__bias64 - ((int)(_const_strconv__mantbits64)) - 2;
		m2 = mant;
	} else {
		e2 = ((int)(exp)) - _const_strconv__bias64 - ((int)(_const_strconv__mantbits64)) - 2;
		m2 = ((((u64)(1U)) << _const_strconv__mantbits64) | mant);
	}
	bool even = ((m2 & 1U)) == 0U;
	bool accept_bounds = even;
	u64 mv = ((u64)(4 * m2));
	u64 mm_shift = strconv__bool_to_u64(mant != 0U || exp <= 1U);
	u64 vr = ((u64)(0U));
	u64 vp = ((u64)(0U));
	u64 vm = ((u64)(0U));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	if (e2 >= 0) {
		u32 q = strconv__log10_pow2(e2) - strconv__bool_to_u32(e2 > 3);
		e10 = ((int)(q));
		int k = _const_strconv__pow5_inv_num_bits_64 + strconv__pow5_bits(((int)(q))) - 1;
		int i = -e2 + ((int)(q)) + k;
		strconv__Uint128 mul = (*(strconv__Uint128*)/*ee elem_sym */array_get(_const_strconv__pow5_inv_split_64, q));
		vr = strconv__mul_shift_64(((u64)(4U)) * m2, mul, i);
		vp = strconv__mul_shift_64(((u64)(4U)) * m2 + ((u64)(2U)), mul, i);
		vm = strconv__mul_shift_64(((u64)(4U)) * m2 - ((u64)(1U)) - mm_shift, mul, i);
		if (q <= 21U) {
			if (mv % 5U == 0U) {
				vr_is_trailing_zeros = strconv__multiple_of_power_of_five_64(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__multiple_of_power_of_five_64(mv - 1U - mm_shift, q);
			} else if (strconv__multiple_of_power_of_five_64(mv + 2U, q)) {
				vp--;
			}
		}
	} else {
		u32 q = strconv__log10_pow5(-e2) - strconv__bool_to_u32(-e2 > 1);
		e10 = ((int)(q)) + e2;
		int i = -e2 - ((int)(q));
		int k = strconv__pow5_bits(i) - _const_strconv__pow5_num_bits_64;
		int j = ((int)(q)) - k;
		strconv__Uint128 mul = (*(strconv__Uint128*)/*ee elem_sym */array_get(_const_strconv__pow5_split_64, i));
		vr = strconv__mul_shift_64(((u64)(4U)) * m2, mul, j);
		vp = strconv__mul_shift_64(((u64)(4U)) * m2 + ((u64)(2U)), mul, j);
		vm = strconv__mul_shift_64(((u64)(4U)) * m2 - ((u64)(1U)) - mm_shift, mul, j);
		if (q <= 1U) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = (mm_shift == 1U);
			} else {
				vp--;
			}
		} else if (q < 63U) {
			vr_is_trailing_zeros = strconv__multiple_of_power_of_two_64(mv, q - 1U);
		}
	}
	int removed = 0;
	u8 last_removed_digit = ((u8)(0));
	u64 out = ((u64)(0U));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		for (;;) {
			u64 vp_div_10 = vp / 10U;
			u64 vm_div_10 = vm / 10U;
			if (vp_div_10 <= vm_div_10) {
				break;
			}
			u64 vm_mod_10 = vm % 10U;
			u64 vr_div_10 = vr / 10U;
			u64 vr_mod_10 = vr % 10U;
			vm_is_trailing_zeros = vm_is_trailing_zeros && vm_mod_10 == 0U;
			vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
			last_removed_digit = ((u8)(vr_mod_10));
			vr = vr_div_10;
			vp = vp_div_10;
			vm = vm_div_10;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			for (;;) {
				u64 vm_div_10 = vm / 10U;
				u64 vm_mod_10 = vm % 10U;
				if (vm_mod_10 != 0U) {
					break;
				}
				u64 vp_div_10 = vp / 10U;
				u64 vr_div_10 = vr / 10U;
				u64 vr_mod_10 = vr % 10U;
				vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0);
				last_removed_digit = ((u8)(vr_mod_10));
				vr = vr_div_10;
				vp = vp_div_10;
				vm = vm_div_10;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2U) == 0U) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		bool round_up = false;
		for (;;) {
			if (!(vp / 100U > vm / 100U)) break;
			round_up = (vr % 100U) >= 50U;
			vr /= 100U;
			vp /= 100U;
			vm /= 100U;
			removed += 2;
		}
		for (;;) {
			if (!(vp / 10U > vm / 10U)) break;
			round_up = (vr % 10U) >= 5U;
			vr /= 10U;
			vp /= 10U;
			vm /= 10U;
			removed++;
		}
		out = vr + strconv__bool_to_u64(vr == vm || round_up);
	}
	return ((strconv__Dec64){.m = out,.e = e10 + removed,});
}

string strconv__f64_to_str(f64 f, int n_digit) {
	strconv__Uf64 u1 = ((strconv__Uf64){0});
	u1.f = f;
	u64 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits64 + _const_strconv__expbits64)) != 0U;
	u64 mant = (u & ((((u64)(1U)) << _const_strconv__mantbits64) - ((u64)(1U))));
	u64 exp = ((u >> _const_strconv__mantbits64) & ((((u64)(1U)) << _const_strconv__expbits64) - ((u64)(1U))));
	if ((exp == _const_strconv__maxexp64) || (exp == 0U && mant == 0U)) {
		return strconv__get_string_special(neg, exp == 0U, mant == 0U);
	}
	multi_return_strconv__Dec64_bool mr_9304 = strconv__f64_to_decimal_exact_int(mant, exp);
	strconv__Dec64 d = mr_9304.arg0;
	bool ok = mr_9304.arg1;
	if (!ok) {
		d = strconv__f64_to_decimal(mant, exp);
	}
	return strconv__Dec64_get_string_64(d, neg, n_digit, 0);
}

string strconv__f64_to_str_pad(f64 f, int n_digit) {
	strconv__Uf64 u1 = ((strconv__Uf64){0});
	u1.f = f;
	u64 u = u1.u;
	bool neg = (u >> (_const_strconv__mantbits64 + _const_strconv__expbits64)) != 0U;
	u64 mant = (u & ((((u64)(1U)) << _const_strconv__mantbits64) - ((u64)(1U))));
	u64 exp = ((u >> _const_strconv__mantbits64) & ((((u64)(1U)) << _const_strconv__expbits64) - ((u64)(1U))));
	if ((exp == _const_strconv__maxexp64) || (exp == 0U && mant == 0U)) {
		return strconv__get_string_special(neg, exp == 0U, mant == 0U);
	}
	multi_return_strconv__Dec64_bool mr_10057 = strconv__f64_to_decimal_exact_int(mant, exp);
	strconv__Dec64 d = mr_10057.arg0;
	bool ok = mr_10057.arg1;
	if (!ok) {
		d = strconv__f64_to_decimal(mant, exp);
	}
	return strconv__Dec64_get_string_64(d, neg, n_digit, n_digit);
}

// Attr: [manualfree]
string strconv__format_str(string s, strconv__BF_param p) {
bool strconv__format_str_defer_0 = false;
strings__Builder res;
	if (p.len0 <= 0) {
		return string_clone(s);
	}
	int dif = p.len0 - utf8_str_visible_length(s);
	if (dif <= 0) {
		return string_clone(s);
	}
	res = strings__new_builder(s.len + dif);
	strconv__format_str_defer_0 = true;
	if (p.allign == strconv__Align_text__right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(&res, p.pad_ch);
		}
	}
	strings__Builder_write_string(&res, s);
	if (p.allign == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(&res, p.pad_ch);
		}
	}
	string _t3 = strings__Builder_str(&res);
	// Defer begin
	if (strconv__format_str_defer_0) {
		strings__Builder_free(&res);
	}
	// Defer end
	return _t3;
}

void strconv__format_str_sb(string s, strconv__BF_param p, strings__Builder* sb) {
	if (p.len0 <= 0) {
		strings__Builder_write_string(sb, s);
		return;
	}
	int dif = p.len0 - utf8_str_visible_length(s);
	if (dif <= 0) {
		strings__Builder_write_string(sb, s);
		return;
	}
	if (p.allign == strconv__Align_text__right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(sb, p.pad_ch);
		}
	}
	strings__Builder_write_string(sb, s);
	if (p.allign == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(sb, p.pad_ch);
		}
	}
}

// Attr: [direct_array_access]
void strconv__format_dec_sb(u64 d, strconv__BF_param p, strings__Builder* res) {
	int n_char = strconv__dec_digits(d);
	int sign_len = (!p.positive || p.sign_flag ? (1) : (0));
	int number_len = sign_len + n_char;
	int dif = p.len0 - number_len;
	bool sign_written = false;
	if (p.allign == strconv__Align_text__right) {
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					strings__Builder_write_u8(res, '+');
					sign_written = true;
				}
			} else {
				strings__Builder_write_u8(res, '-');
				sign_written = true;
			}
		}
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(res, p.pad_ch);
		}
	}
	if (!sign_written) {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_u8(res, '+');
			}
		} else {
			strings__Builder_write_u8(res, '-');
		}
	}
	Array_fixed_u8_32 buf = {0};
	int i = 20;
	u64 n = d;
	u64 d_i = ((u64)(0U));
	if (n > 0U) {
		for (;;) {
			if (!(n > 0U)) break;
			u64 n1 = n / 100U;
			d_i = (n - (n1 * 100U)) << 1U;
			n = n1;
			{ // Unsafe block
				buf[i] = _const_strconv__digit_pairs.str[d_i];
			}
			i--;
			d_i++;
			{ // Unsafe block
				buf[i] = _const_strconv__digit_pairs.str[d_i];
			}
			i--;
		}
		i++;
		if (d_i < 20U) {
			i++;
		}
		strings__Builder_write_ptr(res, &buf[i], n_char);
	} else {
		strings__Builder_write_u8(res, '0');
	}
	if (p.allign == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(res, p.pad_ch);
		}
	}
	return;
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__f64_to_str_lnd1(f64 f, int dec_digit) {
	{ // Unsafe block
		string s = strconv__f64_to_str(f + ((f64*)_const_strconv__dec_round.data)[dec_digit], 18);
		if (s.len > 2 && (s.str[ 0] == 'n' || s.str[ 1] == 'i')) {
			return s;
		}
		bool m_sgn_flag = false;
		int sgn = 1;
		Array_fixed_u8_26 b = {0};
		int d_pos = 1;
		int i = 0;
		int i1 = 0;
		int exp = 0;
		int exp_sgn = 1;
		int dot_res_sp = -1;
		for (int _t2 = 0; _t2 < s.len; ++_t2) {
			byte c = s.str[_t2];

			if (c == ('-')) {
				sgn = -1;
				i++;
			}
			else if (c == ('+')) {
				sgn = 1;
				i++;
			}
			else if ((c >= '0' && c <= '9')) {
				b[i1] = c;
				i1++;
				i++;
			}
			else if (c == ('.')) {
				if (sgn > 0) {
					d_pos = i;
				} else {
					d_pos = i - 1;
				}
				i++;
			}
			else if (c == ('e')) {
				i++;
				break;
			}
			else {
				string_free(&s);
				return _SLIT("[Float conversion error!!]");
			};
		}
		b[i1] = 0;
		if (s.str[ i] == '-') {
			exp_sgn = -1;
			i++;
		} else if (s.str[ i] == '+') {
			exp_sgn = 1;
			i++;
		}
		int c = i;
		for (;;) {
			if (!(c < s.len)) break;
			exp = exp * 10 + ((int)(s.str[ c] - '0'));
			c++;
		}
		Array_u8 res = __new_array_with_default(exp + 32, 0, sizeof(u8), &(u8[]){0});
		int r_i = 0;
		string_free(&s);
		if (sgn == 1) {
			if (m_sgn_flag) {
				((u8*)res.data)[r_i] = '+';
				r_i++;
			}
		} else {
			((u8*)res.data)[r_i] = '-';
			r_i++;
		}
		i = 0;
		if (exp_sgn >= 0) {
			for (;;) {
				if (!(b[i] != 0)) break;
				((u8*)res.data)[r_i] = b[i];
				r_i++;
				i++;
				if (i >= d_pos && exp >= 0) {
					if (exp == 0) {
						dot_res_sp = r_i;
						((u8*)res.data)[r_i] = '.';
						r_i++;
					}
					exp--;
				}
			}
			for (;;) {
				if (!(exp >= 0)) break;
				((u8*)res.data)[r_i] = '0';
				r_i++;
				exp--;
			}
		} else {
			bool dot_p = true;
			for (;;) {
				if (!(exp > 0)) break;
				((u8*)res.data)[r_i] = '0';
				r_i++;
				exp--;
				if (dot_p) {
					dot_res_sp = r_i;
					((u8*)res.data)[r_i] = '.';
					r_i++;
					dot_p = false;
				}
			}
			for (;;) {
				if (!(b[i] != 0)) break;
				((u8*)res.data)[r_i] = b[i];
				r_i++;
				i++;
			}
		}
		if (dec_digit <= 0) {
			if (dot_res_sp < 0) {
				dot_res_sp = i + 1;
			}
			string tmp_res = string_clone(tos(res.data, dot_res_sp));
			array_free(&res);
			return tmp_res;
		}
		if (dot_res_sp >= 0) {
			r_i = dot_res_sp + dec_digit + 1;
			((u8*)res.data)[r_i] = 0;
			for (int c1 = 1; c1 < dec_digit + 1; ++c1) {
				if (((u8*)res.data)[r_i - c1] == 0) {
					((u8*)res.data)[r_i - c1] = '0';
				}
			}
			string tmp_res = string_clone(tos(res.data, r_i));
			array_free(&res);
			return tmp_res;
		} else {
			if (dec_digit > 0) {
				int c1 = 0;
				((u8*)res.data)[r_i] = '.';
				r_i++;
				for (;;) {
					if (!(c1 < dec_digit)) break;
					((u8*)res.data)[r_i] = '0';
					r_i++;
					c1++;
				}
				((u8*)res.data)[r_i] = 0;
			}
			string tmp_res = string_clone(tos(res.data, r_i));
			array_free(&res);
			return tmp_res;
		}
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__format_fl(f64 f, strconv__BF_param p) {
	{ // Unsafe block
		string fs = strconv__f64_to_str_lnd1((f >= 0.0 ? (f) : (-f)), p.len1);
		if (fs.str[ 0] == '[') {
			return fs;
		}
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros(fs);
			string_free(&tmp);
		}
		Array_fixed_u8_32 buf = {0};
		Array_fixed_u8_32 out = {0};
		int buf_i = 0;
		int out_i = 0;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					out[out_i] = '+';
					out_i++;
					sign_len_diff = -1;
				}
			} else {
				out[out_i] = '-';
				out_i++;
				sign_len_diff = -1;
			}
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					buf[buf_i] = '+';
					buf_i++;
				}
			} else {
				buf[buf_i] = '-';
				buf_i++;
			}
		}
		vmemcpy(&buf[buf_i], fs.str, fs.len);
		buf_i += fs.len;
		int dif = p.len0 - buf_i + sign_len_diff;
		if (p.allign == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		vmemcpy(&out[out_i], &buf[0], buf_i);
		out_i += buf_i;
		if (p.allign == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		out[out_i] = 0;
		string tmp = fs;
		fs = tos_clone(&out[0]);
		string_free(&tmp);
		return fs;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__format_es(f64 f, strconv__BF_param p) {
	{ // Unsafe block
		string fs = strconv__f64_to_str_pad((f > 0 ? (f) : (-f)), p.len1);
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros(fs);
			string_free(&tmp);
		}
		Array_fixed_u8_32 buf = {0};
		Array_fixed_u8_32 out = {0};
		int buf_i = 0;
		int out_i = 0;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					out[out_i] = '+';
					out_i++;
					sign_len_diff = -1;
				}
			} else {
				out[out_i] = '-';
				out_i++;
				sign_len_diff = -1;
			}
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					buf[buf_i] = '+';
					buf_i++;
				}
			} else {
				buf[buf_i] = '-';
				buf_i++;
			}
		}
		vmemcpy(&buf[buf_i], fs.str, fs.len);
		buf_i += fs.len;
		int dif = p.len0 - buf_i + sign_len_diff;
		if (p.allign == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		vmemcpy(&out[out_i], &buf[0], buf_i);
		out_i += buf_i;
		if (p.allign == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		out[out_i] = 0;
		string tmp = fs;
		fs = tos_clone(&out[0]);
		string_free(&tmp);
		return fs;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
string strconv__remove_tail_zeros(string s) {
	{ // Unsafe block
		u8* buf = malloc_noscan(s.len + 1);
		int i_d = 0;
		int i_s = 0;
		for (;;) {
			if (!(i_s < s.len && !(s.str[ i_s] == '-' || s.str[ i_s] == '+') && (s.str[ i_s] > '9' || s.str[ i_s] < '0'))) break;
			buf[i_d] = s.str[ i_s];
			i_s++;
			i_d++;
		}
		if (i_s < s.len && (s.str[ i_s] == '-' || s.str[ i_s] == '+')) {
			buf[i_d] = s.str[ i_s];
			i_s++;
			i_d++;
		}
		for (;;) {
			if (!(i_s < s.len && s.str[ i_s] >= '0' && s.str[ i_s] <= '9')) break;
			buf[i_d] = s.str[ i_s];
			i_s++;
			i_d++;
		}
		if (i_s < s.len && s.str[ i_s] == '.') {
			int i_s1 = i_s + 1;
			int sum = 0;
			for (;;) {
				if (!(i_s1 < s.len && s.str[ i_s1] >= '0' && s.str[ i_s1] <= '9')) break;
				sum += s.str[ i_s1] - ((u8)('0'));
				i_s1++;
			}
			if (sum > 0) {
				for (int c_i = i_s; c_i < i_s1; ++c_i) {
					buf[i_d] = s.str[ c_i];
					i_d++;
				}
			}
			i_s = i_s1;
		}
		if (i_s < s.len && s.str[ i_s] != '.') {
			for (;;) {
				buf[i_d] = s.str[ i_s];
				i_s++;
				i_d++;
				if (i_s >= s.len) {
					break;
				}
			}
		}
		buf[i_d] = 0;
		return tos(buf, i_d);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string strconv__ftoa_64(f64 f) {
	return strconv__f64_to_str(f, 17);
}

// Attr: [inline]
inline string strconv__ftoa_long_64(f64 f) {
	return strconv__f64_to_str_l(f);
}

// Attr: [inline]
inline string strconv__ftoa_32(f32 f) {
	return strconv__f32_to_str(f, 8);
}

// Attr: [inline]
inline string strconv__ftoa_long_32(f32 f) {
	return strconv__f32_to_str_l(f);
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__format_int(i64 n, int radix) {
	{ // Unsafe block
		if (radix < 2 || radix > 36) {
			panic_debug(11, tos3("/Users/rcqls/vlang/v/vlib/strconv/number_to_base.c.v"), tos3("strconv"), tos3("format_int"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid radix: "), 0xfe07, {.d_i32 = radix}}, {_SLIT(" . It should be => 2 and <= 36"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
		if (n == 0) {
			return _SLIT("0");
		}
		i64 n_copy = n;
		bool have_minus = false;
		if (n < 0) {
			have_minus = true;
			n_copy = -n_copy;
		}
		string res = _SLIT("");
		for (;;) {
			if (!(n_copy != 0)) break;
			string tmp_0 = res;
			int bdx = ((int)(n_copy % radix));
			string tmp_1 = u8_ascii_str(_const_strconv__base_digits.str[ bdx]);
			res = string__plus(tmp_1, res);
			string_free(&tmp_0);
			string_free(&tmp_1);
			n_copy /= radix;
		}
		if (have_minus) {
			string final_res = string__plus(_SLIT("-"), res);
			string_free(&res);
			return final_res;
		}
		return res;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
string strconv__format_uint(u64 n, int radix) {
	{ // Unsafe block
		if (radix < 2 || radix > 36) {
			panic_debug(48, tos3("/Users/rcqls/vlang/v/vlib/strconv/number_to_base.c.v"), tos3("strconv"), tos3("format_uint"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid radix: "), 0xfe07, {.d_i32 = radix}}, {_SLIT(" . It should be => 2 and <= 36"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
		if (n == 0U) {
			return _SLIT("0");
		}
		u64 n_copy = n;
		string res = _SLIT("");
		u64 uradix = ((u64)(radix));
		for (;;) {
			if (!(n_copy != 0U)) break;
			string tmp_0 = res;
			string tmp_1 = u8_ascii_str(string_at(_const_strconv__base_digits, n_copy % uradix));
			res = string__plus(tmp_1, res);
			string_free(&tmp_0);
			string_free(&tmp_1);
			n_copy /= uradix;
		}
		return res;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
string strconv__f32_to_str_l(f32 f) {
	string s = strconv__f32_to_str(f, 6);
	string res = strconv__fxx_to_str_l_parse(s);
	string_free(&s);
	return res;
}

// Attr: [manualfree]
string strconv__f32_to_str_l_no_dot(f32 f) {
	string s = strconv__f32_to_str(f, 6);
	string res = strconv__fxx_to_str_l_parse_no_dot(s);
	string_free(&s);
	return res;
}

// Attr: [manualfree]
string strconv__f64_to_str_l(f64 f) {
	string s = strconv__f64_to_str(f, 18);
	string res = strconv__fxx_to_str_l_parse(s);
	string_free(&s);
	return res;
}

// Attr: [manualfree]
string strconv__f64_to_str_l_no_dot(f64 f) {
	string s = strconv__f64_to_str(f, 18);
	string res = strconv__fxx_to_str_l_parse_no_dot(s);
	string_free(&s);
	return res;
}

// Attr: [manualfree]
string strconv__fxx_to_str_l_parse(string s) {
	if (s.len > 2 && (string_at(s, 0) == 'n' || string_at(s, 1) == 'i')) {
		return string_clone(s);
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	Array_fixed_u8_26 b = {0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	for (int _t2 = 0; _t2 < s.len; ++_t2) {
		byte c = s.str[_t2];
		if (c == '-') {
			sgn = -1;
			i++;
		} else if (c == '+') {
			sgn = 1;
			i++;
		} else if (c >= '0' && c <= '9') {
			b[v_fixed_index(i1, 26)] = c;
			i1++;
			i++;
		} else if (c == '.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = i - 1;
			}
			i++;
		} else if (c == 'e') {
			i++;
			break;
		} else {
			return _SLIT("Float conversion error!!");
		}
	}
	b[v_fixed_index(i1, 26)] = 0;
	if (string_at(s, i) == '-') {
		exp_sgn = -1;
		i++;
	} else if (string_at(s, i) == '+') {
		exp_sgn = 1;
		i++;
	}
	int c = i;
	for (;;) {
		if (!(c < s.len)) break;
		exp = exp * 10 + ((int)(string_at(s, c) - '0'));
		c++;
	}
	Array_u8 res = __new_array_with_default(exp + 32, 0, sizeof(u8), &(u8[]){0});
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			array_set(&res, r_i, &(u8[]) { '+' });
			r_i++;
		}
	} else {
		array_set(&res, r_i, &(u8[]) { '-' });
		r_i++;
	}
	i = 0;
	if (exp_sgn >= 0) {
		for (;;) {
			if (!(b[v_fixed_index(i, 26)] != 0)) break;
			array_set(&res, r_i, &(u8[]) { b[v_fixed_index(i, 26)] });
			r_i++;
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					array_set(&res, r_i, &(u8[]) { '.' });
					r_i++;
				}
				exp--;
			}
		}
		for (;;) {
			if (!(exp >= 0)) break;
			array_set(&res, r_i, &(u8[]) { '0' });
			r_i++;
			exp--;
		}
	} else {
		bool dot_p = true;
		for (;;) {
			if (!(exp > 0)) break;
			array_set(&res, r_i, &(u8[]) { '0' });
			r_i++;
			exp--;
			if (dot_p) {
				array_set(&res, r_i, &(u8[]) { '.' });
				r_i++;
				dot_p = false;
			}
		}
		for (;;) {
			if (!(b[v_fixed_index(i, 26)] != 0)) break;
			array_set(&res, r_i, &(u8[]) { b[v_fixed_index(i, 26)] });
			r_i++;
			i++;
		}
	}
	array_set(&res, r_i, &(u8[]) { 0 });
	return tos(res.data, r_i);
}

// Attr: [manualfree]
string strconv__fxx_to_str_l_parse_no_dot(string s) {
	if (s.len > 2 && (string_at(s, 0) == 'n' || string_at(s, 1) == 'i')) {
		return string_clone(s);
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	Array_fixed_u8_26 b = {0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	for (int _t2 = 0; _t2 < s.len; ++_t2) {
		byte c = s.str[_t2];
		if (c == '-') {
			sgn = -1;
			i++;
		} else if (c == '+') {
			sgn = 1;
			i++;
		} else if (c >= '0' && c <= '9') {
			b[v_fixed_index(i1, 26)] = c;
			i1++;
			i++;
		} else if (c == '.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = i - 1;
			}
			i++;
		} else if (c == 'e') {
			i++;
			break;
		} else {
			return _SLIT("Float conversion error!!");
		}
	}
	b[v_fixed_index(i1, 26)] = 0;
	if (string_at(s, i) == '-') {
		exp_sgn = -1;
		i++;
	} else if (string_at(s, i) == '+') {
		exp_sgn = 1;
		i++;
	}
	int c = i;
	for (;;) {
		if (!(c < s.len)) break;
		exp = exp * 10 + ((int)(string_at(s, c) - '0'));
		c++;
	}
	Array_u8 res = __new_array_with_default(exp + 32, 0, sizeof(u8), &(u8[]){0});
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			array_set(&res, r_i, &(u8[]) { '+' });
			r_i++;
		}
	} else {
		array_set(&res, r_i, &(u8[]) { '-' });
		r_i++;
	}
	i = 0;
	if (exp_sgn >= 0) {
		for (;;) {
			if (!(b[v_fixed_index(i, 26)] != 0)) break;
			array_set(&res, r_i, &(u8[]) { b[v_fixed_index(i, 26)] });
			r_i++;
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					array_set(&res, r_i, &(u8[]) { '.' });
					r_i++;
				}
				exp--;
			}
		}
		for (;;) {
			if (!(exp >= 0)) break;
			array_set(&res, r_i, &(u8[]) { '0' });
			r_i++;
			exp--;
		}
	} else {
		bool dot_p = true;
		for (;;) {
			if (!(exp > 0)) break;
			array_set(&res, r_i, &(u8[]) { '0' });
			r_i++;
			exp--;
			if (dot_p) {
				array_set(&res, r_i, &(u8[]) { '.' });
				r_i++;
				dot_p = false;
			}
		}
		for (;;) {
			if (!(b[v_fixed_index(i, 26)] != 0)) break;
			array_set(&res, r_i, &(u8[]) { b[v_fixed_index(i, 26)] });
			r_i++;
			i++;
		}
	}
	if (r_i > 1 && (*(u8*)/*ee elem_sym */array_get(res, r_i - 1)) == '.') {
		r_i--;
	}
	array_set(&res, r_i, &(u8[]) { 0 });
	return tos(res.data, r_i);
}

// Attr: [inline]
inline int strconv__bool_to_int(bool b) {
	if (b) {
		return 1;
	}
	return 0;
}

// Attr: [inline]
inline u32 strconv__bool_to_u32(bool b) {
	if (b) {
		return ((u32)(1U));
	}
	return ((u32)(0U));
}

// Attr: [inline]
inline u64 strconv__bool_to_u64(bool b) {
	if (b) {
		return ((u64)(1U));
	}
	return ((u64)(0U));
}

string strconv__get_string_special(bool neg, bool expZero, bool mantZero) {
	if (!mantZero) {
		return _SLIT("nan");
	}
	if (!expZero) {
		if (neg) {
			return _SLIT("-inf");
		} else {
			return _SLIT("+inf");
		}
	}
	if (neg) {
		return _SLIT("-0e+00");
	}
	return _SLIT("0e+00");
}

u32 strconv__mul_shift_32(u32 m, u64 mul, int ishift) {
	multi_return_u64_u64 mr_746 = math__bits__mul_64(((u64)(m)), mul);
	u64 hi = mr_746.arg0;
	u64 lo = mr_746.arg1;
	u64 shifted_sum = (lo >> ((u64)(ishift))) + (hi << ((u64)(64 - ishift)));
	;
	return ((u32)(shifted_sum));
}

u32 strconv__mul_pow5_invdiv_pow2(u32 m, u32 q, int j) {
	return strconv__mul_shift_32(m, (*(u64*)/*ee elem_sym */array_get(_const_strconv__pow5_inv_split_32, q)), j);
}

u32 strconv__mul_pow5_div_pow2(u32 m, u32 i, int j) {
	return strconv__mul_shift_32(m, (*(u64*)/*ee elem_sym */array_get(_const_strconv__pow5_split_32, i)), j);
}

u32 strconv__pow5_factor_32(u32 i_v) {
	u32 v = i_v;
	for (u32 n = ((u32)(0U)); true; n++) {
		u32 q = v / 5U;
		u32 r = v % 5U;
		if (r != 0U) {
			return n;
		}
		v = q;
	}
	return v;
}

bool strconv__multiple_of_power_of_five_32(u32 v, u32 p) {
	return strconv__pow5_factor_32(v) >= p;
}

bool strconv__multiple_of_power_of_two_32(u32 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_32(v))) >= p;
}

u32 strconv__log10_pow2(int e) {
	;
	;
	return (((u32)(e)) * 78913U) >> 18U;
}

u32 strconv__log10_pow5(int e) {
	;
	;
	return (((u32)(e)) * 732923U) >> 20U;
}

int strconv__pow5_bits(int e) {
	;
	;
	return ((int)(((((u32)(e)) * 1217359U) >> 19U) + 1U));
}

u64 strconv__shift_right_128(strconv__Uint128 v, int shift) {
	;
	return ((v.hi << ((u64)(64 - shift))) | (v.lo >> ((u32)(shift))));
}

u64 strconv__mul_shift_64(u64 m, strconv__Uint128 mul, int shift) {
	multi_return_u64_u64 mr_3065 = math__bits__mul_64(m, mul.hi);
	u64 hihi = mr_3065.arg0;
	u64 hilo = mr_3065.arg1;
	multi_return_u64_u64 mr_3100 = math__bits__mul_64(m, mul.lo);
	u64 lohi = mr_3100.arg0;
	strconv__Uint128 sum = ((strconv__Uint128){.lo = lohi + hilo,.hi = hihi,});
	if (sum.lo < lohi) {
		sum.hi++;
	}
	return strconv__shift_right_128(sum, shift - 64);
}

u32 strconv__pow5_factor_64(u64 v_i) {
	u64 v = v_i;
	for (u32 n = ((u32)(0U)); true; n++) {
		u64 q = v / 5U;
		u64 r = v % 5U;
		if (r != 0U) {
			return n;
		}
		v = q;
	}
	return ((u32)(0U));
}

bool strconv__multiple_of_power_of_five_64(u64 v, u32 p) {
	return strconv__pow5_factor_64(v) >= p;
}

bool strconv__multiple_of_power_of_two_64(u64 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_64(v))) >= p;
}

int strconv__dec_digits(u64 n) {
	if (n <= 9999999999U) {
		if (n <= 99999U) {
			if (n <= 99U) {
				if (n <= 9U) {
					return 1;
				} else {
					return 2;
				}
			} else {
				if (n <= 999U) {
					return 3;
				} else {
					if (n <= 9999U) {
						return 4;
					} else {
						return 5;
					}
				}
			}
		} else {
			if (n <= 9999999U) {
				if (n <= 999999U) {
					return 6;
				} else {
					return 7;
				}
			} else {
				if (n <= 99999999U) {
					return 8;
				} else {
					if (n <= 999999999U) {
						return 9;
					}
					return 10;
				}
			}
		}
	} else {
		if (n <= 999999999999999U) {
			if (n <= 999999999999U) {
				if (n <= 99999999999U) {
					return 11;
				} else {
					return 12;
				}
			} else {
				if (n <= 9999999999999U) {
					return 13;
				} else {
					if (n <= 99999999999999U) {
						return 14;
					} else {
						return 15;
					}
				}
			}
		} else {
			if (n <= 99999999999999999U) {
				if (n <= 9999999999999999U) {
					return 16;
				} else {
					return 17;
				}
			} else {
				if (n <= 999999999999999999U) {
					return 18;
				} else {
					if (n <= 9999999999999999999U) {
						return 19;
					}
					return 20;
				}
			}
		}
	}
	return 0;
}

void strconv__v_printf(string str, Array_voidptr pt) {
	print(strconv__v_sprintf(str, pt));
}

// Attr: [manualfree]
string strconv__v_sprintf(string str, Array_voidptr pt) {
bool strconv__v_sprintf_defer_0 = false;
strings__Builder res;
	res = strings__new_builder(pt.len * 16);
	strconv__v_sprintf_defer_0 = true;
	int i = 0;
	int p_index = 0;
	bool sign = false;
	strconv__Align_text allign = strconv__Align_text__right;
	int len0 = -1;
	int len1 = -1;
	int def_len1 = 6;
	u8 pad_ch = ((u8)(' '));
	rune ch1 = '0';
	rune ch2 = '0';
	strconv__Char_parse_state status = strconv__Char_parse_state__norm_char;
	for (;;) {
		if (!(i < str.len)) break;
		if (status == strconv__Char_parse_state__reset_params) {
			sign = false;
			allign = strconv__Align_text__right;
			len0 = -1;
			len1 = -1;
			pad_ch = ' ';
			status = strconv__Char_parse_state__norm_char;
			ch1 = '0';
			ch2 = '0';
			continue;
		}
		u8 ch = string_at(str, i);
		if (ch != '%' && status == strconv__Char_parse_state__norm_char) {
			strings__Builder_write_u8(&res, ch);
			i++;
			continue;
		}
		if (ch == '%' && status == strconv__Char_parse_state__norm_char) {
			status = strconv__Char_parse_state__field_char;
			i++;
			continue;
		}
		if (ch == 'c' && status == strconv__Char_parse_state__field_char) {
			strconv__v_sprintf_panic(p_index, pt.len);
			u8 d1 = *(((u8*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))));
			strings__Builder_write_u8(&res, d1);
			status = strconv__Char_parse_state__reset_params;
			p_index++;
			i++;
			continue;
		}
		if (ch == 'p' && status == strconv__Char_parse_state__field_char) {
			strconv__v_sprintf_panic(p_index, pt.len);
			strings__Builder_write_string(&res, _SLIT("0x"));
			strings__Builder_write_string(&res, ptr_str((*(voidptr*)/*ee elem_sym */array_get(pt, p_index))));
			status = strconv__Char_parse_state__reset_params;
			p_index++;
			i++;
			continue;
		}
		if (status == strconv__Char_parse_state__field_char) {
			rune fc_ch1 = '0';
			rune fc_ch2 = '0';
			if ((i + 1) < str.len) {
				fc_ch1 = string_at(str, i + 1);
				if ((i + 2) < str.len) {
					fc_ch2 = string_at(str, i + 2);
				}
			}
			if (ch == '+') {
				sign = true;
				i++;
				continue;
			} else if (ch == '-') {
				allign = strconv__Align_text__left;
				i++;
				continue;
			} else if (ch == '0' || ch == ' ') {
				if (allign == strconv__Align_text__right) {
					pad_ch = ch;
				}
				i++;
				continue;
			} else if (ch == '\'') {
				i++;
				continue;
			} else if (ch == '.' && fc_ch1 >= '1' && fc_ch1 <= '9') {
				status = strconv__Char_parse_state__check_float;
				i++;
				continue;
			} else if (ch == '.' && fc_ch1 == '*' && fc_ch2 == 's') {
				strconv__v_sprintf_panic(p_index, pt.len);
				int len = *(((int*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))));
				p_index++;
				strconv__v_sprintf_panic(p_index, pt.len);
				string s = *(((string*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))));
				s = string_substr(s, 0, len);
				p_index++;
				strings__Builder_write_string(&res, s);
				status = strconv__Char_parse_state__reset_params;
				i += 3;
				continue;
			}
			status = strconv__Char_parse_state__len_set_start;
			continue;
		}
		if (status == strconv__Char_parse_state__len_set_start) {
			if (ch >= '1' && ch <= '9') {
				len0 = ((int)(ch - '0'));
				status = strconv__Char_parse_state__len_set_in;
				i++;
				continue;
			}
			if (ch == '.') {
				status = strconv__Char_parse_state__check_float;
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__len_set_in) {
			if (ch >= '0' && ch <= '9') {
				len0 *= 10;
				len0 += ((int)(ch - '0'));
				i++;
				continue;
			}
			if (ch == '.') {
				status = strconv__Char_parse_state__check_float;
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__check_float) {
			if (ch >= '0' && ch <= '9') {
				len1 = ((int)(ch - '0'));
				status = strconv__Char_parse_state__check_float_in;
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__check_float_in) {
			if (ch >= '0' && ch <= '9') {
				len1 *= 10;
				len1 += ((int)(ch - '0'));
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__check_type) {
			if (ch == 'l') {
				if (ch1 == '0') {
					ch1 = 'l';
					i++;
					continue;
				} else {
					ch2 = 'l';
					i++;
					continue;
				}
			} else if (ch == 'h') {
				if (ch1 == '0') {
					ch1 = 'h';
					i++;
					continue;
				} else {
					ch2 = 'h';
					i++;
					continue;
				}
			} else if (ch == 'd' || ch == 'i') {
				u64 d1 = ((u64)(0U));
				bool positive = true;

				if (ch1 == ('h')) {
					if (ch2 == 'h') {
						strconv__v_sprintf_panic(p_index, pt.len);
						i8 x = *(((i8*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))));
						positive = (x >= 0 ? (true) : (false));
						d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
					} else {
						i16 x = *(((i16*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))));
						positive = (x >= 0 ? (true) : (false));
						d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
					}
				}
				else if (ch1 == ('l')) {
					strconv__v_sprintf_panic(p_index, pt.len);
					i64 x = *(((i64*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))));
					positive = (x >= 0 ? (true) : (false));
					d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
				}
				else {
					strconv__v_sprintf_panic(p_index, pt.len);
					int x = *(((int*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))));
					positive = (x >= 0 ? (true) : (false));
					d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
				};
				string tmp = strconv__format_dec_old(d1, ((strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = positive,
					.sign_flag = sign,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				strings__Builder_write_string(&res, tmp);
				string_free(&tmp);
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				ch1 = '0';
				ch2 = '0';
				continue;
			} else if (ch == 'u') {
				u64 d1 = ((u64)(0U));
				bool positive = true;
				strconv__v_sprintf_panic(p_index, pt.len);

				if (ch1 == ('h')) {
					if (ch2 == 'h') {
						d1 = ((u64)(*(((u8*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))))));
					} else {
						d1 = ((u64)(*(((u16*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))))));
					}
				}
				else if (ch1 == ('l')) {
					d1 = ((u64)(*(((u64*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))))));
				}
				else {
					d1 = ((u64)(*(((u32*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))))));
				};
				string tmp = strconv__format_dec_old(d1, ((strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = positive,
					.sign_flag = sign,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				strings__Builder_write_string(&res, tmp);
				string_free(&tmp);
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 'x' || ch == 'X') {
				strconv__v_sprintf_panic(p_index, pt.len);
				string s = _SLIT("");

				if (ch1 == ('h')) {
					if (ch2 == 'h') {
						i8 x = *(((i8*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))));
						s = i8_hex(x);
					} else {
						i16 x = *(((i16*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))));
						s = i16_hex(x);
					}
				}
				else if (ch1 == ('l')) {
					i64 x = *(((i64*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))));
					s = i64_hex(x);
				}
				else {
					int x = *(((int*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))));
					s = int_hex(x);
				};
				if (ch == 'X') {
					string tmp = s;
					s = string_to_upper(s);
					string_free(&tmp);
				}
				string tmp = strconv__format_str(s, ((strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = true,
					.sign_flag = false,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				strings__Builder_write_string(&res, tmp);
				string_free(&tmp);
				string_free(&s);
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			}
			if (ch == 'f' || ch == 'F') {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					strconv__v_sprintf_panic(p_index, pt.len);
					f64 x = *(((f64*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))));
					bool positive = x >= ((f64)(0.0));
					len1 = (len1 >= 0 ? (len1) : (def_len1));
					string s = strconv__format_fl_old(((f64)(x)), ((strconv__BF_param){
						.pad_ch = pad_ch,
						.len0 = len0,
						.len1 = len1,
						.positive = positive,
						.sign_flag = sign,
						.allign = allign,
						.rm_tail_zero = 0,
					}));
					if (ch == 'F') {
						string tmp = string_to_upper(s);
						strings__Builder_write_string(&res, tmp);
						string_free(&tmp);
					} else {
						strings__Builder_write_string(&res, s);
					}
					string_free(&s);
				}
				#endif
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 'e' || ch == 'E') {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					strconv__v_sprintf_panic(p_index, pt.len);
					f64 x = *(((f64*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))));
					bool positive = x >= ((f64)(0.0));
					len1 = (len1 >= 0 ? (len1) : (def_len1));
					string s = strconv__format_es_old(((f64)(x)), ((strconv__BF_param){
						.pad_ch = pad_ch,
						.len0 = len0,
						.len1 = len1,
						.positive = positive,
						.sign_flag = sign,
						.allign = allign,
						.rm_tail_zero = 0,
					}));
					if (ch == 'E') {
						string tmp = string_to_upper(s);
						strings__Builder_write_string(&res, tmp);
						string_free(&tmp);
					} else {
						strings__Builder_write_string(&res, s);
					}
					string_free(&s);
				}
				#endif
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 'g' || ch == 'G') {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					strconv__v_sprintf_panic(p_index, pt.len);
					f64 x = *(((f64*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))));
					bool positive = x >= ((f64)(0.0));
					string s = _SLIT("");
					f64 tx = strconv__fabs(x);
					if (tx < 999999.0 && tx >= 0.00001) {
						len1 = (len1 >= 0 ? (len1 + 1) : (def_len1));
						string tmp = s;
						s = strconv__format_fl_old(x, ((strconv__BF_param){
							.pad_ch = pad_ch,
							.len0 = len0,
							.len1 = len1,
							.positive = positive,
							.sign_flag = sign,
							.allign = allign,
							.rm_tail_zero = true,
						}));
						string_free(&tmp);
					} else {
						len1 = (len1 >= 0 ? (len1 + 1) : (def_len1));
						string tmp = s;
						s = strconv__format_es_old(x, ((strconv__BF_param){
							.pad_ch = pad_ch,
							.len0 = len0,
							.len1 = len1,
							.positive = positive,
							.sign_flag = sign,
							.allign = allign,
							.rm_tail_zero = true,
						}));
						string_free(&tmp);
					}
					if (ch == 'G') {
						string tmp = string_to_upper(s);
						strings__Builder_write_string(&res, tmp);
						string_free(&tmp);
					} else {
						strings__Builder_write_string(&res, s);
					}
					string_free(&s);
				}
				#endif
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 's') {
				strconv__v_sprintf_panic(p_index, pt.len);
				string s1 = *(((string*)((*(voidptr*)/*ee elem_sym */array_get(pt, p_index)))));
				pad_ch = ' ';
				string tmp = strconv__format_str(s1, ((strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = true,
					.sign_flag = false,
					.allign = allign,
					.rm_tail_zero = 0,
				}));
				strings__Builder_write_string(&res, tmp);
				string_free(&tmp);
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			}
		}
		status = strconv__Char_parse_state__reset_params;
		p_index++;
		i++;
	}
	if (p_index != pt.len) {
		panic_debug(532, tos3("/Users/rcqls/vlang/v/vlib/strconv/vprintf.c.v"), tos3("strconv"), tos3("v_sprintf"),   str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = p_index}}, {_SLIT(" % conversion specifiers, but given "), 0xfe07, {.d_i32 = pt.len}}, {_SLIT(" args"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	string _t1 = strings__Builder_str(&res);
	// Defer begin
	if (strconv__v_sprintf_defer_0) {
		strings__Builder_free(&res);
	}
	// Defer end
	return _t1;
}

// Attr: [inline]
inline void strconv__v_sprintf_panic(int idx, int len) {
	if (idx >= len) {
		panic_debug(541, tos3("/Users/rcqls/vlang/v/vlib/strconv/vprintf.c.v"), tos3("strconv"), tos3("v_sprintf_panic"),   str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = idx + 1}}, {_SLIT(" % conversion specifiers, but given only "), 0xfe07, {.d_i32 = len}}, {_SLIT(" args"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
}

f64 strconv__fabs(f64 x) {
	if (x < 0.0) {
		return -x;
	}
	return x;
}

// Attr: [manualfree]
string strconv__format_fl_old(f64 f, strconv__BF_param p) {
bool strconv__format_fl_old_defer_0 = false;
strings__Builder res;
	{ // Unsafe block
		string s = _SLIT("");
		string fs = strconv__f64_to_str_lnd1((f >= 0.0 ? (f) : (-f)), p.len1);
		if (string_at(fs, 0) == '[') {
			string_free(&s);
			return fs;
		}
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros_old(fs);
			string_free(&tmp);
		}
		res = strings__new_builder((p.len0 > fs.len ? (p.len0) : (fs.len)));
		strconv__format_fl_old_defer_0 = true;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					strings__Builder_write_u8(&res, '+');
					sign_len_diff = -1;
				}
			} else {
				strings__Builder_write_u8(&res, '-');
				sign_len_diff = -1;
			}
			string tmp = s;
			s = string_clone(fs);
			string_free(&tmp);
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					string tmp = s;
					s = string__plus(_SLIT("+"), fs);
					string_free(&tmp);
				} else {
					string tmp = s;
					s = string_clone(fs);
					string_free(&tmp);
				}
			} else {
				string tmp = s;
				s = string__plus(_SLIT("-"), fs);
				string_free(&tmp);
			}
		}
		int dif = p.len0 - s.len + sign_len_diff;
		if (p.allign == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_u8(&res, p.pad_ch);
			}
		}
		strings__Builder_write_string(&res, s);
		if (p.allign == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_u8(&res, p.pad_ch);
			}
		}
		string_free(&s);
		string_free(&fs);
		string _t2 = strings__Builder_str(&res);
		// Defer begin
		if (strconv__format_fl_old_defer_0) {
			strings__Builder_free(&res);
		}
		// Defer end
		return _t2;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
string strconv__format_es_old(f64 f, strconv__BF_param p) {
bool strconv__format_es_old_defer_0 = false;
strings__Builder res;
string fs;
string s;
	{ // Unsafe block
		s = _SLIT("");
		fs = strconv__f64_to_str_pad((f > 0 ? (f) : (-f)), p.len1);
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros_old(fs);
			string_free(&tmp);
		}
		res = strings__new_builder((p.len0 > fs.len ? (p.len0) : (fs.len)));
		strconv__format_es_old_defer_0 = true;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					strings__Builder_write_u8(&res, '+');
					sign_len_diff = -1;
				}
			} else {
				strings__Builder_write_u8(&res, '-');
				sign_len_diff = -1;
			}
			string tmp = s;
			s = string_clone(fs);
			string_free(&tmp);
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					string tmp = s;
					s = string__plus(_SLIT("+"), fs);
					string_free(&tmp);
				} else {
					string tmp = s;
					s = string_clone(fs);
					string_free(&tmp);
				}
			} else {
				string tmp = s;
				s = string__plus(_SLIT("-"), fs);
				string_free(&tmp);
			}
		}
		int dif = p.len0 - s.len + sign_len_diff;
		if (p.allign == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_u8(&res, p.pad_ch);
			}
		}
		strings__Builder_write_string(&res, s);
		if (p.allign == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_u8(&res, p.pad_ch);
			}
		}
		string _t1 = strings__Builder_str(&res);
		// Defer begin
		if (strconv__format_es_old_defer_0) {
			strings__Builder_free(&res);
			string_free(&fs);
			string_free(&s);
		}
		// Defer end
		return _t1;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string strconv__remove_tail_zeros_old(string s) {
	int i = 0;
	int last_zero_start = -1;
	int dot_pos = -1;
	bool in_decimal = false;
	u8 prev_ch = ((u8)(0));
	for (;;) {
		if (!(i < s.len)) break;
		u8 ch = s.str[i];
		if (ch == '.') {
			in_decimal = true;
			dot_pos = i;
		} else if (in_decimal) {
			if (ch == '0' && prev_ch != '0') {
				last_zero_start = i;
			} else if (ch >= '1' && ch <= '9') {
				last_zero_start = -1;
			} else if (ch == 'e') {
				break;
			}
		}
		prev_ch = ch;
		i++;
	}
	string tmp = _SLIT("");
	if (last_zero_start > 0) {
		if (last_zero_start == dot_pos + 1) {
			tmp = string__plus(string_substr(s, 0, dot_pos), string_substr(s, i, (s).len));
		} else {
			tmp = string__plus(string_substr(s, 0, last_zero_start), string_substr(s, i, (s).len));
		}
	} else {
		tmp = string_clone(s);
	}
	if (tmp.str[tmp.len - 1] == '.') {
		return string_substr(tmp, 0, tmp.len - 1);
	}
	return tmp;
}

// Attr: [manualfree]
string strconv__format_dec_old(u64 d, strconv__BF_param p) {
bool strconv__format_dec_old_defer_0 = false;
strings__Builder res;
string s;
	s = _SLIT("");
	res = strings__new_builder(20);
	strconv__format_dec_old_defer_0 = true;
	int sign_len_diff = 0;
	if (p.pad_ch == '0') {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_u8(&res, '+');
				sign_len_diff = -1;
			}
		} else {
			strings__Builder_write_u8(&res, '-');
			sign_len_diff = -1;
		}
		string tmp = s;
		s = u64_str(d);
		string_free(&tmp);
	} else {
		if (p.positive) {
			if (p.sign_flag) {
				string tmp = s;
				s = string__plus(_SLIT("+"), u64_str(d));
				string_free(&tmp);
			} else {
				string tmp = s;
				s = u64_str(d);
				string_free(&tmp);
			}
		} else {
			string tmp = s;
			s = string__plus(_SLIT("-"), u64_str(d));
			string_free(&tmp);
		}
	}
	int dif = p.len0 - s.len + sign_len_diff;
	if (p.allign == strconv__Align_text__right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(&res, p.pad_ch);
		}
	}
	strings__Builder_write_string(&res, s);
	if (p.allign == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(&res, p.pad_ch);
		}
	}
	string _t1 = strings__Builder_str(&res);
	// Defer begin
	if (strconv__format_dec_old_defer_0) {
		strings__Builder_free(&res);
		string_free(&s);
	}
	// Defer end
	return _t1;
}

array __new_array(int mylen, int cap, int elm_size) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.element_size = elm_size,.data = vcalloc(cap_ * elm_size),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,});
	return arr;
}

array __new_array_with_default(int mylen, int cap, int elm_size, voidptr val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.element_size = elm_size,.data = 0,.offset = 0,.len = mylen,.cap = cap_,.flags = 0,});
	if (cap_ > 0 && mylen == 0) {
		arr.data = _v_malloc(cap_ * elm_size);
	} else {
		arr.data = vcalloc(cap_ * elm_size);
	}
	if (val != 0) {
		for (int i = 0; i < arr.len; ++i) {
			array_set_unsafe(&arr, i, val);
		}
	}
	return arr;
}

array __new_array_with_array_default(int mylen, int cap, int elm_size, array val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.element_size = elm_size,.data = _v_malloc(cap_ * elm_size),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,});
	for (int i = 0; i < arr.len; ++i) {
		array val_clone = array_clone_to_depth(&val, 1);
		array_set_unsafe(&arr, i, &val_clone);
	}
	return arr;
}

array __new_array_with_map_default(int mylen, int cap, int elm_size, map val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.element_size = elm_size,.data = _v_malloc(cap_ * elm_size),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,});
	for (int i = 0; i < arr.len; ++i) {
		map val_clone = map_clone(&val);
		array_set_unsafe(&arr, i, &val_clone);
	}
	return arr;
}

array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array) {
	int cap_ = (cap < len ? (len) : (cap));
	array arr = ((array){.element_size = elm_size,.data = vcalloc(cap_ * elm_size),.offset = 0,.len = len,.cap = cap_,.flags = 0,});
	vmemcpy(arr.data, c_array, len * elm_size);
	return arr;
}

array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, voidptr c_array) {
	array arr = ((array){.element_size = elm_size,.data = c_array,.offset = 0,.len = len,.cap = cap,.flags = 0,});
	return arr;
}

void array_ensure_cap(array* a, int required) {
	if (required <= a->cap) {
		return;
	}
	int cap = (a->cap > 0 ? (a->cap) : (2));
	for (;;) {
		if (!(required > cap)) break;
		cap *= 2;
	}
	int new_size = cap * a->element_size;
	u8* new_data = _v_malloc(new_size);
	if (a->data != ((voidptr)(0))) {
		vmemcpy(new_data, a->data, a->len * a->element_size);
		if (ArrayFlags_has(&a->flags, ArrayFlags__noslices)) {
			_v_free(a->data);
		}
	}
	a->data = new_data;
	a->offset = 0;
	a->cap = cap;
}

array array_repeat(array a, int count) {
	return array_repeat_to_depth(a, count, 0);
}

// Attr: [unsafe]
array array_repeat_to_depth(array a, int count, int depth) {
	if (count < 0) {
		panic_debug(159, tos3("/Users/rcqls/vlang/v/vlib/builtin/array.v"), tos3("builtin"), tos3("repeat_to_depth"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("array.repeat: count is negative: "), 0xfe07, {.d_i32 = count}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	int size = count * a.len * a.element_size;
	if (size == 0) {
		size = a.element_size;
	}
	array arr = ((array){.element_size = a.element_size,.data = vcalloc(size),.offset = 0,.len = count * a.len,.cap = count * a.len,.flags = 0,});
	if (a.len > 0) {
		for (int i = 0; i < count; ++i) {
			if (depth > 0) {
				array ary_clone = array_clone_to_depth(&a, depth);
				vmemcpy(array_get_unsafe(arr, i * a.len), ((u8*)(ary_clone.data)), a.len * a.element_size);
			} else {
				vmemcpy(array_get_unsafe(arr, i * a.len), ((u8*)(a.data)), a.len * a.element_size);
			}
		}
	}
	return arr;
}

void array_insert(array* a, int i, voidptr val) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i > a->len) {
			panic_debug(205, tos3("/Users/rcqls/vlang/v/vlib/builtin/array.v"), tos3("builtin"), tos3("insert"),   str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.insert: index out of range (i == "), 0xfe07, {.d_i32 = i}}, {_SLIT(", a.len == "), 0xfe07, {.d_i32 = a->len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	if (a->len >= a->cap) {
		array_ensure_cap(a, a->len + 1);
	}
	{ // Unsafe block
		vmemmove(array_get_unsafe(/*rec*/*a, i + 1), array_get_unsafe(/*rec*/*a, i), (a->len - i) * a->element_size);
		array_set_unsafe(a, i, val);
	}
	a->len++;
}

// Attr: [unsafe]
void array_insert_many(array* a, int i, voidptr val, int size) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i > a->len) {
			panic_debug(224, tos3("/Users/rcqls/vlang/v/vlib/builtin/array.v"), tos3("builtin"), tos3("insert_many"),   str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.insert_many: index out of range (i == "), 0xfe07, {.d_i32 = i}}, {_SLIT(", a.len == "), 0xfe07, {.d_i32 = a->len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	array_ensure_cap(a, a->len + size);
	int elem_size = a->element_size;
	{ // Unsafe block
		voidptr iptr = array_get_unsafe(/*rec*/*a, i);
		vmemmove(array_get_unsafe(/*rec*/*a, i + size), iptr, (a->len - i) * elem_size);
		vmemcpy(iptr, val, size * elem_size);
	}
	a->len += size;
}

void array_prepend(array* a, voidptr val) {
	array_insert(a, 0, val);
}

// Attr: [unsafe]
void array_prepend_many(array* a, voidptr val, int size) {
	array_insert_many(a, 0, val, size);
}

void array_delete(array* a, int i) {
	array_delete_many(a, i, 1);
}

void array_delete_many(array* a, int i, int size) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i + size > a->len) {
			string endidx = (size > 1 ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT(".."), 0xfe07, {.d_i32 = i + size}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (_SLIT("")));
			panic_debug(284, tos3("/Users/rcqls/vlang/v/vlib/builtin/array.v"), tos3("builtin"), tos3("delete_many"),   str_intp(4, _MOV((StrIntpData[]){{_SLIT("array.delete: index out of range (i == "), 0xfe07, {.d_i32 = i}}, {_SLIT0, 0xfe10, {.d_s = endidx}}, {_SLIT(", a.len == "), 0xfe07, {.d_i32 = a->len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	if (ArrayFlags_all(&a->flags, (ArrayFlags__noshrink | ArrayFlags__noslices))) {
		vmemmove(((u8*)(a->data)) + i * a->element_size, ((u8*)(a->data)) + (i + size) * a->element_size, (a->len - i - size) * a->element_size);
		a->len -= size;
		return;
	}
	voidptr old_data = a->data;
	int new_size = a->len - size;
	int new_cap = (new_size == 0 ? (1) : (new_size));
	a->data = vcalloc(new_cap * a->element_size);
	vmemcpy(a->data, old_data, i * a->element_size);
	vmemcpy(((u8*)(a->data)) + i * a->element_size, ((u8*)(old_data)) + (i + size) * a->element_size, (a->len - i - size) * a->element_size);
	if (ArrayFlags_has(&a->flags, ArrayFlags__noslices)) {
		_v_free(old_data);
	}
	a->len = new_size;
	a->cap = new_cap;
}

void array_clear(array* a) {
	a->len = 0;
}

void array_trim(array* a, int index) {
	if (index < a->len) {
		a->len = index;
	}
}

void array_drop(array* a, int num) {
	if (num <= 0) {
		return;
	}
	int n = (num <= a->len ? (num) : (a->len));
	int blen = n * a->element_size;
	a->data = ((u8*)(a->data)) + blen;
	a->offset += blen;
	a->len -= n;
	a->cap -= n;
}

// Attr: [inline]
// Attr: [unsafe]
inline voidptr array_get_unsafe(array a, int i) {
	{ // Unsafe block
		return ((u8*)(a.data)) + i * a.element_size;
	}
	return 0;
}

voidptr array_get(array a, int i) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a.len) {
			panic_debug(365, tos3("/Users/rcqls/vlang/v/vlib/builtin/array.v"), tos3("builtin"), tos3("get"),   str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.get: index out of range (i == "), 0xfe07, {.d_i32 = i}}, {_SLIT(", a.len == "), 0xfe07, {.d_i32 = a.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	{ // Unsafe block
		return ((u8*)(a.data)) + i * a.element_size;
	}
	return 0;
}

voidptr array_get_with_check(array a, int i) {
	if (i < 0 || i >= a.len) {
		return 0;
	}
	{ // Unsafe block
		return ((u8*)(a.data)) + i * a.element_size;
	}
	return 0;
}

voidptr array_first(array a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a.len == 0) {
			panic_debug(390, tos3("/Users/rcqls/vlang/v/vlib/builtin/array.v"), tos3("builtin"), tos3("first"),  _SLIT("array.first: array is empty"));
			VUNREACHABLE();
		}
	}
	#endif
	return a.data;
}

voidptr array_last(array a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a.len == 0) {
			panic_debug(401, tos3("/Users/rcqls/vlang/v/vlib/builtin/array.v"), tos3("builtin"), tos3("last"),  _SLIT("array.last: array is empty"));
			VUNREACHABLE();
		}
	}
	#endif
	{ // Unsafe block
		return ((u8*)(a.data)) + (a.len - 1) * a.element_size;
	}
	return 0;
}

voidptr array_pop(array* a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a->len == 0) {
			panic_debug(428, tos3("/Users/rcqls/vlang/v/vlib/builtin/array.v"), tos3("builtin"), tos3("pop"),  _SLIT("array.pop: array is empty"));
			VUNREACHABLE();
		}
	}
	#endif
	int new_len = a->len - 1;
	u8* last_elem = ((u8*)(a->data)) + new_len * a->element_size;
	a->len = new_len;
	return last_elem;
}

void array_delete_last(array* a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a->len == 0) {
			panic_debug(447, tos3("/Users/rcqls/vlang/v/vlib/builtin/array.v"), tos3("builtin"), tos3("delete_last"),  _SLIT("array.pop: array is empty"));
			VUNREACHABLE();
		}
	}
	#endif
	a->len--;
}

array array_slice(array a, int start, int _end) {
	int end = _end;
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end) {
			panic_debug(466, tos3("/Users/rcqls/vlang/v/vlib/builtin/array.v"), tos3("builtin"), tos3("slice"),   str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.slice: invalid slice index ("), 0xfe07, {.d_i32 = start}}, {_SLIT(" > "), 0xfe07, {.d_i32 = end}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
		if (end > a.len) {
			panic_debug(469, tos3("/Users/rcqls/vlang/v/vlib/builtin/array.v"), tos3("builtin"), tos3("slice"),   str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.slice: slice bounds out of range ("), 0xfe07, {.d_i32 = end}}, {_SLIT(" >= "), 0xfe07, {.d_i32 = a.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
		if (start < 0) {
			panic_debug(472, tos3("/Users/rcqls/vlang/v/vlib/builtin/array.v"), tos3("builtin"), tos3("slice"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("array.slice: slice bounds out of range ("), 0xfe07, {.d_i32 = start}}, {_SLIT(" < 0)"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	int offset = start * a.element_size;
	u8* data = ((u8*)(a.data)) + offset;
	int l = end - start;
	array res = ((array){.element_size = a.element_size,.data = data,.offset = a.offset + offset,.len = l,.cap = l,.flags = 0,});
	return res;
}

array array_slice_ni(array a, int _start, int _end) {
	int end = _end;
	int start = _start;
	if (start < 0) {
		start = a.len + start;
		if (start < 0) {
			start = 0;
		}
	}
	if (end < 0) {
		end = a.len + end;
		if (end < 0) {
			end = 0;
		}
	}
	if (end >= a.len) {
		end = a.len;
	}
	if (start >= a.len || start > end) {
		array res = ((array){.element_size = a.element_size,.data = a.data,.offset = 0,.len = 0,.cap = 0,.flags = 0,});
		return res;
	}
	int offset = start * a.element_size;
	u8* data = ((u8*)(a.data)) + offset;
	int l = end - start;
	array res = ((array){.element_size = a.element_size,.data = data,.offset = a.offset + offset,.len = l,.cap = l,.flags = 0,});
	return res;
}

array array_slice2(array a, int start, int _end, bool end_max) {
	int end = (end_max ? (a.len) : (_end));
	return array_slice(a, start, end);
}

array array_clone_static_to_depth(array a, int depth) {
	return array_clone_to_depth(&a, depth);
}

array array_clone(array* a) {
	return array_clone_to_depth(a, 0);
}

// Attr: [unsafe]
array array_clone_to_depth(array* a, int depth) {
	int size = a->cap * a->element_size;
	if (size == 0) {
		size++;
	}
	array arr = ((array){.element_size = a->element_size,.data = vcalloc(size),.offset = 0,.len = a->len,.cap = a->cap,.flags = 0,});
	if (depth > 0 && _us32_eq(sizeof(array),a->element_size) && a->len >= 0 && a->cap >= a->len) {
		for (int i = 0; i < a->len; ++i) {
			array ar = ((array){.element_size = 0,.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,});
			vmemcpy(&ar, array_get_unsafe(/*rec*/*a, i), ((int)(sizeof(array))));
			array ar_clone = array_clone_to_depth(&ar, depth - 1);
			array_set_unsafe(&arr, i, &ar_clone);
		}
		return arr;
	} else {
		if (!isnil(a->data)) {
			vmemcpy(((u8*)(arr.data)), a->data, a->cap * a->element_size);
		}
		return arr;
	}
	return (array){.element_size = 0,.data = 0,.offset = 0,.len = 0,.cap = 0,};
}

// Attr: [inline]
// Attr: [unsafe]
inline void array_set_unsafe(array* a, int i, voidptr val) {
	vmemcpy(((u8*)(a->data)) + a->element_size * i, val, a->element_size);
}

void array_set(array* a, int i, voidptr val) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a->len) {
			panic_debug(602, tos3("/Users/rcqls/vlang/v/vlib/builtin/array.v"), tos3("builtin"), tos3("set"),   str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.set: index out of range (i == "), 0xfe07, {.d_i32 = i}}, {_SLIT(", a.len == "), 0xfe07, {.d_i32 = a->len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	vmemcpy(((u8*)(a->data)) + a->element_size * i, val, a->element_size);
}

void array_push(array* a, voidptr val) {
	if (a->len >= a->cap) {
		array_ensure_cap(a, a->len + 1);
	}
	vmemcpy(((u8*)(a->data)) + a->element_size * a->len, val, a->element_size);
	a->len++;
}

// Attr: [unsafe]
void array_push_many(array* a3, voidptr val, int size) {
	array_ensure_cap(a3, a3->len + size);
	if (a3->data == val && !isnil(a3->data)) {
		array copy = array_clone(a3);
		vmemcpy(array_get_unsafe(/*rec*/*a3, a3->len), copy.data, a3->element_size * size);
	} else {
		if (!isnil(a3->data) && !isnil(val)) {
			vmemcpy(array_get_unsafe(/*rec*/*a3, a3->len), val, a3->element_size * size);
		}
	}
	a3->len += size;
}

void array_reverse_in_place(array* a) {
	if (a->len < 2) {
		return;
	}
	{ // Unsafe block
		u8* tmp_value = _v_malloc(a->element_size);
		for (int i = 0; i < a->len / 2; ++i) {
			vmemcpy(tmp_value, ((u8*)(a->data)) + i * a->element_size, a->element_size);
			vmemcpy(((u8*)(a->data)) + i * a->element_size, ((u8*)(a->data)) + (a->len - 1 - i) * a->element_size, a->element_size);
			vmemcpy(((u8*)(a->data)) + (a->len - 1 - i) * a->element_size, tmp_value, a->element_size);
		}
		_v_free(tmp_value);
	}
}

array array_reverse(array a) {
	if (a.len < 2) {
		return a;
	}
	array arr = ((array){.element_size = a.element_size,.data = vcalloc(a.cap * a.element_size),.offset = 0,.len = a.len,.cap = a.cap,.flags = 0,});
	for (int i = 0; i < a.len; ++i) {
		array_set_unsafe(&arr, i, array_get_unsafe(a, a.len - 1 - i));
	}
	return arr;
}

// Attr: [unsafe]
void array_free(array* a) {
	u8* mblock_ptr = ((u8*)(((u64)(a->data)) - ((u64)(a->offset))));
	_v_free(mblock_ptr);
}

array array_filter(array a, bool (*predicate)(voidptr ));

bool array_any(array a, bool (*predicate)(voidptr ));

bool array_all(array a, bool (*predicate)(voidptr ));

array array_map(array a, voidptr (*callback)(voidptr ));

void array_sort(array* a, int (*callback)(voidptr , voidptr ));

void array_sort_with_compare(array* a, int (*callback)(voidptr , voidptr )) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		vqsort(a->data, ((usize)(a->len)), ((usize)(a->element_size)), (voidptr)callback);
	}
	#endif
}

bool array_contains(array a, voidptr value);

int array_index(array a, voidptr value);

// Attr: [unsafe]
void Array_string_free(Array_string* a) {
	for (int _t1 = 0; _t1 < a->len; ++_t1) {
		string s = ((string*)a->data)[_t1];
		string_free(&s);
	}
	array_free((((array*)(a))));
}

// Attr: [manualfree]
string Array_string_str(Array_string a) {
	int sb_len = 4;
	if (a.len > 0) {
		sb_len += (*(string*)/*ee elem_sym */array_get(a, 0)).len;
		sb_len *= a.len;
	}
	sb_len += 2;
	strings__Builder sb = strings__new_builder(sb_len);
	strings__Builder_write_u8(&sb, '[');
	for (int i = 0; i < a.len; ++i) {
		string val = (*(string*)/*ee elem_sym */array_get(a, i));
		strings__Builder_write_u8(&sb, '\'');
		strings__Builder_write_string(&sb, val);
		strings__Builder_write_u8(&sb, '\'');
		if (i < a.len - 1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_u8(&sb, ']');
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}

string Array_u8_hex(Array_u8 b) {
	u8* hex = malloc_noscan(b.len * 2 + 1);
	int dst_i = 0;
	for (int _t1 = 0; _t1 < b.len; ++_t1) {
		u8 i = ((u8*)b.data)[_t1];
		u8 n0 = i >> 4;
		{ // Unsafe block
			hex[dst_i] = (n0 < 10 ? (n0 + '0') : (n0 + ((u8)(87))));
			dst_i++;
		}
		u8 n1 = (i & 0xF);
		{ // Unsafe block
			hex[dst_i] = (n1 < 10 ? (n1 + '0') : (n1 + ((u8)(87))));
			dst_i++;
		}
	}
	{ // Unsafe block
		hex[dst_i] = 0;
		return tos(hex, dst_i);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

int copy(Array_u8* dst, Array_u8 src) {
	int min = (dst->len < src.len ? (dst->len) : (src.len));
	if (min > 0) {
		vmemmove(((u8*)(dst->data)), src.data, min);
	}
	return min;
}

int Array_int_reduce(Array_int a, int (*iter)(int , int ), int accum_start) {
	int accum_ = accum_start;
	for (int _t1 = 0; _t1 < a.len; ++_t1) {
		int i = ((int*)a.data)[_t1];
		accum_ = iter(accum_, i);
	}
	return accum_;
}

void array_grow_cap(array* a, int amount) {
	array_ensure_cap(a, a->cap + amount);
}

// Attr: [unsafe]
void array_grow_len(array* a, int amount) {
	array_ensure_cap(a, a->len + amount);
	a->len += amount;
}

// Attr: [unsafe]
Array_voidptr array_pointers(array a) {
	Array_voidptr res = __new_array_with_default(0, 0, sizeof(voidptr), 0);
	for (int i = 0; i < a.len; ++i) {
		array_push((array*)&res, _MOV((voidptr[]){ array_get_unsafe(a, i) }));
	}
	return res;
}

// Attr: [unsafe]
Array_u8 voidptr_vbytes(voidptr data, int len) {
	array res = ((array){.element_size = 1,.data = data,.offset = 0,.len = len,.cap = len,.flags = 0,});
	return res;
}

// Attr: [unsafe]
Array_u8 u8_vbytes(u8* data, int len) {
	return voidptr_vbytes(((voidptr)(data)), len);
}

array __new_array_noscan(int mylen, int cap, int elm_size) {
	return ((array){.element_size = 0,.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,});
}

// TypeDecl
// Attr: [noreturn]
VNORETURN void vhalt(void) {
	for (;;) {
	}
	while(1);
}

// Attr: [noreturn]
VNORETURN void _v_exit(int code) {
	exit(code);
	VUNREACHABLE();
	while(1);
}

string vcommithash(void) {
	return tos5(((char*)(V_CURRENT_COMMIT_HASH)));
}

// Attr: [noreturn]
VNORETURN void panic_debug(int line_no, string file, string mod, string fn_name, string s) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		eprintln(_SLIT("================ V panic ================"));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("   module: "), 0xfe10, {.d_s = mod}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT(" function: "), 0xfe10, {.d_s = fn_name}}, {_SLIT("()"), 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("  message: "), 0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("     file: "), 0xfe10, {.d_s = file}}, {_SLIT(":"), 0xfe07, {.d_i32 = line_no}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("   v hash: "), 0xfe10, {.d_s = vcommithash()}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln(_SLIT("========================================="));
		#if defined(CUSTOM_DEFINE_exit_after_panic_message)
		{
		}
		#elif defined(CUSTOM_DEFINE_no_backtrace)
		{
		}
		#else
		{
			print_backtrace_skipping_top_frames(1);
			exit(1);
			VUNREACHABLE();
		}
		#endif
	}
	#endif
	vhalt();
	VUNREACHABLE();
	while(1);
}

// Attr: [noreturn]
VNORETURN void panic_optional_not_set(string s) {
	panic_debug(69, tos3("/Users/rcqls/vlang/v/vlib/builtin/builtin.c.v"), tos3("builtin"), tos3("panic_optional_not_set"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("optional not set ("), 0xfe10, {.d_s = s}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	VUNREACHABLE();
	while(1);
}

// Attr: [noreturn]
VNORETURN void _v_panic(string s) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		eprint(_SLIT("V panic: "));
		eprintln(s);
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("v hash: "), 0xfe10, {.d_s = vcommithash()}}, {_SLIT0, 0, { .d_c = 0 }}})));
		#if defined(CUSTOM_DEFINE_exit_after_panic_message)
		{
		}
		#elif defined(CUSTOM_DEFINE_no_backtrace)
		{
		}
		#else
		{
			print_backtrace_skipping_top_frames(1);
			exit(1);
			VUNREACHABLE();
		}
		#endif
	}
	#endif
	vhalt();
	VUNREACHABLE();
	while(1);
}

string c_error_number_str(int errnum) {
	string err_msg = _SLIT("");
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		#if !defined(__vinix__)
		{
			char* c_msg = strerror(errnum);
			err_msg = ((string){.str = ((u8*)(c_msg)), .len = strlen(c_msg), .is_lit = 1});
		}
		#endif
	}
	#endif
	return err_msg;
}

// Attr: [noreturn]
VNORETURN void panic_error_number(string basestr, int errnum) {
	panic_debug(126, tos3("/Users/rcqls/vlang/v/vlib/builtin/builtin.c.v"), tos3("builtin"), tos3("panic_error_number"),  string__plus(basestr, c_error_number_str(errnum)));
	VUNREACHABLE();
	while(1);
}

void eprintln(string s) {
	if (s.str == 0) {
		eprintln(_SLIT("eprintln(NIL)"));
		return;
	}
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		fflush(stdout);
		fflush(stderr);
		_writeln_to_fd(2, s);
		fflush(stderr);
	}
	#endif
}

void eprint(string s) {
	if (s.str == 0) {
		eprint(_SLIT("eprint(NIL)"));
		return;
	}
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		fflush(stdout);
		fflush(stderr);
		_write_buf_to_fd(2, s.str, s.len);
		fflush(stderr);
	}
	#endif
}

void flush_stdout(void) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		fflush(stdout);
	}
	#endif
}

void flush_stderr(void) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		fflush(stderr);
	}
	#endif
}

// Attr: [manualfree]
void print(string s) {
	#if defined(__TARGET_IOS__)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		_write_buf_to_fd(1, s.str, s.len);
	}
	#endif
}

// Attr: [manualfree]
void println(string s) {
	if (s.str == 0) {
		println(_SLIT("println(NIL)"));
		return;
	}
	#if defined(__TARGET_IOS__)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		_writeln_to_fd(1, s);
	}
	#endif
}

// Attr: [manualfree]
void _writeln_to_fd(int fd, string s) {
bool _writeln_to_fd_defer_0 = false;
u8* buf;
	{ // Unsafe block
		int buf_len = s.len + 1;
		buf = _v_malloc(buf_len);
		_writeln_to_fd_defer_0 = true;
		memcpy(buf, s.str, s.len);
		buf[s.len] = '\n';
		_write_buf_to_fd(fd, buf, buf_len);
	}
// Defer begin
if (_writeln_to_fd_defer_0) {
	_v_free(buf);
}
// Defer end
}

// Attr: [manualfree]
void _write_buf_to_fd(int fd, u8* buf, int buf_len) {
	if (buf_len <= 0) {
		return;
	}
	{ // Unsafe block
		u8* ptr = buf;
		int remaining_bytes = buf_len;
		for (;;) {
			if (!(remaining_bytes > 0)) break;
			int x = write(fd, ptr, remaining_bytes);
			ptr += x;
			remaining_bytes -= x;
		}
	}
}

// Attr: [unsafe]
u8* _v_malloc(int n) {
	if (n <= 0) {
		panic_debug(272, tos3("/Users/rcqls/vlang/v/vlib/builtin/builtin.c.v"), tos3("builtin"), tos3("malloc"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("malloc("), 0xfe07, {.d_i32 = n}}, {_SLIT(" <= 0)"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	u8* res = ((u8*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		res = malloc(n);
	}
	#endif
	if (res == 0) {
		panic_debug(302, tos3("/Users/rcqls/vlang/v/vlib/builtin/builtin.c.v"), tos3("builtin"), tos3("malloc"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("malloc("), 0xfe07, {.d_i32 = n}}, {_SLIT(") failed"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return res;
}

// Attr: [unsafe]
u8* malloc_noscan(int n) {
	if (n <= 0) {
		panic_debug(315, tos3("/Users/rcqls/vlang/v/vlib/builtin/builtin.c.v"), tos3("builtin"), tos3("malloc_noscan"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("malloc_noscan("), 0xfe07, {.d_i32 = n}}, {_SLIT(" <= 0)"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	u8* res = ((u8*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		res = malloc(n);
	}
	#endif
	if (res == 0) {
		panic_debug(349, tos3("/Users/rcqls/vlang/v/vlib/builtin/builtin.c.v"), tos3("builtin"), tos3("malloc_noscan"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("malloc_noscan("), 0xfe07, {.d_i32 = n}}, {_SLIT(") failed"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return res;
}

// Attr: [unsafe]
u8* v_realloc(u8* b, int n) {
	u8* new_ptr = ((u8*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
	}
	#else
	{
		new_ptr = realloc(b, n);
	}
	#endif
	if (new_ptr == 0) {
		panic_debug(381, tos3("/Users/rcqls/vlang/v/vlib/builtin/builtin.c.v"), tos3("builtin"), tos3("v_realloc"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("realloc("), 0xfe07, {.d_i32 = n}}, {_SLIT(") failed"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return new_ptr;
}

// Attr: [unsafe]
u8* realloc_data(u8* old_data, int old_size, int new_size) {
	u8* nptr = ((u8*)(0));
	#if defined(_VGCBOEHM)
	{
	}
	#else
	{
		nptr = realloc(old_data, new_size);
	}
	#endif
	if (nptr == 0) {
		panic_debug(427, tos3("/Users/rcqls/vlang/v/vlib/builtin/builtin.c.v"), tos3("builtin"), tos3("realloc_data"),   str_intp(4, _MOV((StrIntpData[]){{_SLIT("realloc_data("), 0xfe11, {.d_p = (void*)(old_data)}}, {_SLIT(", "), 0xfe07, {.d_i32 = old_size}}, {_SLIT(", "), 0xfe07, {.d_i32 = new_size}}, {_SLIT(") failed"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return nptr;
}

u8* vcalloc(int n) {
	if (n < 0) {
		panic_debug(437, tos3("/Users/rcqls/vlang/v/vlib/builtin/builtin.c.v"), tos3("builtin"), tos3("vcalloc"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("calloc("), 0xfe07, {.d_i32 = n}}, {_SLIT(" < 0)"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	} else if (n == 0) {
		return ((u8*)(0));
	}
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
	}
	#else
	{
		return calloc(1, n);
	}
	#endif
	return 0;
}

u8* vcalloc_noscan(int n) {
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
	}
	#else
	{
		return vcalloc(n);
	}
	#endif
	return 0;
}

// Attr: [unsafe]
void _v_free(voidptr ptr) {
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
	}
	#else
	{
		free(ptr);
	}
	#endif
}

// Attr: [unsafe]
voidptr memdup(voidptr src, int sz) {
	if (sz == 0) {
		return vcalloc(1);
	}
	{ // Unsafe block
		u8* mem = _v_malloc(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}

// Attr: [unsafe]
voidptr memdup_noscan(voidptr src, int sz) {
	if (sz == 0) {
		return vcalloc_noscan(1);
	}
	{ // Unsafe block
		u8* mem = malloc_noscan(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}

// Attr: [inline]
inline int v_fixed_index(int i, int len) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= len) {
			string s =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("fixed array index out of range (index: "), 0xfe07, {.d_i32 = i}}, {_SLIT(", len: "), 0xfe07, {.d_i32 = len}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
			panic_debug(531, tos3("/Users/rcqls/vlang/v/vlib/builtin/builtin.c.v"), tos3("builtin"), tos3("v_fixed_index"),  s);
			VUNREACHABLE();
		}
	}
	#endif
	return i;
}

void print_backtrace(void) {
	#if !defined(CUSTOM_DEFINE_no_backtrace)
	{
		#if defined(_VFREESTANDING)
		{
		}
		#else
		{
			#if defined(__TINYC__)
			{
			}
			#else
			{
				print_backtrace_skipping_top_frames(2);
			}
			#endif
		}
		#endif
	}
	#endif
}

// Attr: [inline]
inline bool isnil(voidptr v) {
	return v == 0;
}

voidptr __as_cast(voidptr obj, int obj_type, int expected_type) {
	if (obj_type != expected_type) {
		string obj_name = string_clone((*(VCastTypeIndexName*)/*ee elem_sym */array_get(as_cast_type_indexes, 0)).tname);
		string expected_name = string_clone((*(VCastTypeIndexName*)/*ee elem_sym */array_get(as_cast_type_indexes, 0)).tname);
		for (int _t1 = 0; _t1 < as_cast_type_indexes.len; ++_t1) {
			VCastTypeIndexName x = ((VCastTypeIndexName*)as_cast_type_indexes.data)[_t1];
			if (x.tindex == obj_type) {
				obj_name = string_clone(x.tname);
			}
			if (x.tindex == expected_type) {
				expected_name = string_clone(x.tname);
			}
		}
		panic_debug(39, tos3("/Users/rcqls/vlang/v/vlib/builtin/builtin.v"), tos3("builtin"), tos3("__as_cast"),   str_intp(3, _MOV((StrIntpData[]){{_SLIT("as cast: cannot cast `"), 0xfe10, {.d_s = obj_name}}, {_SLIT("` to `"), 0xfe10, {.d_s = expected_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return obj;
}

// Attr: [manualfree]
// Attr: [unsafe]
void VAssertMetaInfo_free(VAssertMetaInfo* ami) {
	{ // Unsafe block
		string_free(&ami->fpath);
		string_free(&ami->fn_name);
		string_free(&ami->src);
		string_free(&ami->op);
		string_free(&ami->llabel);
		string_free(&ami->rlabel);
		string_free(&ami->lvalue);
		string_free(&ami->rvalue);
	}
}

void __print_assert_failure(VAssertMetaInfo* i) {
	eprintln( str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = i->fpath}}, {_SLIT(":"), 0xfe07, {.d_i32 = i->line_nr + 1}}, {_SLIT(": FAIL: fn "), 0xfe10, {.d_s = i->fn_name}}, {_SLIT(": assert "), 0xfe10, {.d_s = i->src}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if (i->op.len > 0 && !string__eq(i->op, _SLIT("call"))) {
		eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("   left value: "), 0xfe10, {.d_s = i->llabel}}, {_SLIT(" = "), 0xfe10, {.d_s = i->lvalue}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (string__eq(i->rlabel, i->rvalue)) {
			eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("  right value: "), 0xfe10, {.d_s = i->rlabel}}, {_SLIT0, 0, { .d_c = 0 }}})));
		} else {
			eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("  right value: "), 0xfe10, {.d_s = i->rlabel}}, {_SLIT(" = "), 0xfe10, {.d_s = i->rvalue}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
	}
}

// Attr: [markused]
void v_segmentation_fault_handler(int signal) {
	eprintln(_SLIT("signal 11: segmentation fault"));
	print_backtrace();
	_v_exit(128 + 11);
	VUNREACHABLE();
}

void builtin_init(void) {
}

bool print_backtrace_skipping_top_frames(int xskipframes) {
	#if defined(CUSTOM_DEFINE_no_backtrace)
	{
	}
	#else
	{
		int skipframes = xskipframes + 2;
		#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)
		{
			return print_backtrace_skipping_top_frames_bsd(skipframes);
		}
		#elif defined(__linux__)
		{
		}
		#else
		{
		}
		#endif
	}
	#endif
	return false;
}

bool print_backtrace_skipping_top_frames_bsd(int skipframes) {
	#if defined(CUSTOM_DEFINE_no_backtrace)
	{
	}
	#else
	{
		#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__)
		{
			Array_fixed_voidptr_100 buffer = {0};
			int nr_ptrs = backtrace(&buffer[0], 100);
			if (nr_ptrs < 2) {
				eprintln(_SLIT("C.backtrace returned less than 2 frames"));
				return false;
			}
			backtrace_symbols_fd(&buffer[v_fixed_index(skipframes, 100)], nr_ptrs - skipframes, 2);
		}
		#endif
		return true;
	}
	#endif
	return 0;
}

bool print_backtrace_skipping_top_frames_linux(int skipframes) {
	#if defined(CUSTOM_DEFINE_no_backtrace)
	{
	}
	#else
	{
	}
	#endif
	return true;
}

void break_if_debugger_attached(void) {
	{ // Unsafe block
		voidptr* ptr = ((voidptr*)(0));
		*ptr = ((voidptr)(0));
	}
}

string winapi_lasterr_str(void) {
	return _SLIT("");
}

// Attr: [noreturn]
VNORETURN void panic_lasterr(void) {
	while(1);
}

void gc_check_leaks(void) {
}

// Attr: [trusted]
// Attr: [noreturn]
// Attr: [trusted]
// Attr: [trusted]
int proc_pidpath(int , voidptr , int );

// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [inline]
// Attr: [unsafe]
inline int vstrlen(byte* s) {
	return strlen(((char*)(s)));
}

// Attr: [inline]
// Attr: [unsafe]
inline int vstrlen_char(char* s) {
	return strlen(s);
}

// Attr: [inline]
// Attr: [unsafe]
inline voidptr vmemcpy(voidptr dest, const voidptr const_src, int n) {
	{ // Unsafe block
		return memcpy(dest, const_src, n);
	}
	return 0;
}

// Attr: [inline]
// Attr: [unsafe]
inline voidptr vmemmove(voidptr dest, const voidptr const_src, int n) {
	{ // Unsafe block
		return memmove(dest, const_src, n);
	}
	return 0;
}

// Attr: [inline]
// Attr: [unsafe]
inline int vmemcmp(const voidptr const_s1, const voidptr const_s2, int n) {
	{ // Unsafe block
		return memcmp(const_s1, const_s2, n);
	}
	return 0;
}

// Attr: [inline]
// Attr: [unsafe]
inline voidptr vmemset(voidptr s, int c, int n) {
	{ // Unsafe block
		return memset(s, c, n);
	}
	return 0;
}

// TypeDecl
// Attr: [inline]
// Attr: [unsafe]
inline void vqsort(voidptr base, usize nmemb, usize size, int (*sort_cb)(const voidptr const_a, const voidptr const_b)) {
	qsort(base, nmemb, size, ((voidptr)(sort_cb)));
}

void chan_close(chan ch) {
}

ChanState chan_try_pop(chan ch, voidptr obj) {
	return ChanState__success;
}

ChanState chan_try_push(chan ch, voidptr obj) {
	return ChanState__success;
}

// Attr: [inline]
inline string f64_str(f64 x) {
	{ // Unsafe block
		strconv__Float64u f = ((strconv__Float64u){.f = x,});
		if (f.u == _const_strconv__double_minus_zero) {
			return _SLIT("-0");
		}
		if (f.u == _const_strconv__double_plus_zero) {
			return _SLIT("0");
		}
	}
	f64 abs_x = f64_abs(x);
	if (abs_x >= 0.0001 && abs_x < 1.0e6) {
		return strconv__f64_to_str_l(x);
	} else {
		return strconv__ftoa_64(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string f64_strg(f64 x) {
	if (x == 0) {
		return _SLIT("0");
	}
	f64 abs_x = f64_abs(x);
	if (abs_x >= 0.0001 && abs_x < 1.0e6) {
		return strconv__f64_to_str_l_no_dot(x);
	} else {
		return strconv__ftoa_64(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string float_literal_str(float_literal d) {
	return f64_str(((f64)(d)));
}

// Attr: [inline]
inline string f64_strsci(f64 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 17) {
		n_digit = 17;
	}
	return strconv__f64_to_str(x, n_digit);
}

// Attr: [inline]
inline string f64_strlong(f64 x) {
	return strconv__f64_to_str_l(x);
}

// Attr: [inline]
inline string f32_str(f32 x) {
	{ // Unsafe block
		strconv__Float32u f = ((strconv__Float32u){.f = x,});
		if (f.u == _const_strconv__single_minus_zero) {
			return _SLIT("-0");
		}
		if (f.u == _const_strconv__single_plus_zero) {
			return _SLIT("0");
		}
	}
	f32 abs_x = f32_abs(x);
	if (abs_x >= 0.0001 && abs_x < 1.0e6) {
		return strconv__f32_to_str_l(x);
	} else {
		return strconv__ftoa_32(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string f32_strg(f32 x) {
	if (x == 0) {
		return _SLIT("0");
	}
	f32 abs_x = f32_abs(x);
	if (abs_x >= 0.0001 && abs_x < 1.0e6) {
		return strconv__f32_to_str_l_no_dot(x);
	} else {
		return strconv__ftoa_32(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string f32_strsci(f32 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 8) {
		n_digit = 8;
	}
	return strconv__f32_to_str(x, n_digit);
}

// Attr: [inline]
inline string f32_strlong(f32 x) {
	return strconv__f32_to_str_l(x);
}

// Attr: [inline]
inline f32 f32_abs(f32 a) {
	return (a < 0 ? (-a) : (a));
}

// Attr: [inline]
inline f64 f64_abs(f64 a) {
	return (a < 0 ? (-a) : (a));
}

// Attr: [inline]
inline f32 f32_max(f32 a, f32 b) {
	return (a > b ? (a) : (b));
}

// Attr: [inline]
inline f32 f32_min(f32 a, f32 b) {
	return (a < b ? (a) : (b));
}

// Attr: [inline]
inline f64 f64_max(f64 a, f64 b) {
	return (a > b ? (a) : (b));
}

// Attr: [inline]
inline f64 f64_min(f64 a, f64 b) {
	return (a < b ? (a) : (b));
}

// Attr: [inline]
inline bool f32_eq_epsilon(f32 a, f32 b) {
	f32 hi = f32_max(f32_abs(a), f32_abs(b));
	f32 delta = f32_abs(a - b);
	if (hi > ((f32)(1.0))) {
		return delta <= hi * (4 * ((f32)(FLT_EPSILON)));
	} else {
		return (1 / (4 * ((f32)(FLT_EPSILON)))) * delta <= hi;
	}
	return 0;
}

// Attr: [inline]
inline bool f64_eq_epsilon(f64 a, f64 b) {
	f64 hi = f64_max(f64_abs(a), f64_abs(b));
	f64 delta = f64_abs(a - b);
	if (hi > 1.0) {
		return delta <= hi * (4 * ((f64)(DBL_EPSILON)));
	} else {
		return (1 / (4 * ((f64)(DBL_EPSILON)))) * delta <= hi;
	}
	return 0;
}

void float_test(void) {
}

// TypeDecl
// TypeDecl
string ptr_str(voidptr ptr) {
	string buf1 = u64_hex(((u64)(ptr)));
	return buf1;
}

string isize_str(isize x) {
	return i64_str(((i64)(x)));
}

string usize_str(usize x) {
	return u64_str(((u64)(x)));
}

string char_str(char* cptr) {
	return u64_hex(((u64)(cptr)));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline string int_str_l(int nn, int max) {
	{ // Unsafe block
		i64 n = ((i64)(nn));
		int d = 0;
		if (n == 0) {
			return _SLIT("0");
		}
		bool is_neg = false;
		if (n < 0) {
			n = -n;
			is_neg = true;
		}
		int index = max;
		u8* buf = malloc_noscan(max + 1);
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0)) break;
			int n1 = ((int)(n / 100));
			d = ((int)(((u32)(((int)(n)) - (n1 * 100))) << 1U));
			n = n1;
			buf[index] = _const_digit_pairs.str[d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[d];
			index--;
		}
		index++;
		if (d < 20) {
			index++;
		}
		if (is_neg) {
			index--;
			buf[index] = '-';
		}
		int diff = max - index;
		vmemmove(buf, ((voidptr)(buf + index)), diff + 1);
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string i8_str(i8 n) {
	return int_str_l(((int)(n)), 5);
}

string i16_str(i16 n) {
	return int_str_l(((int)(n)), 7);
}

string u16_str(u16 n) {
	return int_str_l(((int)(n)), 7);
}

string int_str(int n) {
	return int_str_l(n, 12);
}

// Attr: [direct_array_access]
// Attr: [inline]
inline string u32_str(u32 nn) {
	{ // Unsafe block
		u32 n = nn;
		u32 d = ((u32)(0U));
		if (n == 0U) {
			return _SLIT("0");
		}
		int max = 12;
		u8* buf = malloc_noscan(max + 1);
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0U)) break;
			u32 n1 = n / ((u32)(100U));
			d = ((n - (n1 * ((u32)(100U)))) << ((u32)(1U)));
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < ((u32)(20U))) {
			index++;
		}
		int diff = max - index;
		vmemmove(buf, ((voidptr)(buf + index)), diff + 1);
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string int_literal_str(int_literal n) {
	return i64_str(((i64)(n)));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline string i64_str(i64 nn) {
	{ // Unsafe block
		i64 n = nn;
		i64 d = ((i64)(0));
		if (n == 0) {
			return _SLIT("0");
		}
		int max = 20;
		u8* buf = malloc_noscan(max + 1);
		bool is_neg = false;
		if (n < 0) {
			n = -n;
			is_neg = true;
		}
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0)) break;
			i64 n1 = n / ((i64)(100));
			d = (((u32)(n - (n1 * ((i64)(100))))) << ((i64)(1)));
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < ((i64)(20))) {
			index++;
		}
		if (is_neg) {
			index--;
			buf[index] = '-';
		}
		int diff = max - index;
		vmemmove(buf, ((voidptr)(buf + index)), diff + 1);
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
// Attr: [inline]
inline string u64_str(u64 nn) {
	{ // Unsafe block
		u64 n = nn;
		u64 d = ((u64)(0U));
		if (n == 0U) {
			return _SLIT("0");
		}
		int max = 20;
		u8* buf = malloc_noscan(max + 1);
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0U)) break;
			u64 n1 = n / 100U;
			d = ((n - (n1 * 100U)) << 1U);
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < 20U) {
			index++;
		}
		int diff = max - index;
		vmemmove(buf, ((voidptr)(buf + index)), diff + 1);
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string bool_str(bool b) {
	if (b) {
		return _SLIT("true");
	}
	return _SLIT("false");
}

// Attr: [direct_array_access]
// Attr: [inline]
inline string u64_to_hex(u64 nn, u8 len) {
	u64 n = nn;
	Array_fixed_u8_17 buf = {0};
	buf[len] = 0;
	int i = 0;
	for (i = len - 1; i >= 0; i--) {
		u8 d = ((u8)((n & 0xFU)));
		buf[i] = (d < 10 ? (d + '0') : (d + 87));
		n = n >> 4U;
	}
	return tos(memdup(&buf[0], len + 1), len);
}

// Attr: [direct_array_access]
// Attr: [inline]
inline string u64_to_hex_no_leading_zeros(u64 nn, u8 len) {
	u64 n = nn;
	Array_fixed_u8_17 buf = {0};
	buf[len] = 0;
	int i = 0;
	for (i = len - 1; i >= 0; i--) {
		u8 d = ((u8)((n & 0xFU)));
		buf[i] = (d < 10 ? (d + '0') : (d + 87));
		n = n >> 4U;
		if (n == 0U) {
			break;
		}
	}
	int res_len = len - i;
	return tos(memdup(&buf[i], res_len + 1), res_len);
}

string u8_hex(u8 nn) {
	if (nn == 0) {
		return _SLIT("00");
	}
	return u64_to_hex(nn, 2);
}

string i8_hex(i8 nn) {
	if (nn == 0) {
		return _SLIT("00");
	}
	return u64_to_hex(((u64)(nn)), 2);
}

string u16_hex(u16 nn) {
	if (nn == 0U) {
		return _SLIT("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 4);
}

string i16_hex(i16 nn) {
	return u16_hex(((u16)(nn)));
}

string u32_hex(u32 nn) {
	if (nn == 0U) {
		return _SLIT("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 8);
}

string int_hex(int nn) {
	return u32_hex(((u32)(nn)));
}

string int_hex2(int n) {
	return string__plus(_SLIT("0x"), int_hex(n));
}

string u64_hex(u64 nn) {
	if (nn == 0U) {
		return _SLIT("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 16);
}

string i64_hex(i64 nn) {
	return u64_hex(((u64)(nn)));
}

string int_literal_hex(int_literal nn) {
	return u64_hex(((u64)(nn)));
}

string voidptr_str(voidptr nn) {
	return string__plus(_SLIT("0x"), u64_hex(((u64)(nn))));
}

string byteptr_str(byteptr nn) {
	return string__plus(_SLIT("0x"), u64_hex(((u64)(nn))));
}

string charptr_str(charptr nn) {
	return string__plus(_SLIT("0x"), u64_hex(((u64)(nn))));
}

string u8_hex_full(u8 nn) {
	return u64_to_hex(((u64)(nn)), 2);
}

string i8_hex_full(i8 nn) {
	return u64_to_hex(((u64)(nn)), 2);
}

string u16_hex_full(u16 nn) {
	return u64_to_hex(((u64)(nn)), 4);
}

string i16_hex_full(i16 nn) {
	return u64_to_hex(((u64)(nn)), 4);
}

string u32_hex_full(u32 nn) {
	return u64_to_hex(((u64)(nn)), 8);
}

string int_hex_full(int nn) {
	return u64_to_hex(((u64)(nn)), 8);
}

string i64_hex_full(i64 nn) {
	return u64_to_hex(((u64)(nn)), 16);
}

string voidptr_hex_full(voidptr nn) {
	return u64_to_hex(((u64)(nn)), 16);
}

string int_literal_hex_full(int_literal nn) {
	return u64_to_hex(((u64)(nn)), 16);
}

string u64_hex_full(u64 nn) {
	return u64_to_hex(nn, 16);
}

string u8_str(u8 b) {
	return int_str_l(((int)(b)), 7);
}

string u8_ascii_str(u8 b) {
	string str = ((string){.str = malloc_noscan(2), .len = 1});
	{ // Unsafe block
		str.str[0] = b;
		str.str[1] = 0;
	}
	return str;
}

// Attr: [manualfree]
string u8_str_escaped(u8 b) {
	string _t1 = (string){.str=(byteptr)"", .is_lit=1};
	
	if (b == (0)) {
		_t1 = _SLIT("`\\0`");
	}
	else if (b == (7)) {
		_t1 = _SLIT("`\\a`");
	}
	else if (b == (8)) {
		_t1 = _SLIT("`\\b`");
	}
	else if (b == (9)) {
		_t1 = _SLIT("`\\t`");
	}
	else if (b == (10)) {
		_t1 = _SLIT("`\\n`");
	}
	else if (b == (11)) {
		_t1 = _SLIT("`\\v`");
	}
	else if (b == (12)) {
		_t1 = _SLIT("`\\f`");
	}
	else if (b == (13)) {
		_t1 = _SLIT("`\\r`");
	}
	else if (b == (27)) {
		_t1 = _SLIT("`\\e`");
	}
	else if ((b >= 32 && b <= 126)) {
		_t1 = u8_ascii_str(b);
	}
	else {
		string xx = u8_hex(b);
		string yy = string__plus(_SLIT("0x"), xx);
		string_free(&xx);
		_t1 = yy;
	}string str = _t1;
	return str;
}

// Attr: [inline]
inline bool u8_is_capital(u8 c) {
	return c >= 'A' && c <= 'Z';
}

Array_u8 Array_u8_clone(Array_u8 b) {
	Array_u8 res = __new_array_with_default(b.len, 0, sizeof(u8), 0);
	for (int i = 0; i < b.len; ++i) {
		array_set(&res, i, &(u8[]) { (*(u8*)/*ee elem_sym */array_get(b, i)) });
	}
	return res;
}

string Array_u8_bytestr(Array_u8 b) {
	{ // Unsafe block
		u8* buf = malloc_noscan(b.len + 1);
		vmemcpy(buf, b.data, b.len);
		buf[b.len] = 0;
		return tos(buf, b.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

Option_rune Array_u8_byterune(Array_u8 b) {
	Option_rune _t1 = Array_u8_utf8_to_utf32(b);
	if (_t1.state != 0) { /*or block*/ 
		Option_rune _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	rune r =  (*(rune*)_t1.data);
	Option_rune _t3;
	opt_ok(&(rune[]) { ((rune)(r)) }, (Option*)(&_t3), sizeof(rune));
	return _t3;
}

string u8_repeat(u8 b, int count) {
	if (count < 0) {
		panic_debug(563, tos3("/Users/rcqls/vlang/v/vlib/builtin/int.v"), tos3("builtin"), tos3("repeat"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("byte.repeat: count is negative: "), 0xfe07, {.d_i32 = count}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	} else if (count == 0) {
		return _SLIT("");
	} else if (count == 1) {
		return u8_ascii_str(b);
	}
	u8* ret = malloc_noscan(count + 1);
	for (int i = 0; i < count; ++i) {
		{ // Unsafe block
			ret[i] = b;
		}
	}
	int new_len = count;
	{ // Unsafe block
		ret[new_len] = 0;
	}
	return u8_vstring_with_len(ret, new_len);
}

// Attr: [inline]
inline bool fast_string_eq(string a, string b) {
	if (a.len != b.len) {
		return false;
	}
	{ // Unsafe block
		return memcmp(a.str, b.str, b.len) == 0;
	}
	return 0;
}

u64 map_hash_string(voidptr pkey) {
	string key = *((string*)(pkey));
	return wyhash(key.str, ((u64)(key.len)), 0U, ((u64*)(_wyp)));
}

u64 map_hash_int_1(voidptr pkey) {
	return wyhash64(*((u8*)(pkey)), 0U);
}

u64 map_hash_int_2(voidptr pkey) {
	return wyhash64(*((u16*)(pkey)), 0U);
}

u64 map_hash_int_4(voidptr pkey) {
	return wyhash64(*((u32*)(pkey)), 0U);
}

u64 map_hash_int_8(voidptr pkey) {
	return wyhash64(*((u64*)(pkey)), 0U);
}

void DenseArray_zeros_to_end(DenseArray* d) {
	u8* tmp_value = _v_malloc(d->value_bytes);
	u8* tmp_key = _v_malloc(d->key_bytes);
	int count = 0;
	for (int i = 0; i < d->len; ++i) {
		if (DenseArray_has_index(d, i)) {
			{ // Unsafe block
				if (count != i) {
					memcpy(tmp_key, DenseArray_key(d, count), d->key_bytes);
					memcpy(DenseArray_key(d, count), DenseArray_key(d, i), d->key_bytes);
					memcpy(DenseArray_key(d, i), tmp_key, d->key_bytes);
					memcpy(tmp_value, DenseArray_value(d, count), d->value_bytes);
					memcpy(DenseArray_value(d, count), DenseArray_value(d, i), d->value_bytes);
					memcpy(DenseArray_value(d, i), tmp_value, d->value_bytes);
				}
			}
			count++;
		}
	}
	{ // Unsafe block
		_v_free(tmp_value);
		_v_free(tmp_key);
		d->deletes = 0U;
		_v_free(d->all_deleted);
	}
	d->len = count;
	int old_cap = d->cap;
	d->cap = (count < 8 ? (8) : (count));
	{ // Unsafe block
		d->values = realloc_data(d->values, d->value_bytes * old_cap, d->value_bytes * d->cap);
		d->keys = realloc_data(d->keys, d->key_bytes * old_cap, d->key_bytes * d->cap);
	}
}

// Attr: [inline]
inline DenseArray new_dense_array(int key_bytes, int value_bytes) {
	int cap = 8;
	return ((DenseArray){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.cap = cap,
		.len = 0,
		.deletes = 0U,
		.all_deleted = 0,
		.values = _v_malloc(cap * value_bytes),
		.keys = _v_malloc(cap * key_bytes),
	});
}

// Attr: [inline]
inline voidptr DenseArray_key(DenseArray* d, int i) {
	return ((voidptr)(d->keys + i * d->key_bytes));
}

// Attr: [inline]
inline voidptr DenseArray_value(DenseArray* d, int i) {
	return ((voidptr)(d->values + i * d->value_bytes));
}

// Attr: [inline]
inline bool DenseArray_has_index(DenseArray* d, int i) {
	return d->deletes == 0U || d->all_deleted[i] == 0;
}

// Attr: [inline]
inline int DenseArray_expand(DenseArray* d) {
	int old_cap = d->cap;
	int old_value_size = d->value_bytes * old_cap;
	int old_key_size = d->key_bytes * old_cap;
	if (d->cap == d->len) {
		d->cap += d->cap >> 3;
		{ // Unsafe block
			d->keys = realloc_data(d->keys, old_key_size, d->key_bytes * d->cap);
			d->values = realloc_data(d->values, old_value_size, d->value_bytes * d->cap);
			if (d->deletes != 0U) {
				d->all_deleted = realloc_data(d->all_deleted, old_cap, d->cap);
				vmemset(((voidptr)(d->all_deleted + d->len)), 0, d->cap - d->len);
			}
		}
	}
	int push_index = d->len;
	{ // Unsafe block
		if (d->deletes != 0U) {
			d->all_deleted[push_index] = 0;
		}
	}
	d->len++;
	return push_index;
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
bool map_eq_string(voidptr a, voidptr b) {
	return fast_string_eq(*((string*)(a)), *((string*)(b)));
}

bool map_eq_int_1(voidptr a, voidptr b) {
	return *((u8*)(a)) == *((u8*)(b));
}

bool map_eq_int_2(voidptr a, voidptr b) {
	return *((u16*)(a)) == *((u16*)(b));
}

bool map_eq_int_4(voidptr a, voidptr b) {
	return *((u32*)(a)) == *((u32*)(b));
}

bool map_eq_int_8(voidptr a, voidptr b) {
	return *((u64*)(a)) == *((u64*)(b));
}

void map_clone_string(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		string s = *((string*)(pkey));
		(*((string*)(dest))) = string_clone(s);
	}
}

void map_clone_int_1(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u8*)(dest)) = *((u8*)(pkey));
	}
}

void map_clone_int_2(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u16*)(dest)) = *((u16*)(pkey));
	}
}

void map_clone_int_4(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u32*)(dest)) = *((u32*)(pkey));
	}
}

void map_clone_int_8(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u64*)(dest)) = *((u64*)(pkey));
	}
}

void map_free_string(voidptr pkey) {
	string_free(ADDR(string, (*((string*)(pkey)))));
}

void map_free_nop(voidptr _d1) {
}

map new_map(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr )) {
	int metasize = ((int)(sizeof(u32) * (_const_init_capicity + _const_extra_metas_inc)));
	bool has_string_keys = _us32_lt(sizeof(voidptr),key_bytes);
	return ((map){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.even_index = _const_init_even_index,
		.cached_hashbits = _const_max_cached_hashbits,
		.shift = _const_init_log_capicity,
		.key_values = new_dense_array(key_bytes, value_bytes),
		.metas = ((u32*)(vcalloc_noscan(metasize))),
		.extra_metas = _const_extra_metas_inc,
		.has_string_keys = has_string_keys,
		.hash_fn = (voidptr)hash_fn,
		.key_eq_fn = (voidptr)key_eq_fn,
		.clone_fn = (voidptr)clone_fn,
		.free_fn = (voidptr)free_fn,
		.len = 0,
	});
}

map new_map_init(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values) {
	map out = new_map(key_bytes, value_bytes, (voidptr)hash_fn, (voidptr)key_eq_fn, (voidptr)clone_fn, (voidptr)free_fn);
	u8* pkey = ((u8*)(keys));
	u8* pval = ((u8*)(values));
	for (int _t1 = 0; _t1 < n; ++_t1) {
		{ // Unsafe block
			map_set(&out, pkey, pval);
			pkey = pkey + key_bytes;
			pval = pval + value_bytes;
		}
	}
	return out;
}

map map_move(map* m) {
	map r = *m;
	vmemset(m, 0, ((int)(sizeof(map))));
	return r;
}

// Attr: [inline]
inline multi_return_u32_u32 map_key_to_index(map* m, voidptr pkey) {
	u64 hash = m->hash_fn(pkey);
	u64 index = (hash & m->even_index);
	u64 meta = ((((hash >> m->shift) & _const_hash_mask)) | _const_probe_inc);
	return (multi_return_u32_u32){.arg0=((u32)(index)), .arg1=((u32)(meta))};
}

// Attr: [inline]
inline multi_return_u32_u32 map_meta_less(map* m, u32 _index, u32 _metas) {
	u32 index = _index;
	u32 meta = _metas;
	for (;;) {
		if (!(meta < m->metas[index])) break;
		index += 2U;
		meta += _const_probe_inc;
	}
	return (multi_return_u32_u32){.arg0=index, .arg1=meta};
}

// Attr: [inline]
inline void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi) {
	u32 meta = _metas;
	u32 index = _index;
	u32 kv_index = kvi;
	for (;;) {
		if (!(m->metas[index] != 0U)) break;
		if (meta > m->metas[index]) {
			{ // Unsafe block
				u32 tmp_meta = m->metas[index];
				m->metas[index] = meta;
				meta = tmp_meta;
				u32 tmp_index = m->metas[index + 1U];
				m->metas[index + 1U] = kv_index;
				kv_index = tmp_index;
			}
		}
		index += 2U;
		meta += _const_probe_inc;
	}
	{ // Unsafe block
		m->metas[index] = meta;
		m->metas[index + 1U] = kv_index;
	}
	u32 probe_count = (meta >> _const_hashbits) - 1U;
	map_ensure_extra_metas(m, probe_count);
}

// Attr: [inline]
inline void map_ensure_extra_metas(map* m, u32 probe_count) {
	if ((probe_count << 1U) == m->extra_metas) {
		u32 size_of_u32 = sizeof(u32);
		u32 old_mem_size = (m->even_index + 2U + m->extra_metas);
		m->extra_metas += _const_extra_metas_inc;
		u32 mem_size = (m->even_index + 2U + m->extra_metas);
		{ // Unsafe block
			u8* x = realloc_data(((u8*)(m->metas)), ((int)(size_of_u32 * old_mem_size)), ((int)(size_of_u32 * mem_size)));
			m->metas = ((u32*)(x));
			vmemset(m->metas + mem_size - _const_extra_metas_inc, 0, ((int)(sizeof(u32) * _const_extra_metas_inc)));
		}
		if (probe_count == 252U) {
			panic_debug(357, tos3("/Users/rcqls/vlang/v/vlib/builtin/map.v"), tos3("builtin"), tos3("ensure_extra_metas"),  _SLIT("Probe overflow"));
			VUNREACHABLE();
		}
	}
}

void map_set(map* m, voidptr key, voidptr value) {
	f32 load_factor = ((f32)(((u32)(m->len)) << 1U)) / ((f32)(m->even_index));
	if (load_factor > _const_max_load_factor) {
		map_expand(m);
	}
	multi_return_u32_u32 mr_10845 = map_key_to_index(m, key);
	u32 index = mr_10845.arg0;
	u32 meta = mr_10845.arg1;
	multi_return_u32_u32 mr_10881 = map_meta_less(m, index, meta);
	index = mr_10881.arg0;
	meta = mr_10881.arg1;
	for (;;) {
		if (!(meta == m->metas[index])) break;
		int kv_index = ((int)(m->metas[index + 1U]));
		voidptr pkey = DenseArray_key(&m->key_values, kv_index);
		if (m->key_eq_fn(key, pkey)) {
			{ // Unsafe block
				voidptr pval = DenseArray_value(&m->key_values, kv_index);
				vmemcpy(pval, value, m->value_bytes);
			}
			return;
		}
		index += 2U;
		meta += _const_probe_inc;
	}
	int kv_index = DenseArray_expand(&m->key_values);
	{ // Unsafe block
		voidptr pkey = DenseArray_key(&m->key_values, kv_index);
		voidptr pvalue = DenseArray_value(&m->key_values, kv_index);
		m->clone_fn(pkey, key);
		vmemcpy(((u8*)(pvalue)), value, m->value_bytes);
	}
	map_meta_greater(m, index, meta, ((u32)(kv_index)));
	m->len++;
}

void map_expand(map* m) {
	u32 old_cap = m->even_index;
	m->even_index = ((m->even_index + 2U) << 1U) - 2U;
	if (m->cached_hashbits == 0) {
		m->shift += _const_max_cached_hashbits;
		m->cached_hashbits = _const_max_cached_hashbits;
		map_rehash(m);
	} else {
		map_cached_rehash(m, old_cap);
		m->cached_hashbits--;
	}
}

void map_rehash(map* m) {
	u32 meta_bytes = sizeof(u32) * (m->even_index + 2U + m->extra_metas);
	{ // Unsafe block
		u8* x = v_realloc(((u8*)(m->metas)), ((int)(meta_bytes)));
		m->metas = ((u32*)(x));
		vmemset(m->metas, 0, ((int)(meta_bytes)));
	}
	for (int i = 0; i < m->key_values.len; i++) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		voidptr pkey = DenseArray_key(&m->key_values, i);
		multi_return_u32_u32 mr_12544 = map_key_to_index(m, pkey);
		u32 index = mr_12544.arg0;
		u32 meta = mr_12544.arg1;
		multi_return_u32_u32 mr_12582 = map_meta_less(m, index, meta);
		index = mr_12582.arg0;
		meta = mr_12582.arg1;
		map_meta_greater(m, index, meta, ((u32)(i)));
	}
}

void map_cached_rehash(map* m, u32 old_cap) {
	u32* old_metas = m->metas;
	int metasize = ((int)(sizeof(u32) * (m->even_index + 2U + m->extra_metas)));
	m->metas = ((u32*)(vcalloc(metasize)));
	u32 old_extra_metas = m->extra_metas;
	for (u32 i = ((u32)(0U)); i <= old_cap + old_extra_metas; i += 2U) {
		if (old_metas[i] == 0U) {
			continue;
		}
		u32 old_meta = old_metas[i];
		u32 old_probe_count = ((old_meta >> _const_hashbits) - 1U) << 1U;
		u32 old_index = ((i - old_probe_count) & (m->even_index >> 1U));
		u32 index = (((old_index | (old_meta << m->shift))) & m->even_index);
		u32 meta = (((old_meta & _const_hash_mask)) | _const_probe_inc);
		multi_return_u32_u32 mr_13381 = map_meta_less(m, index, meta);
		index = mr_13381.arg0;
		meta = mr_13381.arg1;
		u32 kv_index = old_metas[i + 1U];
		map_meta_greater(m, index, meta, kv_index);
	}
	_v_free(old_metas);
}

voidptr map_get_and_set(map* m, voidptr key, voidptr zero) {
	for (;;) {
		multi_return_u32_u32 mr_13829 = map_key_to_index(m, key);
		u32 index = mr_13829.arg0;
		u32 meta = mr_13829.arg1;
		for (;;) {
			if (meta == m->metas[index]) {
				int kv_index = ((int)(m->metas[index + 1U]));
				voidptr pkey = DenseArray_key(&m->key_values, kv_index);
				if (m->key_eq_fn(key, pkey)) {
					voidptr pval = DenseArray_value(&m->key_values, kv_index);
					return ((u8*)(pval));
				}
			}
			index += 2U;
			meta += _const_probe_inc;
			if (meta > m->metas[index]) {
				break;
			}
		}
		map_set(m, key, zero);
	}
	return ((voidptr)(0));
}

voidptr map_get(map* m, voidptr key, voidptr zero) {
	multi_return_u32_u32 mr_14552 = map_key_to_index(m, key);
	u32 index = mr_14552.arg0;
	u32 meta = mr_14552.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[index + 1U]));
			voidptr pkey = DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				voidptr pval = DenseArray_value(&m->key_values, kv_index);
				return ((u8*)(pval));
			}
		}
		index += 2U;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return zero;
}

voidptr map_get_check(map* m, voidptr key) {
	multi_return_u32_u32 mr_15217 = map_key_to_index(m, key);
	u32 index = mr_15217.arg0;
	u32 meta = mr_15217.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[index + 1U]));
			voidptr pkey = DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				voidptr pval = DenseArray_value(&m->key_values, kv_index);
				return ((u8*)(pval));
			}
		}
		index += 2U;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return 0;
}

bool map_exists(map* m, voidptr key) {
	multi_return_u32_u32 mr_15727 = map_key_to_index(m, key);
	u32 index = mr_15727.arg0;
	u32 meta = mr_15727.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[index + 1U]));
			voidptr pkey = DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				return true;
			}
		}
		index += 2U;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return false;
}

// Attr: [inline]
inline void DenseArray_delete(DenseArray* d, int i) {
	if (d->deletes == 0U) {
		d->all_deleted = vcalloc(d->cap);
	}
	d->deletes++;
	{ // Unsafe block
		d->all_deleted[i] = 1;
	}
}

// Attr: [unsafe]
void map_delete(map* m, voidptr key) {
	multi_return_u32_u32 mr_16356 = map_key_to_index(m, key);
	u32 index = mr_16356.arg0;
	u32 meta = mr_16356.arg1;
	multi_return_u32_u32 mr_16392 = map_meta_less(m, index, meta);
	index = mr_16392.arg0;
	meta = mr_16392.arg1;
	for (;;) {
		if (!(meta == m->metas[index])) break;
		int kv_index = ((int)(m->metas[index + 1U]));
		voidptr pkey = DenseArray_key(&m->key_values, kv_index);
		if (m->key_eq_fn(key, pkey)) {
			for (;;) {
				if (!((m->metas[index + 2U] >> _const_hashbits) > 1U)) break;
				{ // Unsafe block
					m->metas[index] = m->metas[index + 2U] - _const_probe_inc;
					m->metas[index + 1U] = m->metas[index + 3U];
				}
				index += 2U;
			}
			m->len--;
			DenseArray_delete(&m->key_values, kv_index);
			{ // Unsafe block
				m->metas[index] = 0U;
				m->free_fn(pkey);
				vmemset(pkey, 0, m->key_bytes);
			}
			if (m->key_values.len <= 32) {
				return;
			}
			if (_us32_ge(m->key_values.deletes,(m->key_values.len >> 1))) {
				DenseArray_zeros_to_end(&m->key_values);
				map_rehash(m);
			}
			return;
		}
		index += 2U;
		meta += _const_probe_inc;
	}
}

array map_keys(map* m) {
	array keys = __new_array(m->len, 0, m->key_bytes);
	u8* item = ((u8*)(keys.data));
	if (m->key_values.deletes == 0U) {
		for (int i = 0; i < m->key_values.len; i++) {
			{ // Unsafe block
				voidptr pkey = DenseArray_key(&m->key_values, i);
				m->clone_fn(item, pkey);
				item = item + m->key_bytes;
			}
		}
		return keys;
	}
	for (int i = 0; i < m->key_values.len; i++) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		{ // Unsafe block
			voidptr pkey = DenseArray_key(&m->key_values, i);
			m->clone_fn(item, pkey);
			item = item + m->key_bytes;
		}
	}
	return keys;
}

// Attr: [unsafe]
DenseArray DenseArray_clone(DenseArray* d) {
	DenseArray res = ((DenseArray){
		.key_bytes = d->key_bytes,
		.value_bytes = d->value_bytes,
		.cap = d->cap,
		.len = d->len,
		.deletes = d->deletes,
		.all_deleted = 0,
		.values = 0,
		.keys = 0,
	});
	{ // Unsafe block
		if (d->deletes != 0U) {
			res.all_deleted = memdup(d->all_deleted, d->cap);
		}
		res.keys = memdup(d->keys, d->cap * d->key_bytes);
		res.values = memdup(d->values, d->cap * d->value_bytes);
	}
	return res;
}

// Attr: [unsafe]
map map_clone(map* m) {
	int metasize = ((int)(sizeof(u32) * (m->even_index + 2U + m->extra_metas)));
	map res = ((map){
		.key_bytes = m->key_bytes,
		.value_bytes = m->value_bytes,
		.even_index = m->even_index,
		.cached_hashbits = m->cached_hashbits,
		.shift = m->shift,
		.key_values = DenseArray_clone(&m->key_values),
		.metas = ((u32*)(malloc_noscan(metasize))),
		.extra_metas = m->extra_metas,
		.has_string_keys = m->has_string_keys,
		.hash_fn = (voidptr)m->hash_fn,
		.key_eq_fn = (voidptr)m->key_eq_fn,
		.clone_fn = (voidptr)m->clone_fn,
		.free_fn = (voidptr)m->free_fn,
		.len = m->len,
	});
	vmemcpy(res.metas, m->metas, metasize);
	if (!m->has_string_keys) {
		return res;
	}
	for (int i = 0; i < m->key_values.len; ++i) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		m->clone_fn(DenseArray_key(&res.key_values, i), DenseArray_key(&m->key_values, i));
	}
	return res;
}

// Attr: [unsafe]
void map_free(map* m) {
	_v_free(m->metas);
	if (m->key_values.deletes == 0U) {
		for (int i = 0; i < m->key_values.len; i++) {
			{ // Unsafe block
				voidptr pkey = DenseArray_key(&m->key_values, i);
				m->free_fn(pkey);
			}
		}
	} else {
		for (int i = 0; i < m->key_values.len; i++) {
			if (!DenseArray_has_index(&m->key_values, i)) {
				continue;
			}
			{ // Unsafe block
				voidptr pkey = DenseArray_key(&m->key_values, i);
				m->free_fn(pkey);
			}
		}
		_v_free(m->key_values.all_deleted);
	}
	{ // Unsafe block
		_v_free(m->key_values.keys);
		_v_free(m->key_values.values);
	}
}

// Attr: [unsafe]
void IError_free(IError* ie) {
	{ // Unsafe block
		IError* cie = ((IError*)(ie));
		_v_free(cie->_object);
	}
}

string IError_str(IError err) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	if (err._typ == _IError_None___index) {
		_t2 = _SLIT("none");
	}
	else if (err._typ == _IError_Error_index) {
		_t2 = Error_msg(/*rec*/*(err._Error));
	}
	else if (err._typ == _IError_MessageError_index) {
		_t2 = MessageError_msg(/*rec*/*(err._MessageError));
	}
	
	else {
		_t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = charptr_vstring_literal( /* IError */ v_typeof_interface_IError( (err)._typ ))}}, {_SLIT(": "), 0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return _t2;
}

string Error_msg(Error err) {
	return _SLIT("");
}

int Error_code(Error err) {
	return 0;
}

string MessageError_msg(MessageError err) {
	return err.msg;
}

int MessageError_code(MessageError err) {
	return err.code;
}

// Attr: [unsafe]
void MessageError_free(MessageError* err) {
	string_free(&err->msg);
}

string None___str(None__ _d1) {
	return _SLIT("none");
}

// Attr: [inline]
inline IError _v_error(string message) {
	;
	return /*&IError*/I_MessageError_to_Interface_IError(((MessageError*)memdup(&(MessageError){.msg = message,.code = 0,}, sizeof(MessageError))));
}

// Attr: [inline]
inline IError error_with_code(string message, int code) {
	;
	return /*&IError*/I_MessageError_to_Interface_IError(((MessageError*)memdup(&(MessageError){.msg = message,.code = code,}, sizeof(MessageError))));
}

void opt_ok(voidptr data, Option* option, int size) {
	{ // Unsafe block
		*option = ((Option){.state = 0,.err = _const_none__,});
		vmemcpy(((u8*)(&option->err)) + sizeof(IError), data, size);
	}
}

string none_str(none _d2) {
	return _SLIT("none");
}

// Attr: [unsafe]
VMemoryBlock* vmemory_block_new(VMemoryBlock* prev, int at_least) {
	VMemoryBlock* v = ((VMemoryBlock*)(calloc(1, sizeof(VMemoryBlock))));
	if (prev != 0) {
		v->id = prev->id + 1;
	}
	v->previous = prev;
	int block_size = (at_least < _const_prealloc_block_size ? (_const_prealloc_block_size) : (at_least));
	v->start = malloc(block_size);
	v->cap = block_size;
	v->remaining = block_size;
	v->current = v->start;
	return v;
}

// Attr: [unsafe]
byte* vmemory_block_malloc(int n) {
	{ // Unsafe block
		if (g_memory_block->remaining < n) {
			g_memory_block = vmemory_block_new(g_memory_block, n);
		}
		u8* res = ((u8*)(0));
		res = g_memory_block->current;
		g_memory_block->remaining -= n;
		g_memory_block->mallocs++;
		g_memory_block->current += n;
		return res;
	}
	return 0;
}

// Attr: [unsafe]
void prealloc_vinit(void) {
	{ // Unsafe block
		g_memory_block = vmemory_block_new(((voidptr)(0)), _const_prealloc_block_size);
		#if !defined(_VFREESTANDING)
		{
			atexit((voidptr)prealloc_vcleanup);
		}
		#endif
	}
}

// Attr: [unsafe]
void prealloc_vcleanup(void) {
	{ // Unsafe block
		for (;;) {
			if (!(g_memory_block != 0)) break;
			free(g_memory_block->start);
			g_memory_block = g_memory_block->previous;
		}
	}
}

// Attr: [unsafe]
byte* prealloc_malloc(int n) {
	return vmemory_block_malloc(n);
}

// Attr: [unsafe]
byte* prealloc_realloc(byte* old_data, int old_size, int new_size) {
	byte* new_ptr = vmemory_block_malloc(new_size);
	int min_size = (old_size < new_size ? (old_size) : (new_size));
	memcpy(new_ptr, old_data, min_size);
	return new_ptr;
}

// Attr: [unsafe]
byte* prealloc_calloc(int n) {
	byte* new_ptr = vmemory_block_malloc(n);
	memset(new_ptr, 0, n);
	return new_ptr;
}

string rune_str(rune c) {
	return utf32_to_str(((u32)(c)));
}

// Attr: [manualfree]
string Array_rune_string(Array_rune ra) {
	strings__Builder sb = strings__new_builder(ra.len);
	strings__Builder_write_runes(&sb, ra);
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}

string rune_repeat(rune c, int count) {
	if (count < 0) {
		panic_debug(46, tos3("/Users/rcqls/vlang/v/vlib/builtin/rune.v"), tos3("builtin"), tos3("repeat"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("rune.repeat: count is negative: "), 0xfe07, {.d_i32 = count}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	} else if (count == 0) {
		return _SLIT("");
	} else if (count == 1) {
		return rune_str(c);
	}
	Array_fixed_u8_5 buffer = {0};
	string res = utf32_to_str_no_malloc(((u32)(c)), &buffer[0]);
	return string_repeat(res, count);
}

// Attr: [manualfree]
Array_u8 rune_bytes(rune c) {
	Array_u8 res = __new_array_with_default(0, 5, sizeof(u8), 0);
	res.len = utf32_decode_to_buffer(((u32)(c)), ((u8*)(res.data)));
	return res;
}

int rune_length_in_bytes(rune c) {
	u32 code = ((u32)(c));
	if (code <= 0x7FU) {
		return 1;
	} else if (code <= 0x7FFU) {
		return 2;
	} else if (0xD800 <= code && code <= 0xDFFFU) {
		return -1;
	} else if (code <= 0xFFFFU) {
		return 3;
	} else if (code <= 0x10FFFFU) {
		return 4;
	}
	return -1;
}

SortedMap new_sorted_map(int n, int value_bytes) {
	return ((SortedMap){.value_bytes = value_bytes,.root = new_node(),.len = 0,});
}

SortedMap new_sorted_map_init(int n, int value_bytes, string* keys, voidptr values) {
	SortedMap out = new_sorted_map(n, value_bytes);
	for (int i = 0; i < n; ++i) {
		SortedMap_set(&out, keys[i], ((u8*)(values)) + i * value_bytes);
	}
	return out;
}

mapnode* new_node(void) {
	return ((mapnode*)memdup(&(mapnode){.children = 0,.len = 0,.keys = {0},.values = {0},}, sizeof(mapnode)));
}

void SortedMap_set(SortedMap* m, string key, voidptr value) {
	mapnode* node = m->root;
	int child_index = 0;
	mapnode* parent = ((mapnode*)(0));
	for (;;) {
		if (node->len == _const_max_len) {
			if (isnil(parent)) {
				parent = new_node();
				m->root = parent;
			}
			mapnode_split_child(parent, child_index, node);
			if (string__eq(key, parent->keys[v_fixed_index(child_index, 11)])) {
				vmemcpy(parent->values[v_fixed_index(child_index, 11)], value, m->value_bytes);
				return;
			}
			if (string__lt(key, parent->keys[v_fixed_index(child_index, 11)])) {
				node = ((mapnode*)(parent->children[child_index]));
			} else {
				node = ((mapnode*)(parent->children[child_index + 1]));
			}
		}
		int i = 0;
		for (;;) {
			if (!(i < node->len && string__lt(node->keys[v_fixed_index(i, 11)], key))) break;
			i++;
		}
		if (i != node->len && string__eq(key, node->keys[v_fixed_index(i, 11)])) {
			vmemcpy(node->values[v_fixed_index(i, 11)], value, m->value_bytes);
			return;
		}
		if (isnil(node->children)) {
			int j = node->len - 1;
			for (;;) {
				if (!(j >= 0 && string__lt(key, node->keys[v_fixed_index(j, 11)]))) break;
				node->keys[v_fixed_index(j + 1, 11)] = node->keys[v_fixed_index(j, 11)];
				node->values[v_fixed_index(j + 1, 11)] = node->values[v_fixed_index(j, 11)];
				j--;
			}
			node->keys[v_fixed_index(j + 1, 11)] = key;
			{ // Unsafe block
				node->values[v_fixed_index(j + 1, 11)] = _v_malloc(m->value_bytes);
				vmemcpy(node->values[v_fixed_index(j + 1, 11)], value, m->value_bytes);
			}
			node->len++;
			m->len++;
			return;
		}
		parent = node;
		child_index = i;
		node = ((mapnode*)(node->children[child_index]));
	}
}

void mapnode_split_child(mapnode* n, int child_index, mapnode* y) {
	mapnode* z = new_node();
	z->len = _const_mid_index;
	y->len = _const_mid_index;
	for (int j = _const_mid_index - 1; j >= 0; j--) {
		z->keys[v_fixed_index(j, 11)] = y->keys[v_fixed_index(j + _const_degree, 11)];
		z->values[v_fixed_index(j, 11)] = y->values[v_fixed_index(j + _const_degree, 11)];
	}
	if (!isnil(y->children)) {
		z->children = ((voidptr*)(_v_malloc(((int)(_const_children_bytes)))));
		for (int jj = _const_degree - 1; jj >= 0; jj--) {
			{ // Unsafe block
				z->children[jj] = y->children[jj + _const_degree];
			}
		}
	}
	{ // Unsafe block
		if (isnil(n->children)) {
			n->children = ((voidptr*)(_v_malloc(((int)(_const_children_bytes)))));
		}
		n->children[n->len + 1] = n->children[n->len];
	}
	for (int j = n->len; j > child_index; j--) {
		n->keys[v_fixed_index(j, 11)] = n->keys[v_fixed_index(j - 1, 11)];
		n->values[v_fixed_index(j, 11)] = n->values[v_fixed_index(j - 1, 11)];
		{ // Unsafe block
			n->children[j] = n->children[j - 1];
		}
	}
	n->keys[v_fixed_index(child_index, 11)] = y->keys[v_fixed_index(_const_mid_index, 11)];
	n->values[v_fixed_index(child_index, 11)] = y->values[v_fixed_index(_const_mid_index, 11)];
	{ // Unsafe block
		n->children[child_index] = ((voidptr)(y));
		n->children[child_index + 1] = ((voidptr)(z));
	}
	n->len++;
}

bool SortedMap_get(SortedMap m, string key, voidptr out) {
	mapnode* node = m.root;
	for (;;) {
		int i = node->len - 1;
		for (;;) {
			if (!(i >= 0 && string__lt(key, node->keys[v_fixed_index(i, 11)]))) break;
			i--;
		}
		if (i != -1 && string__eq(key, node->keys[v_fixed_index(i, 11)])) {
			vmemcpy(out, node->values[v_fixed_index(i, 11)], m.value_bytes);
			return true;
		}
		if (isnil(node->children)) {
			break;
		}
		node = ((mapnode*)(node->children[i + 1]));
	}
	return false;
}

bool SortedMap_exists(SortedMap m, string key) {
	if (isnil(m.root)) {
		return false;
	}
	mapnode* node = m.root;
	for (;;) {
		int i = node->len - 1;
		for (;;) {
			if (!(i >= 0 && string__lt(key, node->keys[v_fixed_index(i, 11)]))) break;
			i--;
		}
		if (i != -1 && string__eq(key, node->keys[v_fixed_index(i, 11)])) {
			return true;
		}
		if (isnil(node->children)) {
			break;
		}
		node = ((mapnode*)(node->children[i + 1]));
	}
	return false;
}

int mapnode_find_key(mapnode* n, string k) {
	int idx = 0;
	for (;;) {
		if (!(idx < n->len && string__lt(n->keys[v_fixed_index(idx, 11)], k))) break;
		idx++;
	}
	return idx;
}

bool mapnode_remove_key(mapnode* n, string k) {
	int idx = mapnode_find_key(n, k);
	if (idx < n->len && string__eq(n->keys[v_fixed_index(idx, 11)], k)) {
		if (isnil(n->children)) {
			mapnode_remove_from_leaf(n, idx);
		} else {
			mapnode_remove_from_non_leaf(n, idx);
		}
		return true;
	} else {
		if (isnil(n->children)) {
			return false;
		}
		bool flag = (idx == n->len ? (true) : (false));
		if (((mapnode*)(n->children[idx]))->len < _const_degree) {
			mapnode_fill(n, idx);
		}
		mapnode* node = ((mapnode*)(0));
		if (flag && idx > n->len) {
			node = ((mapnode*)(n->children[idx - 1]));
		} else {
			node = ((mapnode*)(n->children[idx]));
		}
		return mapnode_remove_key(node, k);
	}
	return 0;
}

void mapnode_remove_from_leaf(mapnode* n, int idx) {
	for (int i = idx + 1; i < n->len; i++) {
		n->keys[v_fixed_index(i - 1, 11)] = n->keys[v_fixed_index(i, 11)];
		n->values[v_fixed_index(i - 1, 11)] = n->values[v_fixed_index(i, 11)];
	}
	n->len--;
}

void mapnode_remove_from_non_leaf(mapnode* n, int idx) {
	string k = n->keys[v_fixed_index(idx, 11)];
	if (((mapnode*)(n->children[idx]))->len >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[idx]));
		for (;;) {
			if (!(!isnil(current->children))) break;
			current = ((mapnode*)(current->children[current->len]));
		}
		string predecessor = current->keys[v_fixed_index(current->len - 1, 11)];
		n->keys[v_fixed_index(idx, 11)] = predecessor;
		n->values[v_fixed_index(idx, 11)] = current->values[v_fixed_index(current->len - 1, 11)];
		mapnode* node = ((mapnode*)(n->children[idx]));
		mapnode_remove_key(node, predecessor);
	} else if (((mapnode*)(n->children[idx + 1]))->len >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[idx + 1]));
		for (;;) {
			if (!(!isnil(current->children))) break;
			current = ((mapnode*)(current->children[0]));
		}
		string successor = current->keys[0];
		n->keys[v_fixed_index(idx, 11)] = successor;
		n->values[v_fixed_index(idx, 11)] = current->values[0];
		mapnode* node = ((mapnode*)(n->children[idx + 1]));
		mapnode_remove_key(node, successor);
	} else {
		mapnode_merge(n, idx);
		mapnode* node = ((mapnode*)(n->children[idx]));
		mapnode_remove_key(node, k);
	}
}

void mapnode_fill(mapnode* n, int idx) {
	if (idx != 0 && ((mapnode*)(n->children[idx - 1]))->len >= _const_degree) {
		mapnode_borrow_from_prev(n, idx);
	} else if (idx != n->len && ((mapnode*)(n->children[idx + 1]))->len >= _const_degree) {
		mapnode_borrow_from_next(n, idx);
	} else if (idx != n->len) {
		mapnode_merge(n, idx);
	} else {
		mapnode_merge(n, idx - 1);
	}
}

void mapnode_borrow_from_prev(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx - 1]));
	for (int i = child->len - 1; i >= 0; i--) {
		child->keys[v_fixed_index(i + 1, 11)] = child->keys[v_fixed_index(i, 11)];
		child->values[v_fixed_index(i + 1, 11)] = child->values[v_fixed_index(i, 11)];
	}
	if (!isnil(child->children)) {
		for (int i = child->len; i >= 0; i--) {
			{ // Unsafe block
				child->children[i + 1] = child->children[i];
			}
		}
	}
	child->keys[0] = n->keys[v_fixed_index(idx - 1, 11)];
	child->values[0] = n->values[v_fixed_index(idx - 1, 11)];
	if (!isnil(child->children)) {
		{ // Unsafe block
			child->children[0] = sibling->children[sibling->len];
		}
	}
	n->keys[v_fixed_index(idx - 1, 11)] = sibling->keys[v_fixed_index(sibling->len - 1, 11)];
	n->values[v_fixed_index(idx - 1, 11)] = sibling->values[v_fixed_index(sibling->len - 1, 11)];
	child->len++;
	sibling->len--;
}

void mapnode_borrow_from_next(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx + 1]));
	child->keys[v_fixed_index(child->len, 11)] = n->keys[v_fixed_index(idx, 11)];
	child->values[v_fixed_index(child->len, 11)] = n->values[v_fixed_index(idx, 11)];
	if (!isnil(child->children)) {
		{ // Unsafe block
			child->children[child->len + 1] = sibling->children[0];
		}
	}
	n->keys[v_fixed_index(idx, 11)] = sibling->keys[0];
	n->values[v_fixed_index(idx, 11)] = sibling->values[0];
	for (int i = 1; i < sibling->len; i++) {
		sibling->keys[v_fixed_index(i - 1, 11)] = sibling->keys[v_fixed_index(i, 11)];
		sibling->values[v_fixed_index(i - 1, 11)] = sibling->values[v_fixed_index(i, 11)];
	}
	if (!isnil(sibling->children)) {
		for (int i = 1; i <= sibling->len; i++) {
			{ // Unsafe block
				sibling->children[i - 1] = sibling->children[i];
			}
		}
	}
	child->len++;
	sibling->len--;
}

void mapnode_merge(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[idx + 1]));
	child->keys[v_fixed_index(_const_mid_index, 11)] = n->keys[v_fixed_index(idx, 11)];
	child->values[v_fixed_index(_const_mid_index, 11)] = n->values[v_fixed_index(idx, 11)];
	for (int i = 0; i < sibling->len; ++i) {
		child->keys[v_fixed_index(i + _const_degree, 11)] = sibling->keys[v_fixed_index(i, 11)];
		child->values[v_fixed_index(i + _const_degree, 11)] = sibling->values[v_fixed_index(i, 11)];
	}
	if (!isnil(child->children)) {
		for (int i = 0; i <= sibling->len; i++) {
			{ // Unsafe block
				child->children[i + _const_degree] = sibling->children[i];
			}
		}
	}
	for (int i = idx + 1; i < n->len; i++) {
		n->keys[v_fixed_index(i - 1, 11)] = n->keys[v_fixed_index(i, 11)];
		n->values[v_fixed_index(i - 1, 11)] = n->values[v_fixed_index(i, 11)];
	}
	for (int i = idx + 2; i <= n->len; i++) {
		{ // Unsafe block
			n->children[i - 1] = n->children[i];
		}
	}
	child->len += sibling->len + 1;
	n->len--;
}

void SortedMap_delete(SortedMap* m, string key) {
	if (m->root->len == 0) {
		return;
	}
	bool removed = mapnode_remove_key(m->root, key);
	if (removed) {
		m->len--;
	}
	if (m->root->len == 0) {
		if (isnil(m->root->children)) {
			return;
		} else {
			m->root = ((mapnode*)(m->root->children[0]));
		}
	}
}

int mapnode_subkeys(mapnode* n, Array_string* keys, int at) {
	int position = at;
	if (!isnil(n->children)) {
		for (int i = 0; i < n->len; ++i) {
			mapnode* child = ((mapnode*)(n->children[i]));
			position += mapnode_subkeys(child, keys, position);
			array_set(keys, position, &(string[]) { n->keys[v_fixed_index(i, 11)] });
			position++;
		}
		mapnode* child = ((mapnode*)(n->children[n->len]));
		position += mapnode_subkeys(child, keys, position);
	} else {
		for (int i = 0; i < n->len; ++i) {
			array_set(keys, position + i, &(string[]) { n->keys[v_fixed_index(i, 11)] });
		}
		position += n->len;
	}
	return position - at;
}

Array_string SortedMap_keys(SortedMap* m) {
	Array_string keys = __new_array_with_default(m->len, 0, sizeof(string), &(string[]){_SLIT("")});
	if (isnil(m->root) || m->root->len == 0) {
		return keys;
	}
	mapnode_subkeys(m->root, &/*arr*/keys, 0);
	return keys;
}

void mapnode_free(mapnode* n) {
	println(_SLIT("TODO"));
}

void SortedMap_free(SortedMap* m) {
	if (isnil(m->root)) {
		return;
	}
	mapnode_free(m->root);
}

void SortedMap_print(SortedMap m) {
	println(_SLIT("TODO"));
}

// Attr: [direct_array_access]
Array_rune string_runes(string s) {
	Array_rune runes = __new_array_with_default(0, s.len, sizeof(rune), 0);
	for (int i = 0; i < s.len; i++) {
		int char_len = utf8_char_len(s.str[i]);
		if (char_len > 1) {
			int end = (s.len - 1 >= i + char_len ? (i + char_len) : (s.len));
			string r = string_substr(s, i, end);
			array_push((array*)&runes, _MOV((rune[]){ string_utf32_code(r) }));
			i += char_len - 1;
		} else {
			array_push((array*)&runes, _MOV((rune[]){ s.str[i] }));
		}
	}
	return runes;
}

// Attr: [unsafe]
string cstring_to_vstring(char* s) {
	return string_clone(tos2(((u8*)(s))));
}

// Attr: [unsafe]
string tos_clone(u8* s) {
	return string_clone(tos2(s));
}

// Attr: [unsafe]
string tos(u8* s, int len) {
	if (s == 0) {
		panic_debug(105, tos3("/Users/rcqls/vlang/v/vlib/builtin/string.v"), tos3("builtin"), tos3("tos"),  _SLIT("tos(): nil string"));
		VUNREACHABLE();
	}
	return ((string){.str = s, .len = len});
}

// Attr: [unsafe]
string tos2(u8* s) {
	if (s == 0) {
		panic_debug(122, tos3("/Users/rcqls/vlang/v/vlib/builtin/string.v"), tos3("builtin"), tos3("tos2"),  _SLIT("tos2: nil string"));
		VUNREACHABLE();
	}
	return ((string){.str = s, .len = vstrlen(s)});
}

// Attr: [unsafe]
string tos3(char* s) {
	if (s == 0) {
		panic_debug(139, tos3("/Users/rcqls/vlang/v/vlib/builtin/string.v"), tos3("builtin"), tos3("tos3"),  _SLIT("tos3: nil string"));
		VUNREACHABLE();
	}
	return ((string){.str = ((u8*)(s)), .len = vstrlen_char(s)});
}

// Attr: [unsafe]
string tos4(u8* s) {
	if (s == 0) {
		return _SLIT("");
	}
	return ((string){.str = s, .len = vstrlen(s)});
}

// Attr: [unsafe]
string tos5(char* s) {
	if (s == 0) {
		return _SLIT("");
	}
	return ((string){.str = ((u8*)(s)), .len = vstrlen_char(s)});
}

// Attr: [unsafe]
string u8_vstring(u8* bp) {
	return ((string){.str = bp, .len = vstrlen(bp)});
}

// Attr: [unsafe]
string u8_vstring_with_len(u8* bp, int len) {
	return ((string){.str = bp, .len = len, .is_lit = 0});
}

// Attr: [unsafe]
string char_vstring(char* cp) {
	return ((string){.str = ((u8*)(cp)), .len = vstrlen_char(cp), .is_lit = 0});
}

// Attr: [unsafe]
string char_vstring_with_len(char* cp, int len) {
	return ((string){.str = ((u8*)(cp)), .len = len, .is_lit = 0});
}

// Attr: [unsafe]
string u8_vstring_literal(u8* bp) {
	return ((string){.str = bp, .len = vstrlen(bp), .is_lit = 1});
}

// Attr: [unsafe]
string u8_vstring_literal_with_len(u8* bp, int len) {
	return ((string){.str = bp, .len = len, .is_lit = 1});
}

// Attr: [unsafe]
string char_vstring_literal(char* cp) {
	return ((string){.str = ((u8*)(cp)), .len = vstrlen_char(cp), .is_lit = 1});
}

// Attr: [unsafe]
string char_vstring_literal_with_len(char* cp, int len) {
	return ((string){.str = ((u8*)(cp)), .len = len, .is_lit = 1});
}

string string_clone_static(string a) {
	return string_clone(a);
}

string string_clone(string a) {
	if (a.len == 0) {
		return _SLIT("");
	}
	string b = ((string){.str = malloc_noscan(a.len + 1), .len = a.len});
	{ // Unsafe block
		vmemcpy(b.str, a.str, a.len);
		b.str[a.len] = 0;
	}
	return b;
}

string string_replace_once(string s, string rep, string with) {
	int idx = string_index_(s, rep);
	if (idx == -1) {
		return string_clone(s);
	}
	return string__plus(string__plus(string_substr(s, 0, idx), with), string_substr(s, idx + rep.len, s.len));
}

// Attr: [direct_array_access]
string string_replace(string s, string rep, string with) {
bool string_replace_defer_0 = false;
Array_int idxs;
	if (s.len == 0 || rep.len == 0 || rep.len > s.len) {
		return string_clone(s);
	}
	if (!string_contains(s, rep)) {
		return string_clone(s);
	}
	idxs = __new_array_with_default(0, s.len / rep.len, sizeof(int), 0);
	string_replace_defer_0 = true;
	int idx = 0;
	for (;;) {
		idx = string_index_after(s, rep, idx);
		if (idx == -1) {
			break;
		}
		array_push((array*)&idxs, _MOV((int[]){ idx }));
		idx += rep.len;
	}
	if (idxs.len == 0) {
		string _t4 = string_clone(s);
		// Defer begin
		if (string_replace_defer_0) {
			array_free(&idxs);
		}
		// Defer end
		return _t4;
	}
	int new_len = s.len + idxs.len * (with.len - rep.len);
	u8* b = malloc_noscan(new_len + 1);
	int b_i = 0;
	int s_idx = 0;
	for (int _t5 = 0; _t5 < idxs.len; ++_t5) {
		int rep_pos = ((int*)idxs.data)[_t5];
		for (int i = s_idx; i < rep_pos; ++i) {
			{ // Unsafe block
				b[b_i] = s.str[ i];
			}
			b_i++;
		}
		s_idx = rep_pos + rep.len;
		for (int i = 0; i < with.len; ++i) {
			{ // Unsafe block
				b[b_i] = with.str[ i];
			}
			b_i++;
		}
	}
	if (s_idx < s.len) {
		for (int i = s_idx; i < s.len; ++i) {
			{ // Unsafe block
				b[b_i] = s.str[ i];
			}
			b_i++;
		}
	}
	{ // Unsafe block
		b[new_len] = 0;
		string _t6 = tos(b, new_len);
		// Defer begin
		if (string_replace_defer_0) {
			array_free(&idxs);
		}
		// Defer end
		return _t6;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
string string_replace_each(string s, Array_string vals) {
	if (s.len == 0 || vals.len == 0) {
		return string_clone(s);
	}
	if (vals.len % 2 != 0) {
		eprintln(_SLIT("string.replace_each(): odd number of strings"));
		return string_clone(s);
	}
	int new_len = s.len;
	Array_RepIndex idxs = __new_array_with_default(0, 6, sizeof(RepIndex), 0);
	int idx = 0;
	string s_ = string_clone(s);
	for (int rep_i = 0; rep_i < vals.len; rep_i += 2) {
		string rep = ((string*)vals.data)[rep_i];
		string with = ((string*)vals.data)[rep_i + 1];
		for (;;) {
			idx = string_index_after(s_, rep, idx);
			if (idx == -1) {
				break;
			}
			for (int i = 0; i < rep.len; ++i) {
				{ // Unsafe block
					s_.str[idx + i] = 127;
				}
			}
			array_push((array*)&idxs, _MOV((RepIndex[]){ ((RepIndex){.idx = idx,.val_idx = rep_i,}) }));
			idx += rep.len;
			new_len += with.len - rep.len;
		}
	}
	if (idxs.len == 0) {
		return string_clone(s);
	}
	qsort(idxs.data, idxs.len, idxs.element_size, (int (*)(const void *, const void *))&compare_14421781451463525574_RepIndex_by_idx);
	u8* b = malloc_noscan(new_len + 1);
	int idx_pos = 0;
	RepIndex cur_idx = ((RepIndex*)idxs.data)[idx_pos];
	int b_i = 0;
	for (int i = 0; i < s.len; i++) {
		if (i == cur_idx.idx) {
			string rep = ((string*)vals.data)[cur_idx.val_idx];
			string with = ((string*)vals.data)[cur_idx.val_idx + 1];
			for (int j = 0; j < with.len; ++j) {
				{ // Unsafe block
					b[b_i] = with.str[ j];
				}
				b_i++;
			}
			i += rep.len - 1;
			idx_pos++;
			if (idx_pos < idxs.len) {
				cur_idx = ((RepIndex*)idxs.data)[idx_pos];
			}
		} else {
			{ // Unsafe block
				b[b_i] = s.str[i];
			}
			b_i++;
		}
	}
	{ // Unsafe block
		b[new_len] = 0;
		return tos(b, new_len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

bool string_bool(string s) {
	return string__eq(s, _SLIT("true")) || string__eq(s, _SLIT("t"));
}

int string_int(string s) {
	Option_i64 _t2 = strconv__common_parse_int(s, 0, 32, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(i64*) _t2.data = 0;
	}
	
 	return ((int)( (*(i64*)_t2.data)));
}

i64 string_i64(string s) {
	Option_i64 _t2 = strconv__common_parse_int(s, 0, 64, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(i64*) _t2.data = 0;
	}
	
 	return  (*(i64*)_t2.data);
}

i8 string_i8(string s) {
	Option_i64 _t2 = strconv__common_parse_int(s, 0, 8, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(i64*) _t2.data = 0;
	}
	
 	return ((i8)( (*(i64*)_t2.data)));
}

i16 string_i16(string s) {
	Option_i64 _t2 = strconv__common_parse_int(s, 0, 16, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(i64*) _t2.data = 0;
	}
	
 	return ((i16)( (*(i64*)_t2.data)));
}

f32 string_f32(string s) {
	Option_f64 _t2 = strconv__atof64(s);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(f64*) _t2.data = 0;
	}
	
 	return ((f32)( (*(f64*)_t2.data)));
}

f64 string_f64(string s) {
	Option_f64 _t2 = strconv__atof64(s);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(f64*) _t2.data = 0;
	}
	
 	return  (*(f64*)_t2.data);
}

u8 string_u8(string s) {
	Option_u64 _t2 = strconv__common_parse_uint(s, 0, 8, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(u64*) _t2.data = 0U;
	}
	
 	return ((u8)( (*(u64*)_t2.data)));
}

u16 string_u16(string s) {
	Option_u64 _t2 = strconv__common_parse_uint(s, 0, 16, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(u64*) _t2.data = 0U;
	}
	
 	return ((u16)( (*(u64*)_t2.data)));
}

u32 string_u32(string s) {
	Option_u64 _t2 = strconv__common_parse_uint(s, 0, 32, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(u64*) _t2.data = 0U;
	}
	
 	return ((u32)( (*(u64*)_t2.data)));
}

u64 string_u64(string s) {
	Option_u64 _t2 = strconv__common_parse_uint(s, 0, 64, false, false);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(u64*) _t2.data = 0U;
	}
	
 	return  (*(u64*)_t2.data);
}

Option_u64 string_parse_uint(string s, int _base, int _bit_size) {
	return strconv__parse_uint(s, _base, _bit_size);
}

Option_i64 string_parse_int(string s, int _base, int _bit_size) {
	return strconv__parse_int(s, _base, _bit_size);
}

// Attr: [direct_array_access]
bool string__eq(string s, string a) {
	if (s.str == 0) {
		panic_debug(575, tos3("/Users/rcqls/vlang/v/vlib/builtin/string.v"), tos3("builtin"), tos3("=="),  _SLIT("string.eq(): nil string"));
		VUNREACHABLE();
	}
	if (s.len != a.len) {
		return false;
	}
	if (s.len > 0) {
		int last_idx = s.len - 1;
		if (s.str[ last_idx] != a.str[ last_idx]) {
			return false;
		}
	}
	{ // Unsafe block
		return vmemcmp(s.str, a.str, a.len) == 0;
	}
	return 0;
}

// Attr: [direct_array_access]
int string_compare(string s, string a) {
	int min_len = (s.len < a.len ? (s.len) : (a.len));
	for (int i = 0; i < min_len; ++i) {
		if (s.str[ i] < a.str[ i]) {
			return -1;
		}
		if (s.str[ i] > a.str[ i]) {
			return 1;
		}
	}
	if (s.len < a.len) {
		return -1;
	}
	if (s.len > a.len) {
		return 1;
	}
	return 0;
}

// Attr: [direct_array_access]
bool string__lt(string s, string a) {
	for (int i = 0; i < s.len; ++i) {
		if (i >= a.len || s.str[ i] > a.str[ i]) {
			return false;
		} else if (s.str[ i] < a.str[ i]) {
			return true;
		}
	}
	if (s.len < a.len) {
		return true;
	}
	return false;
}

// Attr: [direct_array_access]
string string__plus(string s, string a) {
	int new_len = a.len + s.len;
	string res = ((string){.str = malloc_noscan(new_len + 1), .len = new_len});
	for (int j = 0; j < s.len; ++j) {
		{ // Unsafe block
			res.str[j] = s.str[j];
		}
	}
	for (int j = 0; j < a.len; ++j) {
		{ // Unsafe block
			res.str[s.len + j] = a.str[j];
		}
	}
	{ // Unsafe block
		res.str[new_len] = 0;
	}
	return res;
}

// Attr: [direct_array_access]
Array_string string_split_any(string s, string delim) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	int i = 0;
	if (s.len > 0) {
		if (delim.len <= 0) {
			return string_split(s, _SLIT(""));
		}
		for (int index = 0; index < s.len; ++index) {
			byte ch = s.str[index];
			for (int _t2 = 0; _t2 < delim.len; ++_t2) {
				byte delim_ch = delim.str[_t2];
				if (ch == delim_ch) {
					array_push((array*)&res, _MOV((string[]){ string_substr(s, i, index) }));
					i = index + 1;
					break;
				}
			}
		}
		if (i < s.len) {
			array_push((array*)&res, _MOV((string[]){ string_substr(s, i, (s).len) }));
		}
	}
	return res;
}

Array_string string_split(string s, string delim) {
	return string_split_nth(s, delim, 0);
}

// Attr: [direct_array_access]
Array_string string_split_nth(string s, string delim, int nth) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	int i = 0;

	if (delim.len == (0)) {
		i = 1;
		for (int _t1 = 0; _t1 < s.len; ++_t1) {
			byte ch = s.str[_t1];
			if (nth > 0 && i >= nth) {
				array_push((array*)&res, _MOV((string[]){ string_substr(s, i, (s).len) }));
				break;
			}
			array_push((array*)&res, _MOV((string[]){ u8_ascii_str(ch) }));
			i++;
		}
		return res;
	}
	else if (delim.len == (1)) {
		int start = 0;
		u8 delim_byte = delim.str[ 0];
		for (;;) {
			if (!(i < s.len)) break;
			if (s.str[ i] == delim_byte) {
				bool was_last = nth > 0 && res.len == nth - 1;
				if (was_last) {
					break;
				}
				string val = string_substr(s, start, i);
				array_push((array*)&res, _MOV((string[]){ val }));
				start = i + delim.len;
				i = start;
			} else {
				i++;
			}
		}
		if (nth < 1 || res.len < nth) {
			array_push((array*)&res, _MOV((string[]){ string_substr(s, start, (s).len) }));
		}
		return res;
	}
	else {
		int start = 0;
		for (;;) {
			if (!(i <= s.len)) break;
			bool is_delim = i + delim.len <= s.len && string__eq(string_substr(s, i, i + delim.len), delim);
			if (is_delim) {
				bool was_last = nth > 0 && res.len == nth - 1;
				if (was_last) {
					break;
				}
				string val = string_substr(s, start, i);
				array_push((array*)&res, _MOV((string[]){ val }));
				start = i + delim.len;
				i = start;
			} else {
				i++;
			}
		}
		if (nth < 1 || res.len < nth) {
			array_push((array*)&res, _MOV((string[]){ string_substr(s, start, (s).len) }));
		}
		return res;
	};
	return __new_array(0, 0, sizeof(string));
}

// Attr: [direct_array_access]
Array_string string_split_into_lines(string s) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	if (s.len == 0) {
		return res;
	}
	int start = 0;
	int end = 0;
	for (int i = 0; i < s.len; i++) {
		if (s.str[ i] == 10) {
			end = (i > 0 && s.str[ i - 1] == 13 ? (i - 1) : (i));
			array_push((array*)&res, _MOV((string[]){ (start == end ? (_SLIT("")) : (string_substr(s, start, end))) }));
			start = i + 1;
		}
	}
	if (start < s.len) {
		array_push((array*)&res, _MOV((string[]){ string_substr(s, start, (s).len) }));
	}
	return res;
}

string string_substr2(string s, int start, int _end, bool end_max) {
	int end = (end_max ? (s.len) : (_end));
	return string_substr(s, start, end);
}

// Attr: [direct_array_access]
string string_substr(string s, int start, int end) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end || start > s.len || end > s.len || start < 0 || end < 0) {
			panic_debug(798, tos3("/Users/rcqls/vlang/v/vlib/builtin/string.v"), tos3("builtin"), tos3("substr"),   str_intp(4, _MOV((StrIntpData[]){{_SLIT("substr("), 0xfe07, {.d_i32 = start}}, {_SLIT(", "), 0xfe07, {.d_i32 = end}}, {_SLIT(") out of bounds (len="), 0xfe07, {.d_i32 = s.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	int len = end - start;
	if (len == s.len) {
		return string_clone(s);
	}
	string res = ((string){.str = malloc_noscan(len + 1), .len = len});
	for (int i = 0; i < len; ++i) {
		{ // Unsafe block
			res.str[i] = s.str[start + i];
		}
	}
	{ // Unsafe block
		res.str[len] = 0;
	}
	return res;
}

// Attr: [direct_array_access]
Option_string string_substr_with_check(string s, int start, int end) {
	if (start > end || start > s.len || end > s.len || start < 0 || end < 0) {
		return (Option_string){ .state=2, .err=_v_error( str_intp(4, _MOV((StrIntpData[]){{_SLIT("substr("), 0xfe07, {.d_i32 = start}}, {_SLIT(", "), 0xfe07, {.d_i32 = end}}, {_SLIT(") out of bounds (len="), 0xfe07, {.d_i32 = s.len}}, {_SLIT(")"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int len = end - start;
	if (len == s.len) {
		Option_string _t2;
		opt_ok(&(string[]) { string_clone(s) }, (Option*)(&_t2), sizeof(string));
		return _t2;
	}
	string res = ((string){.str = malloc_noscan(len + 1), .len = len});
	for (int i = 0; i < len; ++i) {
		{ // Unsafe block
			res.str[i] = s.str[start + i];
		}
	}
	{ // Unsafe block
		res.str[len] = 0;
	}
	Option_string _t3;
	opt_ok(&(string[]) { res }, (Option*)(&_t3), sizeof(string));
	return _t3;
}

// Attr: [direct_array_access]
string string_substr_ni(string s, int _start, int _end) {
	int start = _start;
	int end = _end;
	if (start < 0) {
		start = s.len + start;
		if (start < 0) {
			start = 0;
		}
	}
	if (end < 0) {
		end = s.len + end;
		if (end < 0) {
			end = 0;
		}
	}
	if (end >= s.len) {
		end = s.len;
	}
	if (start > s.len || end < start) {
		string res = ((string){.str = malloc_noscan(1), .len = 0});
		{ // Unsafe block
			res.str[0] = 0;
		}
		return res;
	}
	int len = end - start;
	string res = ((string){.str = malloc_noscan(len + 1), .len = len});
	for (int i = 0; i < len; ++i) {
		{ // Unsafe block
			res.str[i] = s.str[start + i];
		}
	}
	{ // Unsafe block
		res.str[len] = 0;
	}
	return res;
}

// Attr: [direct_array_access]
int string_index_(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	if (p.len > 2) {
		return string_index_kmp(s, p);
	}
	int i = 0;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[i + j] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

Option_int string_index(string s, string p) {
	int idx = string_index_(s, p);
	if (idx == -1) {
		return (Option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_int _t2;
	opt_ok(&(int[]) { idx }, (Option*)(&_t2), sizeof(int));
	return _t2;
}

// Attr: [direct_array_access]
// Attr: [manualfree]
int string_index_kmp(string s, string p) {
bool string_index_kmp_defer_0 = false;
Array_int prefix;
	if (p.len > s.len) {
		return -1;
	}
	prefix = __new_array_with_default(p.len, 0, sizeof(int), 0);
	string_index_kmp_defer_0 = true;
	int j = 0;
	for (int i = 1; i < p.len; i++) {
		for (;;) {
			if (!(p.str[j] != p.str[i] && j > 0)) break;
			j = ((int*)prefix.data)[j - 1];
		}
		if (p.str[j] == p.str[i]) {
			j++;
		}
		((int*)prefix.data)[i] = j;
	}
	j = 0;
	for (int i = 0; i < s.len; ++i) {
		for (;;) {
			if (!(p.str[j] != s.str[i] && j > 0)) break;
			j = ((int*)prefix.data)[j - 1];
		}
		if (p.str[j] == s.str[i]) {
			j++;
		}
		if (j == p.len) {
			int _t2 = i - p.len + 1;
			// Defer begin
			if (string_index_kmp_defer_0) {
				array_free(&prefix);
			}
			// Defer end
			return _t2;
		}
	}
	int _t3 = -1;
	// Defer begin
	if (string_index_kmp_defer_0) {
		array_free(&prefix);
	}
	// Defer end
	return _t3;
}

int string_index_any(string s, string chars) {
	for (int i = 0; i < s.len; ++i) {
		byte ss = s.str[i];
		for (int _t1 = 0; _t1 < chars.len; ++_t1) {
			byte c = chars.str[_t1];
			if (c == ss) {
				return i;
			}
		}
	}
	return -1;
}

// Attr: [direct_array_access]
int string_last_index_(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	int i = s.len - p.len;
	for (;;) {
		if (!(i >= 0)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[i + j] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i--;
	}
	return -1;
}

Option_int string_last_index(string s, string p) {
	int idx = string_last_index_(s, p);
	if (idx == -1) {
		return (Option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_int _t2;
	opt_ok(&(int[]) { idx }, (Option*)(&_t2), sizeof(int));
	return _t2;
}

// Attr: [direct_array_access]
int string_index_after(string s, string p, int start) {
	if (p.len > s.len) {
		return -1;
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start >= s.len) {
		return -1;
	}
	int i = strt;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		int ii = i;
		for (;;) {
			if (!(j < p.len && s.str[ii] == p.str[j])) break;
			j++;
			ii++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

// Attr: [direct_array_access]
int string_index_u8(string s, u8 c) {
	for (int i = 0; i < s.len; ++i) {
		if (s.str[i] == c) {
			return i;
		}
	}
	return -1;
}

// Attr: [direct_array_access]
int string_last_index_u8(string s, u8 c) {
	for (int i = s.len - 1; i >= 0; i--) {
		if (s.str[i] == c) {
			return i;
		}
	}
	return -1;
}

// Attr: [direct_array_access]
int string_count(string s, string substr) {
	if (s.len == 0 || substr.len == 0) {
		return 0;
	}
	if (substr.len > s.len) {
		return 0;
	}
	int n = 0;
	if (substr.len == 1) {
		u8 target = substr.str[ 0];
		for (int _t3 = 0; _t3 < s.len; ++_t3) {
			byte letter = s.str[_t3];
			if (letter == target) {
				n++;
			}
		}
		return n;
	}
	int i = 0;
	for (;;) {
		i = string_index_after(s, substr, i);
		if (i == -1) {
			return n;
		}
		i += substr.len;
		n++;
	}
	return 0;
}

bool string_contains(string s, string substr) {
	if (substr.len == 0) {
		return true;
	}
	if (string_index_(s, substr) == -1) {
		return false;
	}
	return true;
}

bool string_contains_any(string s, string chars) {
	for (int _t1 = 0; _t1 < chars.len; ++_t1) {
		byte c = chars.str[_t1];
		if (string_contains(s, u8_ascii_str(c))) {
			return true;
		}
	}
	return false;
}

bool string_contains_any_substr(string s, Array_string substrs) {
	if (substrs.len == 0) {
		return true;
	}
	for (int _t2 = 0; _t2 < substrs.len; ++_t2) {
		string sub = ((string*)substrs.data)[_t2];
		if (string_contains(s, sub)) {
			return true;
		}
	}
	return false;
}

// Attr: [direct_array_access]
bool string_starts_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	}
	for (int i = 0; i < p.len; ++i) {
		if (s.str[i] != p.str[i]) {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
bool string_ends_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	}
	for (int i = 0; i < p.len; ++i) {
		if (p.str[i] != s.str[s.len - p.len + i]) {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
string string_to_lower(string s) {
	{ // Unsafe block
		u8* b = malloc_noscan(s.len + 1);
		for (int i = 0; i < s.len; ++i) {
			if (s.str[i] >= 'A' && s.str[i] <= 'Z') {
				b[i] = s.str[i] + 32;
			} else {
				b[i] = s.str[i];
			}
		}
		b[s.len] = 0;
		return tos(b, s.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
bool string_is_lower(string s) {
	for (int i = 0; i < s.len; ++i) {
		if (s.str[ i] >= 'A' && s.str[ i] <= 'Z') {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
string string_to_upper(string s) {
	{ // Unsafe block
		u8* b = malloc_noscan(s.len + 1);
		for (int i = 0; i < s.len; ++i) {
			if (s.str[i] >= 'a' && s.str[i] <= 'z') {
				b[i] = s.str[i] - 32;
			} else {
				b[i] = s.str[i];
			}
		}
		b[s.len] = 0;
		return tos(b, s.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
bool string_is_upper(string s) {
	for (int i = 0; i < s.len; ++i) {
		if (s.str[ i] >= 'a' && s.str[ i] <= 'z') {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
string string_capitalize(string s) {
	if (s.len == 0) {
		return _SLIT("");
	}
	u8 s0 = s.str[ 0];
	string letter = u8_ascii_str(s0);
	string uletter = string_to_upper(letter);
	if (s.len == 1) {
		return uletter;
	}
	string srest = string_substr(s, 1, (s).len);
	string res = string__plus(uletter, srest);
	return res;
}

// Attr: [direct_array_access]
bool string_is_capital(string s) {
	if (s.len == 0 || !(s.str[ 0] >= 'A' && s.str[ 0] <= 'Z')) {
		return false;
	}
	for (int i = 1; i < s.len; ++i) {
		if (s.str[ i] >= 'A' && s.str[ i] <= 'Z') {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
bool string_starts_with_capital(string s) {
	if (s.len == 0 || !(s.str[ 0] >= 'A' && s.str[ 0] <= 'Z')) {
		return false;
	}
	return true;
}

string string_title(string s) {
	Array_string words = string_split(s, _SLIT(" "));
	Array_string tit = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < words.len; ++_t1) {
		string word = ((string*)words.data)[_t1];
		array_push((array*)&tit, _MOV((string[]){ string_capitalize(word) }));
	}
	string title = Array_string_join(tit, _SLIT(" "));
	return title;
}

bool string_is_title(string s) {
	Array_string words = string_split(s, _SLIT(" "));
	for (int _t1 = 0; _t1 < words.len; ++_t1) {
		string word = ((string*)words.data)[_t1];
		if (!string_is_capital(word)) {
			return false;
		}
	}
	return true;
}

string string_find_between(string s, string start, string end) {
	int start_pos = string_index_(s, start);
	if (start_pos == -1) {
		return _SLIT("");
	}
	string val = string_substr(s, start_pos + start.len, (s).len);
	int end_pos = string_index_(val, end);
	if (end_pos == -1) {
		return val;
	}
	return string_substr(val, 0, end_pos);
}

string string_trim_space(string s) {
	return string_trim(s, _SLIT(" \n\t\v\f\r"));
}

// Attr: [direct_array_access]
string string_trim(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return string_clone(s);
	}
	int pos_left = 0;
	int pos_right = s.len - 1;
	bool cs_match = true;
	for (;;) {
		if (!(pos_left <= s.len && pos_right >= -1 && cs_match)) break;
		cs_match = false;
		for (int _t2 = 0; _t2 < cutset.len; ++_t2) {
			byte cs = cutset.str[_t2];
			if (s.str[ pos_left] == cs) {
				pos_left++;
				cs_match = true;
				break;
			}
		}
		for (int _t3 = 0; _t3 < cutset.len; ++_t3) {
			byte cs = cutset.str[_t3];
			if (s.str[ pos_right] == cs) {
				pos_right--;
				cs_match = true;
				break;
			}
		}
		if (pos_left > pos_right) {
			return _SLIT("");
		}
	}
	return string_substr(s, pos_left, pos_right + 1);
}

// Attr: [direct_array_access]
string string_trim_left(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return string_clone(s);
	}
	int pos = 0;
	for (;;) {
		if (!(pos < s.len)) break;
		bool found = false;
		for (int _t2 = 0; _t2 < cutset.len; ++_t2) {
			byte cs = cutset.str[_t2];
			if (s.str[ pos] == cs) {
				found = true;
				break;
			}
		}
		if (!found) {
			break;
		}
		pos++;
	}
	return string_substr(s, pos, (s).len);
}

// Attr: [direct_array_access]
string string_trim_right(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return string_clone(s);
	}
	int pos = s.len - 1;
	for (;;) {
		if (!(pos >= 0)) break;
		bool found = false;
		for (int _t2 = 0; _t2 < cutset.len; ++_t2) {
			byte cs = cutset.str[_t2];
			if (s.str[ pos] == cs) {
				found = true;
			}
		}
		if (!found) {
			break;
		}
		pos--;
	}
	if (pos < 0) {
		return _SLIT("");
	}
	return string_substr(s, 0, pos + 1);
}

string string_trim_string_left(string s, string str) {
	if (string_starts_with(s, str)) {
		return string_substr(s, str.len, (s).len);
	}
	return string_clone(s);
}

string string_trim_string_right(string s, string str) {
	if (string_ends_with(s, str)) {
		return string_substr(s, 0, s.len - str.len);
	}
	return string_clone(s);
}

// Attr: [deprecated]
// Attr: [deprecated_after]
string string_trim_prefix(string s, string str) {
	return string_trim_string_left(s, str);
}

// Attr: [deprecated]
// Attr: [deprecated_after]
string string_trim_suffix(string s, string str) {
	return string_trim_string_right(s, str);
}

int compare_strings(string* a, string* b) {
	if (string__lt(*a, *b)) {
		return -1;
	}
	if (string__lt(*b, *a)) {
		return 1;
	}
	return 0;
}

int compare_strings_by_len(string* a, string* b) {
	if (a->len < b->len) {
		return -1;
	}
	if (a->len > b->len) {
		return 1;
	}
	return 0;
}

int compare_lower_strings(string* a, string* b) {
	string aa = string_to_lower(/*rec*/*a);
	string bb = string_to_lower(/*rec*/*b);
	return compare_strings(&aa, &bb);
}

void Array_string_sort_ignore_case(Array_string* s) {
	array_sort_with_compare(s, (voidptr)compare_lower_strings);
}

void Array_string_sort_by_len(Array_string* s) {
	array_sort_with_compare(s, (voidptr)compare_strings_by_len);
}

string string_str(string s) {
	return string_clone(s);
}

byte string_at(string s, int idx) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (idx < 0 || idx >= s.len) {
			panic_debug(1483, tos3("/Users/rcqls/vlang/v/vlib/builtin/string.v"), tos3("builtin"), tos3("at"),   str_intp(3, _MOV((StrIntpData[]){{_SLIT("string index out of range: "), 0xfe07, {.d_i32 = idx}}, {_SLIT(" / "), 0xfe07, {.d_i32 = s.len}}, {_SLIT0, 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	{ // Unsafe block
		return s.str[idx];
	}
	return 0;
}

Option_u8 string_at_with_check(string s, int idx) {
	if (idx < 0 || idx >= s.len) {
		return (Option_u8){ .state=2, .err=_v_error(_SLIT("string index out of range")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	{ // Unsafe block
		Option_u8 _t2;
		opt_ok(&(u8[]) { s.str[idx] }, (Option*)(&_t2), sizeof(u8));
		return _t2;
	}
	return (Option_u8){0};
}

// Attr: [inline]
inline bool u8_is_space(u8 c) {
	return c == 32 || (c > 8 && c < 14) || (c == 0x85) || (c == 0xa0);
}

// Attr: [inline]
inline bool u8_is_digit(u8 c) {
	return c >= '0' && c <= '9';
}

// Attr: [inline]
inline bool u8_is_hex_digit(u8 c) {
	return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}

// Attr: [inline]
inline bool u8_is_oct_digit(u8 c) {
	return c >= '0' && c <= '7';
}

// Attr: [inline]
inline bool u8_is_bin_digit(u8 c) {
	return c == '0' || c == '1';
}

// Attr: [inline]
inline bool u8_is_letter(u8 c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

// Attr: [inline]
inline bool u8_is_alnum(u8 c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9');
}

// Attr: [manualfree]
// Attr: [unsafe]
void string_free(string* s) {
	if (s->is_lit == -98761234) {
		u8* double_free_msg = ((u8*)("double string.free() detected\n"));
		int double_free_msg_len = vstrlen(double_free_msg);
		#if defined(_VFREESTANDING)
		{
		}
		#else
		{
			_write_buf_to_fd(1, double_free_msg, double_free_msg_len);
		}
		#endif
		return;
	}
	if (s->is_lit == 1 || s->str == 0) {
		return;
	}
	_v_free(s->str);
	s->is_lit = -98761234;
}

string string_before(string s, string sub) {
	int pos = string_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, 0, pos);
}

string string_all_before(string s, string sub) {
	int pos = string_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, 0, pos);
}

string string_all_before_last(string s, string sub) {
	int pos = string_last_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, 0, pos);
}

string string_all_after(string s, string sub) {
	int pos = string_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, pos + sub.len, (s).len);
}

string string_all_after_last(string s, string sub) {
	int pos = string_last_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, pos + sub.len, (s).len);
}

string string_after(string s, string sub) {
	return string_all_after_last(s, sub);
}

string string_after_char(string s, u8 sub) {
	int pos = -1;
	for (int i = 0; i < s.len; ++i) {
		byte c = s.str[i];
		if (c == sub) {
			pos = i;
			break;
		}
	}
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, pos + 1, (s).len);
}

string Array_string_join(Array_string a, string sep) {
	if (a.len == 0) {
		return _SLIT("");
	}
	int len = 0;
	for (int _t2 = 0; _t2 < a.len; ++_t2) {
		string val = ((string*)a.data)[_t2];
		len += val.len + sep.len;
	}
	len -= sep.len;
	string res = ((string){.str = malloc_noscan(len + 1), .len = len});
	int idx = 0;
	for (int i = 0; i < a.len; ++i) {
		string val = ((string*)a.data)[i];
		{ // Unsafe block
			vmemcpy(((voidptr)(res.str + idx)), val.str, val.len);
			idx += val.len;
		}
		if (i != a.len - 1) {
			{ // Unsafe block
				vmemcpy(((voidptr)(res.str + idx)), sep.str, sep.len);
				idx += sep.len;
			}
		}
	}
	{ // Unsafe block
		res.str[res.len] = 0;
	}
	return res;
}

string Array_string_join_lines(Array_string s) {
	return Array_string_join(s, _SLIT("\n"));
}

string string_reverse(string s) {
	if (s.len == 0 || s.len == 1) {
		return string_clone(s);
	}
	string res = ((string){.str = malloc_noscan(s.len + 1), .len = s.len});
	for (int i = s.len - 1; i >= 0; i--) {
		{ // Unsafe block
			res.str[s.len - i - 1] = string_at(s, i);
		}
	}
	{ // Unsafe block
		res.str[res.len] = 0;
	}
	return res;
}

string string_limit(string s, int max) {
	Array_rune u = string_runes(s);
	if (u.len <= max) {
		return string_clone(s);
	}
	return Array_rune_string(array_slice(u, 0, max));
}

int string_hash(string s) {
	u32 h = ((u32)(0U));
	if (h == 0U && s.len > 0) {
		for (int _t1 = 0; _t1 < s.len; ++_t1) {
			byte c = s.str[_t1];
			h = h * 31U + ((u32)(c));
		}
	}
	return ((int)(h));
}

Array_u8 string_bytes(string s) {
	if (s.len == 0) {
		return __new_array_with_default(0, 0, sizeof(u8), 0);
	}
	Array_u8 buf = __new_array_with_default(s.len, 0, sizeof(u8), 0);
	vmemcpy(buf.data, s.str, s.len);
	return buf;
}

string string_repeat(string s, int count) {
	if (count < 0) {
		panic_debug(1766, tos3("/Users/rcqls/vlang/v/vlib/builtin/string.v"), tos3("builtin"), tos3("repeat"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("string.repeat: count is negative: "), 0xfe07, {.d_i32 = count}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	} else if (count == 0) {
		return _SLIT("");
	} else if (count == 1) {
		return string_clone(s);
	}
	u8* ret = malloc_noscan(s.len * count + 1);
	for (int i = 0; i < count; ++i) {
		for (int j = 0; j < s.len; ++j) {
			{ // Unsafe block
				ret[i * s.len + j] = string_at(s, j);
			}
		}
	}
	int new_len = s.len * count;
	{ // Unsafe block
		ret[new_len] = 0;
	}
	return u8_vstring_with_len(ret, new_len);
}

Array_string string_fields(string s) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	int word_start = 0;
	int word_len = 0;
	bool is_in_word = false;
	bool is_space = false;
	for (int i = 0; i < s.len; ++i) {
		byte c = s.str[i];
		is_space = (c == 32 || c == 9 || c == 10);
		if (!is_space) {
			word_len++;
		}
		if (!is_in_word && !is_space) {
			word_start = i;
			is_in_word = true;
			continue;
		}
		if (is_space && is_in_word) {
			array_push((array*)&res, _MOV((string[]){ string_substr(s, word_start, word_start + word_len) }));
			is_in_word = false;
			word_len = 0;
			word_start = 0;
			continue;
		}
	}
	if (is_in_word && word_len > 0) {
		array_push((array*)&res, _MOV((string[]){ string_substr(s, word_start, s.len) }));
	}
	return res;
}

string string_strip_margin(string s) {
	return string_strip_margin_custom(s, '|');
}

// Attr: [direct_array_access]
string string_strip_margin_custom(string s, u8 del) {
	u8 sep = del;
	if (u8_is_space(sep)) {
		println(_SLIT("Warning: `strip_margin` cannot use white-space as a delimiter"));
		println(_SLIT("    Defaulting to `|`"));
		sep = '|';
	}
	u8* ret = malloc_noscan(s.len + 1);
	int count = 0;
	for (int i = 0; i < s.len; i++) {
		if (s.str[ i] == 10 || s.str[ i] == 13) {
			{ // Unsafe block
				ret[count] = s.str[ i];
			}
			count++;
			if (s.str[ i] == 13 && i < s.len - 1 && s.str[ i + 1] == 10) {
				{ // Unsafe block
					ret[count] = s.str[ i + 1];
				}
				count++;
				i++;
			}
			for (;;) {
				if (!(s.str[ i] != sep)) break;
				i++;
				if (i >= s.len) {
					break;
				}
			}
		} else {
			{ // Unsafe block
				ret[count] = s.str[ i];
			}
			count++;
		}
	}
	{ // Unsafe block
		ret[count] = 0;
		return u8_vstring_with_len(ret, count);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
bool string_match_glob(string name, string pattern) {
	int px = 0;
	int nx = 0;
	int next_px = 0;
	int next_nx = 0;
	int plen = pattern.len;
	int nlen = name.len;
	for (;;) {
		if (!(px < plen || nx < nlen)) break;
		if (px < plen) {
			u8 c = pattern.str[ px];

			if (c == ('?')) {
				if (nx < nlen) {
					px++;
					nx++;
					continue;
				}
			}
			else if (c == ('*')) {
				next_px = px;
				next_nx = nx + 1;
				px++;
				continue;
			}
			else if (c == ('[')) {
				if (nx < nlen) {
					u8 wanted_c = name.str[ nx];
					int bstart = px;
					bool is_inverted = false;
					bool inner_match = false;
					int inner_idx = bstart + 1;
					u8 inner_c = ((u8)(0));
					if (inner_idx < plen) {
						inner_c = pattern.str[ inner_idx];
						if (inner_c == '^') {
							is_inverted = true;
							inner_idx++;
						}
					}
					for (; inner_idx < plen; inner_idx++) {
						inner_c = pattern.str[ inner_idx];
						if (inner_c == ']') {
							break;
						}
						if (inner_c == wanted_c) {
							inner_match = true;
							for (;;) {
								if (!(px < plen && pattern.str[ px] != ']')) break;
								px++;
							}
							break;
						}
					}
					if (is_inverted) {
						if (inner_match) {
							return false;
						} else {
							px = inner_idx;
						}
					}
				}
				px++;
				nx++;
				continue;
			}
			else {
				if (nx < nlen && name.str[ nx] == c) {
					px++;
					nx++;
					continue;
				}
			};
		}
		if (0 < next_nx && next_nx <= nlen) {
			px = next_px;
			nx = next_nx;
			continue;
		}
		return false;
	}
	return true;
}

// Attr: [unsafe]
Array_u8 byteptr_vbytes(byteptr data, int len) {
	return voidptr_vbytes(((voidptr)(data)), len);
}

// Attr: [unsafe]
string byteptr_vstring(byteptr bp) {
	return ((string){.str = bp, .len = vstrlen(bp)});
}

// Attr: [unsafe]
string byteptr_vstring_with_len(byteptr bp, int len) {
	return ((string){.str = bp, .len = len, .is_lit = 0});
}

// Attr: [unsafe]
string charptr_vstring(charptr cp) {
	return ((string){.str = ((byteptr)(cp)), .len = vstrlen_char(cp), .is_lit = 0});
}

// Attr: [unsafe]
string charptr_vstring_with_len(charptr cp, int len) {
	return ((string){.str = ((byteptr)(cp)), .len = len, .is_lit = 0});
}

// Attr: [unsafe]
string byteptr_vstring_literal(byteptr bp) {
	return ((string){.str = bp, .len = vstrlen(bp), .is_lit = 1});
}

// Attr: [unsafe]
string byteptr_vstring_literal_with_len(byteptr bp, int len) {
	return ((string){.str = bp, .len = len, .is_lit = 1});
}

// Attr: [unsafe]
string charptr_vstring_literal(charptr cp) {
	return ((string){.str = ((byteptr)(cp)), .len = vstrlen_char(cp), .is_lit = 1});
}

// Attr: [unsafe]
string charptr_vstring_literal_with_len(charptr cp, int len) {
	return ((string){.str = ((byteptr)(cp)), .len = len, .is_lit = 1});
}

string StrIntpType_str(StrIntpType x) {
	switch (x) {
		case StrIntpType__si_no_str: 
			{
				return _SLIT("no_str");
				break;
			}
		case StrIntpType__si_c: 
			{
				return _SLIT("c");
				break;
			}
		case StrIntpType__si_u8: 
			{
				return _SLIT("u8");
				break;
			}
		case StrIntpType__si_i8: 
			{
				return _SLIT("i8");
				break;
			}
		case StrIntpType__si_u16: 
			{
				return _SLIT("u16");
				break;
			}
		case StrIntpType__si_i16: 
			{
				return _SLIT("i16");
				break;
			}
		case StrIntpType__si_u32: 
			{
				return _SLIT("u32");
				break;
			}
		case StrIntpType__si_i32: 
			{
				return _SLIT("i32");
				break;
			}
		case StrIntpType__si_u64: 
			{
				return _SLIT("u64");
				break;
			}
		case StrIntpType__si_i64: 
			{
				return _SLIT("i64");
				break;
			}
		case StrIntpType__si_f32: 
			{
				return _SLIT("f32");
				break;
			}
		case StrIntpType__si_f64: 
			{
				return _SLIT("f64");
				break;
			}
		case StrIntpType__si_g32: 
			{
				return _SLIT("f32");
				break;
			}
		case StrIntpType__si_g64: 
			{
				return _SLIT("f64");
				break;
			}
		case StrIntpType__si_e32: 
			{
				return _SLIT("f32");
				break;
			}
		case StrIntpType__si_e64: 
			{
				return _SLIT("f64");
				break;
			}
		case StrIntpType__si_s: 
			{
				return _SLIT("s");
				break;
			}
		case StrIntpType__si_p: 
			{
				return _SLIT("p");
				break;
			}
		case StrIntpType__si_vp: 
			{
				return _SLIT("vp");
				break;
			}
	}
	;
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline f32 fabs32(f32 x) {
	return (x < 0 ? (-x) : (x));
}

// Attr: [inline]
inline f64 fabs64(f64 x) {
	return (x < 0 ? (-x) : (x));
}

// Attr: [inline]
inline u64 abs64(i64 x) {
	return (x < 0 ? (((u64)(-x))) : (((u64)(x))));
}

u64 get_str_intp_u64_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, byte in_pad_ch, int in_base, bool in_upper_case) {
	u64 width = (in_width != 0 ? (abs64(in_width)) : (((u64)(0U))));
	u64 allign = (in_width > 0 ? (((u64)(1 << 5))) : (((u64)(0U))));
	u64 upper_case = (in_upper_case ? (((u64)(1 << 7))) : (((u64)(0U))));
	u64 sign = (in_sign ? (((u64)(1 << 8))) : (((u64)(0U))));
	u64 precision = (in_precision != 987698 ? ((((u64)((in_precision & 0x7F))) << 9U)) : (((u64)(0x7FU)) << 9U));
	u32 tail_zeros = (in_tail_zeros ? (((u32)(1U)) << 16U) : (((u32)(0U))));
	u64 base = ((u64)(((u32)((in_base & 0xf))) << 27U));
	u64 res = ((u64)(((((((((((((u64)(fmt_type)) & 0x1FU)) | allign) | upper_case) | sign) | precision) | tail_zeros) | (((u64)((width & 0x3FFU))) << 17U)) | base) | (((u64)(in_pad_ch)) << 31U))));
	return res;
}

u32 get_str_intp_u32_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, byte in_pad_ch, int in_base, bool in_upper_case) {
	u64 width = (in_width != 0 ? (abs64(in_width)) : (((u32)(0U))));
	u32 allign = (in_width > 0 ? (((u32)(1 << 5))) : (((u32)(0U))));
	u32 upper_case = (in_upper_case ? (((u32)(1 << 7))) : (((u32)(0U))));
	u32 sign = (in_sign ? (((u32)(1 << 8))) : (((u32)(0U))));
	u32 precision = (in_precision != 987698 ? ((((u32)((in_precision & 0x7F))) << 9U)) : (((u32)(0x7FU)) << 9U));
	u32 tail_zeros = (in_tail_zeros ? (((u32)(1U)) << 16U) : (((u32)(0U))));
	u32 base = ((u32)(((u32)((in_base & 0xf))) << 27U));
	u32 res = ((u32)(((((((((((((u32)(fmt_type)) & 0x1FU)) | allign) | upper_case) | sign) | precision) | tail_zeros) | (((u32)((width & 0x3FFU))) << 17U)) | base) | (((u32)((in_pad_ch & 1))) << 31U))));
	return res;
}

// Attr: [manualfree]
void StrIntpData_process_str_intp_data(StrIntpData* data, strings__Builder* sb) {
	u32 x = data->fmt;
	StrIntpType typ = ((StrIntpType)((x & 0x1FU)));
	int allign = ((int)(((x >> 5U) & 0x01U)));
	bool upper_case = (((x >> 7U) & 0x01U)) > 0U;
	int sign = ((int)(((x >> 8U) & 0x01U)));
	int precision = ((int)(((x >> 9U) & 0x7FU)));
	bool tail_zeros = (((x >> 16U) & 0x01U)) > 0U;
	int width = ((int)(((i16)(((x >> 17U) & 0x3FFU)))));
	int base = (((int)(x >> 27U)) & 0xF);
	u8 fmt_pad_ch = ((u8)(((x >> 31U) & 0xFFU)));
	if (typ == StrIntpType__si_no_str) {
		return;
	}
	if (base > 0) {
		base += 2;
	}
	u8 pad_ch = ((u8)(' '));
	if (fmt_pad_ch > 0) {
		pad_ch = '0';
	}
	int len0_set = (width > 0 ? (width) : (-1));
	int len1_set = (precision == 0x7F ? (-1) : (precision));
	bool sign_set = sign == 1;
	strconv__BF_param bf = ((strconv__BF_param){
		.pad_ch = pad_ch,
		.len0 = len0_set,
		.len1 = len1_set,
		.positive = true,
		.sign_flag = sign_set,
		.allign = strconv__Align_text__left,
		.rm_tail_zero = tail_zeros,
	});
	if (fmt_pad_ch == 0) {

		if (allign == (0)) {
			bf.allign = strconv__Align_text__left;
		}
		else if (allign == (1)) {
			bf.allign = strconv__Align_text__right;
		}
		else {
			bf.allign = strconv__Align_text__left;
		};
	} else {
		bf.allign = strconv__Align_text__right;
	}
	{ // Unsafe block
		if (typ == StrIntpType__si_s) {
			string s = _SLIT("");
			if (upper_case) {
				s = string_to_upper(data->d.d_s);
			} else {
				s = string_clone(data->d.d_s);
			}
			if (width == 0) {
				strings__Builder_write_string(sb, s);
			} else {
				strconv__format_str_sb(s, bf, sb);
			}
			string_free(&s);
			return;
		}
		if (typ == StrIntpType__si_i8 || typ == StrIntpType__si_i16 || typ == StrIntpType__si_i32 || typ == StrIntpType__si_i64) {
			i64 d = data->d.d_i64;
			if (typ == StrIntpType__si_i8) {
				d = ((i64)(data->d.d_i8));
			} else if (typ == StrIntpType__si_i16) {
				d = ((i64)(data->d.d_i16));
			} else if (typ == StrIntpType__si_i32) {
				d = ((i64)(data->d.d_i32));
			}
			if (base == 0) {
				if (width == 0) {
					string d_str = i64_str(d);
					strings__Builder_write_string(sb, d_str);
					string_free(&d_str);
					return;
				}
				if (d < 0) {
					bf.positive = false;
				}
				strconv__format_dec_sb(abs64(d), bf, sb);
			} else {
				if (base == 3) {
					base = 2;
				}
				i64 absd = d;
				bool write_minus = false;
				if (d < 0 && pad_ch != ' ') {
					absd = -d;
					write_minus = true;
				}
				string hx = strconv__format_int(absd, base);
				if (upper_case) {
					string tmp = hx;
					hx = string_to_upper(hx);
					string_free(&tmp);
				}
				if (write_minus) {
					strings__Builder_write_u8(sb, '-');
					bf.len0--;
				}
				if (width == 0) {
					strings__Builder_write_string(sb, hx);
				} else {
					strconv__format_str_sb(hx, bf, sb);
				}
				string_free(&hx);
			}
			return;
		}
		if (typ == StrIntpType__si_u8 || typ == StrIntpType__si_u16 || typ == StrIntpType__si_u32 || typ == StrIntpType__si_u64) {
			u64 d = data->d.d_u64;
			if (typ == StrIntpType__si_u8) {
				d = ((u64)(data->d.d_u8));
			} else if (typ == StrIntpType__si_u16) {
				d = ((u64)(data->d.d_u16));
			} else if (typ == StrIntpType__si_u32) {
				d = ((u64)(data->d.d_u32));
			}
			if (base == 0) {
				if (width == 0) {
					string d_str = u64_str(d);
					strings__Builder_write_string(sb, d_str);
					string_free(&d_str);
					return;
				}
				strconv__format_dec_sb(d, bf, sb);
			} else {
				if (base == 3) {
					base = 2;
				}
				string hx = strconv__format_uint(d, base);
				if (upper_case) {
					string tmp = hx;
					hx = string_to_upper(hx);
					string_free(&tmp);
				}
				if (width == 0) {
					strings__Builder_write_string(sb, hx);
				} else {
					strconv__format_str_sb(hx, bf, sb);
				}
				string_free(&hx);
			}
			return;
		}
		if (typ == StrIntpType__si_p) {
			u64 d = data->d.d_u64;
			base = 16;
			if (base == 0) {
				if (width == 0) {
					string d_str = u64_str(d);
					strings__Builder_write_string(sb, d_str);
					string_free(&d_str);
					return;
				}
				strconv__format_dec_sb(d, bf, sb);
			} else {
				string hx = strconv__format_uint(d, base);
				if (upper_case) {
					string tmp = hx;
					hx = string_to_upper(hx);
					string_free(&tmp);
				}
				if (width == 0) {
					strings__Builder_write_string(sb, hx);
				} else {
					strconv__format_str_sb(hx, bf, sb);
				}
				string_free(&hx);
			}
			return;
		}
		bool use_default_str = false;
		if (width == 0 && precision == 0x7F) {
			bf.len1 = 3;
			use_default_str = true;
		}
		if (bf.len1 < 0) {
			bf.len1 = 3;
		}
		switch (typ) {
			case StrIntpType__si_f32: 
				{
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						if (use_default_str) {
							string f = f32_str(data->d.d_f32);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f32 < 0) {
								bf.positive = false;
							}
							string f = strconv__format_fl(data->d.d_f32, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
					break;
				}
			case StrIntpType__si_f64: 
				{
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						if (use_default_str) {
							string f = f64_str(data->d.d_f64);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f64 < 0) {
								bf.positive = false;
							}
							strconv__Float64u f_union = ((strconv__Float64u){.f = data->d.d_f64,});
							if (f_union.u == _const_strconv__double_minus_zero) {
								bf.positive = false;
							}
							string f = strconv__format_fl(data->d.d_f64, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
					break;
				}
			case StrIntpType__si_g32: 
				{
					if (use_default_str) {
						#if !defined(CUSTOM_DEFINE_nofloat)
						{
							string f = f32_strg(data->d.d_f32);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
						#endif
					} else {
						if (data->d.d_f32 == _const_strconv__single_plus_zero) {
							string tmp_str = _SLIT("0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f32 == _const_strconv__single_minus_zero) {
							string tmp_str = _SLIT("-0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f32 == _const_strconv__single_plus_infinity) {
							string tmp_str = _SLIT("+inf");
							if (upper_case) {
								tmp_str = _SLIT("+INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f32 == _const_strconv__single_minus_infinity) {
							string tmp_str = _SLIT("-inf");
							if (upper_case) {
								tmp_str = _SLIT("-INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f32 < 0) {
							bf.positive = false;
						}
						f32 d = fabs32(data->d.d_f32);
						if (d < 999999.0 && d >= 0.00001) {
							string f = strconv__format_fl(data->d.d_f32, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
							return;
						}
						string f = strconv__format_es(data->d.d_f32, bf);
						if (upper_case) {
							string tmp = f;
							f = string_to_upper(f);
							string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						string_free(&f);
					}
					break;
				}
			case StrIntpType__si_g64: 
				{
					if (use_default_str) {
						#if !defined(CUSTOM_DEFINE_nofloat)
						{
							string f = f64_strg(data->d.d_f64);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
						#endif
					} else {
						if (data->d.d_f64 == _const_strconv__double_plus_zero) {
							string tmp_str = _SLIT("0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f64 == _const_strconv__double_minus_zero) {
							string tmp_str = _SLIT("-0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f64 == _const_strconv__double_plus_infinity) {
							string tmp_str = _SLIT("+inf");
							if (upper_case) {
								tmp_str = _SLIT("+INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f64 == _const_strconv__double_minus_infinity) {
							string tmp_str = _SLIT("-inf");
							if (upper_case) {
								tmp_str = _SLIT("-INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f64 < 0) {
							bf.positive = false;
						}
						f64 d = fabs64(data->d.d_f64);
						if (d < 999999.0 && d >= 0.00001) {
							string f = strconv__format_fl(data->d.d_f64, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
							return;
						}
						string f = strconv__format_es(data->d.d_f64, bf);
						if (upper_case) {
							string tmp = f;
							f = string_to_upper(f);
							string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						string_free(&f);
					}
					break;
				}
			case StrIntpType__si_e32: 
				{
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						bf.len1 = 6;
						if (use_default_str) {
							string f = f32_str(data->d.d_f32);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f32 < 0) {
								bf.positive = false;
							}
							string f = strconv__format_es(data->d.d_f32, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
					break;
				}
			case StrIntpType__si_e64: 
				{
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						bf.len1 = 6;
						if (use_default_str) {
							string f = f64_str(data->d.d_f64);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f64 < 0) {
								bf.positive = false;
							}
							string f = strconv__format_es(data->d.d_f64, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
					break;
				}
			case StrIntpType__si_c: 
				{
					string ss = utf32_to_str(data->d.d_c);
					strings__Builder_write_string(sb, ss);
					string_free(&ss);
					break;
				}
			case StrIntpType__si_vp: 
				{
					string ss = u64_hex(((u64)(data->d.d_vp)));
					strings__Builder_write_string(sb, ss);
					string_free(&ss);
					break;
				}
			case StrIntpType__si_no_str:
			case StrIntpType__si_u8:
			case StrIntpType__si_i8:
			case StrIntpType__si_u16:
			case StrIntpType__si_i16:
			case StrIntpType__si_u32:
			case StrIntpType__si_i32:
			case StrIntpType__si_u64:
			case StrIntpType__si_i64:
			case StrIntpType__si_s:
			case StrIntpType__si_p:
			default:
				{
					strings__Builder_write_string(sb, _SLIT("***ERROR!***"));
					break;
				}
		}
		;
	}
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string str_intp(int data_len, voidptr in_data) {
	strings__Builder res = strings__new_builder(256);
	StrIntpData* input_base = ((StrIntpData*)(in_data));
	for (int i = 0; i < data_len; i++) {
		StrIntpData* data = &input_base[i];
		if (data->str.len != 0) {
			strings__Builder_write_string(&res, data->str);
		}
		if (data->fmt != 0U) {
			StrIntpData_process_str_intp_data(data, (voidptr)&/*qq*/res);
		}
	}
	string ret = strings__Builder_str(&res);
	strings__Builder_free(&res);
	return ret;
}

// Attr: [inline]
inline string str_intp_sq(string in_str) {
	return  str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(2, _MOV((StrIntpData[]){{_SLIT(\"\'\"), "), 0xfe10, {.d_s = _const_si_s_code}}, {_SLIT(", {.d_s = "), 0xfe10, {.d_s = in_str}}, {_SLIT("}},{_SLIT(\"\'\"), 0, {.d_c = 0 }}}))"), 0, { .d_c = 0 }}}));
}

// Attr: [inline]
inline string str_intp_rune(string in_str) {
	return  str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(2, _MOV((StrIntpData[]){{_SLIT(\"`\"), "), 0xfe10, {.d_s = _const_si_s_code}}, {_SLIT(", {.d_s = "), 0xfe10, {.d_s = in_str}}, {_SLIT("}},{_SLIT(\"`\"), 0, {.d_c = 0 }}}))"), 0, { .d_c = 0 }}}));
}

// Attr: [inline]
inline string str_intp_g32(string in_str) {
	return  str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(1, _MOV((StrIntpData[]){{_SLIT0, "), 0xfe10, {.d_s = _const_si_g32_code}}, {_SLIT(", {.d_f32 = "), 0xfe10, {.d_s = in_str}}, {_SLIT(" }}}))"), 0, { .d_c = 0 }}}));
}

// Attr: [inline]
inline string str_intp_g64(string in_str) {
	return  str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(1, _MOV((StrIntpData[]){{_SLIT0, "), 0xfe10, {.d_s = _const_si_g64_code}}, {_SLIT(", {.d_f64 = "), 0xfe10, {.d_s = in_str}}, {_SLIT(" }}}))"), 0, { .d_c = 0 }}}));
}

// Attr: [manualfree]
string str_intp_sub(string base_str, string in_str) {
	Option_int _t1 = string_index(base_str, _SLIT("%%"));
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		eprintln(_SLIT("No strin interpolation %% parameteres"));
		_v_exit(1);
		VUNREACHABLE();
	;
	}
	
 	int index =  (*(int*)_t1.data);
	{ // Unsafe block
		string st_str = string_substr(base_str, 0, index);
		if (index + 2 < base_str.len) {
			string en_str = string_substr(base_str, index + 2, (base_str).len);
			string res_str =  str_intp(5, _MOV((StrIntpData[]){{_SLIT("str_intp(2, _MOV((StrIntpData[]){{_SLIT(\""), 0xfe10, {.d_s = st_str}}, {_SLIT("\"), "), 0xfe10, {.d_s = _const_si_s_code}}, {_SLIT(", {.d_s = "), 0xfe10, {.d_s = in_str}}, {_SLIT(" }},{_SLIT(\""), 0xfe10, {.d_s = en_str}}, {_SLIT("\"), 0, {.d_c = 0}}}))"), 0, { .d_c = 0 }}}));
			string_free(&st_str);
			string_free(&en_str);
			return res_str;
		}
		string res2_str =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("str_intp(1, _MOV((StrIntpData[]){{_SLIT(\""), 0xfe10, {.d_s = st_str}}, {_SLIT("\"), "), 0xfe10, {.d_s = _const_si_s_code}}, {_SLIT(", {.d_s = "), 0xfe10, {.d_s = in_str}}, {_SLIT(" }}}))"), 0, { .d_c = 0 }}}));
		string_free(&st_str);
		return res2_str;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

u16* string_to_wide(string _str) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		Array_rune srunes = string_runes(_str);
		{ // Unsafe block
			u16* result = ((u16*)(vcalloc_noscan((srunes.len + 1) * 2)));
			for (int i = 0; i < srunes.len; ++i) {
				rune r = ((rune*)srunes.data)[i];
				result[i] = ((u16)(r));
			}
			return result;
		}
	}
	#endif
	return 0;
}

// Attr: [unsafe]
string string_from_wide(u16* _wstr) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		return _SLIT("");
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [unsafe]
string string_from_wide2(u16* _wstr, int len) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		return _SLIT("");
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

int utf8_getchar(void) {
	int c = getchar();
	int len = utf8_len(((u8)(~c)));
	if (c < 0) {
		return 0;
	} else if (len == 0) {
		return c;
	} else if (len == 1) {
		return -1;
	} else {
		int uc = (c & ((1 << (7 - len)) - 1));
		for (int i = 0; i + 1 < len; i++) {
			int c2 = getchar();
			if (c2 != -1 && (c2 >> 6) == 2) {
				uc <<= 6;
				uc |= ((c2 & 63));
			} else if (c2 == -1) {
				return 0;
			} else {
				return -1;
			}
		}
		return uc;
	}
	return 0;
}

int utf8_char_len(u8 b) {
	return (((0xe5000000 >> (((b >> 3) & 0x1e))) & 3)) + 1;
}

string utf32_to_str(u32 code) {
	{ // Unsafe block
		u8* buffer = malloc_noscan(5);
		string res = utf32_to_str_no_malloc(code, buffer);
		if (res.len == 0) {
			_v_free(buffer);
		}
		return res;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
// Attr: [unsafe]
string utf32_to_str_no_malloc(u32 code, u8* buf) {
	{ // Unsafe block
		int len = utf32_decode_to_buffer(code, buf);
		if (len == 0) {
			return _SLIT("");
		}
		buf[len] = 0;
		return tos(buf, len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
// Attr: [unsafe]
int utf32_decode_to_buffer(u32 code, u8* buf) {
	{ // Unsafe block
		int icode = ((int)(code));
		u8* buffer = ((u8*)(buf));
		if (icode <= 127) {
			buffer[0] = ((u8)(icode));
			return 1;
		} else if (icode <= 2047) {
			buffer[0] = (192 | ((u8)(icode >> 6)));
			buffer[1] = (128 | ((u8)((icode & 63))));
			return 2;
		} else if (icode <= 65535) {
			buffer[0] = (224 | ((u8)(icode >> 12)));
			buffer[1] = (128 | ((((u8)(icode >> 6)) & 63)));
			buffer[2] = (128 | ((u8)((icode & 63))));
			return 3;
		} else if (icode <= 1114111) {
			buffer[0] = (240 | ((u8)(icode >> 18)));
			buffer[1] = (128 | ((((u8)(icode >> 12)) & 63)));
			buffer[2] = (128 | ((((u8)(icode >> 6)) & 63)));
			buffer[3] = (128 | ((u8)((icode & 63))));
			return 4;
		}
	}
	return 0;
}

int string_utf32_code(string _rune) {
	Option_rune _t2 = Array_u8_utf8_to_utf32(string_bytes(_rune));
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(rune*) _t2.data = ((rune)(0));
	}
	
 	return ((int)( (*(rune*)_t2.data)));
}

Option_rune Array_u8_utf8_to_utf32(Array_u8 _bytes) {
	if (_bytes.len == 0) {
		Option_rune _t1;
		opt_ok(&(rune[]) { 0 }, (Option*)(&_t1), sizeof(rune));
		return _t1;
	}
	if (_bytes.len == 1) {
		Option_rune _t2;
		opt_ok(&(rune[]) { ((rune)((*(u8*)/*ee elem_sym */array_get(_bytes, 0)))) }, (Option*)(&_t2), sizeof(rune));
		return _t2;
	}
	if (_bytes.len > 4) {
		return (Option_rune){ .state=2, .err=_v_error(_SLIT("attempted to decode too many bytes, utf-8 is limited to four bytes maximum")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	u8 b = ((u8)(((int)((*(u8*)/*ee elem_sym */array_get(_bytes, 0))))));
	b = b << _bytes.len;
	rune res = ((rune)(b));
	int shift = 6 - _bytes.len;
	for (int i = 1; i < _bytes.len; i++) {
		rune c = ((rune)((*(u8*)/*ee elem_sym */array_get(_bytes, i))));
		res = ((rune)(res)) << shift;
		res |= (c & 63);
		shift = 6;
	}
	Option_rune _t4;
	opt_ok(&(rune[]) { res }, (Option*)(&_t4), sizeof(rune));
	return _t4;
}

int utf8_len(u8 c) {
	int b = 0;
	u8 x = c;
	if (((x & 240)) != 0) {
		x >>= 4;
	} else {
		b += 4;
	}
	if (((x & 12)) != 0) {
		x >>= 2;
	} else {
		b += 2;
	}
	if (((x & 2)) == 0) {
		b++;
	}
	return b;
}

int utf8_str_len(string s) {
	int l = 0;
	int i = 0;
	for (;;) {
		if (!(i < s.len)) break;
		l++;
		i += (((0xe5000000 >> (((s.str[i] >> 3) & 0x1e))) & 3)) + 1;
	}
	return l;
}

int utf8_str_visible_length(string s) {
	int l = 0;
	int ul = 1;
	for (int i = 0; i < s.len; i += ul) {
		u8 c = s.str[i];
		ul = (((0xe5000000 >> (((s.str[i] >> 3) & 0x1e))) & 3)) + 1;
		if (i + ul > s.len) {
			return l;
		}
		l++;
		if (ul == 1) {
			continue;
		}

		if (ul == (2)) {
			u64 r = ((u64)(((((u16)(c)) << 8U) | s.str[i + 1])));
			if (r >= 0xcc80U && r < 0xcdb0U) {
				l--;
			}
		}
		else if (ul == (3)) {
			u64 r = ((u64)(((((u32)(c)) << 16U) | ((((u32)(s.str[i + 1])) << 8U) | s.str[i + 2]))));
			if ((r >= 0xe1aab0U && r <= 0xe1ac7fU) || (r >= 0xe1b780U && r <= 0xe1b87fU) || (r >= 0xe28390U && r <= 0xe2847fU) || (r >= 0xefb8a0U && r <= 0xefb8afU)) {
				l--;
			} else if ((r >= 0xe18480U && r <= 0xe1859fU) || (r >= 0xe2ba80U && r <= 0xe2bf95U) || (r >= 0xe38080U && r <= 0xe4b77fU) || (r >= 0xe4b880U && r <= 0xea807fU) || (r >= 0xeaa5a0U && r <= 0xeaa79fU) || (r >= 0xeab080U && r <= 0xed9eafU) || (r >= 0xefa480U && r <= 0xefac7fU) || (r >= 0xefb8b8U && r <= 0xefb9afU)) {
				l++;
			}
		}
		else if (ul == (4)) {
			u64 r = ((u64)(((((u32)(c)) << 24U) | (((((u32)(s.str[i + 1])) << 16U) | (((u32)(s.str[i + 2])) << 8U)) | s.str[i + 3]))));
			if ((r >= 0x0f9f8880U && r <= 0xf09f8a8fU) || (r >= 0xf09f8c80U && r <= 0xf09f9c90U) || (r >= 0xf09fa490U && r <= 0xf09fa7afU) || (r >= 0xf0a08080U && r <= 0xf180807fU)) {
				l++;
			}
		}
		else {
		};
	}
	return l;
}

// Attr: [inline]
inline bool ArrayFlags_is_empty(ArrayFlags* e) {
	return ((int)(*e)) == 0;
}

// Attr: [inline]
inline bool ArrayFlags_has(ArrayFlags* e, ArrayFlags flag) {
	return ((((int)(*e)) & (((int)(flag))))) != 0;
}

// Attr: [inline]
inline bool ArrayFlags_all(ArrayFlags* e, ArrayFlags flag) {
	return ((((int)(*e)) & (((int)(flag))))) == ((int)(flag));
}

// Attr: [inline]
inline void ArrayFlags_set(ArrayFlags* e, ArrayFlags flag) {
	{ // Unsafe block
		*e = ((ArrayFlags)((((int)(*e)) | (((int)(flag))))));
	}
}

// Attr: [inline]
inline void ArrayFlags_clear(ArrayFlags* e, ArrayFlags flag) {
	{ // Unsafe block
		*e = ((ArrayFlags)((((int)(*e)) & ~(((int)(flag))))));
	}
}

// Attr: [inline]
inline void ArrayFlags_toggle(ArrayFlags* e, ArrayFlags flag) {
	{ // Unsafe block
		*e = ((ArrayFlags)((((int)(*e)) ^ (((int)(flag))))));
	}
}

Array_string os__args_after(string cut_word) {
	if (_const_os__args.len == 0) {
		Array_string _t1 = __new_array_with_default(0, 0, sizeof(string), 0);
		return _t1;
	}
	Array_string cargs = __new_array_with_default(0, 0, sizeof(string), 0);
	if (!Array_string_contains(_const_os__args, cut_word)) {
		cargs = array_clone_to_depth(&_const_os__args, 0);
	} else {
		bool found = false;
		array_push((array*)&cargs, _MOV((string[]){ string_clone((*(string*)/*ee elem_sym */array_get(_const_os__args, 0))) }));
		Array_string _t4;
				Array_string _t3 = (_t4 = _const_os__args, array_slice(_t4, 1, _t4.len));
		for (int _t5 = 0; _t5 < _t3.len; ++_t5) {
			string a = ((string*)_t3.data)[_t5];
			if (string__eq(a, cut_word)) {
				found = true;
				continue;
			}
			if (!found) {
				continue;
			}
			array_push((array*)&cargs, _MOV((string[]){ string_clone(a) }));
		}
	}
	Array_string _t7 = cargs;
	return _t7;
}

Array_string os__args_before(string cut_word) {
	if (_const_os__args.len == 0) {
		Array_string _t1 = __new_array_with_default(0, 0, sizeof(string), 0);
		return _t1;
	}
	Array_string cargs = __new_array_with_default(0, 0, sizeof(string), 0);
	if (!Array_string_contains(_const_os__args, cut_word)) {
		cargs = array_clone_to_depth(&_const_os__args, 0);
	} else {
		array_push((array*)&cargs, _MOV((string[]){ string_clone((*(string*)/*ee elem_sym */array_get(_const_os__args, 0))) }));
		Array_string _t4;
				Array_string _t3 = (_t4 = _const_os__args, array_slice(_t4, 1, _t4.len));
		for (int _t5 = 0; _t5 < _t3.len; ++_t5) {
			string a = ((string*)_t3.data)[_t5];
			if (string__eq(a, cut_word)) {
				break;
			}
			array_push((array*)&cargs, _MOV((string[]){ string_clone(a) }));
		}
	}
	Array_string _t7 = cargs;
	return _t7;
}

string os__getenv(string key) {
	Option_string _t2 = os__getenv_opt(key);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(string*) _t2.data = _SLIT("");
	}
	
 	string _t1 =  (*(string*)_t2.data);
	return _t1;
}

// Attr: [manualfree]
Option_string os__getenv_opt(string key) {
	{ // Unsafe block
		#if defined(_WIN32)
		{
		}
		#else
		{
			char* s = getenv(((char*)(key.str)));
			if (s == ((voidptr)(0))) {
				return (Option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			Option_string _t2;
			opt_ok(&(string[]) { cstring_to_vstring(s) }, (Option*)(&_t2), sizeof(string));
			return _t2;
		}
		#endif
	}
	return (Option_string){0};
}

int os__setenv(string name, string value, bool overwrite) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		{ // Unsafe block
			int _t1 = setenv(((char*)(name.str)), ((char*)(value.str)), overwrite);
			return _t1;
		}
	}
	#endif
	return 0;
}

int os__unsetenv(string name) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		int _t1 = unsetenv(((char*)(name.str)));
		return _t1;
	}
	#endif
	return 0;
}

char** os__unix_environ(void) {
	char** _t1 = ((voidptr)(environ));
	return _t1;
}

Map_string_string os__environ(void) {
	Map_string_string res = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	#if defined(_WIN32)
	{
	}
	#else
	{
		char** start = os__unix_environ();
		int i = 0;
		for (;;) {
			char* x = start[i];
			if (x == 0) {
				break;
			}
			string eline = cstring_to_vstring(x);
			int eq_index = string_index_u8(eline, '=');
			if (eq_index > 0) {
				map_set(&res, &(string[]){string_substr(eline, 0, eq_index)}, &(string[]) { string_substr(eline, eq_index + 1, (eline).len) });
			}
			i++;
		}
	}
	#endif
	Map_string_string _t1 = res;
	return _t1;
}

int os__fd_close(int fd) {
	if (fd == -1) {
		int _t1 = 0;
		return _t1;
	}
	int _t2 = close(fd);
	return _t2;
}

void os__fd_write(int fd, string s) {
	if (fd == -1) {
		return;
	}
	u8* sp = s.str;
	int remaining = s.len;
	for (;;) {
		if (!(remaining > 0)) break;
		int written = write(fd, sp, remaining);
		if (written < 0) {
			return;
		}
		remaining = remaining - written;
		sp = ((voidptr)(sp + written));
	}
}

Array_string os__fd_slurp(int fd) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	if (fd == -1) {
		Array_string _t1 = res;
		return _t1;
	}
	for (;;) {
		multi_return_string_int mr_582 = os__fd_read(fd, 4096);
		string s = mr_582.arg0;
		int b = mr_582.arg1;
		if (b <= 0) {
			break;
		}
		array_push((array*)&res, _MOV((string[]){ string_clone(s) }));
	}
	Array_string _t3 = res;
	return _t3;
}

multi_return_string_int os__fd_read(int fd, int maxbytes) {
	if (fd == -1) {
		return (multi_return_string_int){.arg0=_SLIT(""), .arg1=0};
	}
	{ // Unsafe block
		u8* buf = malloc_noscan(maxbytes + 1);
		int nbytes = read(fd, buf, maxbytes);
		if (nbytes < 0) {
			_v_free(buf);
			return (multi_return_string_int){.arg0=_SLIT(""), .arg1=nbytes};
		}
		buf[nbytes] = 0;
		return (multi_return_string_int){.arg0=tos(buf, nbytes), .arg1=nbytes};
	}
	return (multi_return_string_int){0};
}

Option_os__File os__open_file(string path, string mode, Array_int options) {
	int flags = 0;
	for (int _t1 = 0; _t1 < mode.len; ++_t1) {
		byte m = mode.str[_t1];

		if (m == ('w')) {
			flags |= (_const_os__o_create | _const_os__o_trunc);
		}
		else if (m == ('a')) {
			flags |= (_const_os__o_create | _const_os__o_append);
		}
		else if (m == ('r')) {
			flags |= _const_os__o_rdonly;
		}
		else if (m == ('b')) {
			flags |= _const_os__o_binary;
		}
		else if (m == ('s')) {
			flags |= _const_os__o_sync;
		}
		else if (m == ('n')) {
			flags |= _const_os__o_nonblock;
		}
		else if (m == ('c')) {
			flags |= _const_os__o_noctty;
		}
		else if (m == ('+')) {
			flags |= _const_os__o_rdwr;
		}
		else {
		};
	}
	if (string__eq(mode, _SLIT("r+"))) {
		flags = _const_os__o_rdwr;
	}
	if (string__eq(mode, _SLIT("w"))) {
		flags = ((_const_os__o_wronly | _const_os__o_create) | _const_os__o_trunc);
	}
	if (string__eq(mode, _SLIT("a"))) {
		flags = ((_const_os__o_wronly | _const_os__o_create) | _const_os__o_append);
	}
	int permission = 0666;
	if (options.len > 0) {
		permission = (*(int*)/*ee elem_sym */array_get(options, 0));
	}
	string p = path;
	int fd = open(((char*)(p.str)), flags, permission);
	if (fd == -1) {
		return (Option_os__File){ .state=2, .err=_v_error(os__posix_get_error_msg(errno)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	FILE* cfile = fdopen(fd, ((char*)(mode.str)));
	if (isnil(cfile)) {
		return (Option_os__File){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed to open or create file \""), 0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_os__File _t4;
	opt_ok(&(os__File[]) { ((os__File){.cfile = cfile,.fd = fd,.is_opened = true,}) }, (Option*)(&_t4), sizeof(os__File));
	return _t4;
}

Option_os__File os__open(string path) {
	Option_FILE_ptr _t1 = os__vfopen(path, _SLIT("rb"));
	if (_t1.state != 0) { /*or block*/ 
		Option_os__File _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	FILE* cfile =  (*(FILE**)_t1.data);
	int fd = os__fileno(cfile);
	Option_os__File _t3;
	opt_ok(&(os__File[]) { ((os__File){.cfile = cfile,.fd = fd,.is_opened = true,}) }, (Option*)(&_t3), sizeof(os__File));
	return _t3;
}

Option_os__File os__create(string path) {
	Option_FILE_ptr _t1 = os__vfopen(path, _SLIT("wb"));
	if (_t1.state != 0) { /*or block*/ 
		Option_os__File _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	FILE* cfile =  (*(FILE**)_t1.data);
	int fd = os__fileno(cfile);
	Option_os__File _t3;
	opt_ok(&(os__File[]) { ((os__File){.cfile = cfile,.fd = fd,.is_opened = true,}) }, (Option*)(&_t3), sizeof(os__File));
	return _t3;
}

os__File os__stdin(void) {
	os__File _t1 = ((os__File){.cfile = stdin,.fd = 0,.is_opened = true,});
	return _t1;
}

os__File os__stdout(void) {
	os__File _t1 = ((os__File){.cfile = stdout,.fd = 1,.is_opened = true,});
	return _t1;
}

os__File os__stderr(void) {
	os__File _t1 = ((os__File){.cfile = stderr,.fd = 2,.is_opened = true,});
	return _t1;
}

Option_int os__File_read(os__File* f, Array_u8* buf) {
	if (buf->len == 0) {
		Option_int _t1;
		opt_ok(&(int[]) { 0 }, (Option*)(&_t1), sizeof(int));
		return _t1;
	}
	Option_int _t2 = os__fread(buf->data, 1, buf->len, f->cfile);
	if (_t2.state != 0) { /*or block*/ 
		Option_int _t3;
		memcpy(&_t3, &_t2, sizeof(Option));
		return _t3;
	}
	
 	int nbytes =  (*(int*)_t2.data);
	Option_int _t4;
	opt_ok(&(int[]) { nbytes }, (Option*)(&_t4), sizeof(int));
	return _t4;
}

Option_int os__File_write(os__File* f, Array_u8 buf) {
	if (!f->is_opened) {
		return (Option_int){ .state=2, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int written = ((int)(fwrite(buf.data, 1, buf.len, f->cfile)));
	if (written == 0 && buf.len != 0) {
		return (Option_int){ .state=2, .err=_v_error(_SLIT("0 bytes written")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_int _t3;
	opt_ok(&(int[]) { written }, (Option*)(&_t3), sizeof(int));
	return _t3;
}

Option_int os__File_writeln(os__File* f, string s) {
	if (!f->is_opened) {
		return (Option_int){ .state=2, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int written = ((int)(fwrite(s.str, 1, s.len, f->cfile)));
	if (written == 0 && s.len != 0) {
		return (Option_int){ .state=2, .err=_v_error(_SLIT("0 bytes written")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int x = fputs("\n", f->cfile);
	if (x < 0) {
		return (Option_int){ .state=2, .err=_v_error(_SLIT("could not add newline")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_int _t4;
	opt_ok(&(int[]) { written + 1 }, (Option*)(&_t4), sizeof(int));
	return _t4;
}

Option_int os__File_write_string(os__File* f, string s) {
		Option_void _t1 = os__File_write_full_buffer(f, s.str, ((usize)(s.len)));
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		Option_int _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 ;
	Option_int _t3;
	opt_ok(&(int[]) { s.len }, (Option*)(&_t3), sizeof(int));
	return _t3;
}

Option_int os__File_write_to(os__File* f, u64 pos, Array_u8 buf) {
	if (!f->is_opened) {
		return (Option_int){ .state=2, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			fseeko(f->cfile, pos, SEEK_SET);
			int res = ((int)(fwrite(buf.data, 1, buf.len, f->cfile)));
			if (res == 0 && buf.len != 0) {
				return (Option_int){ .state=2, .err=_v_error(_SLIT("0 bytes written")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			fseeko(f->cfile, 0U, SEEK_END);
			Option_int _t3;
			opt_ok(&(int[]) { res }, (Option*)(&_t3), sizeof(int));
			return _t3;
		}
		#endif
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		int res = ((int)(fwrite(buf.data, 1, buf.len, f->cfile)));
		if (res == 0 && buf.len != 0) {
			return (Option_int){ .state=2, .err=_v_error(_SLIT("0 bytes written")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		fseek(f->cfile, 0, SEEK_END);
		Option_int _t5;
		opt_ok(&(int[]) { res }, (Option*)(&_t5), sizeof(int));
		return _t5;
	}
	#endif
	return (Option_int){ .state=2, .err=_v_error(_SLIT("Could not write to file")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

// Attr: [unsafe]
int os__File_write_ptr(os__File* f, voidptr data, int size) {
	int _t1 = ((int)(fwrite(data, 1, size, f->cfile)));
	return _t1;
}

// Attr: [unsafe]
Option_void os__File_write_full_buffer(os__File* f, voidptr buffer, usize buffer_len) {
	if (buffer_len <= ((usize)(0))) {
		return (Option_void){0};
	}
	if (!f->is_opened) {
		return (Option_void){ .state=2, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	u8* ptr = ((u8*)(buffer));
	i64 remaining_bytes = ((i64)(buffer_len));
	for (;;) {
		if (!(remaining_bytes > 0)) break;
		{ // Unsafe block
			i64 x = ((i64)(fwrite(ptr, 1, remaining_bytes, f->cfile)));
			ptr += x;
			remaining_bytes -= x;
			if (x <= 0) {
				return (Option_void){ .state=2, .err=_v_error(_SLIT("C.fwrite returned 0")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
	}
	return (Option_void){0};
}

// Attr: [unsafe]
int os__File_write_ptr_at(os__File* f, voidptr data, int size, u64 pos) {
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			fseeko(f->cfile, pos, SEEK_SET);
			int res = ((int)(fwrite(data, 1, size, f->cfile)));
			fseeko(f->cfile, 0U, SEEK_END);
			int _t1 = res;
			return _t1;
		}
		#endif
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		int res = ((int)(fwrite(data, 1, size, f->cfile)));
		fseek(f->cfile, 0, SEEK_END);
		int _t2 = res;
		return _t2;
	}
	#endif
	int _t3 = 0;
	return _t3;
}

Option_int os__fread(voidptr ptr, int item_size, int items, FILE* stream) {
	int nbytes = ((int)(fread(ptr, item_size, items, stream)));
	if (nbytes <= 0) {
		if (feof(stream) != 0) {
			return (Option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		if (ferror(stream) != 0) {
			return (Option_int){ .state=2, .err=_v_error(_SLIT("file read error")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	Option_int _t3;
	opt_ok(&(int[]) { nbytes }, (Option*)(&_t3), sizeof(int));
	return _t3;
}

Array_u8 os__File_read_bytes(os__File* f, int size) {
	Array_u8 _t1 = os__File_read_bytes_at(f, size, 0U);
	return _t1;
}

Array_u8 os__File_read_bytes_at(os__File* f, int size, u64 pos) {
	Array_u8 arr = __new_array_with_default(size, 0, sizeof(u8), 0);
	Option_int _t1 = os__File_read_bytes_into(f, pos, &/*arr*/arr);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		Array_u8 _t2 = __new_array_with_default(0, 0, sizeof(u8), 0);
		return _t2;
	}
	
 	int nreadbytes =  (*(int*)_t1.data);
	Array_u8 _t3 = array_slice(arr, 0, nreadbytes);
	return _t3;
}

Option_int os__File_read_bytes_into_newline(os__File* f, Array_u8* buf) {
	if (buf->len == 0) {
		return (Option_int){ .state=2, .err=_v_error(string__plus(_SLIT("read_bytes_into_newline"), _SLIT(": `buf.len` == 0"))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int newline = 10;
	int c = 0;
	int buf_ptr = 0;
	int nbytes = 0;
	FILE* stream = ((FILE*)(f->cfile));
	for (;;) {
		if (!((buf_ptr < buf->len))) break;
		c = getc(stream);

		if (c == (EOF)) {
			if (feof(stream) != 0) {
				Option_int _t2;
				opt_ok(&(int[]) { nbytes }, (Option*)(&_t2), sizeof(int));
				return _t2;
			}
			if (ferror(stream) != 0) {
				return (Option_int){ .state=2, .err=_v_error(_SLIT("file read error")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (c == (newline)) {
			array_set(buf, buf_ptr, &(u8[]) { ((u8)(c)) });
			nbytes++;
			Option_int _t4;
			opt_ok(&(int[]) { nbytes }, (Option*)(&_t4), sizeof(int));
			return _t4;
		}
		else {
			array_set(buf, buf_ptr, &(u8[]) { ((u8)(c)) });
			buf_ptr++;
			nbytes++;
		};
	}
	Option_int _t5;
	opt_ok(&(int[]) { nbytes }, (Option*)(&_t5), sizeof(int));
	return _t5;
}

Option_int os__File_read_bytes_into(os__File* f, u64 pos, Array_u8* buf) {
	if (buf->len == 0) {
		return (Option_int){ .state=2, .err=_v_error(string__plus(_SLIT("read_bytes_into"), _SLIT(": `buf.len` == 0"))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			fseeko(f->cfile, pos, SEEK_SET);
			Option_int _t2 = os__fread(buf->data, 1, buf->len, f->cfile);
			if (_t2.state != 0) { /*or block*/ 
				Option_int _t3;
				memcpy(&_t3, &_t2, sizeof(Option));
				return _t3;
			}
			
 			int nbytes =  (*(int*)_t2.data);
			#if defined(_VDEBUG)
			{
				fseeko(f->cfile, 0U, SEEK_SET);
			}
			#endif
			Option_int _t4;
			opt_ok(&(int[]) { nbytes }, (Option*)(&_t4), sizeof(int));
			return _t4;
		}
		#endif
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		Option_int _t5 = os__fread(buf->data, 1, buf->len, f->cfile);
		if (_t5.state != 0) { /*or block*/ 
			Option_int _t6;
			memcpy(&_t6, &_t5, sizeof(Option));
			return _t6;
		}
		
 		int nbytes =  (*(int*)_t5.data);
		#if defined(_VDEBUG)
		{
			fseek(f->cfile, 0, SEEK_SET);
		}
		#endif
		Option_int _t7;
		opt_ok(&(int[]) { nbytes }, (Option*)(&_t7), sizeof(int));
		return _t7;
	}
	#endif
	return (Option_int){ .state=2, .err=_v_error(_SLIT("Could not read file")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_int os__File_read_from(os__File* f, u64 pos, Array_u8* buf) {
	if (buf->len == 0) {
		Option_int _t1;
		opt_ok(&(int[]) { 0 }, (Option*)(&_t1), sizeof(int));
		return _t1;
	}
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			fseeko(f->cfile, pos, SEEK_SET);
		}
		#endif
		Option_int _t2 = os__fread(buf->data, 1, buf->len, f->cfile);
		if (_t2.state != 0) { /*or block*/ 
			Option_int _t3;
			memcpy(&_t3, &_t2, sizeof(Option));
			return _t3;
		}
		
 		int nbytes =  (*(int*)_t2.data);
		Option_int _t4;
		opt_ok(&(int[]) { nbytes }, (Option*)(&_t4), sizeof(int));
		return _t4;
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		Option_int _t5 = os__fread(buf->data, 1, buf->len, f->cfile);
		if (_t5.state != 0) { /*or block*/ 
			Option_int _t6;
			memcpy(&_t6, &_t5, sizeof(Option));
			return _t6;
		}
		
 		int nbytes =  (*(int*)_t5.data);
		Option_int _t7;
		opt_ok(&(int[]) { nbytes }, (Option*)(&_t7), sizeof(int));
		return _t7;
	}
	#endif
	return (Option_int){ .state=2, .err=_v_error(_SLIT("Could not read file")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_int os__File_read_into_ptr(os__File* f, u8* ptr, int max_size) {
	Option_int _t1 = os__fread(ptr, 1, max_size, f->cfile);
	return _t1;
}

void os__File_flush(os__File* f) {
	if (!f->is_opened) {
		return;
	}
	fflush(f->cfile);
}

string os__FileNotOpenedError_msg(os__FileNotOpenedError err) {
	string _t1 = _SLIT("os: file not opened");
	return _t1;
}

string os__SizeOfTypeIs0Error_msg(os__SizeOfTypeIs0Error err) {
	string _t1 = _SLIT("os: size of type is 0");
	return _t1;
}

IError os__error_file_not_opened(void) {
	IError _t1 = /*&IError*/I_os__FileNotOpenedError_to_Interface_IError(((os__FileNotOpenedError*)memdup(&(os__FileNotOpenedError){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(os__FileNotOpenedError))));
	return _t1;
}

IError os__error_size_of_type_0(void) {
	IError _t1 = /*&IError*/I_os__SizeOfTypeIs0Error_to_Interface_IError(((os__SizeOfTypeIs0Error*)memdup(&(os__SizeOfTypeIs0Error){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(os__SizeOfTypeIs0Error))));
	return _t1;
}

Option_void os__File_seek(os__File* f, i64 pos, os__SeekMode mode) {
	if (!f->is_opened) {
		return (Option_void){ .state=2, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int whence = ((int)(mode));
	int res = 0;
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
		}
		#else
		{
			res = fseeko(f->cfile, pos, whence);
		}
		#endif
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		res = fseek(f->cfile, pos, whence);
	}
	#endif
	if (res == -1) {
		return (Option_void){ .state=2, .err=_v_error(os__posix_get_error_msg(errno)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

Option_i64 os__File_tell(os__File* f) {
	if (!f->is_opened) {
		return (Option_i64){ .state=2, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	i64 pos = ftell(f->cfile);
	if (pos == -1) {
		return (Option_i64){ .state=2, .err=_v_error(os__posix_get_error_msg(errno)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_i64 _t3;
	opt_ok(&(i64[]) { pos }, (Option*)(&_t3), sizeof(i64));
	return _t3;
}

u32 os__FilePermission_bitmask(os__FilePermission p) {
	u32 mask = ((u32)(0U));
	if (p.read) {
		mask |= 4U;
	}
	if (p.write) {
		mask |= 2U;
	}
	if (p.execute) {
		mask |= 1U;
	}
	u32 _t1 = mask;
	return _t1;
}

u32 os__FileMode_bitmask(os__FileMode m) {
	u32 _t1 = ((os__FilePermission_bitmask(m.owner) << 6U | os__FilePermission_bitmask(m.group) << 3U) | os__FilePermission_bitmask(m.others));
	return _t1;
}

os__FileMode os__inode(string path) {
	struct stat attr;
	stat(((char*)(path.str)), &attr);
	os__FileType typ = os__FileType__regular;
	if ((attr.st_mode & ((u32)(S_IFMT))) == ((u32)(S_IFDIR))) {
		typ = os__FileType__directory;
	}
	#if !defined(_WIN32)
	{
		if ((attr.st_mode & ((u32)(S_IFMT))) == ((u32)(S_IFCHR))) {
			typ = os__FileType__character_device;
		} else if ((attr.st_mode & ((u32)(S_IFMT))) == ((u32)(S_IFBLK))) {
			typ = os__FileType__block_device;
		} else if ((attr.st_mode & ((u32)(S_IFMT))) == ((u32)(S_IFIFO))) {
			typ = os__FileType__fifo;
		} else if ((attr.st_mode & ((u32)(S_IFMT))) == ((u32)(S_IFLNK))) {
			typ = os__FileType__symbolic_link;
		} else if ((attr.st_mode & ((u32)(S_IFMT))) == ((u32)(S_IFSOCK))) {
			typ = os__FileType__socket;
		}
	}
	#endif
	#if defined(_WIN32)
	{
	}
	#else
	{
		os__FileMode _t1 = ((os__FileMode){.typ = typ,.owner = ((os__FilePermission){.read = ((attr.st_mode & ((u32)(S_IRUSR)))) != 0U,.write = ((attr.st_mode & ((u32)(S_IWUSR)))) != 0U,.execute = ((attr.st_mode & ((u32)(S_IXUSR)))) != 0U,}),.group = ((os__FilePermission){.read = ((attr.st_mode & ((u32)(S_IRGRP)))) != 0U,.write = ((attr.st_mode & ((u32)(S_IWGRP)))) != 0U,.execute = ((attr.st_mode & ((u32)(S_IXGRP)))) != 0U,}),.others = ((os__FilePermission){.read = ((attr.st_mode & ((u32)(S_IROTH)))) != 0U,.write = ((attr.st_mode & ((u32)(S_IWOTH)))) != 0U,.execute = ((attr.st_mode & ((u32)(S_IXOTH)))) != 0U,}),});
		return _t1;
	}
	#endif
	return (os__FileMode){.owner = (os__FilePermission){.read = 0,.write = 0,.execute = 0,},.group = (os__FilePermission){.read = 0,.write = 0,.execute = 0,},.others = (os__FilePermission){.read = 0,.write = 0,.execute = 0,},};
}

// Attr: [manualfree]
Option_Array_u8 os__read_bytes(string path) {
bool os__read_bytes_defer_0 = false;
FILE* fp;
	Option_FILE_ptr _t1 = os__vfopen(path, _SLIT("rb"));
	if (_t1.state != 0) { /*or block*/ 
		Option_Array_u8 _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	fp =  (*(FILE**)_t1.data);
	os__read_bytes_defer_0 = true;
	int cseek = fseek(fp, 0, SEEK_END);
	if (cseek != 0) {
		Option_Array_u8 _t3 = (Option_Array_u8){ .state=2, .err=_v_error(_SLIT("fseek failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__read_bytes_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t3;
	}
	i64 fsize = ftell(fp);
	if (fsize < 0) {
		Option_Array_u8 _t4 = (Option_Array_u8){ .state=2, .err=_v_error(_SLIT("ftell failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__read_bytes_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t4;
	}
	int len = ((int)(fsize));
	if (((i64)(len)) < fsize) {
		Option_Array_u8 _t5 = (Option_Array_u8){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = fsize}}, {_SLIT(" cast to int results in "), 0xfe07, {.d_i32 = ((int)(fsize))}}, {_SLIT(")"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__read_bytes_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t5;
	}
	rewind(fp);
	Array_u8 res = __new_array_with_default(len, 0, sizeof(u8), 0);
	int nr_read_elements = ((int)(fread(res.data, len, 1, fp)));
	if (nr_read_elements == 0 && fsize > 0) {
		Option_Array_u8 _t6 = (Option_Array_u8){ .state=2, .err=_v_error(_SLIT("fread failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__read_bytes_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t6;
	}
	array_trim(&res, nr_read_elements * len);
	Option_Array_u8 _t7;
	opt_ok(&(Array_u8[]) { res }, (Option*)(&_t7), sizeof(Array_u8));
	// Defer begin
	if (os__read_bytes_defer_0) {
		fclose(fp);
	}
	// Defer end
	return _t7;
}

Option_string os__read_file(string path) {
bool os__read_file_defer_0 = false;
FILE* fp;
	string mode = _SLIT("rb");
	Option_FILE_ptr _t1 = os__vfopen(path, mode);
	if (_t1.state != 0) { /*or block*/ 
		Option_string _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	fp =  (*(FILE**)_t1.data);
	os__read_file_defer_0 = true;
	int cseek = fseek(fp, 0, SEEK_END);
	if (cseek != 0) {
		Option_string _t3 = (Option_string){ .state=2, .err=_v_error(_SLIT("fseek failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__read_file_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t3;
	}
	i64 fsize = ftell(fp);
	if (fsize < 0) {
		Option_string _t4 = (Option_string){ .state=2, .err=_v_error(_SLIT("ftell failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__read_file_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t4;
	}
	rewind(fp);
	int allocate = ((int)(fsize));
	if (((i64)(allocate)) < fsize) {
		Option_string _t5 = (Option_string){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = fsize}}, {_SLIT(" cast to int results in "), 0xfe07, {.d_i32 = ((int)(fsize))}}, {_SLIT(")"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__read_file_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t5;
	}
	{ // Unsafe block
		u8* str = malloc_noscan(allocate + 1);
		int nelements = ((int)(fread(str, 1, allocate, fp)));
		int is_eof = ((int)(feof(fp)));
		int is_error = ((int)(ferror(fp)));
		if (is_eof == 0 && is_error != 0) {
			_v_free(str);
			Option_string _t6 = (Option_string){ .state=2, .err=_v_error(_SLIT("fread failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
			// Defer begin
			if (os__read_file_defer_0) {
				fclose(fp);
			}
			// Defer end
			return _t6;
		}
		str[nelements] = 0;
		if (nelements == 0) {
			Option_string _t7;
			opt_ok(&(string[]) { u8_vstring(str) }, (Option*)(&_t7), sizeof(string));
			// Defer begin
			if (os__read_file_defer_0) {
				fclose(fp);
			}
			// Defer end
			return _t7;
		}
		Option_string _t8;
		opt_ok(&(string[]) { u8_vstring_with_len(str, nelements) }, (Option*)(&_t8), sizeof(string));
		// Defer begin
		if (os__read_file_defer_0) {
			fclose(fp);
		}
		// Defer end
		return _t8;
	}
	return (Option_string){0};
}

Option_void os__truncate(string path, u64 len) {
bool os__truncate_defer_0 = false;
int fp;
	fp = open(((char*)(path.str)), (_const_os__o_wronly | _const_os__o_trunc), 0);
	os__truncate_defer_0 = true;
	if (fp < 0) {
		Option_void _t1 = (Option_void){ .state=2, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__truncate_defer_0) {
			close(fp);
		}
		// Defer end
		return _t1;
	}
	#if defined(_WIN32)
	{
	}
	#else
	{
		if (ftruncate(fp, len) != 0) {
			Option_void _t2 = (Option_void){ .state=2, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
			// Defer begin
			if (os__truncate_defer_0) {
				close(fp);
			}
			// Defer end
			return _t2;
		}
	}
	#endif
	// Defer begin
	if (os__truncate_defer_0) {
		close(fp);
	}
	// Defer end
	return (Option_void){0};
}

void os__eprintln_unknown_file_size(void) {
	eprintln(string__plus(_SLIT("os.file_size() Cannot determine file-size: "), os__posix_get_error_msg(errno)));
}

u64 os__file_size(string path) {
	struct stat s;
	{ // Unsafe block
		#if defined(TARGET_IS_64BIT)
		{
			#if defined(_WIN32)
			{
			}
			#else
			{
				if (stat(((char*)(path.str)), &s) != 0) {
					os__eprintln_unknown_file_size();
					u64 _t1 = 0U;
					return _t1;
				}
				u64 _t2 = ((u64)(s.st_size));
				return _t2;
			}
			#endif
		}
		#endif
		#if defined(TARGET_IS_32BIT)
		{
			#if defined(_VDEBUG)
			{
				eprintln(_SLIT("Using os.file_size() on 32bit systems may not work on big files."));
			}
			#endif
			#if defined(_WIN32)
			{
			}
			#else
			{
				if (stat(((char*)(path.str)), &s) != 0) {
					os__eprintln_unknown_file_size();
					u64 _t3 = 0U;
					return _t3;
				}
				u64 _t4 = ((u64)(s.st_size));
				return _t4;
			}
			#endif
		}
		#endif
	}
	u64 _t5 = 0U;
	return _t5;
}

Option_void os__mv(string src, string dst) {
	string rdst = dst;
	if (os__is_dir(rdst)) {
		rdst = os__join_path_single(string_trim_right(rdst, _const_os__path_separator), os__file_name(string_trim_right(src, _const_os__path_separator)));
	}
	#if defined(_WIN32)
	{
	}
	#else
	{
		int ret = rename(((char*)(src.str)), ((char*)(rdst.str)));
		if (ret != 0) {
			return (Option_void){ .state=2, .err=error_with_code( str_intp(3, _MOV((StrIntpData[]){{_SLIT("failed to rename "), 0xfe10, {.d_s = src}}, {_SLIT(" to "), 0xfe10, {.d_s = dst}}, {_SLIT0, 0, { .d_c = 0 }}})), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	#endif
	return (Option_void){0};
}

Option_void os__cp(string src, string dst) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		int fp_from = open(((char*)(src.str)), O_RDONLY, 0);
		if (fp_from < 0) {
			return (Option_void){ .state=2, .err=error_with_code( str_intp(2, _MOV((StrIntpData[]){{_SLIT("cp: failed to open "), 0xfe10, {.d_s = src}}, {_SLIT0, 0, { .d_c = 0 }}})), ((int)(fp_from))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		int fp_to = open(((char*)(dst.str)), ((O_WRONLY | O_CREAT) | O_TRUNC), (S_IWUSR | S_IRUSR));
		if (fp_to < 0) {
			close(fp_from);
			return (Option_void){ .state=2, .err=error_with_code( str_intp(3, _MOV((StrIntpData[]){{_SLIT("cp (permission): failed to write to "), 0xfe10, {.d_s = dst}}, {_SLIT(" (fp_to: "), 0xfe07, {.d_i32 = fp_to}}, {_SLIT(")"), 0, { .d_c = 0 }}})), ((int)(fp_to))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		Array_fixed_u8_1024 buf = {0};
		int count = 0;
		for (;;) {
			count = read(fp_from, &buf[0], sizeof(Array_fixed_u8_1024));
			if (count == 0) {
				break;
			}
			if (write(fp_to, &buf[0], count) < 0) {
				close(fp_to);
				close(fp_from);
				return (Option_void){ .state=2, .err=error_with_code( str_intp(2, _MOV((StrIntpData[]){{_SLIT("cp: failed to write to "), 0xfe10, {.d_s = dst}}, {_SLIT0, 0, { .d_c = 0 }}})), ((int)(-1))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		struct stat from_attr;
		stat(((char*)(src.str)), &from_attr);
		if (chmod(((char*)(dst.str)), from_attr.st_mode) < 0) {
			close(fp_to);
			close(fp_from);
			return (Option_void){ .state=2, .err=error_with_code( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed to set permissions for "), 0xfe10, {.d_s = dst}}, {_SLIT0, 0, { .d_c = 0 }}})), ((int)(-1))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		close(fp_to);
		close(fp_from);
	}
	#endif
	return (Option_void){0};
}

Option_FILE_ptr os__vfopen(string path, string mode) {
	if (path.len == 0) {
		return (Option_FILE_ptr){ .state=2, .err=_v_error(_SLIT("vfopen called with \"\"")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	voidptr fp = ((voidptr)(0));
	#if defined(_WIN32)
	{
	}
	#else
	{
		fp = fopen(((char*)(path.str)), ((char*)(mode.str)));
	}
	#endif
	if (isnil(fp)) {
		return (Option_FILE_ptr){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed to open file \""), 0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	} else {
		Option_FILE_ptr _t3;
		opt_ok(&(FILE*[]) { fp }, (Option*)(&_t3), sizeof(FILE*));
		return _t3;
	}
	return (Option_FILE_ptr){0};
}

int os__fileno(voidptr cfile) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		FILE* cfile_casted = ((FILE*)(0));
		cfile_casted = cfile;
		int _t1 = fileno(cfile_casted);
		return _t1;
	}
	#endif
	return 0;
}

voidptr os__vpopen(string path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		u8* cpath = path.str;
		voidptr _t1 = popen(((char*)(cpath)), "r");
		return _t1;
	}
	#endif
	return 0;
}

multi_return_int_bool os__posix_wait4_to_exit_status(int waitret) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		int ret = 0;
		bool is_signaled = true;
		if (WIFEXITED(waitret)) {
			ret = WEXITSTATUS(waitret);
			is_signaled = false;
		} else if (WIFSIGNALED(waitret)) {
			ret = WTERMSIG(waitret);
			is_signaled = true;
		}
		return (multi_return_int_bool){.arg0=ret, .arg1=is_signaled};
	}
	#endif
	return (multi_return_int_bool){0};
}

string os__posix_get_error_msg(int code) {
	char* ptr_text = strerror(code);
	if (ptr_text == 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	string _t2 = tos3(ptr_text);
	return _t2;
}

int os__vpclose(voidptr f) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		multi_return_int_bool mr_8922 = os__posix_wait4_to_exit_status(pclose(f));
		int ret = mr_8922.arg0;
		int _t1 = ret;
		return _t1;
	}
	#endif
	return 0;
}

int os__system(string cmd) {
	int ret = 0;
	#if defined(_WIN32)
	{
	}
	#else
	{
		#if defined(__TARGET_IOS__)
		{
		}
		#else
		{
			{ // Unsafe block
				ret = system(((char*)(cmd.str)));
			}
		}
		#endif
	}
	#endif
	if (ret == -1) {
		os__print_c_errno();
	}
	#if !defined(_WIN32)
	{
		multi_return_int_bool mr_9929 = os__posix_wait4_to_exit_status(ret);
		int pret = mr_9929.arg0;
		bool is_signaled = mr_9929.arg1;
		if (is_signaled) {
			println(string__plus(string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Terminated by signal "), 0x4fe27, {.d_i32 = ret}}, {_SLIT(" ("), 0, { .d_c = 0 }}})), os__sigint_to_signal_name(pret)), _SLIT(")")));
		}
		ret = pret;
	}
	#endif
	int _t1 = ret;
	return _t1;
}

bool os__exists(string path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		bool _t1 = access(((char*)(path.str)), _const_os__f_ok) != -1;
		return _t1;
	}
	#endif
	return 0;
}

bool os__is_executable(string path) {
	bool _t1 = access(((char*)(path.str)), _const_os__x_ok) != -1;
	return _t1;
}

// Attr: [manualfree]
bool os__is_writable(string path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		bool _t1 = access(((char*)(path.str)), _const_os__w_ok) != -1;
		return _t1;
	}
	#endif
	return 0;
}

// Attr: [manualfree]
bool os__is_readable(string path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		bool _t1 = access(((char*)(path.str)), _const_os__r_ok) != -1;
		return _t1;
	}
	#endif
	return 0;
}

Option_void os__rm(string path) {
	int rc = 0;
	#if defined(_WIN32)
	{
	}
	#else
	{
		rc = remove(((char*)(path.str)));
	}
	#endif
	if (rc == -1) {
		return (Option_void){ .state=2, .err=_v_error(string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed to remove \""), 0xfe10, {.d_s = path}}, {_SLIT("\": "), 0, { .d_c = 0 }}})), os__posix_get_error_msg(errno))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

Option_void os__rmdir(string path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		int rc = rmdir(((char*)(path.str)));
		if (rc == -1) {
			return (Option_void){ .state=2, .err=_v_error(os__posix_get_error_msg(errno)), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	#endif
	return (Option_void){0};
}

void os__print_c_errno(void) {
	int e = errno;
	string se = tos_clone(((u8*)(strerror(e))));
	println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("errno="), 0xfe07, {.d_i32 = e}}, {_SLIT(" err="), 0xfe10, {.d_s = se}}, {_SLIT0, 0, { .d_c = 0 }}})));
}

string os__get_raw_line(void) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		usize max = ((usize)(0));
		char* buf = ((char*)(0));
		int nr_chars = getline(&buf, &max, stdin);
		string _t1 = tos(((u8*)(buf)), (nr_chars < 0 ? (0) : (nr_chars)));
		return _t1;
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

Array_u8 os__get_raw_stdin(void) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		usize max = ((usize)(0));
		char* buf = ((char*)(0));
		int nr_chars = getline(&buf, &max, stdin);
		Array_u8 _t1 = ((array){.element_size = 1,.data = ((voidptr)(buf)),.offset = 0,.len = (nr_chars < 0 ? (0) : (nr_chars)),.cap = ((int)(max)),.flags = 0,});
		return _t1;
	}
	#endif
	return __new_array(0, 0, sizeof(u8));
}

// Attr: [manualfree]
string os__executable(void) {
bool os__executable_defer_0 = false;
u8* result;
	int size = os__max_path_bufffer_size();
	result = vcalloc_noscan(size);
	os__executable_defer_0 = true;
	int pid = getpid();
	int ret = proc_pidpath(pid, result, _const_os__max_path_len);
	if (ret <= 0) {
		eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("os.executable() failed at calling proc_pidpath with pid: "), 0xfe07, {.d_i32 = pid}}, {_SLIT(" . proc_pidpath returned "), 0xfe07, {.d_i32 = ret}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
		string _t1 = os__executable_fallback();
		// Defer begin
		if (os__executable_defer_0) {
			_v_free(result);
		}
		// Defer end
		return _t1;
	}
	string res = tos_clone(result);
	string _t2 = res;
	// Defer begin
	if (os__executable_defer_0) {
		_v_free(result);
	}
	// Defer end
	return _t2;
	string _t3 = os__executable_fallback();
	// Defer begin
	if (os__executable_defer_0) {
		_v_free(result);
	}
	// Defer end
	return _t3;
}

bool os__is_dir(string path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		struct stat statbuf;
		if (stat(((char*)(path.str)), &statbuf) != 0) {
			bool _t1 = false;
			return _t1;
		}
		int val = (((int)(statbuf.st_mode)) & _const_os__s_ifmt);
		bool _t2 = val == _const_os__s_ifdir;
		return _t2;
	}
	#endif
	return 0;
}

bool os__is_link(string path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		struct stat statbuf;
		if (lstat(((char*)(path.str)), &statbuf) != 0) {
			bool _t1 = false;
			return _t1;
		}
		bool _t2 = (((int)(statbuf.st_mode)) & _const_os__s_ifmt) == _const_os__s_iflnk;
		return _t2;
	}
	#endif
	return 0;
}

Option_void os__chdir(string path) {
	#if defined(_WIN32)
	#else
	int ret = chdir(((char*)(path.str)));
	#endif
	;
	if (ret == -1) {
		return (Option_void){ .state=2, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

int os__max_path_bufffer_size(void) {
	int size = _const_os__max_path_len;
	int _t1 = size;
	return _t1;
}

// Attr: [manualfree]
string os__getwd(void) {
bool os__getwd_defer_0 = false;
u8* buf;
	{ // Unsafe block
		buf = vcalloc_noscan(os__max_path_bufffer_size());
		os__getwd_defer_0 = true;
		#if defined(_WIN32)
		{
		}
		#else
		{
			if (getcwd(((char*)(buf)), _const_os__max_path_len) == 0) {
				string _t1 = _SLIT("");
				// Defer begin
				if (os__getwd_defer_0) {
					_v_free(buf);
				}
				// Defer end
				return _t1;
			}
			string res = tos_clone(buf);
			string _t2 = res;
			// Defer begin
			if (os__getwd_defer_0) {
				_v_free(buf);
			}
			// Defer end
			return _t2;
		}
		#endif
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
string os__real_path(string fpath) {
bool os__real_path_defer_0 = false;
u8* fullpath;
	int size = os__max_path_bufffer_size();
	fullpath = vcalloc_noscan(size);
	os__real_path_defer_0 = true;
	string res = _SLIT("");
	#if defined(_WIN32)
	{
	}
	#else
	{
		char* ret = ((char*)(realpath(((char*)(fpath.str)), ((char*)(fullpath)))));
		if (ret == 0) {
			string_free(&res);
			string _t1 = string_clone(fpath);
			// Defer begin
			if (os__real_path_defer_0) {
				_v_free(fullpath);
			}
			// Defer end
			return _t1;
		}
		string_free(&res);
		res = tos_clone(fullpath);
	}
	#endif
	os__normalize_drive_letter(res);
	string _t2 = res;
	// Defer begin
	if (os__real_path_defer_0) {
		_v_free(fullpath);
	}
	// Defer end
	return _t2;
}

// Attr: [direct_array_access]
// Attr: [manualfree]
// Attr: [unsafe]
void os__normalize_drive_letter(string path) {
	#if !defined(_WIN32)
	{
		return;
	}
	#endif
	if (path.len > 2 && path.str[ 0] >= 'a' && path.str[ 0] <= 'z' && path.str[ 1] == ':' && path.str[ 2] == _const_os__path_separator.str[ 0]) {
		{ // Unsafe block
			u8* x = &path.str[0];
			(*x) = *x - 32;
		}
	}
}

int os__fork(void) {
	int pid = -1;
	#if !defined(_WIN32)
	{
		pid = fork();
	}
	#endif
	int _t1 = pid;
	return _t1;
}

int os__wait(void) {
	int pid = -1;
	#if !defined(_WIN32)
	{
		pid = wait(0);
	}
	#endif
	int _t1 = pid;
	return _t1;
}

i64 os__file_last_mod_unix(string path) {
	struct stat attr;
	stat(((char*)(path.str)), &attr);
	i64 _t1 = ((i64)(attr.st_mtime));
	return _t1;
}

void os__flush(void) {
	fflush(stdout);
}

Option_void os__chmod(string path, int mode) {
	if (chmod(((char*)(path.str)), mode) != 0) {
		return (Option_void){ .state=2, .err=error_with_code(string__plus(_SLIT("chmod failed: "), os__posix_get_error_msg(errno)), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

Option_void os__chown(string path, int owner, int group) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		if (chown(((char*)(path.str)), owner, group) != 0) {
			return (Option_void){ .state=2, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	#endif
	return (Option_void){0};
}

Option_os__File os__open_append(string path) {
	os__File file = ((os__File){.cfile = 0,.fd = 0,.is_opened = 0,});
	#if defined(_WIN32)
	{
	}
	#else
	{
		u8* cpath = path.str;
		file = ((os__File){.cfile = fopen(((char*)(cpath)), "ab"),.fd = 0,.is_opened = 0,});
	}
	#endif
	if (isnil(file.cfile)) {
		return (Option_os__File){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed to create(append) file \""), 0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	file.is_opened = true;
	Option_os__File _t2;
	opt_ok(&(os__File[]) { file }, (Option*)(&_t2), sizeof(os__File));
	return _t2;
}

Option_void os__execvp(string cmdpath, Array_string cmdargs) {
	Array_char_ptr cargs = __new_array_with_default(0, 0, sizeof(char*), 0);
	array_push((array*)&cargs, _MOV((char*[]){ ((char*)(cmdpath.str)) }));
	for (int i = 0; i < cmdargs.len; ++i) {
		array_push((array*)&cargs, _MOV((char*[]){ ((char*)((*(string*)/*ee elem_sym */array_get(cmdargs, i)).str)) }));
	}
	array_push((array*)&cargs, _MOV((char*[]){ ((char*)(0)) }));
	int res = ((int)(0));
	#if defined(_WIN32)
	{
	}
	#else
	{
		res = execvp(((char*)(cmdpath.str)), cargs.data);
	}
	#endif
	if (res == -1) {
		return (Option_void){ .state=2, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_v_exit(res);
	VUNREACHABLE();
	return (Option_void){0};
}

Option_void os__execve(string cmdpath, Array_string cmdargs, Array_string envs) {
	Array_char_ptr cargv = __new_array_with_default(0, 0, sizeof(char*), 0);
	Array_char_ptr cenvs = __new_array_with_default(0, 0, sizeof(char*), 0);
	array_push((array*)&cargv, _MOV((char*[]){ ((char*)(cmdpath.str)) }));
	for (int i = 0; i < cmdargs.len; ++i) {
		array_push((array*)&cargv, _MOV((char*[]){ ((char*)((*(string*)/*ee elem_sym */array_get(cmdargs, i)).str)) }));
	}
	for (int i = 0; i < envs.len; ++i) {
		array_push((array*)&cenvs, _MOV((char*[]){ ((char*)((*(string*)/*ee elem_sym */array_get(envs, i)).str)) }));
	}
	array_push((array*)&cargv, _MOV((char*[]){ ((char*)(0)) }));
	array_push((array*)&cenvs, _MOV((char*[]){ ((char*)(0)) }));
	int res = ((int)(0));
	#if defined(_WIN32)
	{
	}
	#else
	{
		res = execve(((char*)(cmdpath.str)), cargv.data, cenvs.data);
	}
	#endif
	if (res == -1) {
		return (Option_void){ .state=2, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

int os__is_atty(int fd) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		int _t1 = isatty(fd);
		return _t1;
	}
	#endif
	return 0;
}

Option_void os__write_file_array(string path, array buffer) {
	Option_os__File _t1 = os__create(path);
	if (_t1.state != 0) { /*or block*/ 
		Option_void _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	os__File f =  (*(os__File*)_t1.data);
		Option_void _t3 = os__File_write_full_buffer(&f, buffer.data, ((usize)(buffer.len * buffer.element_size)));
	if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
		Option_void _t4;
		memcpy(&_t4, &_t3, sizeof(Option));
		return _t4;
	}
	
 ;
	os__File_close(&f);
	return (Option_void){0};
}

Option_Array_string os__glob(Array_string patterns) {
	Array_string matches = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < patterns.len; ++_t1) {
		string pattern = ((string*)patterns.data)[_t1];
		Option_void _t2 = os__native_glob_pattern(pattern, &/*arr*/matches);
		if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
			Option_Array_string _t3;
			memcpy(&_t3, &_t2, sizeof(Option));
			return _t3;
		}
		
 ;
	}
	qsort(matches.data, matches.len, matches.element_size, (int (*)(const void *, const void *))&compare_12251921909942893683_string);
	Option_Array_string _t4;
	opt_ok(&(Array_string[]) { matches }, (Option*)(&_t4), sizeof(Array_string));
	return _t4;
}

IError os__last_error(void) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		int code = errno;
		string msg = os__posix_get_error_msg(code);
		IError _t1 = error_with_code(msg, code);
		return _t1;
	}
	#endif
	return (IError){0};
}

// Attr: [unsafe]
void os__Result_free(os__Result* result) {
	string_free(&result->output);
}

Option_void os__cp_all(string src, string dst, bool overwrite) {
	string source_path = os__real_path(src);
	string dest_path = os__real_path(dst);
	if (!os__exists(source_path)) {
		return (Option_void){ .state=2, .err=_v_error(_SLIT("Source path doesn't exist")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (!os__is_dir(source_path)) {
		string fname = os__file_name(source_path);
		string adjusted_path = (os__is_dir(dest_path) ? (os__join_path_single(dest_path, fname)) : (dest_path));
		if (os__exists(adjusted_path)) {
			if (overwrite) {
				Option_void _t2 = os__rm(adjusted_path);
				if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
					Option_void _t3;
					memcpy(&_t3, &_t2, sizeof(Option));
					return _t3;
				}
				
 ;
			} else {
				return (Option_void){ .state=2, .err=_v_error(_SLIT("Destination file path already exist")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		Option_void _t5 = os__cp(source_path, adjusted_path);
		if (_t5.state != 0 && _t5.err._typ != _IError_None___index) {
			Option_void _t6;
			memcpy(&_t6, &_t5, sizeof(Option));
			return _t6;
		}
		
 ;
		return (Option_void){0};
	}
	if (!os__exists(dest_path)) {
		Option_bool _t7 = os__mkdir(dest_path);
		if (_t7.state != 0) { /*or block*/ 
			Option_void _t8;
			memcpy(&_t8, &_t7, sizeof(Option));
			return _t8;
		}
		
  (*(bool*)_t7.data);
	}
	if (!os__is_dir(dest_path)) {
		return (Option_void){ .state=2, .err=_v_error(_SLIT("Destination path is not a valid directory")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_Array_string _t10 = os__ls(source_path);
	if (_t10.state != 0) { /*or block*/ 
		Option_void _t11;
		memcpy(&_t11, &_t10, sizeof(Option));
		return _t11;
	}
	
 	Array_string files =  (*(Array_string*)_t10.data);
	for (int _t12 = 0; _t12 < files.len; ++_t12) {
		string file = ((string*)files.data)[_t12];
		string sp = os__join_path_single(source_path, file);
		string dp = os__join_path_single(dest_path, file);
		if (os__is_dir(sp)) {
			if (!os__exists(dp)) {
				Option_bool _t13 = os__mkdir(dp);
				if (_t13.state != 0) { /*or block*/ 
					Option_void _t14;
					memcpy(&_t14, &_t13, sizeof(Option));
					return _t14;
				}
				
  (*(bool*)_t13.data);
			}
		}
		Option_void _t15 = os__cp_all(sp, dp, overwrite);
		if (_t15.state != 0 && _t15.err._typ != _IError_None___index) {
			IError err = _t15.err;
			Option_void _t16 = os__rmdir(dp);
			if (_t16.state != 0 && _t16.err._typ != _IError_None___index) {
				err = _t16.err;
				return (Option_void){ .state=2, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 ;
			return (Option_void){ .state=2, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 ;
	}
	return (Option_void){0};
}

Option_void os__mv_by_cp(string source, string target) {
	Option_void _t1 = os__cp(source, target);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		Option_void _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 ;
	Option_void _t3 = os__rm(source);
	if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
		Option_void _t4;
		memcpy(&_t4, &_t3, sizeof(Option));
		return _t4;
	}
	
 ;
	return (Option_void){0};
}

// Attr: [manualfree]
Option_Array_string os__read_lines(string path) {
	Option_string _t1 = os__read_file(path);
	if (_t1.state != 0) { /*or block*/ 
		Option_Array_string _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	string buf =  (*(string*)_t1.data);
	Array_string res = string_split_into_lines(buf);
	string_free(&buf);
	Option_Array_string _t3;
	opt_ok(&(Array_string[]) { res }, (Option*)(&_t3), sizeof(Array_string));
	return _t3;
}

string os__sigint_to_signal_name(int si) {

	if (si == (1)) {
		string _t1 = _SLIT("SIGHUP");
		return _t1;
	}
	else if (si == (2)) {
		string _t2 = _SLIT("SIGINT");
		return _t2;
	}
	else if (si == (3)) {
		string _t3 = _SLIT("SIGQUIT");
		return _t3;
	}
	else if (si == (4)) {
		string _t4 = _SLIT("SIGILL");
		return _t4;
	}
	else if (si == (6)) {
		string _t5 = _SLIT("SIGABRT");
		return _t5;
	}
	else if (si == (8)) {
		string _t6 = _SLIT("SIGFPE");
		return _t6;
	}
	else if (si == (9)) {
		string _t7 = _SLIT("SIGKILL");
		return _t7;
	}
	else if (si == (11)) {
		string _t8 = _SLIT("SIGSEGV");
		return _t8;
	}
	else if (si == (13)) {
		string _t9 = _SLIT("SIGPIPE");
		return _t9;
	}
	else if (si == (14)) {
		string _t10 = _SLIT("SIGALRM");
		return _t10;
	}
	else if (si == (15)) {
		string _t11 = _SLIT("SIGTERM");
		return _t11;
	}
	else {
	};
	string _t12 = _SLIT("unknown");
	return _t12;
}

Option_void os__rmdir_all(string path) {
	string ret_err = _SLIT("");
	Option_Array_string _t1 = os__ls(path);
	if (_t1.state != 0) { /*or block*/ 
		Option_void _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	Array_string items =  (*(Array_string*)_t1.data);
	for (int _t3 = 0; _t3 < items.len; ++_t3) {
		string item = ((string*)items.data)[_t3];
		string fullpath = os__join_path_single(path, item);
		if (os__is_dir(fullpath) && !os__is_link(fullpath)) {
			Option_void _t4 = os__rmdir_all(fullpath);
			if (_t4.state != 0 && _t4.err._typ != _IError_None___index) {
				IError err = _t4.err;
				ret_err = IError_name_table[err._typ]._method_msg(err._object);
			}
			
 ;
		} else {
			Option_void _t5 = os__rm(fullpath);
			if (_t5.state != 0 && _t5.err._typ != _IError_None___index) {
				IError err = _t5.err;
				ret_err = IError_name_table[err._typ]._method_msg(err._object);
			}
			
 ;
		}
	}
	Option_void _t6 = os__rmdir(path);
	if (_t6.state != 0 && _t6.err._typ != _IError_None___index) {
		IError err = _t6.err;
		ret_err = IError_name_table[err._typ]._method_msg(err._object);
	}
	
 ;
	if (ret_err.len > 0) {
		return (Option_void){ .state=2, .err=_v_error(ret_err), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

// Attr: [manualfree]
bool os__is_dir_empty(string path) {
	Option_Array_string _t1 = os__ls(path);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t2 = true;
		return _t2;
	}
	
 	Array_string items =  (*(Array_string*)_t1.data);
	bool res = items.len == 0;
	array_free(&items);
	bool _t3 = res;
	return _t3;
}

string os__file_ext(string path) {
	Option_int _t1 = string_last_index(path, _SLIT("."));
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		string _t2 = _SLIT("");
		return _t2;
	}
	
 	int pos =  (*(int*)_t1.data);
	string _t3 = string_substr(path, pos, (path).len);
	return _t3;
}

string os__dir(string opath) {
	if ((opath).len == 0) {
		string _t1 = _SLIT(".");
		return _t1;
	}
	string path = string_replace_each(opath, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("/"), string_clone(_const_os__path_separator), _SLIT("\\"), string_clone(_const_os__path_separator)})));
	Option_int _t2 = string_last_index(path, _const_os__path_separator);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		string _t3 = _SLIT(".");
		return _t3;
	}
	
 	int pos =  (*(int*)_t2.data);
	if (pos == 0 && string__eq(_const_os__path_separator, _SLIT("/"))) {
		string _t4 = _SLIT("/");
		return _t4;
	}
	string _t5 = string_substr(path, 0, pos);
	return _t5;
}

string os__base(string opath) {
	if ((opath).len == 0) {
		string _t1 = _SLIT(".");
		return _t1;
	}
	string path = string_replace_each(opath, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("/"), string_clone(_const_os__path_separator), _SLIT("\\"), string_clone(_const_os__path_separator)})));
	if (string__eq(path, _const_os__path_separator)) {
		string _t2 = _const_os__path_separator;
		return _t2;
	}
	if (string_ends_with(path, _const_os__path_separator)) {
		string path2 = string_substr(path, 0, path.len - 1);
		Option_int _t3 = string_last_index(path2, _const_os__path_separator);
		if (_t3.state != 0) { /*or block*/ 
			IError err = _t3.err;
			string _t4 = string_clone(path2);
			return _t4;
		}
		
 		int pos =  (*(int*)_t3.data);
		string _t5 = string_substr(path2, pos + 1, (path2).len);
		return _t5;
	}
	Option_int _t6 = string_last_index(path, _const_os__path_separator);
	if (_t6.state != 0) { /*or block*/ 
		IError err = _t6.err;
		string _t7 = string_clone(path);
		return _t7;
	}
	
 	int pos =  (*(int*)_t6.data);
	string _t8 = string_substr(path, pos + 1, (path).len);
	return _t8;
}

string os__file_name(string opath) {
	string path = string_replace_each(opath, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("/"), string_clone(_const_os__path_separator), _SLIT("\\"), string_clone(_const_os__path_separator)})));
	string _t1 = string_all_after_last(path, _const_os__path_separator);
	return _t1;
}

Option_string os__input_opt(string prompt) {
	print(prompt);
	os__flush();
	string res = os__get_raw_line();
	if (res.len > 0) {
		Option_string _t1;
		opt_ok(&(string[]) { string_trim_right(res, _SLIT("\r\n")) }, (Option*)(&_t1), sizeof(string));
		return _t1;
	}
	return (Option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

string os__input(string prompt) {
	Option_string _t1 = os__input_opt(prompt);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		string _t2 = _SLIT("<EOF>");
		return _t2;
	}
	
 	string res =  (*(string*)_t1.data);
	string _t3 = res;
	return _t3;
}

string os__get_line(void) {
	string str = os__get_raw_line();
	string _t1 = string_trim_right(str, _SLIT("\n"));
	return _t1;
}

Array_string os__get_lines(void) {
	string line = _SLIT("");
	Array_string inputstr = __new_array_with_default(0, 0, sizeof(string), 0);
	for (;;) {
		line = os__get_line();
		if (line.len <= 0) {
			break;
		}
		line = string_trim_space(line);
		array_push((array*)&inputstr, _MOV((string[]){ string_clone(line) }));
	}
	Array_string _t2 = inputstr;
	return _t2;
}

string os__get_lines_joined(void) {
	string line = _SLIT("");
	string inputstr = _SLIT("");
	for (;;) {
		line = os__get_line();
		if (line.len <= 0) {
			break;
		}
		line = string_trim_space(line);
		inputstr = /*f*/string__plus(inputstr, line);
	}
	string _t1 = inputstr;
	return _t1;
}

string os__get_raw_lines_joined(void) {
	string line = _SLIT("");
	Array_string lines = __new_array_with_default(0, 0, sizeof(string), 0);
	for (;;) {
		line = os__get_raw_line();
		if (line.len <= 0) {
			break;
		}
		array_push((array*)&lines, _MOV((string[]){ string_clone(line) }));
	}
	string res = Array_string_join(lines, _SLIT(""));
	string _t2 = res;
	return _t2;
}

string os__user_os(void) {
	string _t1 = _SLIT("macos");
	return _t1;
	string _t2 = _SLIT("unknown");
	return _t2;
}

string os__home_dir(void) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		string _t1 = os__getenv(_SLIT("HOME"));
		return _t1;
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

string os__expand_tilde_to_home(string path) {
	if (string__eq(path, _SLIT("~"))) {
		string _t1 = string_trim_right(os__home_dir(), _const_os__path_separator);
		return _t1;
	}
	if (string_starts_with(path, string__plus(_SLIT("~"), _const_os__path_separator))) {
		string _t2 = string_replace_once(path, string__plus(_SLIT("~"), _const_os__path_separator), string__plus(string_trim_right(os__home_dir(), _const_os__path_separator), _const_os__path_separator));
		return _t2;
	}
	string _t3 = path;
	return _t3;
}

Option_void os__write_file(string path, string text) {
	Option_os__File _t1 = os__create(path);
	if (_t1.state != 0) { /*or block*/ 
		Option_void _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	os__File f =  (*(os__File*)_t1.data);
		Option_void _t3 = os__File_write_full_buffer(&f, text.str, ((usize)(text.len)));
	if (_t3.state != 0 && _t3.err._typ != _IError_None___index) {
		Option_void _t4;
		memcpy(&_t4, &_t3, sizeof(Option));
		return _t4;
	}
	
 ;
	os__File_close(&f);
	return (Option_void){0};
}

string os__executable_fallback(void) {
	if (_const_os__args.len == 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	string exepath = (*(string*)/*ee elem_sym */array_get(_const_os__args, 0));
	if (!os__is_abs_path(exepath)) {
		string rexepath = string_replace_each(exepath, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("/"), string_clone(_const_os__path_separator), _SLIT("\\"), string_clone(_const_os__path_separator)})));
		if (string_contains(rexepath, _const_os__path_separator)) {
			exepath = os__join_path_single(_const_os__wd_at_startup, exepath);
		} else {
			Option_string _t2 = os__find_abs_path_of_executable(exepath);
			if (_t2.state != 0) { /*or block*/ 
				IError err = _t2.err;
				*(string*) _t2.data = _SLIT("");
			}
			
 			string foundpath =  (*(string*)_t2.data);
			if (foundpath.len > 0) {
				exepath = foundpath;
			}
		}
	}
	exepath = os__real_path(exepath);
	string _t3 = exepath;
	return _t3;
}

string os__ExecutableNotFoundError_msg(os__ExecutableNotFoundError err) {
	string _t1 = _SLIT("os: failed to find executable");
	return _t1;
}

IError os__error_failed_to_find_executable(void) {
	IError _t1 = /*&IError*/I_os__ExecutableNotFoundError_to_Interface_IError(((os__ExecutableNotFoundError*)memdup(&(os__ExecutableNotFoundError){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(os__ExecutableNotFoundError))));
	return _t1;
}

Option_string os__find_abs_path_of_executable(string exepath) {
	if ((exepath).len == 0) {
		return (Option_string){ .state=2, .err=_v_error(_SLIT("expected non empty `exepath`")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (os__is_abs_path(exepath)) {
		Option_string _t2;
		opt_ok(&(string[]) { os__real_path(exepath) }, (Option*)(&_t2), sizeof(string));
		return _t2;
	}
	string res = _SLIT("");
	string path = os__getenv(_SLIT("PATH"));
	Array_string paths = string_split(path, _const_os__path_delimiter);
	for (int _t3 = 0; _t3 < paths.len; ++_t3) {
		string p = ((string*)paths.data)[_t3];
		string found_abs_path = os__join_path_single(p, exepath);
		if (os__exists(found_abs_path) && os__is_executable(found_abs_path)) {
			res = found_abs_path;
			break;
		}
	}
	if (res.len > 0) {
		Option_string _t4;
		opt_ok(&(string[]) { os__real_path(res) }, (Option*)(&_t4), sizeof(string));
		return _t4;
	}
	return (Option_string){ .state=2, .err=os__error_failed_to_find_executable(), .data={EMPTY_STRUCT_INITIALIZATION} };
}

bool os__exists_in_system_path(string prog) {
	Option_string _t1 = os__find_abs_path_of_executable(prog);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		bool _t2 = false;
		return _t2;
	}
	
  (*(string*)_t1.data);
	bool _t3 = true;
	return _t3;
}

bool os__is_file(string path) {
	bool _t1 = os__exists(path) && !os__is_dir(path);
	return _t1;
}

bool os__is_abs_path(string path) {
	if (path.len == 0) {
		bool _t1 = false;
		return _t1;
	}
	bool _t2 = string_at(path, 0) == '/';
	return _t2;
}

// Attr: [manualfree]
string os__join_path(string base, Array_string dirs) {
bool os__join_path_defer_0 = false;
strings__Builder sb;
bool os__join_path_defer_1 = false;
string sbase;
	sb = strings__new_builder(base.len + dirs.len * 50);
	os__join_path_defer_0 = true;
	sbase = string_trim_right(base, _SLIT("\\/"));
	os__join_path_defer_1 = true;
	strings__Builder_write_string(&sb, sbase);
	for (int _t1 = 0; _t1 < dirs.len; ++_t1) {
		string d = ((string*)dirs.data)[_t1];
		strings__Builder_write_string(&sb, _const_os__path_separator);
		strings__Builder_write_string(&sb, d);
	}
	string _t2 = strings__Builder_str(&sb);
	// Defer begin
	if (os__join_path_defer_1) {
		string_free(&sbase);
	}
	// Defer end
	// Defer begin
	if (os__join_path_defer_0) {
		strings__Builder_free(&sb);
	}
	// Defer end
	return _t2;
}

// Attr: [manualfree]
string os__join_path_single(string base, string elem) {
bool os__join_path_single_defer_0 = false;
strings__Builder sb;
bool os__join_path_single_defer_1 = false;
string sbase;
	sb = strings__new_builder(base.len + elem.len + 1);
	os__join_path_single_defer_0 = true;
	sbase = string_trim_right(base, _SLIT("\\/"));
	os__join_path_single_defer_1 = true;
	strings__Builder_write_string(&sb, sbase);
	strings__Builder_write_string(&sb, _const_os__path_separator);
	strings__Builder_write_string(&sb, elem);
	string _t1 = strings__Builder_str(&sb);
	// Defer begin
	if (os__join_path_single_defer_1) {
		string_free(&sbase);
	}
	// Defer end
	// Defer begin
	if (os__join_path_single_defer_0) {
		strings__Builder_free(&sb);
	}
	// Defer end
	return _t1;
}

Array_string os__walk_ext(string path, string ext) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	os__impl_walk_ext(path, ext, &/*arr*/res);
	Array_string _t1 = res;
	return _t1;
}

void os__impl_walk_ext(string path, string ext, Array_string* out) {
	if (!os__is_dir(path)) {
		return;
	}
	Option_Array_string _t1 = os__ls(path);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return;
	}
	
 	Array_string files =  (*(Array_string*)_t1.data);
	string separator = (string_ends_with(path, _const_os__path_separator) ? (_SLIT("")) : (_const_os__path_separator));
	for (int _t2 = 0; _t2 < files.len; ++_t2) {
		string file = ((string*)files.data)[_t2];
		if (string_starts_with(file, _SLIT("."))) {
			continue;
		}
		string p = string__plus(string__plus(path, separator), file);
		if (os__is_dir(p) && !os__is_link(p)) {
			os__impl_walk_ext(p, ext, out);
		} else if (string_ends_with(file, ext)) {
			array_push((array*)out, _MOV((string[]){ string_clone(p) }));
		}
	}
}

void os__walk(string path, void (*f)(string )) {
	if (path.len == 0) {
		return;
	}
	if (!os__is_dir(path)) {
		return;
	}
	Option_Array_string _t1 = os__ls(path);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return;
	}
	
 	Array_string files =  (*(Array_string*)_t1.data);
	string local_path_separator = _const_os__path_separator;
	if (string_ends_with(path, _const_os__path_separator)) {
		local_path_separator = _SLIT("");
	}
	for (int _t2 = 0; _t2 < files.len; ++_t2) {
		string file = ((string*)files.data)[_t2];
		string p = string__plus(string__plus(path, local_path_separator), file);
		if (os__is_dir(p) && !os__is_link(p)) {
			os__walk(p, (voidptr)f);
		} else if (os__exists(p)) {
			f(p);
		}
	}
	return;
}

// TypeDecl
void os__walk_with_context(string path, voidptr context, void (*fcb)(voidptr , string )) {
	if (path.len == 0) {
		return;
	}
	if (!os__is_dir(path)) {
		return;
	}
	Option_Array_string _t1 = os__ls(path);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		return;
	}
	
 	Array_string files =  (*(Array_string*)_t1.data);
	string local_path_separator = _const_os__path_separator;
	if (string_ends_with(path, _const_os__path_separator)) {
		local_path_separator = _SLIT("");
	}
	for (int _t2 = 0; _t2 < files.len; ++_t2) {
		string file = ((string*)files.data)[_t2];
		string p = string__plus(string__plus(path, local_path_separator), file);
		if (os__is_dir(p) && !os__is_link(p)) {
			os__walk_with_context(p, context, (voidptr)fcb);
		} else {
			fcb(context, p);
		}
	}
	return;
}

void os__log(string s) {
	println(string__plus(_SLIT("os.log: "), s));
}

Option_void os__mkdir_all(string opath) {
	string path = string_replace(opath, _SLIT("/"), _const_os__path_separator);
	string p = (string_starts_with(path, _const_os__path_separator) ? (_const_os__path_separator) : (_SLIT("")));
	Array_string path_parts = string_split(string_trim_left(path, _const_os__path_separator), _const_os__path_separator);
	for (int _t1 = 0; _t1 < path_parts.len; ++_t1) {
		string subdir = ((string*)path_parts.data)[_t1];
		p = /*f*/string__plus(p, string__plus(subdir, _const_os__path_separator));
		if (os__exists(p) && os__is_dir(p)) {
			continue;
		}
		Option_bool _t2 = os__mkdir(p);
		if (_t2.state != 0) { /*or block*/ 
			IError err = _t2.err;
			return (Option_void){ .state=2, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("folder: "), 0xfe10, {.d_s = p}}, {_SLIT(", error: "), 0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
  (*(bool*)_t2.data);
	}
	return (Option_void){0};
}

string os__cache_dir(void) {
	string xdg_cache_home = os__getenv(_SLIT("XDG_CACHE_HOME"));
	if ((xdg_cache_home).len != 0) {
		string _t1 = xdg_cache_home;
		return _t1;
	}
	string cdir = os__join_path_single(os__home_dir(), _SLIT(".cache"));
	if (!os__is_dir(cdir) && !os__is_link(cdir)) {
		Option_bool _t2 = os__mkdir(cdir);
		if (_t2.state != 0) { /*or block*/ 
			IError err = _t2.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
  (*(bool*)_t2.data);
	}
	string _t3 = cdir;
	return _t3;
}

string os__temp_dir(void) {
	string path = os__getenv(_SLIT("TMPDIR"));
	string _t1 = _SLIT("/tmp");
	return _t1;
	if ((path).len == 0) {
		path = _SLIT("/tmp");
	}
	string _t2 = path;
	return _t2;
}

string os__default_vmodules_path(void) {
	string hdir = os__home_dir();
	string res = os__join_path_single(hdir, _SLIT(".vmodules"));
	string _t1 = res;
	return _t1;
}

string os__vmodules_dir(void) {
	Array_string paths = os__vmodules_paths();
	if (paths.len > 0) {
		string _t1 = (*(string*)/*ee elem_sym */array_get(paths, 0));
		return _t1;
	}
	string _t2 = os__default_vmodules_path();
	return _t2;
}

Array_string os__vmodules_paths(void) {
bool os__vmodules_paths_defer_0 = false;
bool os__vmodules_paths_defer_1 = false;
	string path = os__getenv(_SLIT("VMODULES"));
	if ((path).len == 0) {
		path = os__default_vmodules_path();
	}
	os__vmodules_paths_defer_0 = true;
	Array_string splitted = string_split(path, _const_os__path_delimiter);
	os__vmodules_paths_defer_1 = true;
	Array_string list = __new_array_with_default(0, splitted.len, sizeof(string), 0);
	for (int i = 0; i < splitted.len; ++i) {
		string si = (*(string*)/*ee elem_sym */array_get(splitted, i));
		string trimmed = string_trim_right(si, _const_os__path_separator);
		array_push((array*)&list, _MOV((string[]){ string_clone(trimmed) }));
	}
	Array_string _t2 = list;
	// Defer begin
	if (os__vmodules_paths_defer_1) {
	}
	// Defer end
	// Defer begin
	if (os__vmodules_paths_defer_0) {
	}
	// Defer end
	return _t2;
}

// Attr: [manualfree]
string os__resource_abs_path(string path) {
	string exe = os__executable();
	string dexe = os__dir(exe);
	string base_path = os__real_path(dexe);
	string vresource = os__getenv(_SLIT("V_RESOURCE_PATH"));
	if (vresource.len != 0) {
		string_free(&base_path);
		base_path = vresource;
	}
	string fp = os__join_path_single(base_path, path);
	string res = os__real_path(fp);
	{ // Unsafe block
		string_free(&fp);
		string_free(&vresource);
		string_free(&base_path);
		string_free(&dexe);
		string_free(&exe);
	}
	string _t1 = res;
	return _t1;
}

os__Result os__execute_or_panic(string cmd) {
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed    cmd: "), 0xfe10, {.d_s = cmd}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed   code: "), 0xfe07, {.d_i32 = res.exit_code}}, {_SLIT0, 0, { .d_c = 0 }}})));
		panic_debug(745, tos3("/Users/rcqls/vlang/v/vlib/os/os.v"), tos3("os"), tos3("execute_or_panic"),  res.output);
		VUNREACHABLE();
	}
	os__Result _t1 = res;
	return _t1;
}

os__Result os__execute_or_exit(string cmd) {
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed    cmd: "), 0xfe10, {.d_s = cmd}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed   code: "), 0xfe07, {.d_i32 = res.exit_code}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln(res.output);
		_v_exit(1);
		VUNREACHABLE();
	}
	os__Result _t1 = res;
	return _t1;
}

string os__quoted_path(string path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("'"), 0xfe10, {.d_s = path}}, {_SLIT("'"), 0, { .d_c = 0 }}}));
		return _t1;
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

Option_string os__config_dir(void) {
	#if defined(_WIN32)
	{
	}
	#elif defined(__APPLE__) || defined(__DARWIN__) || defined(__TARGET_IOS__)
	{
		string home = os__home_dir();
		if ((home).len != 0) {
			Option_string _t1;
			opt_ok(&(string[]) { string__plus(home, _SLIT("/Library/Application Support")) }, (Option*)(&_t1), sizeof(string));
			return _t1;
		}
	}
	#else
	{
	}
	#endif
	return (Option_string){ .state=2, .err=_v_error(_SLIT("Cannot find config directory")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

#if !defined(__sun) && !defined(__HAIKU__)
#endif
Array_string os__glob_match(string dir, string pattern, string next_pattern, Array_string* matches) {
	Array_string subdirs = __new_array_with_default(0, 0, sizeof(string), 0);
	if (os__is_file(dir)) {
		Array_string _t1 = subdirs;
		return _t1;
	}
	Option_Array_string _t2 = os__ls(dir);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		Array_string _t3 = subdirs;
		return _t3;
	}
	
 	Array_string files =  (*(Array_string*)_t2.data);
	os__GlobMatch mode = os__GlobMatch__exact;
	string pat = pattern;
	if (string__eq(pat, _SLIT("*"))) {
		mode = os__GlobMatch__any;
		if (!string__eq(next_pattern, pattern) && (next_pattern).len != 0) {
			for (int _t4 = 0; _t4 < files.len; ++_t4) {
				string file = ((string*)files.data)[_t4];
				if (os__is_dir( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dir}}, {_SLIT("/"), 0xfe10, {.d_s = file}}, {_SLIT0, 0, { .d_c = 0 }}})))) {
					array_push((array*)&subdirs, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dir}}, {_SLIT("/"), 0xfe10, {.d_s = file}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
				}
			}
			Array_string _t6 = subdirs;
			return _t6;
		}
	}
	if (string__eq(pat, _SLIT("**"))) {
		files = os__walk_ext(dir, _SLIT(""));
		pat = next_pattern;
	}
	if (string_starts_with(pat, _SLIT("*"))) {
		mode = os__GlobMatch__ends_with;
		pat = string_substr(pat, 1, (pat).len);
	}
	if (string_ends_with(pat, _SLIT("*"))) {
		mode = (mode == os__GlobMatch__ends_with ? (os__GlobMatch__contains) : (os__GlobMatch__starts_with));
		pat = string_substr(pat, 0, pat.len - 1);
	}
	if (string_contains(pat, _SLIT("*"))) {
		mode = os__GlobMatch__start_and_ends_with;
	}
	for (int _t7 = 0; _t7 < files.len; ++_t7) {
		string file = ((string*)files.data)[_t7];
		string fpath = file;
		string _t8; /* if prepend */
		if (string_contains(file, _const_os__path_separator)) {
			Array_string pathwalk = string_split(file, _const_os__path_separator);
			_t8 = (*(string*)/*ee elem_sym */array_get(pathwalk, pathwalk.len - 1));
		} else {
			fpath = (string__eq(dir, _SLIT(".")) ? (file) : ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dir}}, {_SLIT("/"), 0xfe10, {.d_s = file}}, {_SLIT0, 0, { .d_c = 0 }}}))));
			_t8 = file;
		}
		string f =  _t8;
		if ((string__eq(f, _SLIT(".")) || string__eq(f, _SLIT(".."))) || (f).len == 0) {
			continue;
		}
		bool _t9 = 0;
		
		if (mode == (os__GlobMatch__any)) {
			_t9 = true;
		}
		else if (mode == (os__GlobMatch__exact)) {
			_t9 = string__eq(f, pat);
		}
		else if (mode == (os__GlobMatch__starts_with)) {
			_t9 = string_starts_with(f, pat);
		}
		else if (mode == (os__GlobMatch__ends_with)) {
			_t9 = string_ends_with(f, pat);
		}
		else if (mode == (os__GlobMatch__start_and_ends_with)) {
			Array_string p = string_split(pat, _SLIT("*"));
			_t9 = string_starts_with(f, (*(string*)/*ee elem_sym */array_get(p, 0))) && string_ends_with(f, (*(string*)/*ee elem_sym */array_get(p, 1)));
		}
		else if (mode == (os__GlobMatch__contains)) {
			_t9 = string_contains(f, pat);
		}bool hit = _t9;
		if (hit) {
			if (os__is_dir(fpath)) {
				array_push((array*)&subdirs, _MOV((string[]){ string_clone(fpath) }));
				if (string__eq(next_pattern, pattern) && (next_pattern).len != 0) {
					array_push((array*)matches, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = fpath}}, {_SLIT0, 0xfe10, {.d_s = _const_os__path_separator}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
				}
			} else {
				array_push((array*)matches, _MOV((string[]){ string_clone(fpath) }));
			}
		}
	}
	Array_string _t13 = subdirs;
	return _t13;
}

Option_void os__native_glob_pattern(string pattern, Array_string* matches) {
	Array_string steps = string_split(pattern, _const_os__path_separator);
	string cwd = (string_starts_with(pattern, _const_os__path_separator) ? (_const_os__path_separator) : (_SLIT(".")));
	Array_string subdirs = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(cwd)}));
	for (int i = 0; i < steps.len; i++) {
		string step = (*(string*)/*ee elem_sym */array_get(steps, i));
		string step2 = (i + 1 == steps.len ? (step) : ((*(string*)/*ee elem_sym */array_get(steps, i + 1))));
		if ((step).len == 0) {
			continue;
		}
		if (os__is_dir( str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cwd}}, {_SLIT0, 0xfe10, {.d_s = _const_os__path_separator}}, {_SLIT0, 0xfe10, {.d_s = step}}, {_SLIT0, 0, { .d_c = 0 }}})))) {
			string dd = (string__eq(cwd, _SLIT("/")) ? (step) : ((string__eq(cwd, _SLIT(".")) || (cwd).len == 0 ? (step) : ((string__eq(step, _SLIT(".")) || string__eq(step, _SLIT("/")) ? (cwd) : ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cwd}}, {_SLIT("/"), 0xfe10, {.d_s = step}}, {_SLIT0, 0, { .d_c = 0 }}}))))))));
			if (i + 1 != steps.len) {
				if (!Array_string_contains(subdirs, dd)) {
					array_push((array*)&subdirs, _MOV((string[]){ string_clone(dd) }));
				}
			}
		}
		Array_string subs = __new_array_with_default(0, 0, sizeof(string), 0);
		for (int _t2 = 0; _t2 < subdirs.len; ++_t2) {
			string sd = ((string*)subdirs.data)[_t2];
			string d = (string__eq(cwd, _SLIT("/")) ? (sd) : ((string__eq(cwd, _SLIT(".")) || (cwd).len == 0 ? (sd) : ((string__eq(sd, _SLIT(".")) || string__eq(sd, _SLIT("/")) ? (cwd) : ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cwd}}, {_SLIT("/"), 0xfe10, {.d_s = sd}}, {_SLIT0, 0, { .d_c = 0 }}}))))))));
			_PUSH_MANY(&subs, (os__glob_match(string_replace(d, _SLIT("//"), _SLIT("/")), step, step2, matches)), _t3, Array_string);
		}
		subdirs = array_clone_to_depth(&subs, 0);
	}
	return (Option_void){0};
}

Option_void os__utime(string path, int actime, int modtime) {
	struct utimbuf u = ((struct utimbuf){.actime = actime,.modtime = modtime,});
	if (utime(((char*)(path.str)), ((voidptr)(&u))) != 0) {
		return (Option_void){ .state=2, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

os__Uname os__uname(void) {
	os__Uname u = ((os__Uname){.sysname = (string){.str=(byteptr)"", .is_lit=1},.nodename = (string){.str=(byteptr)"", .is_lit=1},.release = (string){.str=(byteptr)"", .is_lit=1},.version = (string){.str=(byteptr)"", .is_lit=1},.machine = (string){.str=(byteptr)"", .is_lit=1},});
	u32 utsize = sizeof(struct utsname);
	{ // Unsafe block
		u8* x = malloc_noscan(((int)(utsize)));
		struct utsname* d = ((struct utsname*)(x));
		if (uname(d) == 0) {
			u.sysname = cstring_to_vstring(d->sysname);
			u.nodename = cstring_to_vstring(d->nodename);
			u.release = cstring_to_vstring(d->release);
			u.version = cstring_to_vstring(d->version);
			u.machine = cstring_to_vstring(d->machine);
		}
		_v_free(d);
	}
	os__Uname _t1 = u;
	return _t1;
}

string os__hostname(void) {
	string hstnme = _SLIT("");
	int size = 256;
	char* buf = ((char*)(malloc_noscan(size)));
	if (gethostname(buf, size) == 0) {
		hstnme = cstring_to_vstring(buf);
		_v_free(buf);
		string _t1 = hstnme;
		return _t1;
	}
	string _t2 = _SLIT("");
	return _t2;
}

string os__loginname(void) {
	char* x = getlogin();
	if (!isnil(x)) {
		string _t1 = cstring_to_vstring(x);
		return _t1;
	}
	string _t2 = _SLIT("");
	return _t2;
}

Array_string os__init_os_args(int argc, u8** argv) {
	Array_string args_ = __new_array_with_default(argc, 0, sizeof(string), &(string[]){_SLIT("")});
	for (int i = 0; i < argc; ++i) {
		array_set(&args_, i, &(string[]) { tos_clone(argv[i]) });
	}
	Array_string _t1 = args_;
	return _t1;
}

Option_Array_string os__ls(string path) {
	if (path.len == 0) {
		return (Option_Array_string){ .state=2, .err=_v_error(_SLIT("ls() expects a folder, not an empty string")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Array_string res = __new_array_with_default(0, 50, sizeof(string), 0);
	DIR* dir = opendir(((char*)(path.str)));
	if (isnil(dir)) {
		return (Option_Array_string){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("ls() couldnt open dir \""), 0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	struct dirent* ent = ((struct dirent*)(0));
	for (;;) {
		ent = readdir(dir);
		if (isnil(ent)) {
			break;
		}
		{ // Unsafe block
			u8* bptr = ((u8*)(&ent->d_name[0]));
			if (bptr[0] == 0 || (bptr[0] == '.' && bptr[1] == 0) || (bptr[0] == '.' && bptr[1] == '.' && bptr[2] == 0)) {
				continue;
			}
			array_push((array*)&res, _MOV((string[]){ string_clone(tos_clone(bptr)) }));
		}
	}
	closedir(dir);
	Option_Array_string _t4;
	opt_ok(&(Array_string[]) { res }, (Option*)(&_t4), sizeof(Array_string));
	return _t4;
}

Option_bool os__mkdir(string path) {
	if (string__eq(path, _SLIT("."))) {
		Option_bool _t1;
		opt_ok(&(bool[]) { true }, (Option*)(&_t1), sizeof(bool));
		return _t1;
	}
	string apath = os__real_path(path);
	int r = mkdir(((char*)(apath.str)), 511U);
	if (r == -1) {
		return (Option_bool){ .state=2, .err=_v_error(os__posix_get_error_msg(errno)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_bool _t3;
	opt_ok(&(bool[]) { true }, (Option*)(&_t3), sizeof(bool));
	return _t3;
}

// Attr: [manualfree]
os__Result os__execute(string cmd) {
bool os__execute_defer_0 = false;
string pcmd;
bool os__execute_defer_1 = false;
strings__Builder res;
	pcmd = (string_contains(cmd, _SLIT("2>")) ? (string_clone(cmd)) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = cmd}}, {_SLIT(" 2>&1"), 0, { .d_c = 0 }}}))));
	os__execute_defer_0 = true;
	voidptr f = os__vpopen(pcmd);
	if (isnil(f)) {
		os__Result _t1 = ((os__Result){.exit_code = -1,.output =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("exec(\""), 0xfe10, {.d_s = cmd}}, {_SLIT("\") failed"), 0, { .d_c = 0 }}})),});
		// Defer begin
		if (os__execute_defer_0) {
			string_free(&pcmd);
		}
		// Defer end
		return _t1;
	}
	int fd = os__fileno(f);
	res = strings__new_builder(1024);
	os__execute_defer_1 = true;
	Array_fixed_u8_4096 buf = {0};
	{ // Unsafe block
		u8* pbuf = &buf[0];
		for (;;) {
			int len = read(fd, pbuf, 4096);
			if (len == 0) {
				break;
			}
			strings__Builder_write_ptr(&res, pbuf, len);
		}
	}
	string soutput = strings__Builder_str(&res);
	int exit_code = os__vpclose(f);
	os__Result _t2 = ((os__Result){.exit_code = exit_code,.output = soutput,});
	// Defer begin
	if (os__execute_defer_1) {
		strings__Builder_free(&res);
	}
	// Defer end
	// Defer begin
	if (os__execute_defer_0) {
		string_free(&pcmd);
	}
	// Defer end
	return _t2;
}

// Attr: [manualfree]
Option_void os__Command_start(os__Command* c) {
bool os__Command_start_defer_0 = false;
string pcmd;
	pcmd = string__plus(c->path, _SLIT(" 2>&1"));
	os__Command_start_defer_0 = true;
	c->f = os__vpopen(pcmd);
	if (isnil(c->f)) {
		Option_void _t1 = (Option_void){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("exec(\""), 0xfe10, {.d_s = c->path}}, {_SLIT("\") failed"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (os__Command_start_defer_0) {
			string_free(&pcmd);
		}
		// Defer end
		return _t1;
	}
	// Defer begin
	if (os__Command_start_defer_0) {
		string_free(&pcmd);
	}
	// Defer end
	return (Option_void){0};
}

// Attr: [manualfree]
string os__Command_read_line(os__Command* c) {
bool os__Command_read_line_defer_0 = false;
strings__Builder res;
	Array_fixed_u8_4096 buf = {0};
	res = strings__new_builder(1024);
	os__Command_read_line_defer_0 = true;
	{ // Unsafe block
		u8* bufbp = &buf[0];
		for (;;) {
			if (!(fgets(((char*)(bufbp)), 4096, c->f) != 0)) break;
			int len = vstrlen(bufbp);
			for (int i = 0; i < len; ++i) {
				if (bufbp[i] == '\n') {
					strings__Builder_write_ptr(&res, bufbp, i);
					string final = strings__Builder_str(&res);
					string _t1 = final;
					// Defer begin
					if (os__Command_read_line_defer_0) {
						strings__Builder_free(&res);
					}
					// Defer end
					return _t1;
				}
			}
			strings__Builder_write_ptr(&res, bufbp, len);
		}
	}
	c->eof = true;
	string final = strings__Builder_str(&res);
	string _t2 = final;
	// Defer begin
	if (os__Command_read_line_defer_0) {
		strings__Builder_free(&res);
	}
	// Defer end
	return _t2;
}

Option_void os__Command_close(os__Command* c) {
	c->exit_code = os__vpclose(c->f);
	if (c->exit_code == 127) {
		return (Option_void){ .state=2, .err=error_with_code(_SLIT("error"), 127), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

Option_bool os__symlink(string origin, string target) {
	int res = symlink(((char*)(origin.str)), ((char*)(target.str)));
	if (res == 0) {
		Option_bool _t1;
		opt_ok(&(bool[]) { true }, (Option*)(&_t1), sizeof(bool));
		return _t1;
	}
	return (Option_bool){ .state=2, .err=_v_error(os__posix_get_error_msg(errno)), .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_bool os__link(string origin, string target) {
	int res = link(((char*)(origin.str)), ((char*)(target.str)));
	if (res == 0) {
		Option_bool _t1;
		opt_ok(&(bool[]) { true }, (Option*)(&_t1), sizeof(bool));
		return _t1;
	}
	return (Option_bool){ .state=2, .err=_v_error(os__posix_get_error_msg(errno)), .data={EMPTY_STRUCT_INITIALIZATION} };
}

string os__get_error_msg(int code) {
	string _t1 = os__posix_get_error_msg(code);
	return _t1;
}

void os__File_close(os__File* f) {
	if (!f->is_opened) {
		return;
	}
	f->is_opened = false;
	fflush(f->cfile);
	fclose(f->cfile);
}

// Attr: [inline]
inline bool os__debugger_present(void) {
	#if defined(__linux__)
	{
	}
	#elif defined(__APPLE__)
	{
		bool _t1 = ptrace(PT_TRACE_ME, 0U, ((voidptr)(1)), 0) == -1;
		return _t1;
	}
	#endif
	bool _t2 = false;
	return _t2;
}

// Attr: [manualfree]
Option_bool os__is_writable_folder(string folder) {
bool os__is_writable_folder_defer_0 = false;
string tmp_perm_check;
	if (!os__exists(folder)) {
		return (Option_bool){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), 0xfe10, {.d_s = folder}}, {_SLIT("` does not exist"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (!os__is_dir(folder)) {
		return (Option_bool){ .state=2, .err=_v_error(_SLIT("`folder` is not a folder")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	tmp_perm_check = os__join_path_single(folder, _SLIT("XXXXXX"));
	os__is_writable_folder_defer_0 = true;
	{ // Unsafe block
		int x = mkstemp(((char*)(tmp_perm_check.str)));
		if (-1 == x) {
			Option_bool _t3 = (Option_bool){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("folder `"), 0xfe10, {.d_s = folder}}, {_SLIT("` is not writable"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			// Defer begin
			if (os__is_writable_folder_defer_0) {
				string_free(&tmp_perm_check);
			}
			// Defer end
			return _t3;
		}
		close(x);
	}
	Option_void _t4 = os__rm(tmp_perm_check);
	if (_t4.state != 0 && _t4.err._typ != _IError_None___index) {
	// Defer begin
	if (os__is_writable_folder_defer_0) {
		string_free(&tmp_perm_check);
	}
	// Defer end
		Option_bool _t5;
		memcpy(&_t5, &_t4, sizeof(Option));
		return _t5;
	}
	
 ;
	Option_bool _t6;
	opt_ok(&(bool[]) { true }, (Option*)(&_t6), sizeof(bool));
	// Defer begin
	if (os__is_writable_folder_defer_0) {
		string_free(&tmp_perm_check);
	}
	// Defer end
	return _t6;
}

// Attr: [inline]
inline int os__getpid(void) {
	int _t1 = getpid();
	return _t1;
}

// Attr: [inline]
inline int os__getppid(void) {
	int _t1 = getppid();
	return _t1;
}

// Attr: [inline]
inline int os__getuid(void) {
	int _t1 = getuid();
	return _t1;
}

// Attr: [inline]
inline int os__geteuid(void) {
	int _t1 = geteuid();
	return _t1;
}

// Attr: [inline]
inline int os__getgid(void) {
	int _t1 = getgid();
	return _t1;
}

// Attr: [inline]
inline int os__getegid(void) {
	int _t1 = getegid();
	return _t1;
}

void os__posix_set_permission_bit(string path_s, u32 mode, bool enable) {
	struct stat s;
	u32 new_mode = ((u32)(0U));
	char* path = ((char*)(path_s.str));
	{ // Unsafe block
		stat(path, &s);
		new_mode = s.st_mode;
	}

	if (enable == (true)) {
		new_mode |= mode;
	}
	else if (enable == (false)) {
		new_mode &= (07777 - mode);
	};
	chmod(path, ((int)(new_mode)));
}

void os__Process_signal_kill(os__Process* p) {
	if (!(p->status == os__ProcessState__running || p->status == os__ProcessState__stopped)) {
		return;
	}
	os__Process__signal_kill(p);
	p->status = os__ProcessState__aborted;
	return;
}

void os__Process_signal_pgkill(os__Process* p) {
	if (!(p->status == os__ProcessState__running || p->status == os__ProcessState__stopped)) {
		return;
	}
	os__Process__signal_pgkill(p);
	return;
}

void os__Process_signal_stop(os__Process* p) {
	if (p->status != os__ProcessState__running) {
		return;
	}
	os__Process__signal_stop(p);
	p->status = os__ProcessState__stopped;
	return;
}

void os__Process_signal_continue(os__Process* p) {
	if (p->status != os__ProcessState__stopped) {
		return;
	}
	os__Process__signal_continue(p);
	p->status = os__ProcessState__running;
	return;
}

void os__Process_wait(os__Process* p) {
	if (p->status == os__ProcessState__not_started) {
		os__Process__spawn(p);
	}
	if (!(p->status == os__ProcessState__running || p->status == os__ProcessState__stopped)) {
		return;
	}
	os__Process__wait(p);
	return;
}

void os__Process_close(os__Process* p) {
	if (p->status == os__ProcessState__not_started || p->status == os__ProcessState__closed) {
		return;
	}
	p->status = os__ProcessState__closed;
	#if !defined(_WIN32)
	{
		for (int i = 0; i < 3; ++i) {
			if (p->stdio_fd[v_fixed_index(i, 3)] != 0) {
				os__fd_close(p->stdio_fd[v_fixed_index(i, 3)]);
			}
		}
	}
	#endif
}

// Attr: [unsafe]
void os__Process_free(os__Process* p) {
	os__Process_close(p);
	{ // Unsafe block
		string_free(&p->filename);
		string_free(&p->err);
		array_free(&p->args);
		array_free(&p->env);
	}
}

int os__Process__spawn(os__Process* p) {
	if (!p->env_is_custom) {
		p->env = __new_array_with_default(0, 0, sizeof(string), 0);
		Map_string_string current_environment = os__environ();
		int _t2 = current_environment.key_values.len;
		for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
			int _t3 = current_environment.key_values.len - _t2;
			_t2 = current_environment.key_values.len;
			if (_t3 < 0) {
				_t1 = -1;
				continue;
			}
			if (!DenseArray_has_index(&current_environment.key_values, _t1)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&current_environment.key_values, _t1);
			k = string_clone(k);
			string v = (*(string*)DenseArray_value(&current_environment.key_values, _t1));
			array_push((array*)&p->env, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = k}}, {_SLIT("="), 0xfe10, {.d_s = v}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		}
	}
	int pid = 0;
	#if defined(_WIN32)
	{
	}
	#else
	{
		pid = os__Process_unix_spawn_process(p);
	}
	#endif
	p->pid = pid;
	p->status = os__ProcessState__running;
	int _t5 = 0;
	return _t5;
}

bool os__Process_is_alive(os__Process* p) {
	if (p->status == os__ProcessState__running || p->status == os__ProcessState__stopped) {
		bool _t1 = os__Process__is_alive(p);
		return _t1;
	}
	bool _t2 = false;
	return _t2;
}

void os__Process_set_redirect_stdio(os__Process* p) {
	p->use_stdio_ctl = true;
	return;
}

void os__Process_stdin_write(os__Process* p, string s) {
	os__Process__check_redirection_call(p, _SLIT("stdin_write"));
	#if defined(_WIN32)
	{
	}
	#else
	{
		os__fd_write(p->stdio_fd[0], s);
	}
	#endif
}

string os__Process_stdout_slurp(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("stdout_slurp"));
	#if defined(_WIN32)
	{
	}
	#else
	{
		string _t1 = Array_string_join(os__fd_slurp(p->stdio_fd[1]), _SLIT(""));
		return _t1;
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

string os__Process_stderr_slurp(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("stderr_slurp"));
	#if defined(_WIN32)
	{
	}
	#else
	{
		string _t1 = Array_string_join(os__fd_slurp(p->stdio_fd[2]), _SLIT(""));
		return _t1;
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

string os__Process_stdout_read(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("stdout_read"));
	#if defined(_WIN32)
	{
	}
	#else
	{
		multi_return_string_int mr_3534 = os__fd_read(p->stdio_fd[1], 4096);
		string s = mr_3534.arg0;
		string _t1 = s;
		return _t1;
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

string os__Process_stderr_read(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("stderr_read"));
	#if defined(_WIN32)
	{
	}
	#else
	{
		multi_return_string_int mr_3752 = os__fd_read(p->stdio_fd[2], 4096);
		string s = mr_3752.arg0;
		string _t1 = s;
		return _t1;
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

void os__Process__check_redirection_call(os__Process* p, string fn_name) {
	if (!p->use_stdio_ctl) {
		panic_debug(180, tos3("/Users/rcqls/vlang/v/vlib/os/process.c.v"), tos3("os"), tos3("_check_redirection_call"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("Call p.set_redirect_stdio() before calling p."), 0xfe10, {.d_s = fn_name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	if (p->status == os__ProcessState__not_started) {
		panic_debug(183, tos3("/Users/rcqls/vlang/v/vlib/os/process.c.v"), tos3("os"), tos3("_check_redirection_call"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("Call p."), 0xfe10, {.d_s = fn_name}}, {_SLIT("() after you have called p.run()"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
}

void os__Process__signal_stop(os__Process* p) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		os__Process_unix_stop_process(p);
	}
	#endif
}

void os__Process__signal_continue(os__Process* p) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		os__Process_unix_resume_process(p);
	}
	#endif
}

void os__Process__signal_kill(os__Process* p) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		os__Process_unix_kill_process(p);
	}
	#endif
}

void os__Process__signal_pgkill(os__Process* p) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		os__Process_unix_kill_pgroup(p);
	}
	#endif
}

void os__Process__wait(os__Process* p) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		os__Process_unix_wait(p);
	}
	#endif
}

bool os__Process__is_alive(os__Process* p) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		bool _t1 = os__Process_unix_is_alive(p);
		return _t1;
	}
	#endif
	return 0;
}

void os__Process_run(os__Process* p) {
	if (p->status != os__ProcessState__not_started) {
		return;
	}
	os__Process__spawn(p);
	return;
}

os__Process* os__new_process(string filename) {
	os__Process* _t1 = ((os__Process*)memdup(&(os__Process){.filename = filename,.pid = 0,.code = -1,.status = os__ProcessState__not_started,.err = (string){.str=(byteptr)"", .is_lit=1},.args = __new_array(0, 0, sizeof(string)),.env_is_custom = 0,.env = __new_array(0, 0, sizeof(string)),.use_stdio_ctl = 0,.use_pgroup = 0,.stdio_fd = {-1, -1, -1},.wdata = 0,}, sizeof(os__Process)));
	return _t1;
}

void os__Process_set_args(os__Process* p, Array_string pargs) {
	if (p->status != os__ProcessState__not_started) {
		return;
	}
	p->args = pargs;
	return;
}

void os__Process_set_environment(os__Process* p, Map_string_string envs) {
	if (p->status != os__ProcessState__not_started) {
		return;
	}
	p->env_is_custom = true;
	p->env = __new_array_with_default(0, 0, sizeof(string), 0);
	int _t2 = envs.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = envs.key_values.len - _t2;
		_t2 = envs.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!DenseArray_has_index(&envs.key_values, _t1)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&envs.key_values, _t1);
		k = string_clone(k);
		string v = (*(string*)DenseArray_value(&envs.key_values, _t1));
		array_push((array*)&p->env, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = k}}, {_SLIT("="), 0xfe10, {.d_s = v}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	}
	return;
}

int os__Process_unix_spawn_process(os__Process* p) {
	Array_fixed_int_6 pipeset = {0};
	if (p->use_stdio_ctl) {
		int dont_care = pipe(&pipeset[0]);
		dont_care = pipe(&pipeset[2]);
		dont_care = pipe(&pipeset[4]);
		{int _ = dont_care;}
		;
	}
	int pid = os__fork();
	if (pid != 0) {
		if (p->use_stdio_ctl) {
			p->stdio_fd[0] = pipeset[1];
			p->stdio_fd[1] = pipeset[2];
			p->stdio_fd[2] = pipeset[4];
			os__fd_close(pipeset[0]);
			os__fd_close(pipeset[3]);
			os__fd_close(pipeset[5]);
		}
		int _t1 = pid;
		return _t1;
	}
	if (p->use_pgroup) {
		setpgid(0, 0);
	}
	if (p->use_stdio_ctl) {
		os__fd_close(pipeset[1]);
		os__fd_close(pipeset[2]);
		os__fd_close(pipeset[4]);
		dup2(pipeset[0], 0);
		dup2(pipeset[3], 1);
		dup2(pipeset[5], 2);
		os__fd_close(pipeset[0]);
		os__fd_close(pipeset[3]);
		os__fd_close(pipeset[5]);
	}
	Option_void _t2 = os__execve(p->filename, p->args, p->env);
	if (_t2.state != 0 && _t2.err._typ != _IError_None___index) {
		IError err = _t2.err;
		eprintln(IError_str(err));
		_v_exit(1);
		VUNREACHABLE();
	;
	}
	
 ;
	int _t3 = 0;
	return _t3;
}

void os__Process_unix_stop_process(os__Process* p) {
	kill(p->pid, SIGSTOP);
}

void os__Process_unix_resume_process(os__Process* p) {
	kill(p->pid, SIGCONT);
}

void os__Process_unix_kill_process(os__Process* p) {
	kill(p->pid, SIGKILL);
}

void os__Process_unix_kill_pgroup(os__Process* p) {
	kill(-p->pid, SIGKILL);
}

void os__Process_unix_wait(os__Process* p) {
	int cstatus = 0;
	int ret = waitpid(p->pid, &cstatus, 0);
	if (ret == -1) {
		p->err = os__posix_get_error_msg(errno);
		return;
	}
	multi_return_int_bool mr_2291 = os__posix_wait4_to_exit_status(cstatus);
	int pret = mr_2291.arg0;
	bool is_signaled = mr_2291.arg1;
	if (is_signaled) {
		p->status = os__ProcessState__aborted;
		p->err =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Terminated by signal "), 0x4fe27, {.d_i32 = ret}}, {_SLIT(" ("), 0xfe10, {.d_s = os__sigint_to_signal_name(pret)}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
	} else {
		p->status = os__ProcessState__exited;
	}
	p->code = pret;
}

bool os__Process_unix_is_alive(os__Process* p) {
	int cstatus = 0;
	int ret = waitpid(p->pid, &cstatus, WNOHANG);
	if (ret == -1) {
		p->err = os__posix_get_error_msg(errno);
		bool _t1 = false;
		return _t1;
	}
	if (ret == 0) {
		bool _t2 = true;
		return _t2;
	}
	multi_return_int_bool mr_2724 = os__posix_wait4_to_exit_status(cstatus);
	int pret = mr_2724.arg0;
	bool is_signaled = mr_2724.arg1;
	if (is_signaled) {
		p->status = os__ProcessState__aborted;
		p->err =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Terminated by signal "), 0x4fe27, {.d_i32 = ret}}, {_SLIT(" ("), 0xfe10, {.d_s = os__sigint_to_signal_name(pret)}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
	} else {
		p->status = os__ProcessState__exited;
	}
	p->code = pret;
	bool _t3 = false;
	return _t3;
}

int os__Process_win_spawn_process(os__Process* p) {
	int _t1 = 0;
	return _t1;
}

void os__Process_win_stop_process(os__Process* p) {
}

void os__Process_win_resume_process(os__Process* p) {
}

void os__Process_win_kill_process(os__Process* p) {
}

void os__Process_win_kill_pgroup(os__Process* p) {
}

void os__Process_win_wait(os__Process* p) {
}

bool os__Process_win_is_alive(os__Process* p) {
	bool _t1 = false;
	return _t1;
}

void os__Process_win_write_string(os__Process* p, int idx, string s) {
}

multi_return_string_int os__Process_win_read_string(os__Process* p, int idx, int maxbytes) {
	return (multi_return_string_int){.arg0=_SLIT(""), .arg1=0};
}

string os__Process_win_slurp(os__Process* p, int idx) {
	string _t1 = _SLIT("");
	return _t1;
}

Option_os__SignalHandler os__signal_opt(os__Signal signum, void (*handler)(os__Signal )) {
	errno = 0;
	voidptr prev_handler = signal(((int)(signum)), (voidptr)handler);
	if (prev_handler == SIG_ERR) {
		return (Option_os__SignalHandler){ .state=2, .err=error_with_code(os__posix_get_error_msg(EINVAL), EINVAL), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_os__SignalHandler _t2;
	opt_ok(&(os__SignalHandler[]) { (voidptr)((os__SignalHandler)(prev_handler)) }, (Option*)(&_t2), sizeof(os__SignalHandler));
	return _t2;
}

// TypeDecl
Option_void os__open_uri(string uri) {
	string vopen_uri_cmd = os__getenv(_SLIT("VOPEN_URI_CMD"));
	if ((vopen_uri_cmd).len == 0) {
		#if defined(__APPLE__)
		{
			vopen_uri_cmd = _SLIT("open");
		}
		#elif defined(__FreeBSD__) || defined(__OpenBSD__)
		{
		}
		#elif defined(__linux__)
		{
		}
		#endif
	}
	if ((vopen_uri_cmd).len == 0) {
		return (Option_void){ .state=2, .err=_v_error(_SLIT("unsupported platform")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	os__Result result = os__execute( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = vopen_uri_cmd}}, {_SLIT(" \""), 0xfe10, {.d_s = uri}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
	if (result.exit_code != 0) {
		return (Option_void){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unable to open url: "), 0xfe10, {.d_s = result.output}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

// TypeDecl
i64 time__portable_timegm(struct tm* t) {
	int year = t->tm_year + 1900;
	int month = t->tm_mon;
	if (month > 11) {
		year += month / 12;
		month %= 12;
	} else if (month < 0) {
		int years_diff = (11 - month) / 12;
		year -= years_diff;
		month += 12 * years_diff;
	}
	i64 days_since_1970 = ((i64)(time__days_from_civil(year, month + 1, t->tm_mday)));
	i64 _t1 = 60 * (60 * (24 * days_since_1970 + t->tm_hour) + t->tm_min) + t->tm_sec;
	return _t1;
}

int time__days_from_civil(int oy, int m, int d) {
	int y = (m <= 2 ? (oy - 1) : (oy));
	int era = y / 400;
	int yoe = y - era * 400;
	int doy = (153 * (m + ((m > 2 ? (-3) : (9)))) + 2) / 5 + d - 1;
	int doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;
	int _t1 = era * 146097 + doe - 719468;
	return _t1;
}

string time__Time_format(time__Time t) {
	string _t1 = time__Time_get_fmt_str(t, time__FormatDelimiter__hyphen, time__FormatTime__hhmm24, time__FormatDate__yyyymmdd);
	return _t1;
}

string time__Time_format_ss(time__Time t) {
	string _t1 = time__Time_get_fmt_str(t, time__FormatDelimiter__hyphen, time__FormatTime__hhmmss24, time__FormatDate__yyyymmdd);
	return _t1;
}

string time__Time_format_ss_milli(time__Time t) {
	string _t1 = time__Time_get_fmt_str(t, time__FormatDelimiter__hyphen, time__FormatTime__hhmmss24_milli, time__FormatDate__yyyymmdd);
	return _t1;
}

string time__Time_format_ss_micro(time__Time t) {
	string _t1 = time__Time_get_fmt_str(t, time__FormatDelimiter__hyphen, time__FormatTime__hhmmss24_micro, time__FormatDate__yyyymmdd);
	return _t1;
}

string time__Time_hhmm(time__Time t) {
	string _t1 = time__Time_get_fmt_time_str(t, time__FormatTime__hhmm24);
	return _t1;
}

string time__Time_hhmmss(time__Time t) {
	string _t1 = time__Time_get_fmt_time_str(t, time__FormatTime__hhmmss24);
	return _t1;
}

string time__Time_hhmm12(time__Time t) {
	string _t1 = time__Time_get_fmt_time_str(t, time__FormatTime__hhmm12);
	return _t1;
}

string time__Time_ymmdd(time__Time t) {
	string _t1 = time__Time_get_fmt_date_str(t, time__FormatDelimiter__hyphen, time__FormatDate__yyyymmdd);
	return _t1;
}

string time__Time_ddmmy(time__Time t) {
	string _t1 = time__Time_get_fmt_date_str(t, time__FormatDelimiter__dot, time__FormatDate__ddmmyyyy);
	return _t1;
}

string time__Time_md(time__Time t) {
	string _t1 = time__Time_get_fmt_date_str(t, time__FormatDelimiter__space, time__FormatDate__mmmd);
	return _t1;
}

string time__Time_clean(time__Time t) {
	time__Time znow = time__now();
	if (t.month == znow.month && t.year == znow.year && t.day == znow.day) {
		string _t1 = time__Time_get_fmt_time_str(t, time__FormatTime__hhmm24);
		return _t1;
	}
	if (t.year == znow.year) {
		string _t2 = time__Time_get_fmt_str(t, time__FormatDelimiter__space, time__FormatTime__hhmm24, time__FormatDate__mmmd);
		return _t2;
	}
	string _t3 = time__Time_format(t);
	return _t3;
}

string time__Time_clean12(time__Time t) {
	time__Time znow = time__now();
	if (t.month == znow.month && t.year == znow.year && t.day == znow.day) {
		string _t1 = time__Time_get_fmt_time_str(t, time__FormatTime__hhmm12);
		return _t1;
	}
	if (t.year == znow.year) {
		string _t2 = time__Time_get_fmt_str(t, time__FormatDelimiter__space, time__FormatTime__hhmm12, time__FormatDate__mmmd);
		return _t2;
	}
	string _t3 = time__Time_format(t);
	return _t3;
}

string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time) {
	if (fmt_time == time__FormatTime__no_time) {
		string _t1 = _SLIT("");
		return _t1;
	}
	string tp = (t.hour > 11 ? (_SLIT("p.m.")) : (_SLIT("a.m.")));
	int hour_ = (t.hour > 12 ? (t.hour - 12) : t.hour == 0 ? (12) : (t.hour));
	string _t3 = (string){.str=(byteptr)"", .is_lit=1};
	switch (fmt_time) {
		case time__FormatTime__hhmm12: 
			{
				_t3 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = hour_}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(" "), 0xfe10, {.d_s = tp}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatTime__hhmm24: 
			{
				_t3 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatTime__hhmmss12: 
			{
				_t3 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = hour_}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.second}}, {_SLIT(" "), 0xfe10, {.d_s = tp}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatTime__hhmmss24: 
			{
				_t3 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.second}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatTime__hhmmss24_milli: 
			{
				_t3 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.second}}, {_SLIT("."), 0x8006fe27, {.d_i32 = (t.microsecond / 1000)}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatTime__hhmmss24_micro: 
			{
				_t3 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.second}}, {_SLIT("."), 0x800cfe27, {.d_i32 = t.microsecond}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatTime__no_time:
		default:
			{
				_t3 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown enumeration "), 0xfe10, {.d_s = time__FormatTime_str(fmt_time)}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
	}
	string _t2 = _t3;
	return _t2;
}

string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate__no_date) {
		string _t1 = _SLIT("");
		return _t1;
	}
	string month = time__Time_smonth(&t);
	string year =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = (t.year % 100)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (fmt_date) {
		case time__FormatDate__ddmmyy: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), 0xfe10, {.d_s = year}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatDate__ddmmyyyy: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), 0x8008fe27, {.d_i32 = t.year}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatDate__mmddyy: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), 0xfe10, {.d_s = year}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatDate__mmddyyyy: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), 0x8008fe27, {.d_i32 = t.year}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatDate__mmmd: 
			{
				_t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = month}}, {_SLIT("|"), 0xfe07, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatDate__mmmdd: 
			{
				_t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = month}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatDate__mmmddyy: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = month}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), 0xfe10, {.d_s = year}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatDate__mmmddyyyy: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = month}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), 0x8008fe27, {.d_i32 = t.year}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatDate__yyyymmdd: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0x8008fe27, {.d_i32 = t.year}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatDate__yymmdd: 
			{
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = year}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), 0x8004fe27, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
		case time__FormatDate__no_date:
		default:
			{
				_t2 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown enumeration "), 0xfe10, {.d_s = time__FormatDate_str(fmt_date)}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
			}
	}
	string res = _t2;
	string del = ((fmt_dlmtr == (time__FormatDelimiter__dot)) ? (_SLIT(".")) : (fmt_dlmtr == (time__FormatDelimiter__hyphen)) ? (_SLIT("-")) : (fmt_dlmtr == (time__FormatDelimiter__slash)) ? (_SLIT("/")) : (fmt_dlmtr == (time__FormatDelimiter__space)) ? (_SLIT(" ")) : (_SLIT("")));
	res = string_replace(res, _SLIT("|"), del);
	string _t3 = res;
	return _t3;
}

string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate__no_date) {
		if (fmt_time == time__FormatTime__no_time) {
			string _t1 = _SLIT("");
			return _t1;
		} else {
			string _t2 = time__Time_get_fmt_time_str(t, fmt_time);
			return _t2;
		}
	} else {
		if (fmt_time != time__FormatTime__no_time) {
			string dstr = time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date);
			string tstr = time__Time_get_fmt_time_str(t, fmt_time);
			string _t3 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = dstr}}, {_SLIT(" "), 0xfe10, {.d_s = tstr}}, {_SLIT0, 0, { .d_c = 0 }}}));
			return _t3;
		} else {
			string _t4 = time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date);
			return _t4;
		}
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string time__Time_utc_string(time__Time t) {
	string day_str = time__Time_weekday_str(&t);
	string month_str = time__Time_smonth(&t);
	string utc_string =  str_intp(8, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = day_str}}, {_SLIT(", "), 0xfe07, {.d_i32 = t.day}}, {_SLIT(" "), 0xfe10, {.d_s = month_str}}, {_SLIT(" "), 0xfe07, {.d_i32 = t.year}}, {_SLIT(" "), 0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), 0x8004fe27, {.d_i32 = t.second}}, {_SLIT(" UTC"), 0, { .d_c = 0 }}}));
	string _t1 = utc_string;
	return _t1;
}

// Attr: [inline]
inline bool time__Time__eq(time__Time t1, time__Time t2) {
	bool _t1 = t1._v_unix == t2._v_unix && t1.microsecond == t2.microsecond;
	return _t1;
}

// Attr: [inline]
inline bool time__Time__lt(time__Time t1, time__Time t2) {
	bool _t1 = t1._v_unix < t2._v_unix || (t1._v_unix == t2._v_unix && t1.microsecond < t2.microsecond);
	return _t1;
}

// Attr: [inline]
inline time__Duration time__Time__minus(time__Time lhs, time__Time rhs) {
	i64 lhs_micro = lhs._v_unix * 1000000 + lhs.microsecond;
	i64 rhs_micro = rhs._v_unix * 1000000 + rhs.microsecond;
	time__Duration _t1 = (lhs_micro - rhs_micro) * _const_time__microsecond;
	return _t1;
}

Option_time__Time time__parse_rfc3339(string s) {
	if ((s).len == 0) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(0), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string sn = string_replace_each(s, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("t"), _SLIT("T"), _SLIT("z"), _SLIT("Z")})));
	Option_time__Time _t2 = time__parse_iso8601(sn);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(time__Time*) _t2.data = ((time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,.is_local = 0,});
	}
	
 	time__Time t =  (*(time__Time*)_t2.data);
	if (!time__Time__eq(t, ((time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,.is_local = 0,}))) {
		Option_time__Time _t3;
		opt_ok(&(time__Time[]) { t }, (Option*)(&_t3), sizeof(time__Time));
		return _t3;
	}
	Option_int _t4 = string_index(sn, _SLIT("T"));
	if (_t4.state != 0) { /*or block*/ 
		IError err = _t4.err;
		*(int*) _t4.data = -1;
	}
	
 	int t_i =  (*(int*)_t4.data);
	Array_string parts = (t_i != -1 ? (new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){string_clone(string_substr(sn, 0, t_i)), string_clone(string_substr(sn, t_i + 1, (sn).len))}))) : (string_split(sn, _SLIT(" "))));
	if (!string_contains_any((*(string*)/*ee elem_sym */array_get(parts, 0)), _SLIT(" Z")) && string_contains((*(string*)/*ee elem_sym */array_get(parts, 0)), _SLIT("-"))) {
		Option_multi_return_int_int_int _t5 = time__parse_iso8601_date(sn);
		if (_t5.state != 0) { /*or block*/ 
			Option_time__Time _t6;
			memcpy(&_t6, &_t5, sizeof(Option));
			return _t6;
		}
		
 		multi_return_int_int_int mr_1001 =  (*(multi_return_int_int_int*)_t5.data);
		int year = mr_1001.arg0;
		int month = mr_1001.arg1;
		int day = mr_1001.arg2;
		t = time__new_time(((time__Time){.year = year,.month = month,.day = day,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,.is_local = 0,}));
		Option_time__Time _t7;
		opt_ok(&(time__Time[]) { t }, (Option*)(&_t7), sizeof(time__Time));
		return _t7;
	}
	if (!string_contains((*(string*)/*ee elem_sym */array_get(parts, 0)), _SLIT("-")) && string_contains((*(string*)/*ee elem_sym */array_get(parts, 0)), _SLIT(":"))) {
		int hour_ = 0;
		int minute_ = 0;
		int second_ = 0;
		int microsecond_ = 0;
		i64 unix_offset = ((i64)(0));
		bool is_local_time = true;
		Option_multi_return_int_int_int_int_i64_bool _t8 = time__parse_iso8601_time((*(string*)/*ee elem_sym */array_get(parts, 0)));
		if (_t8.state != 0) { /*or block*/ 
			Option_time__Time _t9;
			memcpy(&_t9, &_t8, sizeof(Option));
			return _t9;
		}
		
 		multi_return_int_int_int_int_i64_bool mr_1384 =  (*(multi_return_int_int_int_int_i64_bool*)_t8.data);
		hour_ = mr_1384.arg0;
		minute_ = mr_1384.arg1;
		second_ = mr_1384.arg2;
		microsecond_ = mr_1384.arg3;
		unix_offset = mr_1384.arg4;
		is_local_time = mr_1384.arg5;
		t = time__new_time(((time__Time){.year = 0,.month = 0,.day = 0,.hour = hour_,.minute = minute_,.second = second_,.microsecond = microsecond_,._v_unix = 0,.is_local = 0,}));
		if (is_local_time) {
			Option_time__Time _t10;
			opt_ok(&(time__Time[]) { t }, (Option*)(&_t10), sizeof(time__Time));
			return _t10;
		}
		i64 unix_time = t._v_unix;
		if (unix_offset < 0) {
			unix_time -= (-unix_offset);
		} else if (unix_offset > 0) {
			unix_time += unix_offset;
		}
		t = time__unix2(((i64)(unix_time)), t.microsecond);
		Option_time__Time _t11;
		opt_ok(&(time__Time[]) { t }, (Option*)(&_t11), sizeof(time__Time));
		return _t11;
	}
	return (Option_time__Time){ .state=2, .err=time__error_invalid_time(9), .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_time__Time time__parse(string s) {
	if ((s).len == 0) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(0), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_int _t2 = string_index(s, _SLIT(" "));
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(1), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int pos =  (*(int*)_t2.data);
	string symd = string_substr(s, 0, pos);
	Array_string ymd = string_split(symd, _SLIT("-"));
	if (ymd.len != 3) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(2), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string shms = string_substr(s, pos, (s).len);
	Array_string hms = string_split(shms, _SLIT(":"));
	string hour_ = string_substr((*(string*)/*ee elem_sym */array_get(hms, 0)), 1, ((*(string*)/*ee elem_sym */array_get(hms, 0))).len);
	string minute_ = (*(string*)/*ee elem_sym */array_get(hms, 1));
	string second_ = (*(string*)/*ee elem_sym */array_get(hms, 2));
	int iyear = string_int((*(string*)/*ee elem_sym */array_get(ymd, 0)));
	int imonth = string_int((*(string*)/*ee elem_sym */array_get(ymd, 1)));
	int iday = string_int((*(string*)/*ee elem_sym */array_get(ymd, 2)));
	int ihour = string_int(hour_);
	int iminute = string_int(minute_);
	int isecond = string_int(second_);
	if (iyear > 9999 || iyear < -9999) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(3), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (imonth > 12 || imonth < 1) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(4), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (iday > 31 || iday < 1) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(5), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (ihour > 23 || ihour < 0) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(6), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (iminute > 59 || iminute < 0) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(7), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (isecond > 59 || isecond < 0) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(8), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	time__Time res = time__new_time(((time__Time){
		.year = iyear,
		.month = imonth,
		.day = iday,
		.hour = ihour,
		.minute = iminute,
		.second = isecond,
		.microsecond = 0,
		._v_unix = 0,
		.is_local = 0,
	}));
	Option_time__Time _t11;
	opt_ok(&(time__Time[]) { res }, (Option*)(&_t11), sizeof(time__Time));
	return _t11;
}

Option_time__Time time__parse_iso8601(string s) {
	if ((s).len == 0) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(0), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_int _t2 = string_index(s, _SLIT("T"));
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		*(int*) _t2.data = -1;
	}
	
 	int t_i =  (*(int*)_t2.data);
	Array_string parts = (t_i != -1 ? (new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){string_clone(string_substr(s, 0, t_i)), string_clone(string_substr(s, t_i + 1, (s).len))}))) : (string_split(s, _SLIT(" "))));
	if (!(parts.len == 1 || parts.len == 2)) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(12), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_multi_return_int_int_int _t4 = time__parse_iso8601_date((*(string*)/*ee elem_sym */array_get(parts, 0)));
	if (_t4.state != 0) { /*or block*/ 
		Option_time__Time _t5;
		memcpy(&_t5, &_t4, sizeof(Option));
		return _t5;
	}
	
 	multi_return_int_int_int mr_3646 =  (*(multi_return_int_int_int*)_t4.data);
	int year = mr_3646.arg0;
	int month = mr_3646.arg1;
	int day = mr_3646.arg2;
	int hour_ = 0;
	int minute_ = 0;
	int second_ = 0;
	int microsecond_ = 0;
	i64 unix_offset = ((i64)(0));
	bool is_local_time = true;
	if (parts.len == 2) {
		Option_multi_return_int_int_int_int_i64_bool _t6 = time__parse_iso8601_time((*(string*)/*ee elem_sym */array_get(parts, 1)));
		if (_t6.state != 0) { /*or block*/ 
			Option_time__Time _t7;
			memcpy(&_t7, &_t6, sizeof(Option));
			return _t7;
		}
		
 		multi_return_int_int_int_int_i64_bool mr_3888 =  (*(multi_return_int_int_int_int_i64_bool*)_t6.data);
		hour_ = mr_3888.arg0;
		minute_ = mr_3888.arg1;
		second_ = mr_3888.arg2;
		microsecond_ = mr_3888.arg3;
		unix_offset = mr_3888.arg4;
		is_local_time = mr_3888.arg5;
	}
	time__Time t = time__new_time(((time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hour_,
		.minute = minute_,
		.second = second_,
		.microsecond = microsecond_,
		._v_unix = 0,
		.is_local = 0,
	}));
	if (is_local_time) {
		Option_time__Time _t8;
		opt_ok(&(time__Time[]) { t }, (Option*)(&_t8), sizeof(time__Time));
		return _t8;
	}
	i64 unix_time = t._v_unix;
	if (unix_offset < 0) {
		unix_time -= (-unix_offset);
	} else if (unix_offset > 0) {
		unix_time += unix_offset;
	}
	t = time__unix2(((i64)(unix_time)), t.microsecond);
	Option_time__Time _t9;
	opt_ok(&(time__Time[]) { t }, (Option*)(&_t9), sizeof(time__Time));
	return _t9;
}

Option_time__Time time__parse_rfc2822(string s) {
	if ((s).len == 0) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(0), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Array_string fields = string_split(s, _SLIT(" "));
	if (fields.len < 5) {
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(1), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_int _t3 = string_index(_const_time__months_string, (*(string*)/*ee elem_sym */array_get(fields, 2)));
	if (_t3.state != 0) { /*or block*/ 
		IError err = _t3.err;
		return (Option_time__Time){ .state=2, .err=time__error_invalid_time(2), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int pos =  (*(int*)_t3.data);
	int mm = pos / 3 + 1;
	{ // Unsafe block
		u8* tmstr = malloc_noscan(s.len * 2);
		int count = snprintf(((char*)(tmstr)), (s.len * 2), "%s-%02d-%s %s", (*(string*)/*ee elem_sym */array_get(fields, 3)).str, mm, (*(string*)/*ee elem_sym */array_get(fields, 1)).str, (*(string*)/*ee elem_sym */array_get(fields, 4)).str);
		Option_time__Time _t5 = time__parse(tos(tmstr, count));
		return _t5;
	}
	return (Option_time__Time){0};
}

Option_multi_return_int_int_int time__parse_iso8601_date(string s) {
	int year = 0;
	int month = 0;
	int day = 0;
	u8 dummy = ((u8)(0));
	int count = sscanf(((char*)(s.str)), "%4d-%2d-%2d%c", &year, &month, &day, &dummy);
	if (count != 3) {
		return (Option_multi_return_int_int_int){ .state=2, .err=time__error_invalid_time(10), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (year > 9999) {
		return (Option_multi_return_int_int_int){ .state=2, .err=time__error_invalid_time(13), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (month > 12) {
		return (Option_multi_return_int_int_int){ .state=2, .err=time__error_invalid_time(14), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (day > 31) {
		return (Option_multi_return_int_int_int){ .state=2, .err=time__error_invalid_time(15), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_multi_return_int_int_int _t5;
	opt_ok(&(multi_return_int_int_int/*X*/[]) { (multi_return_int_int_int){.arg0=year, .arg1=month, .arg2=day} }, (Option*)(&_t5), sizeof(multi_return_int_int_int));
	return _t5;
}

Option_multi_return_int_int_int_int_i64_bool time__parse_iso8601_time(string s) {
	int hour_ = 0;
	int minute_ = 0;
	int second_ = 0;
	int microsecond_ = 0;
	rune plus_min_z = 'a';
	int offset_hour = 0;
	int offset_minute = 0;
	int count = sscanf(((char*)(s.str)), "%2d:%2d:%2d.%6d%c%2d:%2d", &hour_, &minute_, &second_, &microsecond_, ((char*)(&plus_min_z)), &offset_hour, &offset_minute);
	if (count < 4) {
		count = sscanf(((char*)(s.str)), "%2d:%2d:%2d%c%2d:%2d", &hour_, &minute_, &second_, ((char*)(&plus_min_z)), &offset_hour, &offset_minute);
		count++;
	}
	if (count < 4) {
		return (Option_multi_return_int_int_int_int_i64_bool){ .state=2, .err=time__error_invalid_time(10), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	bool is_local_time = plus_min_z == 'a' && count == 4;
	bool is_utc = plus_min_z == 'Z' && count == 5;
	if (!(count == 7 || is_local_time || is_utc)) {
		return (Option_multi_return_int_int_int_int_i64_bool){ .state=2, .err=time__error_invalid_time(11), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (plus_min_z != '+' && plus_min_z != '-' && !is_utc && !is_local_time) {
		return (Option_multi_return_int_int_int_int_i64_bool){ .state=2, .err=time__error_invalid_time(12), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int unix_offset = 0;
	if (offset_hour > 0) {
		unix_offset += 3600 * offset_hour;
	}
	if (offset_minute > 0) {
		unix_offset += 60 * offset_minute;
	}
	if (plus_min_z == '+') {
		unix_offset *= -1;
	}
	Option_multi_return_int_int_int_int_i64_bool _t4;
	opt_ok(&(multi_return_int_int_int_int_i64_bool/*X*/[]) { (multi_return_int_int_int_int_i64_bool){.arg0=hour_, .arg1=minute_, .arg2=second_, .arg3=microsecond_, .arg4=unix_offset, .arg5=is_local_time} }, (Option*)(&_t4), sizeof(multi_return_int_int_int_int_i64_bool));
	return _t4;
}

string time__TimeParseError_msg(time__TimeParseError err) {
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Invalid time format code: "), 0xfe07, {.d_i32 = err.code}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

IError time__error_invalid_time(int code) {
	IError _t1 = I_time__TimeParseError_to_Interface_IError(((time__TimeParseError*)memdup(&(time__TimeParseError){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),.code = code,}, sizeof(time__TimeParseError))));
	return _t1;
}

time__StopWatch time__new_stopwatch(time__StopWatchOptions opts) {
	u64 initial = ((u64)(0U));
	if (opts.auto_start) {
		initial = time__sys_mono_now();
	}
	time__StopWatch _t1 = ((time__StopWatch){.elapsed = 0U,.start = initial,.end = 0U,});
	return _t1;
}

void time__StopWatch_start(time__StopWatch* t) {
	t->start = time__sys_mono_now();
	t->end = 0U;
}

void time__StopWatch_restart(time__StopWatch* t) {
	t->start = time__sys_mono_now();
	t->end = 0U;
	t->elapsed = 0U;
}

void time__StopWatch_stop(time__StopWatch* t) {
	t->end = time__sys_mono_now();
}

void time__StopWatch_pause(time__StopWatch* t) {
	if (t->start > 0U) {
		if (t->end == 0U) {
			t->elapsed += time__sys_mono_now() - t->start;
		} else {
			t->elapsed += t->end - t->start;
		}
	}
	t->start = 0U;
}

time__Duration time__StopWatch_elapsed(time__StopWatch t) {
	if (t.start > 0U) {
		if (t.end == 0U) {
			time__Duration _t1 = ((((i64)(time__sys_mono_now() - t.start + t.elapsed))));
			return _t1;
		} else {
			time__Duration _t2 = ((((i64)(t.end - t.start + t.elapsed))));
			return _t2;
		}
	}
	time__Duration _t3 = ((((i64)(t.elapsed))));
	return _t3;
}

time__Time time__now(void) {
	time__Time _t1 = time__darwin_now();
	return _t1;
	time_t t = time(0);
	struct tm* now = localtime(&t);
	time__Time _t2 = time__convert_ctime(*now, 0);
	return _t2;
}

time__Time time__utc(void) {
	time__Time _t1 = time__darwin_utc();
	return _t1;
	time_t t = time(0);
	time(&t);
	time__Time _t2 = time__unix2(((i64)(t)), 0);
	return _t2;
}

time__Time time__new_time(time__Time t) {
	if (t._v_unix != 0) {
		time__Time _t1 = t;
		return _t1;
	}
	struct tm tt = ((struct tm){
		.tm_sec = t.second,
		.tm_min = t.minute,
		.tm_hour = t.hour,
		.tm_mday = t.day,
		.tm_mon = t.month - 1,
		.tm_year = t.year - 1900,
		.tm_wday = 0,
		.tm_yday = 0,
		.tm_isdst = 0,
	});
	i64 utime = time__make_unix_time(tt);
	time__Time _t2 = ((time__Time){t.year,t.month,t.day,t.hour,t.minute,t.second,t.microsecond,._v_unix = utime,t.is_local,});
	return _t2;
}

i64 time__ticks(void) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		struct timeval ts = ((struct timeval){.tv_sec = 0,.tv_usec = 0,});
		gettimeofday(&ts, 0);
		i64 _t1 = ((i64)(ts.tv_sec * ((u64)(1000U)) + (ts.tv_usec / ((u64)(1000U)))));
		return _t1;
	}
	#endif
	return 0;
}

string time__Time_str(time__Time t) {
	string _t1 = time__Time_format_ss(t);
	return _t1;
}

time__Time time__convert_ctime(struct tm t, int microsecond) {
	time__Time _t1 = ((time__Time){
		.year = t.tm_year + 1900,
		.month = t.tm_mon + 1,
		.day = t.tm_mday,
		.hour = t.tm_hour,
		.minute = t.tm_min,
		.second = t.tm_sec,
		.microsecond = microsecond,
		._v_unix = time__make_unix_time(t),
		.is_local = true,
	});
	return _t1;
}

string time__Time_strftime(time__Time t, string fmt) {
	struct tm* tm = ((struct tm*)memdup(&(struct tm){.tm_sec = 0,.tm_min = 0,.tm_hour = 0,.tm_mday = 0,.tm_mon = 0,.tm_year = 0,.tm_wday = 0,.tm_yday = 0,.tm_isdst = 0,}, sizeof(struct tm)));
	#if defined(_WIN32)
	{
	}
	#else
	{
		gmtime_r(((voidptr)(&t._v_unix)), tm);
	}
	#endif
	Array_fixed_C__char_1024 buf = {0};
	char* fmt_c = ((char*)(fmt.str));
	strftime(&buf[0], ((size_t)(sizeof(Array_fixed_C__char_1024))), fmt_c, tm);
	string _t1 = cstring_to_vstring(((char*)(&buf[0])));
	return _t1;
}

string time__Time_smonth(time__Time* t) {
	if (t->month <= 0 || t->month > 12) {
		string _t1 = _SLIT("---");
		return _t1;
	}
	int i = t->month - 1;
	string _t2 = string_substr(_const_time__months_string, i * 3, (i + 1) * 3);
	return _t2;
}

// Attr: [inline]
inline i64 time__Time_unix_time(time__Time* t) {
	i64 _t1 = t->_v_unix;
	return _t1;
}

// Attr: [inline]
inline i64 time__Time_unix_time_milli(time__Time* t) {
	i64 _t1 = t->_v_unix * 1000 + (t->microsecond / 1000);
	return _t1;
}

time__Time time__Time_add(time__Time* t, time__Duration d) {
	i64 microseconds = ((i64)(t->_v_unix)) * 1000000 + t->microsecond + time__Duration_microseconds(d);
	i64 _v_unix = microseconds / 1000000;
	i64 micro = microseconds % 1000000;
	time__Time _t1 = time__unix2(_v_unix, ((int)(micro)));
	return _t1;
}

time__Time time__Time_add_seconds(time__Time* t, int seconds) {
	time__Time _t1 = time__Time_add(t, seconds * _const_time__second);
	return _t1;
}

time__Time time__Time_add_days(time__Time* t, int days) {
	time__Time _t1 = time__Time_add(t, days * 24 * _const_time__hour);
	return _t1;
}

time__Duration time__since(time__Time t) {
	time__Duration _t1 = time__Time__minus(time__now(), t);
	return _t1;
}

string time__Time_relative(time__Time* t) {
	time__Time znow = time__now();
	i64 secs = znow._v_unix - t->_v_unix;
	if (secs <= 30) {
		string _t1 = _SLIT("now");
		return _t1;
	}
	if (secs < 60) {
		string _t2 = _SLIT("1m");
		return _t2;
	}
	if (secs < 3600) {
		i64 m = secs / 60;
		if (m == 1) {
			string _t3 = _SLIT("1 minute ago");
			return _t3;
		}
		string _t4 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = m}}, {_SLIT(" minutes ago"), 0, { .d_c = 0 }}}));
		return _t4;
	}
	if (secs < 3600 * 24) {
		i64 h = secs / 3600;
		if (h == 1) {
			string _t5 = _SLIT("1 hour ago");
			return _t5;
		}
		string _t6 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = h}}, {_SLIT(" hours ago"), 0, { .d_c = 0 }}}));
		return _t6;
	}
	if (secs < 3600 * 24 * 5) {
		i64 d = secs / 3600 / 24;
		if (d == 1) {
			string _t7 = _SLIT("1 day ago");
			return _t7;
		}
		string _t8 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = d}}, {_SLIT(" days ago"), 0, { .d_c = 0 }}}));
		return _t8;
	}
	if (secs > 3600 * 24 * 10000) {
		string _t9 = _SLIT("");
		return _t9;
	}
	string _t10 = time__Time_md(/*rec*/*t);
	return _t10;
}

string time__Time_relative_short(time__Time* t) {
	time__Time znow = time__now();
	i64 secs = znow._v_unix - t->_v_unix;
	if (secs <= 30) {
		string _t1 = _SLIT("now");
		return _t1;
	}
	if (secs < 60) {
		string _t2 = _SLIT("1m");
		return _t2;
	}
	if (secs < 3600) {
		string _t3 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = secs / 60}}, {_SLIT("m"), 0, { .d_c = 0 }}}));
		return _t3;
	}
	if (secs < 3600 * 24) {
		string _t4 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = secs / 3600}}, {_SLIT("h"), 0, { .d_c = 0 }}}));
		return _t4;
	}
	if (secs < 3600 * 24 * 5) {
		string _t5 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = secs / 3600 / 24}}, {_SLIT("d"), 0, { .d_c = 0 }}}));
		return _t5;
	}
	if (secs > 3600 * 24 * 10000) {
		string _t6 = _SLIT("");
		return _t6;
	}
	string _t7 = time__Time_md(/*rec*/*t);
	return _t7;
}

int time__day_of_week(int y, int m, int d) {
	Array_int t = new_array_from_c_array(12, 12, sizeof(int), _MOV((int[12]){
			0, 3, 2, 5, 0, 3, 5, 1, 4,
			6, 2, 4}));
	int sy = y;
	if (m < 3) {
		sy = sy - 1;
	}
	int _t1 = (sy + sy / 4 - sy / 100 + sy / 400 + (*(int*)/*ee elem_sym */array_get(t, m - 1)) + d - 1) % 7 + 1;
	return _t1;
}

int time__Time_day_of_week(time__Time* t) {
	int _t1 = time__day_of_week(t->year, t->month, t->day);
	return _t1;
}

string time__Time_weekday_str(time__Time* t) {
	int i = time__Time_day_of_week(t) - 1;
	string _t1 = string_substr(_const_time__days_string, i * 3, (i + 1) * 3);
	return _t1;
}

string time__Time_long_weekday_str(time__Time* t) {
	int i = time__Time_day_of_week(t) - 1;
	string _t1 = (*(string*)/*ee elem_sym */array_get(_const_time__long_days, i));
	return _t1;
}

bool time__is_leap_year(int year) {
	bool _t1 = (year % 4 == 0) && (year % 100 != 0 || year % 400 == 0);
	return _t1;
}

Option_int time__days_in_month(int month, int year) {
	if (month > 12 || month < 1) {
		return (Option_int){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Invalid month: "), 0xfe07, {.d_i32 = month}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int extra = (month == 2 && time__is_leap_year(year) ? (1) : (0));
	int res = (*(int*)/*ee elem_sym */array_get(_const_time__month_days, month - 1)) + extra;
	Option_int _t2;
	opt_ok(&(int[]) { res }, (Option*)(&_t2), sizeof(int));
	return _t2;
}

string time__Time_debug(time__Time* t) {
	string _t1 =  str_intp(9, _MOV((StrIntpData[]){{_SLIT("Time{ year: "), 0x8008fe27, {.d_i32 = t->year}}, {_SLIT(" month: "), 0x8004fe27, {.d_i32 = t->month}}, {_SLIT(" day: "), 0x8004fe27, {.d_i32 = t->day}}, {_SLIT(" hour: "), 0x8004fe27, {.d_i32 = t->hour}}, {_SLIT(" minute: "), 0x8004fe27, {.d_i32 = t->minute}}, {_SLIT(" second: "), 0x8004fe27, {.d_i32 = t->second}}, {_SLIT(" microsecond: "), 0x800cfe27, {.d_i32 = t->microsecond}}, {_SLIT(" unix: "), 0x800efe29, {.d_i64 = t->_v_unix}}, {_SLIT(" }"), 0, { .d_c = 0 }}}));
	return _t1;
}

// TypeDecl
i64 time__Duration_nanoseconds(time__Duration d) {
	i64 _t1 = ((i64)(d));
	return _t1;
}

i64 time__Duration_microseconds(time__Duration d) {
	i64 _t1 = ((i64)(d)) / 1000;
	return _t1;
}

i64 time__Duration_milliseconds(time__Duration d) {
	i64 _t1 = ((i64)(d)) / 1000000;
	return _t1;
}

f64 time__Duration_seconds(time__Duration d) {
	i64 sec = d / _const_time__second;
	i64 nsec = d % _const_time__second;
	f64 _t1 = ((f64)(sec)) + ((f64)(nsec)) / 1e9;
	return _t1;
}

f64 time__Duration_minutes(time__Duration d) {
	i64 min = d / _const_time__minute;
	i64 nsec = d % _const_time__minute;
	f64 _t1 = ((f64)(min)) + ((f64)(nsec)) / (60 * 1e9);
	return _t1;
}

f64 time__Duration_hours(time__Duration d) {
	i64 hr = d / _const_time__hour;
	i64 nsec = d % _const_time__hour;
	f64 _t1 = ((f64)(hr)) + ((f64)(nsec)) / (60 * 60 * 1e9);
	return _t1;
}

string time__Duration_str(time__Duration d) {
	if (time__Duration_alias_eq(d, _const_time__infinite)) {
		string _t1 = _SLIT("inf");
		return _t1;
	}
	i64 t = ((i64)(d));
	i64 hr = t / _const_time__hour;
	t -= hr * _const_time__hour;
	i64 min = t / _const_time__minute;
	t -= min * _const_time__minute;
	i64 sec = t / _const_time__second;
	t -= sec * _const_time__second;
	i64 ms = t / _const_time__millisecond;
	t -= ms * _const_time__millisecond;
	i64 us = t / _const_time__microsecond;
	t -= us * _const_time__microsecond;
	i64 ns = t;
	if (hr > 0) {
		string _t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = hr}}, {_SLIT(":"), 0x8004fe29, {.d_i64 = min}}, {_SLIT(":"), 0x8004fe29, {.d_i64 = sec}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t2;
	}
	if (min > 0) {
		string _t3 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = min}}, {_SLIT(":"), 0x8004fe29, {.d_i64 = sec}}, {_SLIT("."), 0x8006fe29, {.d_i64 = ms}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t3;
	}
	if (sec > 0) {
		string _t4 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = sec}}, {_SLIT("."), 0x8006fe29, {.d_i64 = ms}}, {_SLIT("s"), 0, { .d_c = 0 }}}));
		return _t4;
	}
	if (ms > 0) {
		string _t5 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = ms}}, {_SLIT("."), 0x8006fe29, {.d_i64 = us}}, {_SLIT("ms"), 0, { .d_c = 0 }}}));
		return _t5;
	}
	if (us > 0) {
		string _t6 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = us}}, {_SLIT("."), 0x8006fe29, {.d_i64 = ns}}, {_SLIT("us"), 0, { .d_c = 0 }}}));
		return _t6;
	}
	string _t7 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe09, {.d_i64 = ns}}, {_SLIT("ns"), 0, { .d_c = 0 }}}));
	return _t7;
}

int time__offset(void) {
	time__Time t = time__utc();
	time__Time local = time__Time_local(&t);
	int _t1 = ((int)(local._v_unix - t._v_unix));
	return _t1;
}

mach_timebase_info_data_t time__init_time_base(void) {
	mach_timebase_info_data_t tb = ((mach_timebase_info_data_t){.numer = 0,.denom = 0,});
	mach_timebase_info(&tb);
	mach_timebase_info_data_t _t1 = ((mach_timebase_info_data_t){.numer = tb.numer,.denom = tb.denom,});
	return _t1;
}

u64 time__sys_mono_now_darwin(void) {
	u64 tm = mach_absolute_time();
	if (_const_time__time_base.denom == 0U) {
		mach_timebase_info(&_const_time__time_base);
	}
	u64 _t1 = (tm - _const_time__start_time) * _const_time__time_base.numer / _const_time__time_base.denom;
	return _t1;
}

// Attr: [inline]
inline u64 time__vpc_now_darwin(void) {
	u64 tm = mach_absolute_time();
	if (_const_time__time_base.denom == 0U) {
		mach_timebase_info(&_const_time__time_base);
	}
	u64 _t1 = (tm - _const_time__start_time) * _const_time__time_base.numer / _const_time__time_base.denom;
	return _t1;
}

time__Time time__darwin_now(void) {
	struct timeval *tv = HEAP(struct timeval, (((struct timeval){.tv_sec = 0,.tv_usec = 0,})));
	gettimeofday(&(*(tv)), 0);
	struct tm loc_tm = ((struct tm){.tm_sec = 0,.tm_min = 0,.tm_hour = 0,.tm_mday = 0,.tm_mon = 0,.tm_year = 0,.tm_wday = 0,.tm_yday = 0,.tm_isdst = 0,});
	voidptr asec = ((voidptr)(&(*(tv)).tv_sec));
	localtime_r(asec, &loc_tm);
	time__Time _t1 = time__convert_ctime(loc_tm, ((int)((*(tv)).tv_usec)));
	return _t1;
}

time__Time time__darwin_utc(void) {
	struct timeval tv = ((struct timeval){.tv_sec = 0,.tv_usec = 0,});
	gettimeofday(&tv, 0);
	time__Time _t1 = time__unix2(((i64)(tv.tv_sec)), ((int)(tv.tv_usec)));
	return _t1;
}

time__Time time__solaris_now(void) {
	time__Time _t1 = ((time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,.is_local = 0,});
	return _t1;
}

time__Time time__solaris_utc(void) {
	time__Time _t1 = ((time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,.is_local = 0,});
	return _t1;
}

i64 time__make_unix_time(struct tm t) {
	i64 _t1 = ((i64)(timegm(&t)));
	return _t1;
}

time__Time time__Time_local(time__Time* t) {
	if (t->is_local) {
		time__Time _t1 = *t;
		return _t1;
	}
	struct tm loc_tm = ((struct tm){.tm_sec = 0,.tm_min = 0,.tm_hour = 0,.tm_mday = 0,.tm_mon = 0,.tm_year = 0,.tm_wday = 0,.tm_yday = 0,.tm_isdst = 0,});
	localtime_r(((voidptr)(&t->_v_unix)), &loc_tm);
	time__Time _t2 = time__convert_ctime(loc_tm, t->microsecond);
	return _t2;
}

u64 time__sys_mono_now(void) {
	#if defined(__APPLE__)
	{
		u64 _t1 = time__sys_mono_now_darwin();
		return _t1;
	}
	#else
	{
	}
	#endif
	return 0;
}

// Attr: [inline]
inline u64 time__vpc_now(void) {
	struct timespec ts = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
	clock_gettime(CLOCK_MONOTONIC, &ts);
	u64 _t1 = ((u64)(ts.tv_sec)) * 1000000000U + ((u64)(ts.tv_nsec));
	return _t1;
}

time__Time time__linux_now(void) {
	struct timespec ts = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
	clock_gettime(CLOCK_REALTIME, &ts);
	struct tm loc_tm = ((struct tm){.tm_sec = 0,.tm_min = 0,.tm_hour = 0,.tm_mday = 0,.tm_mon = 0,.tm_year = 0,.tm_wday = 0,.tm_yday = 0,.tm_isdst = 0,});
	localtime_r(((voidptr)(&ts.tv_sec)), &loc_tm);
	time__Time _t1 = time__convert_ctime(loc_tm, ((int)(ts.tv_nsec / 1000)));
	return _t1;
}

time__Time time__linux_utc(void) {
	struct timespec ts = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
	clock_gettime(CLOCK_REALTIME, &ts);
	time__Time _t1 = time__unix2(((i64)(ts.tv_sec)), ((int)(ts.tv_nsec / 1000)));
	return _t1;
}

time__Time time__win_now(void) {
	time__Time _t1 = ((time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,.is_local = 0,});
	return _t1;
}

time__Time time__win_utc(void) {
	time__Time _t1 = ((time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,.is_local = 0,});
	return _t1;
}

struct timespec time__Duration_timespec(time__Duration d) {
	struct timespec ts = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
	clock_gettime(CLOCK_REALTIME, &ts);
	i64 d_sec = d / _const_time__second;
	i64 d_nsec = d % _const_time__second;
	ts.tv_sec += d_sec;
	ts.tv_nsec += d_nsec;
	if (ts.tv_nsec > ((i64)(_const_time__second))) {
		ts.tv_nsec -= ((i64)(_const_time__second));
		ts.tv_sec++;
	}
	struct timespec _t1 = ts;
	return _t1;
}

struct timespec time__zero_timespec(void) {
	struct timespec ts = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
	struct timespec _t1 = ts;
	return _t1;
}

void time__sleep(time__Duration duration) {
	struct timespec req = ((struct timespec){.tv_sec = duration / _const_time__second,.tv_nsec = duration % _const_time__second,});
	struct timespec rem = ((struct timespec){.tv_sec = 0,.tv_nsec = 0,});
	for (;;) {
		if (!(nanosleep(&req, &rem) < 0)) break;
		if (errno == EINTR) {
			req = rem;
		} else {
			break;
		}
	}
}

int time__Duration_sys_milliseconds(time__Duration d) {
	if (d > INT32_MAX * _const_time__millisecond) {
		int _t1 = -1;
		return _t1;
	} else if (d <= 0) {
		int _t2 = 0;
		return _t2;
	} else {
		int _t3 = ((int)(d / _const_time__millisecond));
		return _t3;
	}
	return 0;
}

time__Time time__unix(i64 abs) {
	i64 day_offset = abs / _const_time__seconds_per_day;
	if (abs % _const_time__seconds_per_day < 0) {
		day_offset--;
	}
	multi_return_int_int_int mr_472 = time__calculate_date_from_offset(day_offset);
	int year = mr_472.arg0;
	int month = mr_472.arg1;
	int day = mr_472.arg2;
	multi_return_int_int_int mr_528 = time__calculate_time_from_offset(abs % _const_time__seconds_per_day);
	int hr = mr_528.arg0;
	int min = mr_528.arg1;
	int sec = mr_528.arg2;
	time__Time _t1 = ((time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hr,
		.minute = min,
		.second = sec,
		.microsecond = 0,
		._v_unix = abs,
		.is_local = 0,
	});
	return _t1;
}

time__Time time__unix2(i64 abs, int microsecond) {
	i64 day_offset = abs / _const_time__seconds_per_day;
	if (abs % _const_time__seconds_per_day < 0) {
		day_offset--;
	}
	multi_return_int_int_int mr_1020 = time__calculate_date_from_offset(day_offset);
	int year = mr_1020.arg0;
	int month = mr_1020.arg1;
	int day = mr_1020.arg2;
	multi_return_int_int_int mr_1076 = time__calculate_time_from_offset(abs % _const_time__seconds_per_day);
	int hr = mr_1076.arg0;
	int min = mr_1076.arg1;
	int sec = mr_1076.arg2;
	time__Time _t1 = ((time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hr,
		.minute = min,
		.second = sec,
		.microsecond = microsecond,
		._v_unix = abs,
		.is_local = 0,
	});
	return _t1;
}

multi_return_int_int_int time__calculate_date_from_offset(i64 day_offset_) {
	i64 day_offset = day_offset_;
	int year = 2001;
	day_offset -= 31 * 365 + 8;
	year += ((int)(day_offset / _const_time__days_per_400_years)) * 400;
	day_offset %= _const_time__days_per_400_years;
	if (day_offset == _const_time__days_per_100_years * 4) {
		year += 300;
		day_offset -= _const_time__days_per_100_years * 3;
	} else {
		year += ((int)(day_offset / _const_time__days_per_100_years)) * 100;
		day_offset %= _const_time__days_per_100_years;
	}
	if (day_offset == _const_time__days_per_4_years * 25) {
		year += 96;
		day_offset -= _const_time__days_per_4_years * 24;
	} else {
		year += ((int)(day_offset / _const_time__days_per_4_years)) * 4;
		day_offset %= _const_time__days_per_4_years;
	}
	if (day_offset == 365 * 4) {
		year += 3;
		day_offset -= 365 * 3;
	} else {
		year += ((int)(day_offset / 365));
		day_offset %= 365;
	}
	if (day_offset < 0) {
		year--;
		if (time__is_leap_year(year)) {
			day_offset += 366;
		} else {
			day_offset += 365;
		}
	}
	if (time__is_leap_year(year)) {
		if (day_offset > 31 + 29 - 1) {
			day_offset--;
		} else if (day_offset == 31 + 29 - 1) {
			return (multi_return_int_int_int){.arg0=year, .arg1=2, .arg2=29};
		}
	}
	i64 estimated_month = day_offset / 31;
	for (;;) {
		if (!(day_offset >= (*(int*)/*ee elem_sym */array_get(_const_time__days_before, estimated_month + 1)))) break;
		estimated_month++;
	}
	for (;;) {
		if (!(day_offset < (*(int*)/*ee elem_sym */array_get(_const_time__days_before, estimated_month)))) break;
		if (estimated_month == 0) {
			break;
		}
		estimated_month--;
	}
	day_offset -= (*(int*)/*ee elem_sym */array_get(_const_time__days_before, estimated_month));
	return (multi_return_int_int_int){.arg0=year, .arg1=((int)(estimated_month + 1)), .arg2=((int)(day_offset + 1))};
}

multi_return_int_int_int time__calculate_time_from_offset(i64 second_offset_) {
	i64 second_offset = second_offset_;
	if (second_offset < 0) {
		second_offset += _const_time__seconds_per_day;
	}
	i64 hour_ = second_offset / _const_time__seconds_per_hour;
	second_offset %= _const_time__seconds_per_hour;
	i64 min = second_offset / _const_time__seconds_per_minute;
	second_offset %= _const_time__seconds_per_minute;
	return (multi_return_int_int_int){.arg0=((int)(hour_)), .arg1=((int)(min)), .arg2=((int)(second_offset))};
}

// TypeDecl
eventbus__EventBus* eventbus__new(void) {
	eventbus__Registry* registry = ((eventbus__Registry*)memdup(&(eventbus__Registry){.events = __new_array_with_default(0, 0, sizeof(eventbus__EventHandler), 0),}, sizeof(eventbus__Registry)));
	eventbus__EventBus* _t1 = ((eventbus__EventBus*)memdup(&(eventbus__EventBus){.registry = registry,.publisher = ((eventbus__Publisher*)memdup(&(eventbus__Publisher){.registry = registry,}, sizeof(eventbus__Publisher))),.subscriber = ((eventbus__Subscriber*)memdup(&(eventbus__Subscriber){.registry = registry,}, sizeof(eventbus__Subscriber))),}, sizeof(eventbus__EventBus)));
	return _t1;
}

void eventbus__EventBus_publish(eventbus__EventBus* eb, string name, voidptr sender, voidptr args) {
	eventbus__Publisher* publisher = eb->publisher;
	eventbus__Publisher_publish(publisher, name, sender, args);
}

void eventbus__EventBus_clear_all(eventbus__EventBus* eb) {
	eventbus__Publisher* publisher = eb->publisher;
	eventbus__Publisher_clear_all(publisher);
}

bool eventbus__EventBus_has_subscriber(eventbus__EventBus* eb, string name) {
	bool _t1 = eventbus__Registry_check_subscriber(eb->registry, name);
	return _t1;
}

void eventbus__Publisher_publish(eventbus__Publisher* pb, string name, voidptr sender, voidptr args) {
	for (int _t1 = 0; _t1 < pb->registry->events.len; ++_t1) {
		eventbus__EventHandler event = ((eventbus__EventHandler*)pb->registry->events.data)[_t1];
		if (string__eq(event.name, name)) {
			event.handler(event.receiver, args, sender);
		}
	}
	Array_eventbus__EventHandler _t2 = {0};
	Array_eventbus__EventHandler _t2_orig = pb->registry->events;
	int _t2_len = _t2_orig.len;
	_t2 = __new_array(0, _t2_len, sizeof(eventbus__EventHandler));

	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		eventbus__EventHandler it = ((eventbus__EventHandler*) _t2_orig.data)[_t3];
		if (!(string__eq(it.name, name) && it.once)) {
			array_push((array*)&_t2, &it);
		}
	}
	pb->registry->events =_t2;
}

void eventbus__Publisher_clear_all(eventbus__Publisher* p) {
	array_clear(&p->registry->events);
}

void eventbus__Subscriber_subscribe(eventbus__Subscriber* s, string name, void (*handler)(voidptr receiver, voidptr args, voidptr sender)) {
	array_push((array*)&s->registry->events, _MOV((eventbus__EventHandler[]){ ((eventbus__EventHandler){.name = name,.handler = (voidptr)handler,.receiver = ((voidptr)(0)),.once = 0,}) }));
}

void eventbus__Subscriber_subscribe_method(eventbus__Subscriber* s, string name, void (*handler)(voidptr receiver, voidptr args, voidptr sender), voidptr receiver) {
	array_push((array*)&s->registry->events, _MOV((eventbus__EventHandler[]){ ((eventbus__EventHandler){.name = name,.handler = (voidptr)handler,.receiver = receiver,.once = 0,}) }));
}

void eventbus__Subscriber_unsubscribe_method(eventbus__Subscriber* s, string name, voidptr receiver) {
	Array_eventbus__EventHandler _t1 = {0};
	Array_eventbus__EventHandler _t1_orig = s->registry->events;
	int _t1_len = _t1_orig.len;
	_t1 = __new_array(0, _t1_len, sizeof(eventbus__EventHandler));

	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		eventbus__EventHandler it = ((eventbus__EventHandler*) _t1_orig.data)[_t2];
		if (!(string__eq(it.name, name) && it.receiver == receiver)) {
			array_push((array*)&_t1, &it);
		}
	}
	s->registry->events =_t1;
}

void eventbus__Subscriber_unsubscribe_receiver(eventbus__Subscriber* s, voidptr receiver) {
	Array_eventbus__EventHandler _t1 = {0};
	Array_eventbus__EventHandler _t1_orig = s->registry->events;
	int _t1_len = _t1_orig.len;
	_t1 = __new_array(0, _t1_len, sizeof(eventbus__EventHandler));

	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		eventbus__EventHandler it = ((eventbus__EventHandler*) _t1_orig.data)[_t2];
		if (it.receiver != receiver) {
			array_push((array*)&_t1, &it);
		}
	}
	s->registry->events =_t1;
}

void eventbus__Subscriber_subscribe_once(eventbus__Subscriber* s, string name, void (*handler)(voidptr receiver, voidptr args, voidptr sender)) {
	array_push((array*)&s->registry->events, _MOV((eventbus__EventHandler[]){ ((eventbus__EventHandler){.name = name,.handler = (voidptr)handler,.receiver = ((voidptr)(0)),.once = true,}) }));
}

bool eventbus__Subscriber_is_subscribed(eventbus__Subscriber* s, string name) {
	bool _t1 = eventbus__Registry_check_subscriber(s->registry, name);
	return _t1;
}

bool eventbus__Subscriber_is_subscribed_method(eventbus__Subscriber* s, string name, voidptr receiver) {
	bool _t2 = false;
	Array_eventbus__EventHandler _t2_orig = s->registry->events;
	int _t2_len = _t2_orig.len;
	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		eventbus__EventHandler it = ((eventbus__EventHandler*) _t2_orig.data)[_t3];
		if (string__eq(it.name, name) && it.receiver == receiver) {
			_t2 = true;
			break;
		}
	}
	bool _t1 =_t2;
	return _t1;
}

void eventbus__Subscriber_unsubscribe(eventbus__Subscriber* s, string name, void (*handler)(voidptr receiver, voidptr args, voidptr sender)) {
	Array_eventbus__EventHandler _t1 = {0};
	Array_eventbus__EventHandler _t1_orig = s->registry->events;
	int _t1_len = _t1_orig.len;
	_t1 = __new_array(0, _t1_len, sizeof(eventbus__EventHandler));

	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		eventbus__EventHandler it = ((eventbus__EventHandler*) _t1_orig.data)[_t2];
		if (!(string__eq(it.name, name) && it.handler == (voidptr)handler)) {
			array_push((array*)&_t1, &it);
		}
	}
	s->registry->events =_t1;
}

bool eventbus__Registry_check_subscriber(eventbus__Registry* r, string name) {
	bool _t2 = false;
	Array_eventbus__EventHandler _t2_orig = r->events;
	int _t2_len = _t2_orig.len;
	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		eventbus__EventHandler it = ((eventbus__EventHandler*) _t2_orig.data)[_t3];
		if (string__eq(it.name, name)) {
			_t2 = true;
			break;
		}
	}
	bool _t1 =_t2;
	return _t1;
}

clipboard__Clipboard* clipboard__new(void) {
	clipboard__Clipboard* _t1 = clipboard__new_clipboard();
	return _t1;
}

bool clipboard__Clipboard_copy(clipboard__Clipboard* cb, string text) {
	bool _t1 = clipboard__Clipboard_set_text(cb, text);
	return _t1;
}

string clipboard__Clipboard_paste(clipboard__Clipboard* cb) {
	string _t1 = clipboard__Clipboard_get_text(cb);
	return _t1;
}

void clipboard__Clipboard_clear_all(clipboard__Clipboard* cb) {
	clipboard__Clipboard_clear(cb);
}

void clipboard__Clipboard_destroy(clipboard__Clipboard* cb) {
	clipboard__Clipboard_free(cb);
}

bool clipboard__Clipboard_check_ownership(clipboard__Clipboard cb) {
	bool _t1 = clipboard__Clipboard_has_ownership(&cb);
	return _t1;
}

bool clipboard__Clipboard_is_available(clipboard__Clipboard* cb) {
	bool _t1 = clipboard__Clipboard_check_availability(cb);
	return _t1;
}

clipboard__Clipboard* clipboard__new_clipboard(void) {
	clipboard__Clipboard* cb = ((clipboard__Clipboard*)memdup(&(clipboard__Clipboard){.pb = darwin_new_pasteboard(),.last_cb_serial = 0,.foo = 0,}, sizeof(clipboard__Clipboard)));
	clipboard__Clipboard* _t1 = cb;
	return _t1;
}

bool clipboard__Clipboard_check_availability(clipboard__Clipboard* cb) {
	bool _t1 = cb->pb != NULL;
	return _t1;
}

void clipboard__Clipboard_clear(clipboard__Clipboard* cb) {
	cb->foo = 0;
	clipboard__Clipboard_set_text(cb, _SLIT(""));
}

void clipboard__Clipboard_free(clipboard__Clipboard* cb) {
	cb->foo = 0;
}

bool clipboard__Clipboard_has_ownership(clipboard__Clipboard* cb) {
	if (cb->last_cb_serial == 0) {
		bool _t1 = false;
		return _t1;
	}
	bool _t2 = false;
	return _t2;
}

bool clipboard__Clipboard_set_text(clipboard__Clipboard* cb, string text) {
	bool _t1 = darwin_set_pasteboard_text(cb->pb, text);
	return _t1;
}

string clipboard__Clipboard_get_text(clipboard__Clipboard* cb) {
	cb->foo = 0;
	if (isnil(cb->pb)) {
		string _t1 = _SLIT("");
		return _t1;
	}
	u8* utf8_clip = darwin_get_pasteboard_text(cb->pb);
	string _t2 = tos_clone(((u8*)(utf8_clip)));
	return _t2;
}

clipboard__Clipboard* clipboard__new_primary(void) {
	panic_debug(83, tos3("/Users/rcqls/vlang/v/vlib/clipboard/clipboard_darwin.c.v"), tos3("clipboard"), tos3("new_primary"),  _SLIT("Primary clipboard is not supported on non-Linux systems."));
	VUNREACHABLE();
	return 0;
}

#if !defined(_WIN32) && !defined(__ANDROID__)
#endif
#if defined(_WIN32)
#else
#endif
// TypeDecl
// Attr: [inline]
inline fontstash__Context* fontstash__create_internal(struct FONSparams* params) {
	fontstash__Context* _t1 = fonsCreateInternal(params);
	return _t1;
}

// Attr: [inline]
inline void fontstash__delete_internal(fontstash__Context* s) {
	fonsDeleteInternal(s);
}

// Attr: [inline]
inline void fontstash__Context_set_error_callback(fontstash__Context* s, void (*callback)(voidptr , int , int ), voidptr uptr) {
	fonsSetErrorCallback(s, (voidptr)callback, uptr);
}

// Attr: [inline]
inline multi_return_int_int fontstash__Context_get_atlas_size(fontstash__Context* s) {
	int width = 0;
	int height = 0;
	fonsGetAtlasSize(s, &width, &height);
	return (multi_return_int_int){.arg0=width, .arg1=height};
}

// Attr: [inline]
inline int fontstash__Context_expand_atlas(fontstash__Context* s, int width, int height) {
	int _t1 = fonsExpandAtlas(s, width, height);
	return _t1;
}

// Attr: [inline]
inline int fontstash__Context_reset_atlas(fontstash__Context* s, int width, int height) {
	int _t1 = fonsResetAtlas(s, width, height);
	return _t1;
}

// Attr: [inline]
inline int fontstash__Context_get_font_by_name(fontstash__Context* s, string name) {
	int _t1 = fonsGetFontByName(s, ((char*)(name.str)));
	return _t1;
}

// Attr: [inline]
inline int fontstash__Context_add_fallback_font(fontstash__Context* s, int base, int fallback) {
	int _t1 = fonsAddFallbackFont(s, base, fallback);
	return _t1;
}

// Attr: [inline]
inline int fontstash__Context_add_font_mem(fontstash__Context* s, string name, Array_u8 data, bool free_data) {
	int _t1 = fonsAddFontMem(s, ((char*)(name.str)), data.data, data.len, (int[]){(free_data)?1:0}[0]);
	return _t1;
}

// Attr: [inline]
inline void fontstash__Context_push_state(fontstash__Context* s) {
	fonsPushState(s);
}

// Attr: [inline]
inline void fontstash__Context_pop_state(fontstash__Context* s) {
	fonsPopState(s);
}

// Attr: [inline]
inline void fontstash__Context_clear_state(fontstash__Context* s) {
	fonsClearState(s);
}

// Attr: [inline]
inline void fontstash__Context_set_size(fontstash__Context* s, f32 size) {
	fonsSetSize(s, size);
}

// Attr: [inline]
inline void fontstash__Context_set_color(fontstash__Context* s, u32 color) {
	fonsSetColor(s, color);
}

// Attr: [inline]
inline void fontstash__Context_set_spacing(fontstash__Context* s, f32 spacing) {
	fonsSetSpacing(s, spacing);
}

// Attr: [inline]
inline void fontstash__Context_set_blur(fontstash__Context* s, f32 blur) {
	fonsSetBlur(s, blur);
}

// Attr: [inline]
inline void fontstash__Context_set_align(fontstash__Context* s, int align) {
	fonsSetAlign(s, ((int)(align)));
}

// Attr: [inline]
inline void fontstash__Context_set_alignment(fontstash__Context* s, fontstash__Align align) {
	fonsSetAlign(s, ((int)(align)));
}

// Attr: [inline]
inline void fontstash__Context_set_font(fontstash__Context* s, int font_id) {
	fonsSetFont(s, font_id);
}

// Attr: [inline]
inline f32 fontstash__Context_draw_text(fontstash__Context* s, f32 x, f32 y, string text) {
	f32 _t1 = fonsDrawText(s, x, y, ((char*)(text.str)), ((char*)(0)));
	return _t1;
}

// Attr: [inline]
inline f32 fontstash__Context_text_bounds(fontstash__Context* s, f32 x, f32 y, string text, f32* bounds) {
	f32 _t1 = fonsTextBounds(s, x, y, ((char*)(text.str)), ((char*)(0)), bounds);
	return _t1;
}

// Attr: [inline]
inline void fontstash__Context_line_bounds(fontstash__Context* s, f32 y, f32* miny, f32* maxy) {
	fonsLineBounds(s, y, miny, maxy);
}

// Attr: [inline]
inline void fontstash__Context_vert_metrics(fontstash__Context* s, f32* ascender, f32* descender, f32* lineh) {
	fonsVertMetrics(s, ascender, descender, lineh);
}

// Attr: [inline]
inline int fontstash__Context_text_iter_init(fontstash__Context* s, struct FONStextIter* iter, f32 x, f32 y, char* str, char* end) {
	int _t1 = fonsTextIterInit(s, iter, x, y, str, end);
	return _t1;
}

// Attr: [inline]
inline int fontstash__Context_text_iter_next(fontstash__Context* s, struct FONStextIter* iter, struct FONSquad* quad) {
	int _t1 = fonsTextIterNext(s, iter, quad);
	return _t1;
}

// Attr: [inline]
inline u8* fontstash__Context_get_texture_data(fontstash__Context* s, int* width, int* height) {
	u8* _t1 = ((u8*)(fonsGetTextureData(s, width, height)));
	return _t1;
}

// Attr: [inline]
inline int fontstash__Context_validate_texture(fontstash__Context* s, int* dirty) {
	int _t1 = fonsValidateTexture(s, dirty);
	return _t1;
}

// Attr: [inline]
inline void fontstash__Context_draw_debug(fontstash__Context* s, f32 x, f32 y) {
	fonsDrawDebug(s, x, y);
}

// Attr: [inline]
inline bool fontstash__Flags_is_empty(fontstash__Flags* e) {
	bool _t1 = ((int)(*e)) == 0;
	return _t1;
}

// Attr: [inline]
inline bool fontstash__Flags_has(fontstash__Flags* e, fontstash__Flags flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) != 0;
	return _t1;
}

// Attr: [inline]
inline bool fontstash__Flags_all(fontstash__Flags* e, fontstash__Flags flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) == ((int)(flag));
	return _t1;
}

// Attr: [inline]
inline void fontstash__Flags_set(fontstash__Flags* e, fontstash__Flags flag) {
	{ // Unsafe block
		*e = ((fontstash__Flags)((((int)(*e)) | (((int)(flag))))));
	}
}

// Attr: [inline]
inline void fontstash__Flags_clear(fontstash__Flags* e, fontstash__Flags flag) {
	{ // Unsafe block
		*e = ((fontstash__Flags)((((int)(*e)) & ~(((int)(flag))))));
	}
}

// Attr: [inline]
inline void fontstash__Flags_toggle(fontstash__Flags* e, fontstash__Flags flag) {
	{ // Unsafe block
		*e = ((fontstash__Flags)((((int)(*e)) ^ (((int)(flag))))));
	}
}

// Attr: [inline]
inline bool fontstash__Align_is_empty(fontstash__Align* e) {
	bool _t1 = ((int)(*e)) == 0;
	return _t1;
}

// Attr: [inline]
inline bool fontstash__Align_has(fontstash__Align* e, fontstash__Align flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) != 0;
	return _t1;
}

// Attr: [inline]
inline bool fontstash__Align_all(fontstash__Align* e, fontstash__Align flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) == ((int)(flag));
	return _t1;
}

// Attr: [inline]
inline void fontstash__Align_set(fontstash__Align* e, fontstash__Align flag) {
	{ // Unsafe block
		*e = ((fontstash__Align)((((int)(*e)) | (((int)(flag))))));
	}
}

// Attr: [inline]
inline void fontstash__Align_clear(fontstash__Align* e, fontstash__Align flag) {
	{ // Unsafe block
		*e = ((fontstash__Align)((((int)(*e)) & ~(((int)(flag))))));
	}
}

// Attr: [inline]
inline void fontstash__Align_toggle(fontstash__Align* e, fontstash__Align flag) {
	{ // Unsafe block
		*e = ((fontstash__Align)((((int)(*e)) ^ (((int)(flag))))));
	}
}

#if defined(_WIN32)
#else
#endif
void stbi__set_flip_vertically_on_load(bool val) {
	stbi_set_flip_vertically_on_load(val);
}

void stbi__set_flip_vertically_on_write(bool val) {
	stbi_flip_vertically_on_write(val);
}

void stbi__set_png_compression_level(int level) {
	set_png_compression_level(level);
}

void stbi__write_force_png_filter(int level) {
	write_force_png_filter(level);
}

void stbi__write_tga_with_rle(bool flag) {
	write_tga_with_rle((flag ? (1) : (0)));
}

void stbi__Image_free(stbi__Image* img) {
	stbi_image_free(img->data);
}

Option_stbi__Image stbi__load(string path) {
	string ext = string_all_after_last(path, _SLIT("."));
	stbi__Image res = ((stbi__Image){.width = 0,.height = 0,.nr_channels = 0,.ok = true,.data = 0,.ext = ext,});
	int desired_channels = ((string__eq(ext, _SLIT("png")) || string__eq(ext, _SLIT("jpg")) || string__eq(ext, _SLIT("jpeg"))) ? (4) : (0));
	res.data = stbi_load(((char*)(path.str)), &res.width, &res.height, &res.nr_channels, desired_channels);
	if (desired_channels == 4 && res.nr_channels == 3) {
		res.nr_channels = 4;
	}
	if (isnil(res.data)) {
		return (Option_stbi__Image){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("stbi_image failed to load from \""), 0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_stbi__Image _t2;
	opt_ok(&(stbi__Image[]) { res }, (Option*)(&_t2), sizeof(stbi__Image));
	return _t2;
}

Option_stbi__Image stbi__load_from_memory(u8* buf, int bufsize) {
	stbi__Image res = ((stbi__Image){.width = 0,.height = 0,.nr_channels = 0,.ok = true,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},});
	int flag = STBI_rgb_alpha;
	res.data = stbi_load_from_memory(buf, bufsize, &res.width, &res.height, &res.nr_channels, flag);
	if (isnil(res.data)) {
		return (Option_stbi__Image){ .state=2, .err=_v_error(_SLIT("stbi_image failed to load from memory")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_stbi__Image _t2;
	opt_ok(&(stbi__Image[]) { res }, (Option*)(&_t2), sizeof(stbi__Image));
	return _t2;
}

Option_void stbi__stbi_write_png(string path, int w, int h, int comp, u8* buf, int row_stride_in_bytes) {
	if (0 == stbi_write_png(((char*)(path.str)), w, h, comp, buf, row_stride_in_bytes)) {
		return (Option_void){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("stbi_image failed to write png file to \""), 0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

Option_void stbi__stbi_write_bmp(string path, int w, int h, int comp, u8* buf) {
	if (0 == stbi_write_bmp(((char*)(path.str)), w, h, comp, buf)) {
		return (Option_void){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("stbi_image failed to write bmp file to \""), 0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

Option_void stbi__stbi_write_tga(string path, int w, int h, int comp, u8* buf) {
	if (0 == stbi_write_tga(((char*)(path.str)), w, h, comp, buf)) {
		return (Option_void){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("stbi_image failed to write tga file to \""), 0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

Option_void stbi__stbi_write_jpg(string path, int w, int h, int comp, u8* buf, int quality) {
	if (0 == stbi_write_jpg(((char*)(path.str)), w, h, comp, buf, quality)) {
		return (Option_void){ .state=2, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("stbi_image failed to write jpg file to \""), 0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (Option_void){0};
}

#if defined(CUSTOM_DEFINE_darwin_sokol_glcore33)
#else
#endif
gx__Color gx__hex(int color) {
	gx__Color _t1 = ((gx__Color){.r = ((u8)(((color >> 24) & 0xFF))),.g = ((u8)(((color >> 16) & 0xFF))),.b = ((u8)(((color >> 8) & 0xFF))),.a = ((u8)((color & 0xFF))),});
	return _t1;
}

gx__Color gx__rgb(u8 r, u8 g, u8 b) {
	gx__Color _t1 = ((gx__Color){.r = r,.g = g,.b = b,.a = 255,});
	return _t1;
}

gx__Color gx__rgba(u8 r, u8 g, u8 b, u8 a) {
	gx__Color _t1 = ((gx__Color){.r = r,.g = g,.b = b,.a = a,});
	return _t1;
}

gx__Color gx__Color__plus(gx__Color a, gx__Color b) {
	int na = ((int)(a.a)) + b.a;
	int nr = ((int)(a.r)) + b.r;
	int ng = ((int)(a.g)) + b.g;
	int nb = ((int)(a.b)) + b.b;
	if (na > 255) {
		na = 255;
	}
	if (nr > 255) {
		nr = 255;
	}
	if (ng > 255) {
		ng = 255;
	}
	if (nb > 255) {
		nb = 255;
	}
	gx__Color _t1 = ((gx__Color){.r = ((u8)(nr)),.g = ((u8)(ng)),.b = ((u8)(nb)),.a = ((u8)(na)),});
	return _t1;
}

gx__Color gx__Color__minus(gx__Color a, gx__Color b) {
	u8 na = (a.a > b.a ? (a.a) : (b.a));
	int nr = ((int)(a.r)) - b.r;
	int ng = ((int)(a.g)) - b.g;
	int nb = ((int)(a.b)) - b.b;
	if (na < 0) {
		na = 0;
	}
	if (nr < 0) {
		nr = 0;
	}
	if (ng < 0) {
		ng = 0;
	}
	if (nb < 0) {
		nb = 0;
	}
	gx__Color _t1 = ((gx__Color){.r = ((u8)(nr)),.g = ((u8)(ng)),.b = ((u8)(nb)),.a = ((u8)(na)),});
	return _t1;
}

gx__Color gx__Color__mult(gx__Color c, gx__Color c2) {
	gx__Color _t1 = ((gx__Color){.r = c.r * c2.r,.g = c.g * c2.g,.b = c.b * c2.b,.a = c.a * c2.a,});
	return _t1;
}

gx__Color gx__Color__div(gx__Color c, gx__Color c2) {
	gx__Color _t1 = ((gx__Color){.r = c.r / c2.r,.g = c.g / c2.g,.b = c.b / c2.b,.a = c.a / c2.a,});
	return _t1;
}

gx__Color gx__Color_over(gx__Color a, gx__Color b) {
	f32 aa = ((f32)(a.a)) / 255;
	f32 ab = ((f32)(b.a)) / 255;
	f32 ar = aa + ab * (1 - aa);
	f32 rr = (((f32)(a.r)) * aa + ((f32)(b.r)) * ab * (1 - aa)) / ar;
	f32 gr = (((f32)(a.g)) * aa + ((f32)(b.g)) * ab * (1 - aa)) / ar;
	f32 br = (((f32)(a.b)) * aa + ((f32)(b.b)) * ab * (1 - aa)) / ar;
	gx__Color _t1 = ((gx__Color){.r = ((u8)(rr)),.g = ((u8)(gr)),.b = ((u8)(br)),.a = ((u8)(ar * 255)),});
	return _t1;
}

bool gx__Color_eq(gx__Color c, gx__Color c2) {
	bool _t1 = c.r == c2.r && c.g == c2.g && c.b == c2.b && c.a == c2.a;
	return _t1;
}

string gx__Color_str(gx__Color c) {
	string _t1 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT("Color{"), 0xfe02, {.d_u8 = c.r}}, {_SLIT(", "), 0xfe02, {.d_u8 = c.g}}, {_SLIT(", "), 0xfe02, {.d_u8 = c.b}}, {_SLIT(", "), 0xfe02, {.d_u8 = c.a}}, {_SLIT("}"), 0, { .d_c = 0 }}}));
	return _t1;
}

// Attr: [inline]
inline int gx__Color_rgba8(gx__Color c) {
	int _t1 = ((int)((((((u32)(c.r)) << 24U | ((u32)(c.g)) << 16U) | ((u32)(c.b)) << 8U) | ((u32)(c.a)))));
	return _t1;
}

// Attr: [inline]
inline int gx__Color_bgra8(gx__Color c) {
	int _t1 = ((int)((((((u32)(c.b)) << 24U | ((u32)(c.g)) << 16U) | ((u32)(c.r)) << 8U) | ((u32)(c.a)))));
	return _t1;
}

// Attr: [inline]
inline int gx__Color_abgr8(gx__Color c) {
	int _t1 = ((int)((((((u32)(c.a)) << 24U | ((u32)(c.b)) << 16U) | ((u32)(c.g)) << 8U) | ((u32)(c.r)))));
	return _t1;
}

gx__Color gx__color_from_string(string s) {
	gx__Color _t1 = (*(gx__Color*)map_get(ADDR(map, _const_gx__string_colors), &(string[]){s}, &(gx__Color[]){ (gx__Color){.r = 0,.g = 0,.b = 0,.a = 255,} }));
	return _t1;
}

string gx__Color_to_css_string(gx__Color c) {
	string _t1 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT("rgba("), 0xfe02, {.d_u8 = c.r}}, {_SLIT(","), 0xfe02, {.d_u8 = c.g}}, {_SLIT(","), 0xfe02, {.d_u8 = c.b}}, {_SLIT(","), 0xfe02, {.d_u8 = c.a}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
	return _t1;
}

bool gx__Image_is_empty(gx__Image i) {
	bool _t1 = isnil(i.obj);
	return _t1;
}

string gx__TextCfg_to_css_string(gx__TextCfg* cfg) {
	string font_style = _SLIT("");
	if (cfg->bold) {
		font_style = /*f*/string__plus(font_style, _SLIT("bold "));
	}
	if (cfg->mono) {
		font_style = /*f*/string__plus(font_style, _SLIT("mono "));
	}
	if (cfg->italic) {
		font_style = /*f*/string__plus(font_style, _SLIT("italic "));
	}
	string _t1 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = font_style}}, {_SLIT(" "), 0xfe07, {.d_i32 = cfg->size}}, {_SLIT("px "), 0xfe10, {.d_s = cfg->family}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

// Attr: [deprecated]
f64 math__fabs(f64 x) {
	if (x > 0.0) {
		f64 _t1 = x;
		return _t1;
	}
	f64 _t2 = -x;
	return _t2;
}

f64 math__inf(int sign) {
	u64 v = (sign >= 0 ? (_const_math__uvinf) : (_const_math__uvneginf));
	f64 _t1 = math__f64_from_bits(v);
	return _t1;
}

f64 math__nan(void) {
	f64 _t1 = math__f64_from_bits(_const_math__uvnan);
	return _t1;
}

bool math__is_nan(f64 f) {
	bool _t1 = f != f;
	return _t1;
}

bool math__is_inf(f64 f, int sign) {
	bool _t1 = (sign >= 0 && f > _const_math__max_f64) || (sign <= 0 && f < -_const_math__max_f64);
	return _t1;
}

bool math__is_finite(f64 f) {
	bool _t1 = !math__is_nan(f) && !math__is_inf(f, 0);
	return _t1;
}

multi_return_f64_int math__normalize(f64 x) {
	f64 smallest_normal = 2.2250738585072014e-308;
	if (math__abs_T_f64(x) < smallest_normal) {
		return (multi_return_f64_int){.arg0=x * _const_math__normalize_smallest_mask, .arg1=-52};
	}
	return (multi_return_f64_int){.arg0=x, .arg1=0};
}

f64 math__cbrt(f64 a) {
	f64 x = a;
	int b1 = 715094163;
	int b2 = 696219795;
	f64 c = 5.42857142857142815906e-01;
	f64 d = -7.05306122448979611050e-01;
	f64 e_ = 1.41428571428571436819e+00;
	f64 f = 1.60714285714285720630e+00;
	f64 g = 3.57142857142857150787e-01;
	f64 smallest_normal = 2.22507385850720138309e-308;
	if (x == 0.0 || math__is_nan(x) || math__is_inf(x, 0)) {
		f64 _t1 = x;
		return _t1;
	}
	bool sign = false;
	if (x < 0) {
		x = -x;
		sign = true;
	}
	f64 t = math__f64_from_bits(math__f64_bits(x) / ((u64)(3 + (((u64)(b1)) << 32U))));
	if (x < smallest_normal) {
		t = ((f64)(((u64)(1U)) << 54U));
		t *= x;
		t = math__f64_from_bits(math__f64_bits(t) / ((u64)(3 + (((u64)(b2)) << 32U))));
	}
	f64 r = t * t / x;
	f64 s = c + r * t;
	t *= g + f / (s + e_ + d / s);
	t = math__f64_from_bits((math__f64_bits(t) & (((u64)(0xffffffffcU)) << 28U)) + (((u64)(1U)) << 30U));
	s = t * t;
	r = x / s;
	f64 w = t + t;
	r = (r - t) / (w + r);
	t = t + t * r;
	if (sign) {
		t = -t;
	}
	f64 _t2 = t;
	return _t2;
}

f64 math__mod(f64 x, f64 y) {
	f64 _t1 = math__fmod(x, y);
	return _t1;
}

f64 math__fmod(f64 x, f64 y) {
	if (y == 0 || math__is_inf(x, 0) || math__is_nan(x) || math__is_nan(y)) {
		f64 _t1 = math__nan();
		return _t1;
	}
	f64 abs_y = math__abs_T_f64(y);
	multi_return_f64_int mr_594 = math__frexp(abs_y);
	f64 abs_y_fr = mr_594.arg0;
	int abs_y_exp = mr_594.arg1;
	f64 r = x;
	if (x < 0) {
		r = -x;
	}
	for (;;) {
		if (!(r >= abs_y)) break;
		multi_return_f64_int mr_680 = math__frexp(r);
		f64 rfr = mr_680.arg0;
		int rexp = mr_680.arg1;
		if (rfr < abs_y_fr) {
			rexp = rexp - 1;
		}
		r = r - math__ldexp(abs_y, rexp - abs_y_exp);
	}
	if (x < 0) {
		r = -r;
	}
	f64 _t2 = r;
	return _t2;
}

i64 math__gcd(i64 a_, i64 b_) {
	i64 a = a_;
	i64 b = b_;
	if (a < 0) {
		a = -a;
	}
	if (b < 0) {
		b = -b;
	}
	for (;;) {
		if (!(b != 0)) break;
		a %= b;
		if (a == 0) {
			i64 _t1 = b;
			return _t1;
		}
		b %= a;
	}
	i64 _t2 = a;
	return _t2;
}

multi_return_i64_i64_i64 math__egcd(i64 a, i64 b) {
	i64 old_r = a;
	i64 r = b;
	i64 old_s = ((i64)(1));
	i64 s = ((i64)(0));
	i64 old_t = ((i64)(0));
	i64 t = ((i64)(1));
	for (;;) {
		if (!(r != 0)) break;
		i64 quot = old_r / r;
		i64 _var_1339 = old_r;
		i64 _var_1346 = r;
		old_r = _var_1346;
		r = _var_1339%_var_1346;
		i64 _var_1365 = old_s;
		i64 _var_1372 = s;
		old_s = _var_1372;
		s = _var_1365-quot*_var_1372;
		i64 _var_1398 = old_t;
		i64 _var_1405 = t;
		old_t = _var_1405;
		t = _var_1398-quot*_var_1405;
	}
	return (multi_return_i64_i64_i64){.arg0=(old_r < 0 ? (-old_r) : (old_r)), .arg1=old_s, .arg2=old_t};
}

i64 math__lcm(i64 a, i64 b) {
	if (a == 0) {
		i64 _t1 = a;
		return _t1;
	}
	i64 res = a * (b / math__gcd(b, a));
	if (res < 0) {
		i64 _t2 = -res;
		return _t2;
	}
	i64 _t3 = res;
	return _t3;
}

f64 math__erf(f64 a) {
	f64 x = a;
	f64 very_tiny = 2.848094538889218e-306;
	f64 small_ = 1.0 / ((f64)(((u64)(1U)) << 28U));
	if (math__is_nan(x)) {
		f64 _t1 = math__nan();
		return _t1;
	}
	if (math__is_inf(x, 1)) {
		f64 _t2 = 1.0;
		return _t2;
	}
	if (math__is_inf(x, -1)) {
		f64 _t3 = ((f64)(-1));
		return _t3;
	}
	bool sign = false;
	if (x < 0) {
		x = -x;
		sign = true;
	}
	if (x < 0.84375) {
		f64 temp = 0.0;
		if (x < small_) {
			if (x < very_tiny) {
				temp = 0.125 * (8.0 * x + _const_math__efx8 * x);
			} else {
				temp = x + _const_math__efx * x;
			}
		} else {
			f64 z = x * x;
			f64 r = _const_math__pp0 + z * (_const_math__pp1 + z * (_const_math__pp2 + z * (_const_math__pp3 + z * _const_math__pp4)));
			f64 s_ = 1.0 + z * (_const_math__qq1 + z * (_const_math__qq2 + z * (_const_math__qq3 + z * (_const_math__qq4 + z * _const_math__qq5))));
			f64 y = r / s_;
			temp = x + x * y;
		}
		if (sign) {
			f64 _t4 = -temp;
			return _t4;
		}
		f64 _t5 = temp;
		return _t5;
	}
	if (x < 1.25) {
		f64 s_ = x - 1;
		f64 p = _const_math__pa0 + s_ * (_const_math__pa1 + s_ * (_const_math__pa2 + s_ * (_const_math__pa3 + s_ * (_const_math__pa4 + s_ * (_const_math__pa5 + s_ * _const_math__pa6)))));
		f64 q = 1.0 + s_ * (_const_math__qa1 + s_ * (_const_math__qa2 + s_ * (_const_math__qa3 + s_ * (_const_math__qa4 + s_ * (_const_math__qa5 + s_ * _const_math__qa6)))));
		if (sign) {
			f64 _t6 = -_const_math__erx - p / q;
			return _t6;
		}
		f64 _t7 = _const_math__erx + p / q;
		return _t7;
	}
	if (x >= 6) {
		if (sign) {
			f64 _t8 = -1;
			return _t8;
		}
		f64 _t9 = 1.0;
		return _t9;
	}
	f64 s_ = 1.0 / (x * x);
	f64 r = 0.0;
	f64 s = 0.0;
	if (x < 1.0 / 0.35) {
		r = _const_math__ra0 + s_ * (_const_math__ra1 + s_ * (_const_math__ra2 + s_ * (_const_math__ra3 + s_ * (_const_math__ra4 + s_ * (_const_math__ra5 + s_ * (_const_math__ra6 + s_ * _const_math__ra7))))));
		s = 1.0 + s_ * (_const_math__sa1 + s_ * (_const_math__sa2 + s_ * (_const_math__sa3 + s_ * (_const_math__sa4 + s_ * (_const_math__sa5 + s_ * (_const_math__sa6 + s_ * (_const_math__sa7 + s_ * _const_math__sa8)))))));
	} else {
		r = _const_math__rb0 + s_ * (_const_math__rb1 + s_ * (_const_math__rb2 + s_ * (_const_math__rb3 + s_ * (_const_math__rb4 + s_ * (_const_math__rb5 + s_ * _const_math__rb6)))));
		s = 1.0 + s_ * (_const_math__sb1 + s_ * (_const_math__sb2 + s_ * (_const_math__sb3 + s_ * (_const_math__sb4 + s_ * (_const_math__sb5 + s_ * (_const_math__sb6 + s_ * _const_math__sb7))))));
	}
	f64 z = math__f64_from_bits((math__f64_bits(x) & 0xffffffff00000000U));
	f64 r_ = math__exp(-z * z - 0.5625) * math__exp((z - x) * (z + x) + r / s);
	if (sign) {
		f64 _t10 = r_ / x - 1.0;
		return _t10;
	}
	f64 _t11 = 1.0 - r_ / x;
	return _t11;
}

f64 math__erfc(f64 a) {
	f64 x = a;
	f64 tiny = 1.0 / ((f64)(((u64)(1U)) << 56U));
	if (math__is_nan(x)) {
		f64 _t1 = math__nan();
		return _t1;
	}
	if (math__is_inf(x, 1)) {
		f64 _t2 = 0.0;
		return _t2;
	}
	if (math__is_inf(x, -1)) {
		f64 _t3 = 2.0;
		return _t3;
	}
	bool sign = false;
	if (x < 0) {
		x = -x;
		sign = true;
	}
	if (x < 0.84375) {
		f64 temp = 0.0;
		if (x < tiny) {
			temp = x;
		} else {
			f64 z = x * x;
			f64 r = _const_math__pp0 + z * (_const_math__pp1 + z * (_const_math__pp2 + z * (_const_math__pp3 + z * _const_math__pp4)));
			f64 s_ = 1.0 + z * (_const_math__qq1 + z * (_const_math__qq2 + z * (_const_math__qq3 + z * (_const_math__qq4 + z * _const_math__qq5))));
			f64 y = r / s_;
			if (x < 0.25) {
				temp = x + x * y;
			} else {
				temp = 0.5 + (x * y + (x - 0.5));
			}
		}
		if (sign) {
			f64 _t4 = 1.0 + temp;
			return _t4;
		}
		f64 _t5 = 1.0 - temp;
		return _t5;
	}
	if (x < 1.25) {
		f64 s_ = x - 1;
		f64 p = _const_math__pa0 + s_ * (_const_math__pa1 + s_ * (_const_math__pa2 + s_ * (_const_math__pa3 + s_ * (_const_math__pa4 + s_ * (_const_math__pa5 + s_ * _const_math__pa6)))));
		f64 q = 1.0 + s_ * (_const_math__qa1 + s_ * (_const_math__qa2 + s_ * (_const_math__qa3 + s_ * (_const_math__qa4 + s_ * (_const_math__qa5 + s_ * _const_math__qa6)))));
		if (sign) {
			f64 _t6 = 1.0 + _const_math__erx + p / q;
			return _t6;
		}
		f64 _t7 = 1.0 - _const_math__erx - p / q;
		return _t7;
	}
	if (x < 28) {
		f64 s_ = 1.0 / (x * x);
		f64 r = 0.0;
		f64 s = 0.0;
		if (x < 1.0 / 0.35) {
			r = _const_math__ra0 + s_ * (_const_math__ra1 + s_ * (_const_math__ra2 + s_ * (_const_math__ra3 + s_ * (_const_math__ra4 + s_ * (_const_math__ra5 + s_ * (_const_math__ra6 + s_ * _const_math__ra7))))));
			s = 1.0 + s_ * (_const_math__sa1 + s_ * (_const_math__sa2 + s_ * (_const_math__sa3 + s_ * (_const_math__sa4 + s_ * (_const_math__sa5 + s_ * (_const_math__sa6 + s_ * (_const_math__sa7 + s_ * _const_math__sa8)))))));
		} else {
			if (sign && x > 6) {
				f64 _t8 = 2.0;
				return _t8;
			}
			r = _const_math__rb0 + s_ * (_const_math__rb1 + s_ * (_const_math__rb2 + s_ * (_const_math__rb3 + s_ * (_const_math__rb4 + s_ * (_const_math__rb5 + s_ * _const_math__rb6)))));
			s = 1.0 + s_ * (_const_math__sb1 + s_ * (_const_math__sb2 + s_ * (_const_math__sb3 + s_ * (_const_math__sb4 + s_ * (_const_math__sb5 + s_ * (_const_math__sb6 + s_ * _const_math__sb7))))));
		}
		f64 z = math__f64_from_bits((math__f64_bits(x) & 0xffffffff00000000U));
		f64 r_ = math__exp(-z * z - 0.5625) * math__exp((z - x) * (z + x) + r / s);
		if (sign) {
			f64 _t9 = 2.0 - r_ / x;
			return _t9;
		}
		f64 _t10 = r_ / x;
		return _t10;
	}
	if (sign) {
		f64 _t11 = 2.0;
		return _t11;
	}
	f64 _t12 = 0.0;
	return _t12;
}

f64 math__exp(f64 x) {
	f64 log2e = 1.44269504088896338700e+00;
	f64 overflow = 7.09782712893383973096e+02;
	f64 underflow = -7.45133219101941108420e+02;
	f64 near_zero = 1.0 / (1 << 28);
	if (math__is_nan(x) || math__is_inf(x, 1)) {
		f64 _t1 = x;
		return _t1;
	}
	if (math__is_inf(x, -1)) {
		f64 _t2 = 0.0;
		return _t2;
	}
	if (x > overflow) {
		f64 _t3 = math__inf(1);
		return _t3;
	}
	if (x < underflow) {
		f64 _t4 = 0.0;
		return _t4;
	}
	if (-near_zero < x && x < near_zero) {
		f64 _t5 = 1.0 + x;
		return _t5;
	}
	int k = 0;
	if (x < 0) {
		k = ((int)(log2e * x - 0.5));
	}
	if (x > 0) {
		k = ((int)(log2e * x + 0.5));
	}
	f64 hi = x - ((f64)(k)) * _const_math__ln2hi;
	f64 lo = ((f64)(k)) * _const_math__ln2lo;
	f64 _t6 = math__expmulti(hi, lo, k);
	return _t6;
}

f64 math__exp2(f64 x) {
	f64 overflow = 1.0239999999999999e+03;
	f64 underflow = -1.0740e+03;
	if (math__is_nan(x) || math__is_inf(x, 1)) {
		f64 _t1 = x;
		return _t1;
	}
	if (math__is_inf(x, -1)) {
		f64 _t2 = 0;
		return _t2;
	}
	if (x > overflow) {
		f64 _t3 = math__inf(1);
		return _t3;
	}
	if (x < underflow) {
		f64 _t4 = 0;
		return _t4;
	}
	int k = 0;
	if (x > 0) {
		k = ((int)(x + 0.5));
	}
	if (x < 0) {
		k = ((int)(x - 0.5));
	}
	f64 t = x - ((f64)(k));
	f64 hi = t * _const_math__ln2hi;
	f64 lo = -t * _const_math__ln2lo;
	f64 _t5 = math__expmulti(hi, lo, k);
	return _t5;
}

f64 math__ldexp(f64 frac, int exp) {
	f64 _t1 = math__scalbn(frac, exp);
	return _t1;
}

multi_return_f64_int math__frexp(f64 x) {
	u64 y = math__f64_bits(x);
	int ee = ((int)(((y >> 52U) & 0x7ffU)));
	if (ee == 0) {
		if (x != 0.0) {
			f64 x1p64 = math__f64_from_bits(((u64)(0x43f0000000000000U)));
			multi_return_f64_int mr_3352 = math__frexp(x * x1p64);
			f64 z = mr_3352.arg0;
			int e_ = mr_3352.arg1;
			return (multi_return_f64_int){.arg0=z, .arg1=e_ - 64};
		}
		return (multi_return_f64_int){.arg0=x, .arg1=0};
	} else if (ee == 0x7ff) {
		return (multi_return_f64_int){.arg0=x, .arg1=0};
	}
	int e_ = ee - 0x3fe;
	y &= ((u64)(0x800fffffffffffffU));
	y |= ((u64)(0x3fe0000000000000U));
	return (multi_return_f64_int){.arg0=math__f64_from_bits(y), .arg1=e_};
}

f64 math__expm1(f64 x) {
	if (math__is_inf(x, 1) || math__is_nan(x)) {
		f64 _t1 = x;
		return _t1;
	}
	if (math__is_inf(x, -1)) {
		f64 _t2 = ((f64)(-1));
		return _t2;
	}
	if (math__abs_T_f64(x) < _const_math__ln2) {
		f64 i = 1.0;
		f64 sum = x;
		f64 term = x / 1.0;
		i++;
		term *= x / ((f64)(i));
		sum += term;
		for (;;) {
			if (!(math__abs_T_f64(term) > math__abs_T_f64(sum) * _const_math__internal__f64_epsilon)) break;
			i++;
			term *= x / ((f64)(i));
			sum += term;
		}
		f64 _t3 = sum;
		return _t3;
	} else {
		f64 _t4 = math__exp(x) - 1;
		return _t4;
	}
	return 0;
}

f64 math__expmulti(f64 hi, f64 lo, int k) {
	f64 exp_p1 = 1.66666666666666657415e-01;
	f64 exp_p2 = -2.77777777770155933842e-03;
	f64 exp_p3 = 6.61375632143793436117e-05;
	f64 exp_p4 = -1.65339022054652515390e-06;
	f64 exp_p5 = 4.13813679705723846039e-08;
	f64 r = hi - lo;
	f64 t = r * r;
	f64 c = r - t * (exp_p1 + t * (exp_p2 + t * (exp_p3 + t * (exp_p4 + t * exp_p5))));
	f64 y = 1 - ((lo - (r * c) / (2 - c)) - hi);
	f64 _t1 = math__ldexp(y, k);
	return _t1;
}

f64 math__factorial(f64 n) {
	if (n >= _const_math__factorials_table.len) {
		f64 _t1 = _const_math__max_f64;
		return _t1;
	}
	if (n == ((f64)(((i64)(n)))) && n >= 0.0) {
		f64 _t2 = (*(f64*)/*ee elem_sym */array_get(_const_math__factorials_table, ((i64)(n))));
		return _t2;
	}
	f64 _t3 = math__gamma(n + 1.0);
	return _t3;
}

f64 math__log_factorial(f64 n) {
	if (n < 0) {
		f64 _t1 = -_const_math__max_f64;
		return _t1;
	}
	if (n != ((f64)(((i64)(n))))) {
		f64 _t2 = math__log_gamma(n + 1);
		return _t2;
	} else if (n < _const_math__log_factorials_table.len) {
		f64 _t3 = (*(f64*)/*ee elem_sym */array_get(_const_math__log_factorials_table, ((i64)(n))));
		return _t3;
	}
	f64 _t4 = math__log_factorial_asymptotic_expansion(((int)(n)));
	return _t4;
}

f64 math__log_factorial_asymptotic_expansion(int n) {
	int m = 6;
	Array_f64 term = __new_array_with_default(0, 0, sizeof(f64), 0);
	f64 xx = ((f64)((n + 1) * (n + 1)));
	f64 xj = ((f64)(n + 1));
	f64 log_factorial = _const_math__log_sqrt_2pi - xj + (xj - 0.5) * math__log(xj);
	int i = 0;
	for (i = 0; i < m; i++) {
		array_push((array*)&term, _MOV((f64[]){ (*(f64*)/*ee elem_sym */array_get(_const_math__bernoulli, i)) / xj }));
		xj *= xx;
	}
	f64 sum = (*(f64*)/*ee elem_sym */array_get(term, m - 1));
	for (i = m - 2; i >= 0; i--) {
		if (math__abs_T_f64(sum) <= math__abs_T_f64((*(f64*)/*ee elem_sym */array_get(term, i)))) {
			break;
		}
		sum = (*(f64*)/*ee elem_sym */array_get(term, i));
	}
	for (;;) {
		if (!(i >= 0)) break;
		sum += (*(f64*)/*ee elem_sym */array_get(term, i));
		i--;
	}
	f64 _t2 = log_factorial + sum;
	return _t2;
}

i64 math__factoriali(int n) {
	if (n <= 0) {
		i64 _t1 = ((i64)(1));
		return _t1;
	}
	if (n < 21) {
		i64 _t2 = ((i64)((*(f64*)/*ee elem_sym */array_get(_const_math__factorials_table, n))));
		return _t2;
	}
	i64 _t3 = ((i64)(-1));
	return _t3;
}

f64 math__floor(f64 x) {
	if (x == 0 || math__is_nan(x) || math__is_inf(x, 0)) {
		f64 _t1 = x;
		return _t1;
	}
	if (x < 0) {
		multi_return_f64_f64 mr_280 = math__modf(-x);
		f64 d = mr_280.arg0;
		f64 fract = mr_280.arg1;
		if (fract != 0.0) {
			d = d + 1;
		}
		f64 _t2 = -d;
		return _t2;
	}
	multi_return_f64_f64 mr_350 = math__modf(x);
	f64 d = mr_350.arg0;
	f64 _t3 = d;
	return _t3;
}

f64 math__ceil(f64 x) {
	f64 _t1 = -math__floor(-x);
	return _t1;
}

f64 math__trunc(f64 x) {
	if (x == 0 || math__is_nan(x) || math__is_inf(x, 0)) {
		f64 _t1 = x;
		return _t1;
	}
	multi_return_f64_f64 mr_793 = math__modf(x);
	f64 d = mr_793.arg0;
	f64 _t2 = d;
	return _t2;
}

f64 math__round(f64 x) {
	if (x == 0 || math__is_nan(x) || math__is_inf(x, 0)) {
		f64 _t1 = x;
		return _t1;
	}
	f64 y = math__floor(x);
	f64 r = x - y;
	if (r > 0.5) {
		{ // Unsafe block
			goto rndup;
		}
	}
	if (r == 0.5) {
		r = y - 2.0 * math__floor(0.5 * y);
		if (r == 1.0) {
			rndup: {}
			y += 1.0;
		}
	}
	f64 _t2 = y;
	return _t2;
}

f64 math__round_to_even(f64 x) {
	u64 bits = math__f64_bits(x);
	u64 e_ = ((bits >> _const_math__shift) & _const_math__mask);
	if (e_ >= _const_math__bias) {
		u64 half_minus_ulp = ((u64)(((u64)(1U)) << (_const_math__shift - 1))) - 1U;
		e_ -= ((u64)(_const_math__bias));
		bits += (half_minus_ulp + ((bits >> (_const_math__shift - e_)) & 1U)) >> e_;
		bits &= _const_math__frac_mask >> e_;
		bits ^= _const_math__frac_mask >> e_;
	} else if (e_ == _const_math__bias - 1 && (bits & _const_math__frac_mask) != 0U) {
		bits = ((bits & _const_math__sign_mask) | _const_math__uvone);
	} else {
		bits &= _const_math__sign_mask;
	}
	f64 _t1 = math__f64_from_bits(bits);
	return _t1;
}

multi_return_f64_f64 math__stirling(f64 x) {
	if (x > 200) {
		return (multi_return_f64_f64){.arg0=math__inf(1), .arg1=1.0};
	}
	f64 sqrt_two_pi = 2.506628274631000502417;
	f64 max_stirling = 143.01608;
	f64 w = 1.0 / x;
	w = 1.0 + w * (((((*(f64*)/*ee elem_sym */array_get(_const_math__gamma_s, 0)) * w + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_s, 1))) * w + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_s, 2))) * w + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_s, 3))) * w + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_s, 4)));
	f64 y1 = math__exp(x);
	f64 y2 = 1.0;
	if (x > max_stirling) {
		f64 v = math__pow(x, 0.5 * x - 0.25);
		f64 y1_ = y1;
		y1 = v;
		y2 = v / y1_;
	} else {
		y1 = math__pow(x, x - 0.5) / y1;
	}
	return (multi_return_f64_f64){.arg0=y1, .arg1=((f64)(sqrt_two_pi)) * w * y2};
}

f64 math__gamma(f64 a) {
	f64 x = a;
	f64 euler = 0.57721566490153286060651209008240243104215933593992;
	if (math__is_neg_int(x) || math__is_inf(x, -1) || math__is_nan(x)) {
		f64 _t1 = math__nan();
		return _t1;
	}
	if (math__is_inf(x, 1)) {
		f64 _t2 = math__inf(1);
		return _t2;
	}
	if (x == 0.0) {
		f64 _t3 = math__copysign(math__inf(1), x);
		return _t3;
	}
	f64 q = math__abs_T_f64(x);
	f64 p = math__floor(q);
	if (q > 33) {
		if (x >= 0) {
			multi_return_f64_f64 mr_1482 = math__stirling(x);
			f64 y1 = mr_1482.arg0;
			f64 y2 = mr_1482.arg1;
			f64 _t4 = y1 * y2;
			return _t4;
		}
		int signgam = 1;
		i64 ip = ((i64)(p));
		if (((ip & 1)) == 0) {
			signgam = -1;
		}
		f64 z = q - p;
		if (z > 0.5) {
			p = p + 1;
			z = q - p;
		}
		z = q * math__sin(_const_math__pi * z);
		if (z == 0) {
			f64 _t5 = math__inf(signgam);
			return _t5;
		}
		multi_return_f64_f64 mr_1927 = math__stirling(q);
		f64 sq1 = mr_1927.arg0;
		f64 sq2 = mr_1927.arg1;
		f64 absz = math__abs_T_f64(z);
		f64 d = absz * sq1 * sq2;
		if (math__is_inf(d, 0)) {
			z = _const_math__pi / absz / sq1 / sq2;
		} else {
			z = _const_math__pi / d;
		}
		f64 _t6 = ((f64)(signgam)) * z;
		return _t6;
	}
	f64 z = 1.0;
	for (;;) {
		if (!(x >= 3)) break;
		x = x - 1;
		z = z * x;
	}
	for (;;) {
		if (!(x < 0)) break;
		if (x > -1e-09) {
			{ // Unsafe block
				goto _v_small;
			}
		}
		z = z / x;
		x = x + 1;
	}
	for (;;) {
		if (!(x < 2)) break;
		if (x < 1e-09) {
			{ // Unsafe block
				goto _v_small;
			}
		}
		z = z / x;
		x = x + 1;
	}
	if (x == 2) {
		f64 _t7 = z;
		return _t7;
	}
	x = x - 2;
	p = (((((x * (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_p, 0)) + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_p, 1))) * x + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_p, 2))) * x + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_p, 3))) * x + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_p, 4))) * x + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_p, 5))) * x + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_p, 6));
	q = ((((((x * (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_q, 0)) + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_q, 1))) * x + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_q, 2))) * x + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_q, 3))) * x + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_q, 4))) * x + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_q, 5))) * x + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_q, 6))) * x + (*(f64*)/*ee elem_sym */array_get(_const_math__gamma_q, 7));
	if (true) {
		f64 _t8 = z * p / q;
		return _t8;
	}
	_v_small: {}
	if (x == 0) {
		f64 _t9 = math__inf(1);
		return _t9;
	}
	f64 _t10 = z / ((1.0 + euler * x) * x);
	return _t10;
}

f64 math__log_gamma(f64 x) {
	multi_return_f64_int mr_3045 = math__log_gamma_sign(x);
	f64 y = mr_3045.arg0;
	f64 _t1 = y;
	return _t1;
}

multi_return_f64_int math__log_gamma_sign(f64 a) {
	f64 x = a;
	f64 ymin = 1.461632144968362245;
	f64 tiny = math__exp2(-70);
	f64 two52 = math__exp2(52);
	f64 two58 = math__exp2(58);
	f64 tc = 1.46163214496836224576e+00;
	f64 tf = -1.21486290535849611461e-01;
	f64 tt = -3.63867699703950536541e-18;
	int sign = 1;
	if (math__is_nan(x)) {
		return (multi_return_f64_int){.arg0=x, .arg1=sign};
	}
	if (math__is_inf(x, 1)) {
		return (multi_return_f64_int){.arg0=x, .arg1=sign};
	}
	if (x == 0.0) {
		return (multi_return_f64_int){.arg0=math__inf(1), .arg1=sign};
	}
	bool neg = false;
	if (x < 0) {
		x = -x;
		neg = true;
	}
	if (x < tiny) {
		if (neg) {
			sign = -1;
		}
		return (multi_return_f64_int){.arg0=-math__log(x), .arg1=sign};
	}
	f64 nadj = 0.0;
	if (neg) {
		if (x >= two52) {
			return (multi_return_f64_int){.arg0=math__inf(1), .arg1=sign};
		}
		f64 t = math__sin_pi(x);
		if (t == 0) {
			return (multi_return_f64_int){.arg0=math__inf(1), .arg1=sign};
		}
		nadj = math__log(_const_math__pi / math__abs_T_f64(t * x));
		if (t < 0) {
			sign = -1;
		}
	}
	f64 lgamma = 0.0;
	if (x == 1 || x == 2) {
		return (multi_return_f64_int){.arg0=0.0, .arg1=sign};
	} else if (x < 2) {
		f64 y = 0.0;
		int i = 0;
		if (x <= 0.9) {
			lgamma = -math__log(x);
			if (x >= (ymin - 1 + 0.27)) {
				y = 1.0 - x;
				i = 0;
			} else if (x >= (ymin - 1 - 0.27)) {
				y = x - (tc - 1);
				i = 1;
			} else {
				y = x;
				i = 2;
			}
		} else {
			lgamma = 0;
			if (x >= (ymin + 0.27)) {
				y = ((f64)(2)) - x;
				i = 0;
			} else if (x >= (ymin - 0.27)) {
				y = x - tc;
				i = 1;
			} else {
				y = x - 1;
				i = 2;
			}
		}
		if (i == 0) {
			f64 z = y * y;
			f64 gamma_p1 = (*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_a, 0)) + z * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_a, 2)) + z * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_a, 4)) + z * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_a, 6)) + z * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_a, 8)) + z * (*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_a, 10))))));
			f64 gamma_p2 = z * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_a, 1)) + z * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_a, 3)) + z * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_a, 5)) + z * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_a, 7)) + z * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_a, 9)) + z * (*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_a, 11)))))));
			f64 p = y * gamma_p1 + gamma_p2;
			lgamma += (p - 0.5 * y);
		} else if (i == 1) {
			f64 z = y * y;
			f64 w = z * y;
			f64 gamma_p1 = (*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_t, 0)) + w * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_t, 3)) + w * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_t, 6)) + w * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_t, 9)) + w * (*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_t, 12)))));
			f64 gamma_p2 = (*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_t, 1)) + w * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_t, 4)) + w * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_t, 7)) + w * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_t, 10)) + w * (*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_t, 13)))));
			f64 gamma_p3 = (*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_t, 2)) + w * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_t, 5)) + w * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_t, 8)) + w * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_t, 11)) + w * (*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_t, 14)))));
			f64 p = z * gamma_p1 - (tt - w * (gamma_p2 + y * gamma_p3));
			lgamma += (tf + p);
		} else if (i == 2) {
			f64 gamma_p1 = y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_u, 0)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_u, 1)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_u, 2)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_u, 3)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_u, 4)) + y * (*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_u, 5)))))));
			f64 gamma_p2 = 1.0 + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_v, 1)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_v, 2)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_v, 3)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_v, 4)) + y * (*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_v, 5))))));
			lgamma += (-0.5 * y + gamma_p1 / gamma_p2);
		}
	} else if (x < 8) {
		int i = ((int)(x));
		f64 y = x - ((f64)(i));
		f64 p = y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_s, 0)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_s, 1)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_s, 2)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_s, 3)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_s, 4)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_s, 5)) + y * (*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_s, 6))))))));
		f64 q = 1.0 + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_r, 1)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_r, 2)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_r, 3)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_r, 4)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_r, 5)) + y * (*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_r, 6)))))));
		lgamma = 0.5 * y + p / q;
		f64 z = 1.0;
		if (i == 7) {
			z *= (y + 6);
			z *= (y + 5);
			z *= (y + 4);
			z *= (y + 3);
			z *= (y + 2);
			lgamma += math__log(z);
		} else if (i == 6) {
			z *= (y + 5);
			z *= (y + 4);
			z *= (y + 3);
			z *= (y + 2);
			lgamma += math__log(z);
		} else if (i == 5) {
			z *= (y + 4);
			z *= (y + 3);
			z *= (y + 2);
			lgamma += math__log(z);
		} else if (i == 4) {
			z *= (y + 3);
			z *= (y + 2);
			lgamma += math__log(z);
		} else if (i == 3) {
			z *= (y + 2);
			lgamma += math__log(z);
		}
	} else if (x < two58) {
		f64 t = math__log(x);
		f64 z = 1.0 / x;
		f64 y = z * z;
		f64 w = (*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_w, 0)) + z * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_w, 1)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_w, 2)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_w, 3)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_w, 4)) + y * ((*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_w, 5)) + y * (*(f64*)/*ee elem_sym */array_get(_const_math__lgamma_w, 6)))))));
		lgamma = (x - 0.5) * (t - 1.0) + w;
	} else {
		lgamma = x * (math__log(x) - 1.0);
	}
	if (neg) {
		lgamma = nadj - lgamma;
	}
	return (multi_return_f64_int){.arg0=lgamma, .arg1=sign};
}

f64 math__sin_pi(f64 x_) {
	f64 x = x_;
	f64 two52 = math__exp2(52);
	f64 two53 = math__exp2(53);
	if (x < 0.25) {
		f64 _t1 = -math__sin(_const_math__pi * x);
		return _t1;
	}
	f64 z = math__floor(x);
	int n = 0;
	if (z != x) {
		x = math__mod(x, 2);
		n = ((int)(x * 4));
	} else {
		if (x >= two53) {
			x = 0;
			n = 0;
		} else {
			if (x < two52) {
				z = x + two52;
			}
			n = (1 & ((int)(math__f64_bits(z))));
			x = ((f64)(n));
			n <<= 2;
		}
	}
	if (n == 0) {
		x = math__sin(_const_math__pi * x);
	} else if (n == 1 || n == 2) {
		x = math__cos(_const_math__pi * (0.5 - x));
	} else if (n == 3 || n == 4) {
		x = math__sin(_const_math__pi * (1.0 - x));
	} else if (n == 5 || n == 6) {
		x = -math__cos(_const_math__pi * (x - 1.5));
	} else {
		x = math__sin(_const_math__pi * (x - 2));
	}
	f64 _t2 = -x;
	return _t2;
}

f64 math__hypot(f64 x, f64 y) {
	if (math__is_inf(x, 0) || math__is_inf(y, 0)) {
		f64 _t1 = math__inf(1);
		return _t1;
	}
	if (math__is_nan(x) || math__is_nan(y)) {
		f64 _t2 = math__nan();
		return _t2;
	}
	f64 result = 0.0;
	if (x != 0.0 || y != 0.0) {
		f64 abs_x = math__abs_T_f64(x);
		f64 abs_y = math__abs_T_f64(y);
		multi_return_f64_f64 mr_240 = math__minmax(abs_x, abs_y);
		f64 min = mr_240.arg0;
		f64 max = mr_240.arg1;
		f64 rat = min / max;
		f64 root_term = math__sqrt(1.0 + rat * rat);
		if (max < _const_math__max_f64 / root_term) {
			result = max * root_term;
		} else {
			panic_debug(20, tos3("/Users/rcqls/vlang/v/vlib/math/hypot.v"), tos3("math"), tos3("hypot"),  _SLIT("overflow in hypot_e function"));
			VUNREACHABLE();
		}
	}
	f64 _t3 = result;
	return _t3;
}

f64 math__acosh(f64 x) {
	if (x == 0.0) {
		f64 _t1 = 0.0;
		return _t1;
	} else if (x > 1.0 / _const_math__internal__sqrt_f64_epsilon) {
		f64 _t2 = math__log(x) + _const_math__pi * 2;
		return _t2;
	} else if (x > 2.0) {
		f64 _t3 = math__log(2.0 * x - 1.0 / (math__sqrt(x * x - 1.0) + x));
		return _t3;
	} else if (x > 1.0) {
		f64 t = x - 1.0;
		f64 _t4 = math__log1p(t + math__sqrt(2.0 * t + t * t));
		return _t4;
	} else if (x == 1.0) {
		f64 _t5 = 0.0;
		return _t5;
	} else {
		f64 _t6 = math__nan();
		return _t6;
	}
	return 0;
}

f64 math__asinh(f64 x) {
	f64 a = math__abs_T_f64(x);
	f64 s = (x < 0 ? (-1.0) : (1.0));
	if (a > 1.0 / _const_math__internal__sqrt_f64_epsilon) {
		f64 _t1 = s * (math__log(a) + _const_math__pi * 2.0);
		return _t1;
	} else if (a > 2.0) {
		f64 _t2 = s * math__log(2.0 * a + 1.0 / (a + math__sqrt(a * a + 1.0)));
		return _t2;
	} else if (a > _const_math__internal__sqrt_f64_epsilon) {
		f64 a2 = a * a;
		f64 _t3 = s * math__log1p(a + a2 / (1.0 + math__sqrt(1.0 + a2)));
		return _t3;
	} else {
		f64 _t4 = x;
		return _t4;
	}
	return 0;
}

f64 math__atanh(f64 x) {
	f64 a = math__abs_T_f64(x);
	f64 s = (x < 0 ? (-1.0) : (1.0));
	if (a > 1.0) {
		f64 _t1 = math__nan();
		return _t1;
	} else if (a == 1.0) {
		f64 _t2 = (x < 0 ? (math__inf(-1)) : (math__inf(1)));
		return _t2;
	} else if (a >= 0.5) {
		f64 _t3 = s * 0.5 * math__log1p(2.0 * a / (1.0 - a));
		return _t3;
	} else if (a > _const_math__internal__f64_epsilon) {
		f64 _t4 = s * 0.5 * math__log1p(2.0 * a + 2.0 * a * a / (1.0 - a));
		return _t4;
	} else {
		f64 _t5 = x;
		return _t5;
	}
	return 0;
}

// Attr: [inline]
inline f64 math__xatan(f64 x) {
	f64 xatan_p0 = -8.750608600031904122785e-01;
	f64 xatan_p1 = -1.615753718733365076637e+01;
	f64 xatan_p2 = -7.500855792314704667340e+01;
	f64 xatan_p3 = -1.228866684490136173410e+02;
	f64 xatan_p4 = -6.485021904942025371773e+01;
	f64 xatan_q0 = 2.485846490142306297962e+01;
	f64 xatan_q1 = 1.650270098316988542046e+02;
	f64 xatan_q2 = 4.328810604912902668951e+02;
	f64 xatan_q3 = 4.853903996359136964868e+02;
	f64 xatan_q4 = 1.945506571482613964425e+02;
	f64 z = x * x;
	z = z * ((((xatan_p0 * z + xatan_p1) * z + xatan_p2) * z + xatan_p3) * z + xatan_p4) / (((((z + xatan_q0) * z + xatan_q1) * z + xatan_q2) * z + xatan_q3) * z + xatan_q4);
	z = x * z + x;
	f64 _t1 = z;
	return _t1;
}

// Attr: [inline]
inline f64 math__satan(f64 x) {
	if (x <= 0.66) {
		f64 _t1 = math__xatan(x);
		return _t1;
	}
	if (x > _const_math__tan3pio8) {
		f64 _t2 = _const_math__pi / 2.0 - math__xatan(1.0 / x) + ((f64)(_const_math__morebits));
		return _t2;
	}
	f64 _t3 = _const_math__pi / 4 + math__xatan((x - 1.0) / (x + 1.0)) + 0.5 * ((f64)(_const_math__morebits));
	return _t3;
}

f64 math__atan(f64 x) {
	if (x == 0) {
		f64 _t1 = x;
		return _t1;
	}
	if (x > 0) {
		f64 _t2 = math__satan(x);
		return _t2;
	}
	f64 _t3 = -math__satan(-x);
	return _t3;
}

f64 math__atan2(f64 y, f64 x) {
	if (math__is_nan(y) || math__is_nan(x)) {
		f64 _t1 = math__nan();
		return _t1;
	}
	if (y == 0.0) {
		if (x >= 0 && !math__signbit(x)) {
			f64 _t2 = math__copysign(0, y);
			return _t2;
		}
		f64 _t3 = math__copysign(_const_math__pi, y);
		return _t3;
	}
	if (x == 0.0) {
		f64 _t4 = math__copysign(_const_math__pi / 2.0, y);
		return _t4;
	}
	if (math__is_inf(x, 0)) {
		if (math__is_inf(x, 1)) {
			if (math__is_inf(y, 0)) {
				f64 _t5 = math__copysign(_const_math__pi / 4, y);
				return _t5;
			}
			f64 _t6 = math__copysign(0, y);
			return _t6;
		}
		if (math__is_inf(y, 0)) {
			f64 _t7 = math__copysign(3.0 * _const_math__pi / 4.0, y);
			return _t7;
		}
		f64 _t8 = math__copysign(_const_math__pi, y);
		return _t8;
	}
	if (math__is_inf(y, 0)) {
		f64 _t9 = math__copysign(_const_math__pi / 2.0, y);
		return _t9;
	}
	f64 q = math__atan(y / x);
	if (x < 0) {
		if (q <= 0) {
			f64 _t10 = q + _const_math__pi;
			return _t10;
		}
		f64 _t11 = q - _const_math__pi;
		return _t11;
	}
	f64 _t12 = q;
	return _t12;
}

f64 math__asin(f64 x_) {
	f64 x = x_;
	if (x == 0.0) {
		f64 _t1 = x;
		return _t1;
	}
	bool sign = false;
	if (x < 0.0) {
		x = -x;
		sign = true;
	}
	if (x > 1.0) {
		f64 _t2 = math__nan();
		return _t2;
	}
	f64 temp = math__sqrt(1.0 - x * x);
	if (x > 0.7) {
		temp = _const_math__pi / 2.0 - math__satan(temp / x);
	} else {
		temp = math__satan(x / temp);
	}
	if (sign) {
		temp = -temp;
	}
	f64 _t3 = temp;
	return _t3;
}

// Attr: [inline]
inline f64 math__acos(f64 x) {
	if ((x < -1.0) || (x > 1.0)) {
		f64 _t1 = math__nan();
		return _t1;
	}
	if (x > 0.5) {
		f64 _t2 = ((f64)(2.0)) * math__asin(math__sqrt(0.5 - 0.5 * x));
		return _t2;
	}
	f64 z = _const_math__pi / ((f64)(4.0)) - math__asin(x);
	z = z + _const_math__morebits;
	z = z + _const_math__pi / ((f64)(4.0));
	f64 _t3 = z;
	return _t3;
}

f64 math__log_n(f64 x, f64 b) {
	f64 y = math__log(x);
	f64 z = math__log(b);
	f64 _t1 = y / z;
	return _t1;
}

f64 math__log10(f64 x) {
	f64 _t1 = math__log(x) * (1.0 / _const_math__ln10);
	return _t1;
}

f64 math__log2(f64 x) {
	multi_return_f64_int mr_364 = math__frexp(x);
	f64 frac = mr_364.arg0;
	int exp = mr_364.arg1;
	if (frac == 0.5) {
		f64 _t1 = ((f64)(exp - 1));
		return _t1;
	}
	f64 _t2 = math__log(frac) * (1.0 / _const_math__ln2) + ((f64)(exp));
	return _t2;
}

f64 math__log1p(f64 x) {
	f64 y = 1.0 + x;
	f64 z = y - 1.0;
	f64 _t1 = math__log(y) - (z - x) / y;
	return _t1;
}

f64 math__log_b(f64 x) {
	if (x == 0) {
		f64 _t1 = math__inf(-1);
		return _t1;
	}
	if (math__is_inf(x, 0)) {
		f64 _t2 = math__inf(1);
		return _t2;
	}
	if (math__is_nan(x)) {
		f64 _t3 = x;
		return _t3;
	}
	f64 _t4 = ((f64)(math__ilog_b_(x)));
	return _t4;
}

int math__ilog_b(f64 x) {
	if (x == 0) {
		int _t1 = _const_math__min_i32;
		return _t1;
	}
	if (math__is_nan(x)) {
		int _t2 = _const_math__max_i32;
		return _t2;
	}
	if (math__is_inf(x, 0)) {
		int _t3 = _const_math__max_i32;
		return _t3;
	}
	int _t4 = math__ilog_b_(x);
	return _t4;
}

int math__ilog_b_(f64 x_) {
	multi_return_f64_int mr_1424 = math__normalize(x_);
	f64 x = mr_1424.arg0;
	int exp = mr_1424.arg1;
	int _t1 = ((int)(((math__f64_bits(x) >> _const_math__shift) & _const_math__mask))) - _const_math__bias + exp;
	return _t1;
}

f64 math__log(f64 a) {
	f64 ln2_hi = 6.93147180369123816490e-01;
	f64 ln2_lo = 1.90821492927058770002e-10;
	f64 l1 = 6.666666666666735130e-01;
	f64 l2 = 3.999999999940941908e-01;
	f64 l3 = 2.857142874366239149e-01;
	f64 l4 = 2.222219843214978396e-01;
	f64 l5 = 1.818357216161805012e-01;
	f64 l6 = 1.531383769920937332e-01;
	f64 l7 = 1.479819860511658591e-01;
	f64 x = a;
	if (math__is_nan(x) || math__is_inf(x, 1)) {
		f64 _t1 = x;
		return _t1;
	} else if (x < 0) {
		f64 _t2 = math__nan();
		return _t2;
	} else if (x == 0) {
		f64 _t3 = math__inf(-1);
		return _t3;
	}
	multi_return_f64_int mr_4006 = math__frexp(x);
	f64 f1 = mr_4006.arg0;
	int ki = mr_4006.arg1;
	if (f1 < _const_math__sqrt2 / 2) {
		f1 *= 2;
		ki--;
	}
	f64 f = f1 - 1;
	f64 k = ((f64)(ki));
	f64 s = f / (2 + f);
	f64 s2 = s * s;
	f64 s4 = s2 * s2;
	f64 t1 = s2 * (l1 + s4 * (l3 + s4 * (l5 + s4 * l7)));
	f64 t2 = s4 * (l2 + s4 * (l4 + s4 * l6));
	f64 r = t1 + t2;
	f64 hfsq = 0.5 * f * f;
	f64 _t4 = k * ln2_hi - ((hfsq - (s * (hfsq + r) + k * ln2_lo)) - f);
	return _t4;
}

#if defined(_WIN32)
#else
#endif
f64 math__aprox_sin(f64 a) {
	f64 a0 = 1.91059300966915117e-31;
	f64 a1 = 1.00086760103908896;
	f64 a2 = -1.21276126894734565e-2;
	f64 a3 = -1.38078780785773762e-1;
	f64 a4 = -2.67353392911981221e-2;
	f64 a5 = 2.08026600266304389e-2;
	f64 a6 = -3.03996055049204407e-3;
	f64 a7 = 1.38235642404333740e-4;
	f64 _t1 = a0 + a * (a1 + a * (a2 + a * (a3 + a * (a4 + a * (a5 + a * (a6 + a * a7))))));
	return _t1;
}

f64 math__aprox_cos(f64 a) {
	f64 a0 = 9.9995999154986614e-1;
	f64 a1 = 1.2548995793001028e-3;
	f64 a2 = -5.0648546280678015e-1;
	f64 a3 = 1.2942246466519995e-2;
	f64 a4 = 2.8668384702547972e-2;
	f64 a5 = 7.3726485210586547e-3;
	f64 a6 = -3.8510875386947414e-3;
	f64 a7 = 4.7196604604366623e-4;
	f64 a8 = -1.8776444013090451e-5;
	f64 _t1 = a0 + a * (a1 + a * (a2 + a * (a3 + a * (a4 + a * (a5 + a * (a6 + a * (a7 + a * a8)))))));
	return _t1;
}

// Attr: [inline]
inline f64 math__copysign(f64 x, f64 y) {
	f64 _t1 = math__f64_from_bits((((math__f64_bits(x) & ~_const_math__sign_mask)) | ((math__f64_bits(y) & _const_math__sign_mask))));
	return _t1;
}

// Attr: [inline]
inline f64 math__degrees(f64 radians) {
	f64 _t1 = radians * (180.0 / _const_math__pi);
	return _t1;
}

Array_int math__digits(i64 num, math__DigitParams params) {
	int b = params.base;
	if (b < 2) {
		panic_debug(63, tos3("/Users/rcqls/vlang/v/vlib/math/math.v"), tos3("math"), tos3("digits"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("digits: Cannot find digits of n with base "), 0xfe07, {.d_i32 = b}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	i64 n = num;
	int sign = 1;
	if (n < 0) {
		sign = -1;
		n = -n;
	}
	Array_int res = __new_array_with_default(0, 0, sizeof(int), 0);
	if (n == 0) {
		array_push((array*)&res, _MOV((int[]){ 0 }));
		Array_int _t2 = res;
		return _t2;
	}
	for (;;) {
		if (!(n != 0)) break;
		i64 next_n = n / b;
		array_push((array*)&res, _MOV((int[]){ ((int)(n - next_n * b)) }));
		n = next_n;
	}
	if (sign == -1) {
		(*(int*)array_get(res, res.len - 1)) *= sign;
	}
	if (params.reverse) {
		res = array_reverse(res);
	}
	Array_int _t4 = res;
	return _t4;
}

int math__count_digits(i64 number) {
	i64 n = number;
	if (n == 0) {
		int _t1 = 1;
		return _t1;
	}
	int c = 0;
	for (;;) {
		if (!(n != 0)) break;
		n = n / 10;
		c++;
	}
	int _t2 = c;
	return _t2;
}

multi_return_f64_f64 math__minmax(f64 a, f64 b) {
	if (a < b) {
		return (multi_return_f64_f64){.arg0=a, .arg1=b};
	}
	return (multi_return_f64_f64){.arg0=b, .arg1=a};
}

// Attr: [inline]
inline f64 math__clamp(f64 x, f64 a, f64 b) {
	if (x < a) {
		f64 _t1 = a;
		return _t1;
	}
	if (x > b) {
		f64 _t2 = b;
		return _t2;
	}
	f64 _t3 = x;
	return _t3;
}

// Attr: [inline]
inline f64 math__sign(f64 n) {
	if (math__is_nan(n)) {
		f64 _t1 = math__nan();
		return _t1;
	}
	f64 _t2 = math__copysign(1.0, n);
	return _t2;
}

// Attr: [inline]
inline int math__signi(f64 n) {
	int _t1 = ((int)(math__copysign(1.0, n)));
	return _t1;
}

// Attr: [inline]
inline f64 math__radians(f64 degrees) {
	f64 _t1 = degrees * (_const_math__pi / 180.0);
	return _t1;
}

// Attr: [inline]
inline bool math__signbit(f64 x) {
	bool _t1 = (math__f64_bits(x) & _const_math__sign_mask) != 0U;
	return _t1;
}

bool math__tolerance(f64 a, f64 b, f64 tol) {
	f64 ee = tol;
	if (a == b) {
		bool _t1 = true;
		return _t1;
	}
	f64 d = a - b;
	if (d < 0) {
		d = -d;
	}
	if (b != 0) {
		ee = ee * b;
		if (ee < 0) {
			ee = -ee;
		}
	}
	bool _t2 = d < ee;
	return _t2;
}

bool math__close(f64 a, f64 b) {
	bool _t1 = math__tolerance(a, b, 1e-14);
	return _t1;
}

bool math__veryclose(f64 a, f64 b) {
	bool _t1 = math__tolerance(a, b, 4e-16);
	return _t1;
}

bool math__alike(f64 a, f64 b) {
	if (math__is_nan(a) && math__is_nan(b)) {
		bool _t1 = true;
		return _t1;
	} else if (a == b) {
		bool _t2 = math__signbit(a) == math__signbit(b);
		return _t2;
	}
	bool _t3 = false;
	return _t3;
}

bool math__is_odd_int(f64 x) {
	multi_return_f64_f64 mr_4654 = math__modf(x);
	f64 xi = mr_4654.arg0;
	f64 xf = mr_4654.arg1;
	bool _t1 = xf == 0 && ((((i64)(xi)) & 1)) == 1;
	return _t1;
}

bool math__is_neg_int(f64 x) {
	if (x < 0) {
		multi_return_f64_f64 mr_4754 = math__modf(x);
		f64 xf = mr_4754.arg1;
		bool _t1 = xf == 0;
		return _t1;
	}
	bool _t2 = false;
	return _t2;
}

// Attr: [inline]
inline int math__min_T_int(int a, int b) {
	int _t1 = (a < b ? (a) : (b));
	return _t1;
}
inline f32 math__min_T_f32(f32 a, f32 b) {
	f32 _t1 = (a < b ? (a) : (b));
	return _t1;
}

// Attr: [inline]
inline f32 math__max_T_f32(f32 a, f32 b) {
	f32 _t1 = (a > b ? (a) : (b));
	return _t1;
}
inline int math__max_T_int(int a, int b) {
	int _t1 = (a > b ? (a) : (b));
	return _t1;
}

// Attr: [inline]
inline f64 math__abs_T_f64(f64 a) {
	f64 _t1 = (a > 0 ? (a) : (-a));
	return _t1;
}
inline f32 math__abs_T_f32(f32 a) {
	f32 _t1 = (a > 0 ? (a) : (-a));
	return _t1;
}
inline int math__abs_T_int(int a) {
	int _t1 = (a > 0 ? (a) : (-a));
	return _t1;
}

multi_return_f64_f64 math__modf(f64 f) {
	f64 abs_f = math__abs_T_f64(f);
	f64 i = 0.0;
	if (abs_f >= _const_math__modf_maxpowtwo) {
		i = f;
	} else {
		i = abs_f + _const_math__modf_maxpowtwo;
		i -= _const_math__modf_maxpowtwo;
		for (;;) {
			if (!(i > abs_f)) break;
			i -= 1.0;
		}
		if (f < 0.0) {
			i = -i;
		}
	}
	return (multi_return_f64_f64){.arg0=i, .arg1=f - i};
}

f32 math__nextafter32(f32 x, f32 y) {
	f32 r = ((f32)(0.0));
	if (math__is_nan(((f64)(x))) || math__is_nan(((f64)(y)))) {
		r = ((f32)(math__nan()));
	} else if (x == y) {
		r = x;
	} else if (x == 0) {
		r = ((f32)(math__copysign(((f64)(math__f32_from_bits(1U))), ((f64)(y)))));
	} else if ((y > x) == (x > 0)) {
		r = math__f32_from_bits(math__f32_bits(x) + 1U);
	} else {
		r = math__f32_from_bits(math__f32_bits(x) - 1U);
	}
	f32 _t1 = r;
	return _t1;
}

f64 math__nextafter(f64 x, f64 y) {
	f64 r = 0.0;
	if (math__is_nan(x) || math__is_nan(y)) {
		r = math__nan();
	} else if (x == y) {
		r = x;
	} else if (x == 0) {
		r = math__copysign(math__f64_from_bits(1U), y);
	} else if ((y > x) == (x > 0)) {
		r = math__f64_from_bits(math__f64_bits(x) + 1U);
	} else {
		r = math__f64_from_bits(math__f64_bits(x) - 1U);
	}
	f64 _t1 = r;
	return _t1;
}

f64 math__poly_n_eval(Array_f64 c, int n, f64 x) {
	if (c.len == 0) {
		panic_debug(7, tos3("/Users/rcqls/vlang/v/vlib/math/poly.v"), tos3("math"), tos3("poly_n_eval"),  _SLIT("coeficients can not be empty"));
		VUNREACHABLE();
	}
	int len = ((int)(math__min_T_int(c.len, n)));
	f64 ans = (*(f64*)/*ee elem_sym */array_get(c, len - 1));
	Array_f64 _t1 = array_slice(c, 0, len - 1);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		f64 e = ((f64*)_t1.data)[_t2];
		ans = e + x * ans;
	}
	f64 _t3 = ans;
	return _t3;
}

f64 math__poly_n_1_eval(Array_f64 c, int n, f64 x) {
	if (c.len == 0) {
		panic_debug(19, tos3("/Users/rcqls/vlang/v/vlib/math/poly.v"), tos3("math"), tos3("poly_n_1_eval"),  _SLIT("coeficients can not be empty"));
		VUNREACHABLE();
	}
	int len = ((int)(math__min_T_int(c.len, n))) - 1;
	f64 ans = (*(f64*)/*ee elem_sym */array_get(c, len - 1));
	Array_f64 _t1 = array_slice(c, 0, len - 1);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		f64 e = ((f64*)_t1.data)[_t2];
		ans = e + x * ans;
	}
	f64 _t3 = ans;
	return _t3;
}

// Attr: [inline]
inline f64 math__poly_eval(Array_f64 c, f64 x) {
	f64 _t1 = math__poly_n_eval(c, c.len, x);
	return _t1;
}

// Attr: [inline]
inline f64 math__poly_1_eval(Array_f64 c, f64 x) {
	f64 _t1 = math__poly_n_1_eval(c, c.len, x);
	return _t1;
}

multi_return_f64_f64 math__ChebSeries_eval_e(math__ChebSeries cs, f64 x) {
	f64 d = 0.0;
	f64 dd = 0.0;
	f64 y = (2.0 * x - cs.a - cs.b) / (cs.b - cs.a);
	f64 y2 = 2.0 * y;
	f64 e_ = 0.0;
	f64 temp = 0.0;
	for (int j = cs.order; j >= 1; j--) {
		temp = d;
		d = y2 * d - dd + (*(f64*)/*ee elem_sym */array_get(cs.c, j));
		e_ += math__abs_T_f64(y2 * temp) + math__abs_T_f64(dd) + math__abs_T_f64((*(f64*)/*ee elem_sym */array_get(cs.c, j)));
		dd = temp;
	}
	temp = d;
	d = y * d - dd + 0.5 * (*(f64*)/*ee elem_sym */array_get(cs.c, 0));
	e_ += math__abs_T_f64(y * temp) + math__abs_T_f64(dd) + 0.5 * math__abs_T_f64((*(f64*)/*ee elem_sym */array_get(cs.c, 0)));
	return (multi_return_f64_f64){.arg0=d, .arg1=((f64)(_const_math__internal__f64_epsilon)) * e_ + math__abs_T_f64((*(f64*)/*ee elem_sym */array_get(cs.c, cs.order)))};
}

// Attr: [inline]
inline f32 math__powf(f32 a, f32 b) {
	f32 _t1 = powf(a, b);
	return _t1;
}

// Attr: [inline]
inline f32 math__pure_v_but_overriden_by_c_powf(f32 a, f32 b) {
	f32 _t1 = ((f32)(math__pow(a, b)));
	return _t1;
}

f64 math__pow10(int n) {
	if (0 <= n && n <= 308) {
		f64 _t1 = (*(f64*)/*ee elem_sym */array_get(_const_math__pow10postab32, ((u32)(n)) / 32U)) * (*(f64*)/*ee elem_sym */array_get(_const_math__pow10tab, ((u32)(n)) % 32U));
		return _t1;
	}
	if (-323 <= n && n <= 0) {
		f64 _t2 = (*(f64*)/*ee elem_sym */array_get(_const_math__pow10negtab32, ((u32)(-n)) / 32U)) / (*(f64*)/*ee elem_sym */array_get(_const_math__pow10tab, ((u32)(-n)) % 32U));
		return _t2;
	}
	if (n > 0) {
		f64 _t3 = math__inf(1);
		return _t3;
	}
	f64 _t4 = 0.0;
	return _t4;
}

i64 math__powi(i64 a, i64 b) {
	i64 b_ = b;
	i64 p = a;
	i64 v = ((i64)(1));
	if (b_ < 0) {
		if (a == 0) {
			i64 _t1 = -1;
			return _t1;
		}
		i64 _t2 = (a * a != 1 ? (0) : ((((b_ & 1)) > 0 ? (a) : (1))));
		return _t2;
	}
	for (; b_ > 0; ) {
		if ((b_ & 1) > 0) {
			v *= p;
		}
		p *= p;
		b_ >>= 1;
	}
	i64 _t3 = v;
	return _t3;
}

f64 math__pow(f64 x, f64 y) {
	if (y == 0 || x == 1) {
		f64 _t1 = 1;
		return _t1;
	} else if (y == 1) {
		f64 _t2 = x;
		return _t2;
	} else if (math__is_nan(x) || math__is_nan(y)) {
		f64 _t3 = math__nan();
		return _t3;
	} else if (x == 0) {
		if (y < 0) {
			if (math__is_odd_int(y)) {
				f64 _t4 = math__copysign(math__inf(1), x);
				return _t4;
			}
			f64 _t5 = math__inf(1);
			return _t5;
		} else if (y > 0) {
			if (math__is_odd_int(y)) {
				f64 _t6 = x;
				return _t6;
			}
			f64 _t7 = 0;
			return _t7;
		}
	} else if (math__is_inf(y, 0)) {
		if (x == -1) {
			f64 _t8 = 1;
			return _t8;
		} else if ((math__abs_T_f64(x) < 1) == math__is_inf(y, 1)) {
			f64 _t9 = 0;
			return _t9;
		} else {
			f64 _t10 = math__inf(1);
			return _t10;
		}
	} else if (math__is_inf(x, 0)) {
		if (math__is_inf(x, -1)) {
			f64 _t11 = math__pow(1 / x, -y);
			return _t11;
		}
		if (y < 0) {
			f64 _t12 = 0;
			return _t12;
		} else if (y > 0) {
			f64 _t13 = math__inf(1);
			return _t13;
		}
	} else if (y == 0.5) {
		f64 _t14 = math__sqrt(x);
		return _t14;
	} else if (y == -0.5) {
		f64 _t15 = 1 / math__sqrt(x);
		return _t15;
	}
	multi_return_f64_f64 mr_2400 = math__modf(math__abs_T_f64(y));
	f64 yi = mr_2400.arg0;
	f64 yf = mr_2400.arg1;
	if (yf != 0 && x < 0) {
		f64 _t16 = math__nan();
		return _t16;
	}
	if (yi >= (((u64)(1U)) << 63U)) {
		if (x == -1) {
			f64 _t17 = 1;
			return _t17;
		} else if ((math__abs_T_f64(x) < 1) == (y > 0)) {
			f64 _t18 = 0;
			return _t18;
		} else {
			f64 _t19 = math__inf(1);
			return _t19;
		}
	}
	f64 a1 = 1.0;
	int ae = 0;
	if (yf != 0) {
		if (yf > 0.5) {
			yf--;
			yi++;
		}
		a1 = math__exp(yf * math__log(x));
	}
	multi_return_f64_int mr_3038 = math__frexp(x);
	f64 x1 = mr_3038.arg0;
	int xe = mr_3038.arg1;
	for (i64 i = ((i64)(yi)); i != 0; i >>= 1) {
		if (xe < ((int)(((u32)(((u32)(-1)) << 12U)))) || 1 << 12 < xe) {
			ae += xe;
			break;
		}
		if ((i & 1) == 1) {
			a1 *= x1;
			ae += xe;
		}
		x1 *= x1;
		xe <<= 1;
		if (x1 < .5) {
			x1 += x1;
			xe--;
		}
	}
	if (y < 0) {
		a1 = 1 / a1;
		ae = -ae;
	}
	f64 _t20 = math__ldexp(a1, ae);
	return _t20;
}

// Attr: [inline]
inline f64 math__q_rsqrt(f64 x) {
	f64 x_half = 0.5 * x;
	i64 i = ((i64)(math__f64_bits(x)));
	i = 0x5fe6eb50c7b537a9 - (i >> 1);
	f64 j = math__f64_from_bits(((u64)(i)));
	j *= (1.5 - x_half * j * j);
	j *= (1.5 - x_half * j * j);
	f64 _t1 = j;
	return _t1;
}

f64 math__scalbn(f64 x, int n_) {
	int n = n_;
	f64 x1p1023 = math__f64_from_bits(((u64)(0x7fe0000000000000U)));
	f64 x1p53 = math__f64_from_bits(((u64)(0x4340000000000000U)));
	f64 x1p_1022 = math__f64_from_bits(((u64)(0x0010000000000000U)));
	f64 y = x;
	if (n > 1023) {
		y *= x1p1023;
		n -= 1023;
		if (n > 1023) {
			y *= x1p1023;
			n -= 1023;
			if (n > 1023) {
				n = 1023;
			}
		}
	} else if (n < -1022) {
		y *= x1p_1022 * x1p53;
		n += 1022 - 53;
		if (n < -1022) {
			y *= x1p_1022 * x1p53;
			n += 1022 - 53;
			if (n < -1022) {
				n = -1022;
			}
		}
	}
	f64 _t1 = y * math__f64_from_bits(((u64)((0x3ff + n))) << 52U);
	return _t1;
}

// Attr: [inline]
inline f32 math__cosf(f32 a) {
	f32 _t1 = cosf(a);
	return _t1;
}

// Attr: [inline]
inline f32 math__sinf(f32 a) {
	f32 _t1 = sinf(a);
	return _t1;
}

f64 math__sin(f64 x) {
	f64 p1 = 7.85398125648498535156e-1;
	f64 p2 = 3.77489470793079817668e-8;
	f64 p3 = 2.69515142907905952645e-15;
	int sgn_x = (x < 0 ? (-1) : (1));
	f64 abs_x = math__abs_T_f64(x);
	if (abs_x < _const_math__internal__root4_f64_epsilon) {
		f64 x2 = x * x;
		f64 _t1 = x * (1.0 - x2 / 6.0);
		return _t1;
	} else {
		int sgn_result = sgn_x;
		f64 y = math__floor(abs_x / (0.25 * _const_math__pi));
		int octant = ((int)(y - math__ldexp(math__floor(math__ldexp(y, -3)), 3)));
		if (((octant & 1)) == 1) {
			octant++;
			octant &= 7;
			y += 1.0;
		}
		if (octant > 3) {
			octant -= 4;
			sgn_result = -sgn_result;
		}
		f64 z = ((abs_x - y * p1) - y * p2) - y * p3;
		f64 result = 0.0;
		if (octant == 0) {
			f64 t = 8.0 * math__abs_T_f64(z) / _const_math__pi - 1.0;
			multi_return_f64_f64 mr_1676 = math__ChebSeries_eval_e(_const_math__sin_cs, t);
			f64 sin_cs_val = mr_1676.arg0;
			result = z * (1.0 + z * z * sin_cs_val);
		} else {
			f64 t = 8.0 * math__abs_T_f64(z) / _const_math__pi - 1.0;
			multi_return_f64_f64 mr_1804 = math__ChebSeries_eval_e(_const_math__cos_cs, t);
			f64 cos_cs_val = mr_1804.arg0;
			result = 1.0 - 0.5 * z * z * (1.0 - z * z * cos_cs_val);
		}
		result *= sgn_result;
		f64 _t2 = result;
		return _t2;
	}
	return 0;
}

f64 math__cos(f64 x) {
	f64 p1 = 7.85398125648498535156e-1;
	f64 p2 = 3.77489470793079817668e-8;
	f64 p3 = 2.69515142907905952645e-15;
	f64 abs_x = math__abs_T_f64(x);
	if (abs_x < _const_math__internal__root4_f64_epsilon) {
		f64 x2 = x * x;
		f64 _t1 = 1.0 - 0.5 * x2;
		return _t1;
	} else {
		int sgn_result = 1;
		f64 y = math__floor(abs_x / (0.25 * _const_math__pi));
		int octant = ((int)(y - math__ldexp(math__floor(math__ldexp(y, -3)), 3)));
		if (((octant & 1)) == 1) {
			octant++;
			octant &= 7;
			y += 1.0;
		}
		if (octant > 3) {
			octant -= 4;
			sgn_result = -sgn_result;
		}
		if (octant > 1) {
			sgn_result = -sgn_result;
		}
		f64 z = ((abs_x - y * p1) - y * p2) - y * p3;
		f64 result = 0.0;
		if (octant == 0) {
			f64 t = 8.0 * math__abs_T_f64(z) / _const_math__pi - 1.0;
			multi_return_f64_f64 mr_2597 = math__ChebSeries_eval_e(_const_math__cos_cs, t);
			f64 cos_cs_val = mr_2597.arg0;
			result = 1.0 - 0.5 * z * z * (1.0 - z * z * cos_cs_val);
		} else {
			f64 t = 8.0 * math__abs_T_f64(z) / _const_math__pi - 1.0;
			multi_return_f64_f64 mr_2741 = math__ChebSeries_eval_e(_const_math__sin_cs, t);
			f64 sin_cs_val = mr_2741.arg0;
			result = z * (1.0 + z * z * sin_cs_val);
		}
		result *= sgn_result;
		f64 _t2 = result;
		return _t2;
	}
	return 0;
}

// Attr: [inline]
inline f32 math__pure_v_but_overriden_by_c_cosf(f32 a) {
	f32 _t1 = ((f32)(math__cos(a)));
	return _t1;
}

// Attr: [inline]
inline f32 math__pure_v_but_overriden_by_c_sinf(f32 a) {
	f32 _t1 = ((f32)(math__sin(a)));
	return _t1;
}

multi_return_f64_f64 math__sincos(f64 x) {
	f64 p1 = 7.85398125648498535156e-1;
	f64 p2 = 3.77489470793079817668e-8;
	f64 p3 = 2.69515142907905952645e-15;
	int sgn_x = (x < 0 ? (-1) : (1));
	f64 abs_x = math__abs_T_f64(x);
	if (abs_x < _const_math__internal__root4_f64_epsilon) {
		f64 x2 = x * x;
		return (multi_return_f64_f64){.arg0=x * (1.0 - x2 / 6.0), .arg1=1.0 - 0.5 * x2};
	} else {
		int sgn_result_sin = sgn_x;
		int sgn_result_cos = 1;
		f64 y = math__floor(abs_x / (0.25 * _const_math__pi));
		int octant = ((int)(y - math__ldexp(math__floor(math__ldexp(y, -3)), 3)));
		if (((octant & 1)) == 1) {
			octant++;
			octant &= 7;
			y += 1.0;
		}
		if (octant > 3) {
			octant -= 4;
			sgn_result_sin = -sgn_result_sin;
			sgn_result_cos = -sgn_result_cos;
		}
		sgn_result_cos = (octant > 1 ? (-sgn_result_cos) : (sgn_result_cos));
		f64 z = ((abs_x - y * p1) - y * p2) - y * p3;
		f64 t = 8.0 * math__abs_T_f64(z) / _const_math__pi - 1.0;
		multi_return_f64_f64 mr_3838 = math__ChebSeries_eval_e(_const_math__sin_cs, t);
		f64 sin_cs_val = mr_3838.arg0;
		multi_return_f64_f64 mr_3879 = math__ChebSeries_eval_e(_const_math__cos_cs, t);
		f64 cos_cs_val = mr_3879.arg0;
		f64 result_sin = 0.0;
		f64 result_cos = 0.0;
		if (octant == 0) {
			result_sin = z * (1.0 + z * z * sin_cs_val);
			result_cos = 1.0 - 0.5 * z * z * (1.0 - z * z * cos_cs_val);
		} else {
			result_sin = 1.0 - 0.5 * z * z * (1.0 - z * z * cos_cs_val);
			result_cos = z * (1.0 + z * z * sin_cs_val);
		}
		result_sin *= sgn_result_sin;
		result_cos *= sgn_result_cos;
		return (multi_return_f64_f64){.arg0=result_sin, .arg1=result_cos};
	}
	return (multi_return_f64_f64){0};
}

f64 math__sinh(f64 x_) {
	f64 x = x_;
	f64 p0 = -0.6307673640497716991184787251e+6;
	f64 p1 = -0.8991272022039509355398013511e+5;
	f64 p2 = -0.2894211355989563807284660366e+4;
	f64 p3 = -0.2630563213397497062819489e+2;
	f64 q0 = -0.6307673640497716991212077277e+6;
	f64 q1 = 0.1521517378790019070696485176e+5;
	f64 q2 = -0.173678953558233699533450911e+3;
	bool sign = false;
	if (x < 0) {
		x = -x;
		sign = true;
	}
	f64 temp = 0.0;
	if (x > 21) {
		temp = math__exp(x) * 0.5;
	} else if (x > 0.5) {
		f64 ex = math__exp(x);
		temp = (ex - 1.0 / ex) * 0.5;
	} else {
		f64 sq = x * x;
		temp = (((p3 * sq + p2) * sq + p1) * sq + p0) * x;
		temp = temp / (((sq + q2) * sq + q1) * sq + q0);
	}
	if (sign) {
		temp = -temp;
	}
	f64 _t1 = temp;
	return _t1;
}

f64 math__cosh(f64 x) {
	f64 abs_x = math__abs_T_f64(x);
	if (abs_x > 21) {
		f64 _t1 = math__exp(abs_x) * 0.5;
		return _t1;
	}
	f64 ex = math__exp(abs_x);
	f64 _t2 = (ex + 1.0 / ex) * 0.5;
	return _t2;
}

// Attr: [inline]
inline f32 math__sqrtf(f32 a) {
	f32 _t1 = sqrtf(a);
	return _t1;
}

// Attr: [inline]
inline f64 math__sqrt(f64 a) {
	f64 x = a;
	if (x == 0.0 || math__is_nan(x) || math__is_inf(x, 1)) {
		f64 _t1 = x;
		return _t1;
	}
	if (x < 0.0) {
		f64 _t2 = math__nan();
		return _t2;
	}
	multi_return_f64_int mr_258 = math__frexp(x);
	f64 z = mr_258.arg0;
	int ex = mr_258.arg1;
	f64 w = x;
	x = 4.173075996388649989089e-1 + 5.9016206709064458299663e-1 * z;
	if (((ex & 1)) != 0) {
		x *= _const_math__sqrt2;
	}
	x = math__ldexp(x, ex >> 1);
	x = 0.5 * (x + w / x);
	x = 0.5 * (x + w / x);
	x = 0.5 * (x + w / x);
	f64 _t3 = x;
	return _t3;
}

// Attr: [inline]
inline f32 math__pure_v_but_overriden_by_c_sqrtf(f32 a) {
	f32 _t1 = ((f32)(math__sqrt(a)));
	return _t1;
}

i64 math__sqrti(i64 a) {
	i64 x = a;
	i64 q = ((i64)(1));
	i64 r = ((i64)(0));
	for (; q <= x; ) {
		q <<= 2;
	}
	for (; q > 1; ) {
		q >>= 2;
		i64 t = x - r - q;
		r >>= 1;
		if (t >= 0) {
			x = t;
			r += q;
		}
	}
	i64 _t1 = r;
	return _t1;
}

// Attr: [inline]
inline f32 math__tanf(f32 a) {
	f32 _t1 = tanf(a);
	return _t1;
}

f64 math__tan(f64 a) {
	f64 x = a;
	if (x == 0.0 || math__is_nan(x)) {
		f64 _t1 = x;
		return _t1;
	}
	if (math__is_inf(x, 0)) {
		f64 _t2 = math__nan();
		return _t2;
	}
	int sign = 1;
	if (x < 0) {
		x = -x;
		sign = -1;
	}
	if (x > _const_math__tan_lossth) {
		f64 _t3 = 0.0;
		return _t3;
	}
	f64 y = math__floor(x * 4.0 / _const_math__pi);
	f64 z = math__ldexp(y, -3);
	z = math__floor(z);
	z = y - math__ldexp(z, 3);
	int octant = ((int)(z));
	if (((octant & 1)) == 1) {
		octant++;
		y += 1.0;
	}
	z = ((x - y * _const_math__tan_dp1) - y * _const_math__tan_dp2) - y * _const_math__tan_dp3;
	f64 zz = z * z;
	if (zz > 1.0e-14) {
		y = z + z * (zz * ((((*(f64*)/*ee elem_sym */array_get(_const_math__tan_p, 0)) * zz) + (*(f64*)/*ee elem_sym */array_get(_const_math__tan_p, 1))) * zz + (*(f64*)/*ee elem_sym */array_get(_const_math__tan_p, 2))) / ((((zz + (*(f64*)/*ee elem_sym */array_get(_const_math__tan_q, 1))) * zz + (*(f64*)/*ee elem_sym */array_get(_const_math__tan_q, 2))) * zz + (*(f64*)/*ee elem_sym */array_get(_const_math__tan_q, 3))) * zz + (*(f64*)/*ee elem_sym */array_get(_const_math__tan_q, 4))));
	} else {
		y = z;
	}
	if (((octant & 2)) == 2) {
		y = -1.0 / y;
	}
	if (sign < 0) {
		y = -y;
	}
	f64 _t4 = y;
	return _t4;
}

// Attr: [inline]
inline f32 math__pure_v_but_overriden_by_c_tanf(f32 a) {
	f32 _t1 = ((f32)(math__tan(a)));
	return _t1;
}

f64 math__cot(f64 a) {
	f64 x = a;
	if (x == 0.0) {
		f64 _t1 = math__inf(1);
		return _t1;
	}
	int sign = 1;
	if (x < 0) {
		x = -x;
		sign = -1;
	}
	if (x > _const_math__tan_lossth) {
		f64 _t2 = 0.0;
		return _t2;
	}
	f64 y = math__floor(x * 4.0 / _const_math__pi);
	f64 z = math__ldexp(y, -3);
	z = math__floor(z);
	z = y - math__ldexp(z, 3);
	int octant = ((int)(z));
	if (((octant & 1)) == 1) {
		octant++;
		y += 1.0;
	}
	z = ((x - y * _const_math__tan_dp1) - y * _const_math__tan_dp2) - y * _const_math__tan_dp3;
	f64 zz = z * z;
	if (zz > 1.0e-14) {
		y = z + z * (zz * ((((*(f64*)/*ee elem_sym */array_get(_const_math__tan_p, 0)) * zz) + (*(f64*)/*ee elem_sym */array_get(_const_math__tan_p, 1))) * zz + (*(f64*)/*ee elem_sym */array_get(_const_math__tan_p, 2))) / ((((zz + (*(f64*)/*ee elem_sym */array_get(_const_math__tan_q, 1))) * zz + (*(f64*)/*ee elem_sym */array_get(_const_math__tan_q, 2))) * zz + (*(f64*)/*ee elem_sym */array_get(_const_math__tan_q, 3))) * zz + (*(f64*)/*ee elem_sym */array_get(_const_math__tan_q, 4))));
	} else {
		y = z;
	}
	if (((octant & 2)) == 2) {
		y = -y;
	} else {
		y = 1.0 / y;
	}
	if (sign < 0) {
		y = -y;
	}
	f64 _t3 = y;
	return _t3;
}

f64 math__tanh(f64 x) {
	f64 maxlog = 8.8029691931113054295988e+01;
	f64 z = math__abs_T_f64(x);
	if (z > 0.5 * maxlog) {
		if (x < 0) {
			f64 _t1 = ((f64)(-1));
			return _t1;
		}
		f64 _t2 = 1.0;
		return _t2;
	} else if (z >= 0.625) {
		f64 s = math__exp(2.0 * z);
		z = 1.0 - 2.0 / (s + 1.0);
		if (x < 0) {
			z = -z;
		}
	} else {
		if (x == 0) {
			f64 _t3 = x;
			return _t3;
		}
		f64 s = x * x;
		z = x + x * s * (((*(f64*)/*ee elem_sym */array_get(_const_math__tanh_p, 0)) * s + (*(f64*)/*ee elem_sym */array_get(_const_math__tanh_p, 1))) * s + (*(f64*)/*ee elem_sym */array_get(_const_math__tanh_p, 2))) / (((s + (*(f64*)/*ee elem_sym */array_get(_const_math__tanh_q, 0))) * s + (*(f64*)/*ee elem_sym */array_get(_const_math__tanh_q, 1))) * s + (*(f64*)/*ee elem_sym */array_get(_const_math__tanh_q, 2)));
	}
	f64 _t4 = z;
	return _t4;
}

u32 math__f32_bits(f32 f) {
	u32 p = *((u32*)(&f));
	u32 _t1 = p;
	return _t1;
}

f32 math__f32_from_bits(u32 b) {
	f32 p = *((f32*)(&b));
	f32 _t1 = p;
	return _t1;
}

u64 math__f64_bits(f64 f) {
	u64 p = *((u64*)(&f));
	u64 _t1 = p;
	return _t1;
}

f64 math__f64_from_bits(u64 b) {
	f64 p = *((f64*)(&b));
	f64 _t1 = p;
	return _t1;
}

f64 math__with_set_low_word(f64 f, u32 lo) {
	u64 tmp = math__f64_bits(f);
	tmp &= 0xffffffff00000000U;
	tmp |= ((u64)(lo));
	f64 _t1 = math__f64_from_bits(tmp);
	return _t1;
}

f64 math__with_set_high_word(f64 f, u32 hi) {
	u64 tmp = math__f64_bits(f);
	tmp &= 0x00000000ffffffffU;
	tmp |= ((u64)(hi)) << 32U;
	f64 _t1 = math__f64_from_bits(tmp);
	return _t1;
}

u32 math__get_high_word(f64 f) {
	u32 _t1 = ((u32)(math__f64_bits(f) >> 32U));
	return _t1;
}

string os__font__default(void) {
	string env_font = os__getenv(_SLIT("VUI_FONT"));
	if ((env_font).len != 0 && os__exists(env_font)) {
		string _t1 = env_font;
		return _t1;
	}
	Array_string fonts = new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT("/System/Library/Fonts/SFNS.ttf"), _SLIT("/System/Library/Fonts/SFNSText.ttf"), _SLIT("/Library/Fonts/Arial.ttf")}));
	for (int _t2 = 0; _t2 < fonts.len; ++_t2) {
		string font = ((string*)fonts.data)[_t2];
		if (os__is_file(font)) {
			;
			string _t3 = font;
			return _t3;
		}
	}
	os__Result fm = os__execute(_SLIT("fc-match --format='%{file}\n' -s"));
	if (fm.exit_code == 0) {
		Array_string lines = string_split(fm.output, _SLIT("\n"));
		for (int _t4 = 0; _t4 < lines.len; ++_t4) {
			string l = ((string*)lines.data)[_t4];
			if (!string_contains(l, _SLIT(".ttc"))) {
				;
				string _t5 = l;
				return _t5;
			}
		}
	} else {
		panic_debug(81, tos3("/Users/rcqls/vlang/v/vlib/os/font/font.v"), tos3("os.font"), tos3("default"),  _SLIT("fc-match failed to fetch system font"));
		VUNREACHABLE();
	}
	panic_debug(83, tos3("/Users/rcqls/vlang/v/vlib/os/font/font.v"), tos3("os.font"), tos3("default"),  _SLIT("failed to init the font"));
	VUNREACHABLE();
	return (string){.str=(byteptr)"", .is_lit=1};
}

string os__font__get_path_variant(string font_path, os__font__Variant variant) {
	string file = os__file_name(font_path);
	string fpath = string_replace(font_path, file, _SLIT(""));
	file = string_replace(file, _SLIT(".ttf"), _SLIT(""));

	if (variant == (os__font__Variant__normal)) {
	}
	else if (variant == (os__font__Variant__bold)) {
		if (string_ends_with(fpath, _SLIT("-Regular"))) {
			file = string_replace(file, _SLIT("-Regular"), _SLIT("-Bold"));
		} else if (string_starts_with(file, _SLIT("DejaVuSans"))) {
			file = /*f*/string__plus(file, _SLIT("-Bold"));
		} else if (string_starts_with(string_to_lower(file), _SLIT("arial"))) {
			file = /*f*/string__plus(file, _SLIT("bd"));
		} else {
			file = /*f*/string__plus(file, _SLIT("-bold"));
		}
		if (os__exists(_SLIT("SFNS-bold"))) {
			file = _SLIT("SFNS-bold");
		}
	}
	else if (variant == (os__font__Variant__italic)) {
		if (string_ends_with(file, _SLIT("-Regular"))) {
			file = string_replace(file, _SLIT("-Regular"), _SLIT("-Italic"));
		} else if (string_starts_with(file, _SLIT("DejaVuSans"))) {
			file = /*f*/string__plus(file, _SLIT("-Oblique"));
		} else if (string_starts_with(string_to_lower(file), _SLIT("arial"))) {
			file = /*f*/string__plus(file, _SLIT("i"));
		} else {
			file = /*f*/string__plus(file, _SLIT("Italic"));
		}
	}
	else if (variant == (os__font__Variant__mono)) {
		if (!string_ends_with(file, _SLIT("Mono-Regular")) && string_ends_with(file, _SLIT("-Regular"))) {
			file = string_replace(file, _SLIT("-Regular"), _SLIT("Mono-Regular"));
		} else if (string_starts_with(string_to_lower(file), _SLIT("arial"))) {
		} else {
			file = /*f*/string__plus(file, _SLIT("Mono"));
		}
	};
	string _t1 = string__plus(string__plus(fpath, file), _SLIT(".ttf"));
	return _t1;
}

// Attr: [inline]
inline void sokol__gfx__setup(sokol__gfx__Desc* desc) {
	sg_setup(desc);
}

// Attr: [inline]
inline void sokol__gfx__shutdown(void) {
	sg_shutdown();
}

// Attr: [inline]
inline bool sokol__gfx__is_valid(void) {
	bool _t1 = sg_isvalid();
	return _t1;
}

// Attr: [inline]
inline void sokol__gfx__reset_state_cache(void) {
	sg_reset_state_cache();
}

// Attr: [inline]
inline sokol__gfx__Buffer sokol__gfx__make_buffer(sokol__gfx__BufferDesc* desc) {
	sokol__gfx__Buffer _t1 = sg_make_buffer(desc);
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__Image sokol__gfx__make_image(sokol__gfx__ImageDesc* desc) {
	sokol__gfx__Image _t1 = sg_make_image(desc);
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__Shader sokol__gfx__make_shader(sokol__gfx__ShaderDesc* desc) {
	sokol__gfx__Shader _t1 = sg_make_shader(desc);
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__Pipeline sokol__gfx__make_pipeline(sokol__gfx__PipelineDesc* desc) {
	sokol__gfx__Pipeline _t1 = sg_make_pipeline(desc);
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__Pass sokol__gfx__make_pass(sokol__gfx__PassDesc* desc) {
	sokol__gfx__Pass _t1 = sg_make_pass(desc);
	return _t1;
}

// Attr: [inline]
inline void sokol__gfx__destroy_buffer(sokol__gfx__Buffer buf) {
	sg_destroy_buffer(buf);
}

// Attr: [inline]
inline void sokol__gfx__destroy_image(sokol__gfx__Image img) {
	sg_destroy_image(img);
}

// Attr: [inline]
inline void sokol__gfx__destroy_shader(sokol__gfx__Shader shd) {
	sg_destroy_shader(shd);
}

// Attr: [inline]
inline void sokol__gfx__destroy_pipeline(sokol__gfx__Pipeline pip) {
	sg_destroy_pipeline(pip);
}

// Attr: [inline]
inline void sokol__gfx__destroy_pass(sokol__gfx__Pass pass) {
	sg_destroy_pass(pass);
}

// Attr: [inline]
inline void sokol__gfx__update_buffer(sokol__gfx__Buffer buf, sokol__gfx__Range* data) {
	sg_update_buffer(buf, data);
}

// Attr: [inline]
inline void sokol__gfx__update_image(sokol__gfx__Image img, sokol__gfx__ImageData* data) {
	sg_update_image(img, data);
}

// Attr: [inline]
inline int sokol__gfx__append_buffer(sokol__gfx__Buffer buf, sokol__gfx__Range* data) {
	int _t1 = sg_append_buffer(buf, data);
	return _t1;
}

// Attr: [inline]
inline bool sokol__gfx__query_buffer_overflow(sokol__gfx__Buffer buf) {
	bool _t1 = sg_query_buffer_overflow(buf);
	return _t1;
}

// Attr: [inline]
inline void sokol__gfx__begin_default_pass(sokol__gfx__PassAction* actions, int width, int height) {
	sg_begin_default_pass(actions, width, height);
}

// Attr: [inline]
inline void sokol__gfx__begin_pass(sokol__gfx__Pass pass, sokol__gfx__PassAction* actions) {
	sg_begin_pass(pass, actions);
}

// Attr: [inline]
inline void sokol__gfx__apply_viewport(int x, int y, int width, int height, bool origin_top_left) {
	sg_apply_viewport(x, y, width, height, origin_top_left);
}

// Attr: [inline]
inline void sokol__gfx__apply_scissor_rect(int x, int y, int width, int height, bool origin_top_left) {
	sg_apply_scissor_rect(x, y, width, height, origin_top_left);
}

// Attr: [inline]
inline void sokol__gfx__apply_pipeline(sokol__gfx__Pipeline pip) {
	sg_apply_pipeline(pip);
}

// Attr: [inline]
inline void sokol__gfx__apply_bindings(sokol__gfx__Bindings* bindings) {
	sg_apply_bindings(bindings);
}

// Attr: [inline]
inline void sokol__gfx__apply_uniforms(sokol__gfx__ShaderStage stage, int ub_index, sokol__gfx__Range* data) {
	sg_apply_uniforms(((int)(stage)), ub_index, data);
}

// Attr: [inline]
inline void sokol__gfx__draw(int base_element, int num_elements, int num_instances) {
	sg_draw(base_element, num_elements, num_instances);
}

// Attr: [inline]
inline void sokol__gfx__end_pass(void) {
	sg_end_pass();
}

// Attr: [inline]
inline void sokol__gfx__commit(void) {
	sg_commit();
}

// Attr: [inline]
inline sokol__gfx__Desc sokol__gfx__query_desc(void) {
	sokol__gfx__Desc _t1 = sg_query_desc();
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__Backend sokol__gfx__query_backend(void) {
	sokol__gfx__Backend _t1 = sg_query_backend();
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__Features sokol__gfx__query_features(void) {
	sokol__gfx__Features _t1 = sg_query_features();
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__Limits sokol__gfx__query_limits(void) {
	sokol__gfx__Limits _t1 = sg_query_limits();
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__PixelFormatInfo sokol__gfx__query_pixelformat(sokol__gfx__PixelFormat fmt) {
	sokol__gfx__PixelFormatInfo _t1 = sg_query_pixelformat(fmt);
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__ResourceState sokol__gfx__query_buffer_state(sokol__gfx__Buffer buf) {
	sokol__gfx__ResourceState _t1 = ((sokol__gfx__ResourceState)(sg_query_buffer_state(buf)));
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__ResourceState sokol__gfx__query_image_state(sokol__gfx__Image img) {
	sokol__gfx__ResourceState _t1 = ((sokol__gfx__ResourceState)(sg_query_image_state(img)));
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__ResourceState sokol__gfx__query_shader_state(sokol__gfx__Shader shd) {
	sokol__gfx__ResourceState _t1 = ((sokol__gfx__ResourceState)(sg_query_shader_state(shd)));
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__ResourceState sokol__gfx__query_pipeline_state(sokol__gfx__Pipeline pip) {
	sokol__gfx__ResourceState _t1 = ((sokol__gfx__ResourceState)(sg_query_pipeline_state(pip)));
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__ResourceState sokol__gfx__query_pass_state(sokol__gfx__Pass pass) {
	sokol__gfx__ResourceState _t1 = ((sokol__gfx__ResourceState)(sg_query_pass_state(pass)));
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__BufferInfo sokol__gfx__query_buffer_info(sokol__gfx__Buffer buf) {
	sokol__gfx__BufferInfo _t1 = sg_query_buffer_info(buf);
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__ImageInfo sokol__gfx__query_image_info(sokol__gfx__Image img) {
	sokol__gfx__ImageInfo _t1 = sg_query_image_info(img);
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__ShaderInfo sokol__gfx__query_shader_info(sokol__gfx__Shader shd) {
	sokol__gfx__ShaderInfo _t1 = sg_query_shader_info(shd);
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__PipelineInfo sokol__gfx__query_pipeline_info(sokol__gfx__Pipeline pip) {
	sokol__gfx__PipelineInfo _t1 = sg_query_pipeline_info(pip);
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__PassInfo sokol__gfx__query_pass_info(sokol__gfx__Pass pass) {
	sokol__gfx__PassInfo _t1 = sg_query_pass_info(pass);
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__BufferDesc sokol__gfx__query_buffer_defaults(sokol__gfx__Buffer* desc) {
	sokol__gfx__BufferDesc _t1 = sg_query_buffer_defaults(((sokol__gfx__BufferDesc*)(((voidptr)(desc)))));
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__ImageDesc sokol__gfx__query_image_defaults(sokol__gfx__Image* desc) {
	sokol__gfx__ImageDesc _t1 = sg_query_image_defaults(((sokol__gfx__ImageDesc*)(((voidptr)(desc)))));
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__ShaderDesc sokol__gfx__query_shader_defaults(sokol__gfx__Shader* desc) {
	sokol__gfx__ShaderDesc _t1 = sg_query_shader_defaults(((sokol__gfx__ShaderDesc*)(((voidptr)(desc)))));
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__PipelineDesc sokol__gfx__query_pipeline_defaults(sokol__gfx__Pipeline* desc) {
	sokol__gfx__PipelineDesc _t1 = sg_query_pipeline_defaults(((sokol__gfx__PipelineDesc*)(((voidptr)(desc)))));
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__PassDesc sokol__gfx__query_pass_defaults(sokol__gfx__Pass* desc) {
	sokol__gfx__PassDesc _t1 = sg_query_pass_defaults(((sokol__gfx__PassDesc*)(((voidptr)(desc)))));
	return _t1;
}

// Attr: [inline]
inline sokol__gfx__Context sokol__gfx__setup_context(void) {
	sokol__gfx__Context _t1 = sg_setup_context();
	return _t1;
}

// Attr: [inline]
inline void sokol__gfx__activate_context(sokol__gfx__Context ctx_id) {
	sg_activate_context(ctx_id);
}

// Attr: [inline]
inline void sokol__gfx__discard_context(sokol__gfx__Context ctx_id) {
	sg_discard_context(ctx_id);
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
void C__sg_pipeline_free(struct sg_pipeline* p) {
	sg_destroy_pipeline(*p);
}

// TypeDecl
void sokol__gfx__Bindings_set_vert_image(sokol__gfx__Bindings* b, int index, sokol__gfx__Image img) {
	b->vs_images[v_fixed_index(index, 8)] = img;
}

void sokol__gfx__Bindings_set_frag_image(sokol__gfx__Bindings* b, int index, sokol__gfx__Image img) {
	b->fs_images[v_fixed_index(index, 8)] = img;
}

void sokol__gfx__Bindings_update_vert_buffer(sokol__gfx__Bindings* b, int index, voidptr data, int element_size, int element_count) {
	sokol__gfx__Range range = ((sokol__gfx__Range){.ptr = data,.size = ((usize)(element_size * element_count)),});
	sg_update_buffer(b->vertex_buffers[v_fixed_index(index, 8)], &range);
}

int sokol__gfx__Bindings_append_vert_buffer(sokol__gfx__Bindings* b, int index, voidptr data, int element_size, int element_count) {
	sokol__gfx__Range range = ((sokol__gfx__Range){.ptr = data,.size = ((usize)(element_size * element_count)),});
	int _t1 = sg_append_buffer(b->vertex_buffers[v_fixed_index(index, 8)], &range);
	return _t1;
}

void sokol__gfx__Bindings_update_index_buffer(sokol__gfx__Bindings* b, voidptr data, int element_size, int element_count) {
	sokol__gfx__Range range = ((sokol__gfx__Range){.ptr = data,.size = ((usize)(element_size * element_count)),});
	sg_update_buffer(b->index_buffer, &range);
}

int sokol__gfx__Bindings_append_index_buffer(sokol__gfx__Bindings* b, voidptr data, int element_size, int element_count) {
	sokol__gfx__Range range = ((sokol__gfx__Range){.ptr = data,.size = ((usize)(element_size * element_count)),});
	int _t1 = sg_append_buffer(b->index_buffer, &range);
	return _t1;
}

// TypeDecl
sokol__gfx__ShaderDesc* C__sg_shader_desc_set_vert_src(struct sg_shader_desc* desc, string src) {
	desc->vs.source = ((char*)(src.str));
	sokol__gfx__ShaderDesc* _t1 = desc;
	return _t1;
}

sokol__gfx__ShaderDesc* C__sg_shader_desc_set_frag_src(struct sg_shader_desc* desc, string src) {
	desc->fs.source = ((char*)(src.str));
	sokol__gfx__ShaderDesc* _t1 = desc;
	return _t1;
}

sokol__gfx__ShaderDesc* C__sg_shader_desc_set_vert_image(struct sg_shader_desc* desc, int index, string name) {
	desc->vs.images[v_fixed_index(index, 12)].name = ((char*)(name.str));
	desc->vs.images[v_fixed_index(index, 12)].image_type = sokol__gfx__ImageType___2d;
	sokol__gfx__ShaderDesc* _t1 = desc;
	return _t1;
}

sokol__gfx__ShaderDesc* C__sg_shader_desc_set_frag_image(struct sg_shader_desc* desc, int index, string name) {
	desc->fs.images[v_fixed_index(index, 12)].name = ((char*)(name.str));
	desc->fs.images[v_fixed_index(index, 12)].image_type = sokol__gfx__ImageType___2d;
	sokol__gfx__ShaderDesc* _t1 = desc;
	return _t1;
}

sokol__gfx__ShaderDesc* C__sg_shader_desc_set_vert_uniform_block_size(struct sg_shader_desc* desc, int block_index, usize size) {
	desc->vs.uniform_blocks[v_fixed_index(block_index, 4)].size = size;
	sokol__gfx__ShaderDesc* _t1 = desc;
	return _t1;
}

sokol__gfx__ShaderDesc* C__sg_shader_desc_set_frag_uniform_block_size(struct sg_shader_desc* desc, int block_index, usize size) {
	desc->fs.uniform_blocks[v_fixed_index(block_index, 4)].size = size;
	sokol__gfx__ShaderDesc* _t1 = desc;
	return _t1;
}

sokol__gfx__ShaderDesc* C__sg_shader_desc_set_vert_uniform(struct sg_shader_desc* desc, int block_index, int uniform_index, string name, sokol__gfx__UniformType type, int array_count) {
	desc->vs.uniform_blocks[v_fixed_index(block_index, 4)].uniforms[v_fixed_index(uniform_index, 16)].name = ((char*)(name.str));
	desc->vs.uniform_blocks[v_fixed_index(block_index, 4)].uniforms[v_fixed_index(uniform_index, 16)].type = type;
	sokol__gfx__ShaderDesc* _t1 = desc;
	return _t1;
}

sokol__gfx__ShaderDesc* C__sg_shader_desc_set_frag_uniform(struct sg_shader_desc* desc, int block_index, int uniform_index, string name, sokol__gfx__UniformType type, int array_count) {
	desc->fs.uniform_blocks[v_fixed_index(block_index, 4)].uniforms[v_fixed_index(uniform_index, 16)].name = ((char*)(name.str));
	desc->fs.uniform_blocks[v_fixed_index(block_index, 4)].uniforms[v_fixed_index(uniform_index, 16)].type = type;
	sokol__gfx__ShaderDesc* _t1 = desc;
	return _t1;
}

sokol__gfx__Shader sokol__gfx__ShaderDesc_make_shader(sokol__gfx__ShaderDesc* desc) {
	sokol__gfx__Shader _t1 = sg_make_shader(desc);
	return _t1;
}

// TypeDecl
// TypeDecl
sokol__gfx__ShaderStageDesc sokol__gfx__ShaderStageDesc_set_image(sokol__gfx__ShaderStageDesc* desc, int index, string name) {
	desc->images[v_fixed_index(index, 12)].name = ((char*)(name.str));
	desc->images[v_fixed_index(index, 12)].image_type = sokol__gfx__ImageType___2d;
	sokol__gfx__ShaderStageDesc _t1 = *desc;
	return _t1;
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
void sokol__gfx__Shader_free(sokol__gfx__Shader* s) {
	sg_destroy_shader(*s);
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
void sokol__gfx__Pass_free(sokol__gfx__Pass* p) {
	sg_destroy_pass(*p);
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
void sokol__gfx__Buffer_free(sokol__gfx__Buffer* b) {
	sg_destroy_buffer(*b);
}

// TypeDecl
// TypeDecl
// TypeDecl
void sokol__gfx__Image_free(sokol__gfx__Image* i) {
	sg_destroy_image(*i);
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
sokol__gfx__PassAction sokol__gfx__create_clear_pass(f32 r, f32 g, f32 b, f32 a) {
	sokol__gfx__ColorAttachmentAction color_action = ((sokol__gfx__ColorAttachmentAction){.action = ((sokol__gfx__Action)(SG_ACTION_CLEAR)),.value = ((sokol__gfx__Color){.r = r,.g = g,.b = b,.a = a,}),});
	sokol__gfx__PassAction pass_action = ((sokol__gfx__PassAction){._start_canary = 0,.colors = {0},.depth = {0},.stencil = {0},._end_canary = 0,});
	pass_action.colors[0] = color_action;
	sokol__gfx__PassAction _t1 = pass_action;
	return _t1;
}

// Attr: [inline]
inline void sokol__sgl__setup(sokol__sgl__Desc* desc) {
	sgl_setup(desc);
}

// Attr: [inline]
inline void sokol__sgl__shutdown(void) {
	sgl_shutdown();
}

// Attr: [inline]
inline sokol__sgl__SglError sokol__sgl__error(void) {
	sokol__sgl__SglError _t1 = ((sokol__sgl__SglError)(((int)(sgl_error()))));
	return _t1;
}

// Attr: [inline]
inline sokol__sgl__SglError sokol__sgl__context_error(sokol__sgl__Context ctx) {
	sokol__sgl__SglError _t1 = ((sokol__sgl__SglError)(((int)(sgl_context_error(ctx)))));
	return _t1;
}

// Attr: [inline]
inline f32 sokol__sgl__rad(f32 deg) {
	f32 _t1 = sgl_rad(deg);
	return _t1;
}

// Attr: [inline]
inline f32 sokol__sgl__deg(f32 rad) {
	f32 _t1 = sgl_deg(rad);
	return _t1;
}

// Attr: [inline]
inline sokol__sgl__Context sokol__sgl__make_context(sokol__sgl__ContextDesc* desc) {
	sokol__sgl__Context _t1 = sgl_make_context(desc);
	return _t1;
}

// Attr: [inline]
inline void sokol__sgl__destroy_context(sokol__sgl__Context ctx) {
	sgl_destroy_context(ctx);
}

// Attr: [inline]
inline void sokol__sgl__set_context(sokol__sgl__Context ctx) {
	sgl_set_context(ctx);
}

// Attr: [inline]
inline sokol__sgl__Context sokol__sgl__get_context(void) {
	sokol__sgl__Context _t1 = sgl_get_context();
	return _t1;
}

// Attr: [inline]
inline sokol__sgl__Context sokol__sgl__default_context(void) {
	sokol__sgl__Context _t1 = sgl_default_context();
	return _t1;
}

// Attr: [inline]
inline sokol__sgl__Pipeline sokol__sgl__make_pipeline(sokol__gfx__PipelineDesc* desc) {
	sokol__sgl__Pipeline _t1 = sgl_make_pipeline(desc);
	return _t1;
}

// Attr: [inline]
inline sokol__sgl__Pipeline sokol__sgl__context_make_pipeline(sokol__sgl__Context ctx, sokol__gfx__PipelineDesc* desc) {
	sokol__sgl__Pipeline _t1 = sgl_context_make_pipeline(ctx, desc);
	return _t1;
}

// Attr: [inline]
inline void sokol__sgl__destroy_pipeline(sokol__sgl__Pipeline pip) {
	sgl_destroy_pipeline(pip);
}

// Attr: [inline]
inline void sokol__sgl__defaults(void) {
	sgl_defaults();
}

// Attr: [inline]
inline void sokol__sgl__viewport(int x, int y, int w, int h, bool origin_top_left) {
	sgl_viewport(x, y, w, h, origin_top_left);
}

// Attr: [inline]
inline void sokol__sgl__scissor_rect(int x, int y, int w, int h, bool origin_top_left) {
	sgl_scissor_rect(x, y, w, h, origin_top_left);
}

// Attr: [inline]
inline void sokol__sgl__enable_texture(void) {
	sgl_enable_texture();
}

// Attr: [inline]
inline void sokol__sgl__disable_texture(void) {
	sgl_disable_texture();
}

// Attr: [inline]
inline void sokol__sgl__texture(sokol__gfx__Image img) {
	sgl_texture(img);
}

// Attr: [inline]
inline void sokol__sgl__load_default_pipeline(void) {
	sgl_load_default_pipeline();
}

// Attr: [inline]
inline void sokol__sgl__default_pipeline(void) {
	sgl_load_default_pipeline();
}

// Attr: [inline]
inline void sokol__sgl__load_pipeline(sokol__sgl__Pipeline pip) {
	sgl_load_pipeline(pip);
}

// Attr: [inline]
inline void sokol__sgl__push_pipeline(void) {
	sgl_push_pipeline();
}

// Attr: [inline]
inline void sokol__sgl__pop_pipeline(void) {
	sgl_pop_pipeline();
}

// Attr: [inline]
inline void sokol__sgl__matrix_mode_modelview(void) {
	sgl_matrix_mode_modelview();
}

// Attr: [inline]
inline void sokol__sgl__matrix_mode_projection(void) {
	sgl_matrix_mode_projection();
}

// Attr: [inline]
inline void sokol__sgl__matrix_mode_texture(void) {
	sgl_matrix_mode_texture();
}

// Attr: [inline]
inline void sokol__sgl__load_identity(void) {
	sgl_load_identity();
}

// Attr: [inline]
inline void sokol__sgl__load_matrix(Array_f32 m) {
	sgl_load_matrix(m.data);
}

// Attr: [inline]
inline void sokol__sgl__load_transpose_matrix(Array_f32 m) {
	sgl_load_transpose_matrix(m.data);
}

// Attr: [inline]
inline void sokol__sgl__mult_matrix(Array_f32 m) {
	sgl_mult_matrix(m.data);
}

// Attr: [inline]
inline void sokol__sgl__mult_transpose_matrix(Array_f32 m) {
	sgl_mult_transpose_matrix(m.data);
}

// Attr: [inline]
inline void sokol__sgl__rotate(f32 angle_rad, f32 x, f32 y, f32 z) {
	sgl_rotate(angle_rad, x, y, z);
}

// Attr: [inline]
inline void sokol__sgl__scale(f32 x, f32 y, f32 z) {
	sgl_scale(x, y, z);
}

// Attr: [inline]
inline void sokol__sgl__translate(f32 x, f32 y, f32 z) {
	sgl_translate(x, y, z);
}

// Attr: [inline]
inline void sokol__sgl__frustum(f32 l, f32 r, f32 b, f32 t, f32 n, f32 f) {
	sgl_frustum(l, r, b, t, n, f);
}

// Attr: [inline]
inline void sokol__sgl__ortho(f32 l, f32 r, f32 b, f32 t, f32 n, f32 f) {
	sgl_ortho(l, r, b, t, n, f);
}

// Attr: [inline]
inline void sokol__sgl__perspective(f32 fov_y, f32 aspect, f32 z_near, f32 z_far) {
	sgl_perspective(fov_y, aspect, z_near, z_far);
}

// Attr: [inline]
inline void sokol__sgl__lookat(f32 eye_x, f32 eye_y, f32 eye_z, f32 center_x, f32 center_y, f32 center_z, f32 up_x, f32 up_y, f32 up_z) {
	sgl_lookat(eye_x, eye_y, eye_z, center_x, center_y, center_z, up_x, up_y, up_z);
}

// Attr: [inline]
inline void sokol__sgl__push_matrix(void) {
	sgl_push_matrix();
}

// Attr: [inline]
inline void sokol__sgl__pop_matrix(void) {
	sgl_pop_matrix();
}

// Attr: [inline]
inline void sokol__sgl__t2f(f32 u, f32 v) {
	sgl_t2f(u, v);
}

// Attr: [inline]
inline void sokol__sgl__c3f(f32 r, f32 g, f32 b) {
	sgl_c3f(r, g, b);
}

// Attr: [inline]
inline void sokol__sgl__c4f(f32 r, f32 g, f32 b, f32 a) {
	sgl_c4f(r, g, b, a);
}

// Attr: [inline]
inline void sokol__sgl__c3b(u8 r, u8 g, u8 b) {
	sgl_c3b(r, g, b);
}

// Attr: [inline]
inline void sokol__sgl__c4b(u8 r, u8 g, u8 b, u8 a) {
	sgl_c4b(r, g, b, a);
}

// Attr: [inline]
inline void sokol__sgl__c1i(u32 rgba) {
	sgl_c1i(rgba);
}

// Attr: [inline]
inline void sokol__sgl__point_size(f32 s) {
	sgl_point_size(s);
}

// Attr: [inline]
inline void sokol__sgl__begin_points(void) {
	sgl_begin_points();
}

// Attr: [inline]
inline void sokol__sgl__begin_lines(void) {
	sgl_begin_lines();
}

// Attr: [inline]
inline void sokol__sgl__begin_line_strip(void) {
	sgl_begin_line_strip();
}

// Attr: [inline]
inline void sokol__sgl__begin_triangles(void) {
	sgl_begin_triangles();
}

// Attr: [inline]
inline void sokol__sgl__begin_triangle_strip(void) {
	sgl_begin_triangle_strip();
}

// Attr: [inline]
inline void sokol__sgl__begin_quads(void) {
	sgl_begin_quads();
}

// Attr: [inline]
inline void sokol__sgl__v2f(f32 x, f32 y) {
	sgl_v2f(x, y);
}

// Attr: [inline]
inline void sokol__sgl__v3f(f32 x, f32 y, f32 z) {
	sgl_v3f(x, y, z);
}

// Attr: [inline]
inline void sokol__sgl__v2f_t2f(f32 x, f32 y, f32 u, f32 v) {
	sgl_v2f_t2f(x, y, u, v);
}

// Attr: [inline]
inline void sokol__sgl__v3f_t2f(f32 x, f32 y, f32 z, f32 u, f32 v) {
	sgl_v3f_t2f(x, y, z, u, v);
}

// Attr: [inline]
inline void sokol__sgl__v2f_c3f(f32 x, f32 y, f32 r, f32 g, f32 b) {
	sgl_v2f_c3f(x, y, r, g, b);
}

// Attr: [inline]
inline void sokol__sgl__v2f_c3b(f32 x, f32 y, u8 r, u8 g, u8 b) {
	sgl_v2f_c3b(x, y, r, g, b);
}

// Attr: [inline]
inline void sokol__sgl__v2f_c4f(f32 x, f32 y, f32 r, f32 g, f32 b, f32 a) {
	sgl_v2f_c4f(x, y, r, g, b, a);
}

// Attr: [inline]
inline void sokol__sgl__v2f_c4b(f32 x, f32 y, u8 r, u8 g, u8 b, u8 a) {
	sgl_v2f_c4b(x, y, r, g, b, a);
}

// Attr: [inline]
inline void sokol__sgl__v2f_c1i(f32 x, f32 y, u32 rgba) {
	sgl_v2f_c1i(x, y, rgba);
}

// Attr: [inline]
inline void sokol__sgl__v3f_c3f(f32 x, f32 y, f32 z, f32 r, f32 g, f32 b) {
	sgl_v3f_c3f(x, y, z, r, g, b);
}

// Attr: [inline]
inline void sokol__sgl__v3f_c3b(f32 x, f32 y, f32 z, u8 r, u8 g, u8 b) {
	sgl_v3f_c3b(x, y, z, r, g, b);
}

// Attr: [inline]
inline void sokol__sgl__v3f_c4f(f32 x, f32 y, f32 z, f32 r, f32 g, f32 b, f32 a) {
	sgl_v3f_c4f(x, y, z, r, g, b, a);
}

// Attr: [inline]
inline void sokol__sgl__v3f_c4b(f32 x, f32 y, f32 z, u8 r, u8 g, u8 b, u8 a) {
	sgl_v3f_c4b(x, y, z, r, g, b, a);
}

// Attr: [inline]
inline void sokol__sgl__v3f_c1i(f32 x, f32 y, f32 z, u32 rgba) {
	sgl_v3f_c1i(x, y, z, rgba);
}

// Attr: [inline]
inline void sokol__sgl__v2f_t2f_c3f(f32 x, f32 y, f32 u, f32 v, f32 r, f32 g, f32 b) {
	sgl_v2f_t2f_c3f(x, y, u, v, r, g, b);
}

// Attr: [inline]
inline void sokol__sgl__v2f_t2f_c3b(f32 x, f32 y, f32 u, f32 v, u8 r, u8 g, u8 b) {
	sgl_v2f_t2f_c3b(x, y, u, v, r, g, b);
}

// Attr: [inline]
inline void sokol__sgl__v2f_t2f_c4f(f32 x, f32 y, f32 u, f32 v, f32 r, f32 g, f32 b, f32 a) {
	sgl_v2f_t2f_c4f(x, y, u, v, r, g, b, a);
}

// Attr: [inline]
inline void sokol__sgl__v2f_t2f_c4b(f32 x, f32 y, f32 u, f32 v, u8 r, u8 g, u8 b, u8 a) {
	sgl_v2f_t2f_c4b(x, y, u, v, r, g, b, a);
}

// Attr: [inline]
inline void sokol__sgl__v2f_t2f_c1i(f32 x, f32 y, f32 u, f32 v, u32 rgba) {
	sgl_v2f_t2f_c1i(x, y, u, v, rgba);
}

// Attr: [inline]
inline void sokol__sgl__v3f_t2f_c3f(f32 x, f32 y, f32 z, f32 u, f32 v, f32 r, f32 g, f32 b) {
	sgl_v3f_t2f_c3f(x, y, z, u, v, r, g, b);
}

// Attr: [inline]
inline void sokol__sgl__v3f_t2f_c3b(f32 x, f32 y, f32 z, f32 u, f32 v, u8 r, u8 g, u8 b) {
	sgl_v3f_t2f_c3b(x, y, z, u, v, r, g, b);
}

// Attr: [inline]
inline void sokol__sgl__v3f_t2f_c4f(f32 x, f32 y, f32 z, f32 u, f32 v, f32 r, f32 g, f32 b, f32 a) {
	sgl_v3f_t2f_c4f(x, y, z, u, v, r, g, b, a);
}

// Attr: [inline]
inline void sokol__sgl__v3f_t2f_c4b(f32 x, f32 y, f32 z, f32 u, f32 v, u8 r, u8 g, u8 b, u8 a) {
	sgl_v3f_t2f_c4b(x, y, z, u, v, r, g, b, a);
}

// Attr: [inline]
inline void sokol__sgl__v3f_t2f_c1i(f32 x, f32 y, f32 z, f32 u, f32 v, u32 rgba) {
	sgl_v3f_t2f_c1i(x, y, z, u, v, rgba);
}

// Attr: [inline]
inline void sokol__sgl__end(void) {
	sgl_end();
}

// Attr: [inline]
inline void sokol__sgl__draw(void) {
	sgl_draw();
}

// Attr: [inline]
inline void sokol__sgl__context_draw(sokol__sgl__Context ctx) {
	sgl_context_draw(ctx);
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
sokol__gfx__Desc sokol__sapp__create_desc(void) {
	sokol__gfx__MetalContextDesc metal_desc = ((sokol__gfx__MetalContextDesc){.device = sokol__sapp__metal_get_device(),.renderpass_descriptor_cb = (voidptr)sokol__sapp__metal_get_renderpass_descriptor,.drawable_cb = (voidptr)sokol__sapp__metal_get_drawable,});
	sokol__gfx__D3D11ContextDesc d3d11_desc = ((sokol__gfx__D3D11ContextDesc){.device = sokol__sapp__d3d11_get_device(),.device_context = sokol__sapp__d3d11_get_device_context(),.render_target_view_cb = (voidptr)sokol__sapp__d3d11_get_render_target_view,.depth_stencil_view_cb = (voidptr)sokol__sapp__d3d11_get_depth_stencil_view,});
	sokol__gfx__Desc _t1 = ((sokol__gfx__Desc){._start_canary = 0,.buffer_pool_size = 0,.image_pool_size = 1000,.shader_pool_size = 0,.pipeline_pool_size = 0,.pass_pool_size = 0,.context_pool_size = 0,.context = ((sokol__gfx__ContextDesc){.color_format = sokol__gfx__PixelFormat__bgra8,.depth_format = 0,.sample_count = 0,.gl = {0},.metal = metal_desc,.d3d11 = d3d11_desc,}),._end_canary = 0,});
	return _t1;
}

// Attr: [inline]
inline bool sokol__sapp__isvalid(void) {
	bool _t1 = sapp_isvalid();
	return _t1;
}

// Attr: [inline]
inline int sokol__sapp__width(void) {
	int _t1 = sapp_width();
	return _t1;
}

// Attr: [inline]
inline int sokol__sapp__height(void) {
	int _t1 = sapp_height();
	return _t1;
}

// Attr: [inline]
inline int sokol__sapp__color_format(void) {
	int _t1 = sapp_color_format();
	return _t1;
}

// Attr: [inline]
inline int sokol__sapp__depth_format(void) {
	int _t1 = sapp_depth_format();
	return _t1;
}

// Attr: [inline]
inline int sokol__sapp__sample_count(void) {
	int _t1 = sapp_sample_count();
	return _t1;
}

// Attr: [inline]
inline bool sokol__sapp__high_dpi(void) {
	bool _t1 = sapp_high_dpi();
	return _t1;
}

// Attr: [inline]
inline f32 sokol__sapp__dpi_scale(void) {
	f32 _t1 = sapp_dpi_scale();
	return _t1;
}

// Attr: [inline]
inline void sokol__sapp__show_keyboard(bool visible) {
	sapp_show_keyboard(visible);
}

// Attr: [inline]
inline bool sokol__sapp__keyboard_shown(void) {
	bool _t1 = sapp_keyboard_shown();
	return _t1;
}

// Attr: [inline]
inline void sokol__sapp__show_mouse(bool visible) {
	sapp_show_mouse(visible);
}

// Attr: [inline]
inline bool sokol__sapp__mouse_shown(void) {
	bool _t1 = sapp_mouse_shown();
	return _t1;
}

// Attr: [inline]
inline void sokol__sapp__lock_mouse(bool locked) {
	sapp_lock_mouse(locked);
}

// Attr: [inline]
inline bool sokol__sapp__mouse_locked(void) {
	bool _t1 = sapp_mouse_locked();
	return _t1;
}

// Attr: [inline]
inline voidptr sokol__sapp__userdata(void) {
	voidptr _t1 = sapp_userdata();
	return _t1;
}

// Attr: [inline]
inline sokol__sapp__Desc sokol__sapp__query_desc(void) {
	sokol__sapp__Desc _t1 = sapp_query_desc();
	return _t1;
}

// Attr: [inline]
inline void sokol__sapp__request_quit(void) {
	sapp_request_quit();
}

// Attr: [inline]
inline void sokol__sapp__cancel_quit(void) {
	sapp_cancel_quit();
}

// Attr: [inline]
inline void sokol__sapp__quit(void) {
	sapp_quit();
}

// Attr: [inline]
inline void sokol__sapp__consume_event(void) {
	sapp_consume_event();
}

// Attr: [inline]
inline u64 sokol__sapp__frame_count(void) {
	u64 _t1 = sapp_frame_count();
	return _t1;
}

// Attr: [inline]
inline f64 sokol__sapp__frame_duration(void) {
	f64 _t1 = sapp_frame_duration();
	return _t1;
}

// Attr: [inline]
inline void sokol__sapp__set_clipboard_string(u8* str) {
	sapp_set_clipboard_string(str);
}

// Attr: [inline]
inline char* sokol__sapp__get_clipboard_string(void) {
	char* _t1 = ((char*)(sapp_get_clipboard_string()));
	return _t1;
}

// Attr: [inline]
inline void sokol__sapp__run(sokol__sapp__Desc* desc) {
	g_desc = *desc;
	sapp_run(desc);
}

// Attr: [inline]
inline bool sokol__sapp__gles2(void) {
	bool _t1 = sapp_gles2();
	return _t1;
}

// Attr: [inline]
inline void sokol__sapp__html5_ask_leave_site(bool ask) {
	sapp_html5_ask_leave_site(ask);
}

// Attr: [inline]
inline voidptr sokol__sapp__metal_get_device(void) {
	voidptr _t1 = ((voidptr)(sapp_metal_get_device()));
	return _t1;
}

// Attr: [inline]
inline voidptr sokol__sapp__metal_get_renderpass_descriptor(void) {
	voidptr _t1 = ((voidptr)(sapp_metal_get_renderpass_descriptor()));
	return _t1;
}

// Attr: [inline]
inline voidptr sokol__sapp__metal_get_drawable(void) {
	voidptr _t1 = ((voidptr)(sapp_metal_get_drawable()));
	return _t1;
}

// Attr: [inline]
inline voidptr sokol__sapp__macos_get_window(void) {
	voidptr _t1 = ((voidptr)(sapp_macos_get_window()));
	return _t1;
}

// Attr: [inline]
inline voidptr sokol__sapp__ios_get_window(void) {
	voidptr _t1 = ((voidptr)(sapp_ios_get_window()));
	return _t1;
}

// Attr: [inline]
inline voidptr sokol__sapp__d3d11_get_device(void) {
	voidptr _t1 = ((voidptr)(sapp_d3d11_get_device()));
	return _t1;
}

// Attr: [inline]
inline voidptr sokol__sapp__d3d11_get_device_context(void) {
	voidptr _t1 = ((voidptr)(sapp_d3d11_get_device_context()));
	return _t1;
}

// Attr: [inline]
inline voidptr sokol__sapp__d3d11_get_render_target_view(void) {
	voidptr _t1 = ((voidptr)(sapp_d3d11_get_render_target_view()));
	return _t1;
}

// Attr: [inline]
inline voidptr sokol__sapp__d3d11_get_depth_stencil_view(void) {
	voidptr _t1 = ((voidptr)(sapp_d3d11_get_depth_stencil_view()));
	return _t1;
}

// Attr: [inline]
inline voidptr sokol__sapp__win32_get_hwnd(void) {
	voidptr _t1 = ((voidptr)(sapp_win32_get_hwnd()));
	return _t1;
}

// Attr: [inline]
inline voidptr sokol__sapp__android_get_native_activity(void) {
	voidptr _t1 = ((voidptr)(sapp_android_get_native_activity()));
	return _t1;
}

// Attr: [inline]
inline void sokol__sapp__toggle_fullscreen(void) {
	sapp_toggle_fullscreen();
}

// Attr: [inline]
inline bool sokol__sapp__is_fullscreen(void) {
	bool _t1 = sapp_is_fullscreen();
	return _t1;
}

// Attr: [inline]
inline int sokol__sapp__get_num_dropped_files(void) {
	int _t1 = sapp_get_num_dropped_files();
	return _t1;
}

// Attr: [inline]
inline string sokol__sapp__get_dropped_file_path(int index) {
	{ // Unsafe block
		string _t1 = cstring_to_vstring(sapp_get_dropped_file_path(index));
		return _t1;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
string C__sapp_event_str(struct sapp_event* e) {
	sokol__sapp__EventType t = e->type;
	string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("evt: frame_count="), 0xfe08, {.d_u64 = e->frame_count}}, {_SLIT(", type="), 0xfe10, {.d_s = sokol__sapp__EventType_str(t)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

// TypeDecl
Option_void sokol__sapp__screenshot(string path) {
	string _t1 = os__file_ext(path);
	
	if (string__eq(_t1, _SLIT(".png"))) {
		Option_void _t2 = sokol__sapp__screenshot_png(path);
		return _t2;
	}
	else if (string__eq(_t1, _SLIT(".ppm"))) {
		Option_void _t3 = sokol__sapp__screenshot_ppm(path);
		return _t3;
	}
	else {
		return (Option_void){ .state=2, .err=_v_error(string__plus(string__plus(string__plus(_SLIT("sokol.sapp"), _SLIT(".")), _SLIT("screenshot")), _SLIT(" currently only supports .png and .ppm files."))), .data={EMPTY_STRUCT_INITIALIZATION} };
	};
	return (Option_void){0};
}

// Attr: [manualfree]
Option_void sokol__sapp__screenshot_ppm(string path) {
	sokol__sapp__Screenshot* ss = sokol__sapp__screenshot_window();
	Option_void _t1 = sokol__sapp__write_rgba_to_ppm(path, ss->width, ss->height, 4, ss->pixels);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		Option_void _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 ;
	sokol__sapp__Screenshot_destroy(ss);
	return (Option_void){0};
}

// Attr: [manualfree]
Option_void sokol__sapp__screenshot_png(string path) {
	sokol__sapp__Screenshot* ss = sokol__sapp__screenshot_window();
	stbi__set_flip_vertically_on_write(true);
	Option_void _t1 = stbi__stbi_write_png(path, ss->width, ss->height, 4, ss->pixels, ss->width * 4);
	if (_t1.state != 0 && _t1.err._typ != _IError_None___index) {
		Option_void _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 ;
	sokol__sapp__Screenshot_destroy(ss);
	return (Option_void){0};
}

Option_void sokol__sapp__write_rgba_to_ppm(string path, int w, int h, int components, u8* pixels) {
bool sokol__sapp__write_rgba_to_ppm_defer_0 = false;
os__File f_out;
	Option_os__File _t1 = os__create(path);
	if (_t1.state != 0) { /*or block*/ 
		Option_void _t2;
		memcpy(&_t2, &_t1, sizeof(Option));
		return _t2;
	}
	
 	f_out =  (*(os__File*)_t1.data);
	sokol__sapp__write_rgba_to_ppm_defer_0 = true;
	Option_int _t3 = os__File_writeln(&f_out, _SLIT("P3"));
	if (_t3.state != 0) { /*or block*/ 
	// Defer begin
	if (sokol__sapp__write_rgba_to_ppm_defer_0) {
		os__File_close(&f_out);
	}
	// Defer end
		Option_void _t4;
		memcpy(&_t4, &_t3, sizeof(Option));
		return _t4;
	}
	
  (*(int*)_t3.data);
	Option_int _t5 = os__File_writeln(&f_out,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = w}}, {_SLIT(" "), 0xfe07, {.d_i32 = h}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if (_t5.state != 0) { /*or block*/ 
	// Defer begin
	if (sokol__sapp__write_rgba_to_ppm_defer_0) {
		os__File_close(&f_out);
	}
	// Defer end
		Option_void _t6;
		memcpy(&_t6, &_t5, sizeof(Option));
		return _t6;
	}
	
  (*(int*)_t5.data);
	Option_int _t7 = os__File_writeln(&f_out, _SLIT("255"));
	if (_t7.state != 0) { /*or block*/ 
	// Defer begin
	if (sokol__sapp__write_rgba_to_ppm_defer_0) {
		os__File_close(&f_out);
	}
	// Defer end
		Option_void _t8;
		memcpy(&_t8, &_t7, sizeof(Option));
		return _t8;
	}
	
  (*(int*)_t7.data);
	for (int i = h - 1; i >= 0; i--) {
		for (int j = 0; j < w; j++) {
			int idx = i * w * components + j * components;
			{ // Unsafe block
				int r = ((int)(pixels[idx]));
				int g = ((int)(pixels[idx + 1]));
				int b = ((int)(pixels[idx + 2]));
				Option_int _t9 = os__File_write_string(&f_out,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = r}}, {_SLIT(" "), 0xfe07, {.d_i32 = g}}, {_SLIT(" "), 0xfe07, {.d_i32 = b}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
				if (_t9.state != 0) { /*or block*/ 
				// Defer begin
				if (sokol__sapp__write_rgba_to_ppm_defer_0) {
					os__File_close(&f_out);
				}
				// Defer end
					Option_void _t10;
					memcpy(&_t10, &_t9, sizeof(Option));
					return _t10;
				}
				
  (*(int*)_t9.data);
			}
		}
	}
	// Defer begin
	if (sokol__sapp__write_rgba_to_ppm_defer_0) {
		os__File_close(&f_out);
	}
	// Defer end
	return (Option_void){0};
}

// Attr: [manualfree]
sokol__sapp__Screenshot* sokol__sapp__screenshot_window(void) {
	int img_width = sokol__sapp__width();
	int img_height = sokol__sapp__height();
	int img_size = img_width * img_height * 4;
	u8* img_pixels = ((u8*)(_v_malloc(img_size)));
	v_sapp_gl_read_rgba_pixels(0, 0, img_width, img_height, img_pixels);
	sokol__sapp__Screenshot* _t1 = ((sokol__sapp__Screenshot*)memdup(&(sokol__sapp__Screenshot){.width = img_width,.height = img_height,.size = img_size,.pixels = img_pixels,}, sizeof(sokol__sapp__Screenshot)));
	return _t1;
}

// Attr: [unsafe]
void sokol__sapp__Screenshot_free(sokol__sapp__Screenshot* ss) {
	{ // Unsafe block
		_v_free(ss->pixels);
		ss->pixels = ((u8*)(0));
	}
}

// Attr: [unsafe]
void sokol__sapp__Screenshot_destroy(sokol__sapp__Screenshot* ss) {
	sokol__sapp__Screenshot_free(ss);
	_v_free(ss);
}

// Attr: [inline]
inline fontstash__Context* sokol__sfons__create(int width, int height, int flags) {
	fontstash__Context* _t1 = sfons_create(width, height, flags);
	return _t1;
}

// Attr: [inline]
inline void sokol__sfons__destroy(fontstash__Context* ctx) {
	sfons_destroy(ctx);
}

// Attr: [inline]
inline u32 sokol__sfons__rgba(u8 r, u8 g, u8 b, u8 a) {
	u32 _t1 = sfons_rgba(r, g, b, a);
	return _t1;
}

// Attr: [inline]
inline void sokol__sfons__flush(fontstash__Context* ctx) {
	sfons_flush(ctx);
}

// Attr: [inline]
inline void gg__Context_draw_pixel(gg__Context* ctx, f32 x, f32 y, gx__Color c) {
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_points();
	sokol__sgl__v2f(x * ctx->scale, y * ctx->scale);
	sokol__sgl__end();
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void gg__Context_draw_pixels(gg__Context* ctx, Array_f32 points, gx__Color c) {
	// assert
	if (!(points.len % 2 == 0)) {
		VAssertMetaInfo v_assert_meta_info__t1 = {0};
		v_assert_meta_info__t1.fpath = _SLIT("/Users/rcqls/vlang/v/vlib/gg/draw.c.v");
		v_assert_meta_info__t1.line_nr = 33;
		v_assert_meta_info__t1.fn_name = _SLIT("draw_pixels");
		v_assert_meta_info__t1.src = _SLIT("points.len % 2 == 0");
		v_assert_meta_info__t1.op = _SLIT("==");
		v_assert_meta_info__t1.llabel = _SLIT("points.len % 2");
		v_assert_meta_info__t1.rlabel = _SLIT("0");
		v_assert_meta_info__t1.lvalue = string_clone(int_str(points.len % 2)) /* typeof: v.ast.InfixExpr type: ast.Type(0x7 = 7) */ ;
		v_assert_meta_info__t1.rvalue = string_clone(int_str(0)) /* typeof: v.ast.IntegerLiteral type: ast.Type(0x7 = 7) */ ;
		__print_assert_failure(&v_assert_meta_info__t1);
		_v_panic(_SLIT("Assertion failed..."));
	}
	int len = points.len / 2;
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_points();
	for (int i = 0; i < len; ++i) {
		f32 x = ((f32*)points.data)[i * 2];
		f32 y = ((f32*)points.data)[i * 2 + 1];
		sokol__sgl__v2f(x * ctx->scale, y * ctx->scale);
	}
	sokol__sgl__end();
}

void gg__Context_draw_line(gg__Context* ctx, f32 x, f32 y, f32 x2, f32 y2, gx__Color c) {
	if (ctx->native_rendering) {
		f32 width = math__abs_T_f32(x2 - x);
		f32 height = math__abs_T_f32(y2 - y);
		if (width == 0) {
			width = 1;
		} else if (height == 0) {
			height = 1;
		}
		gg__Context_draw_rect_filled(ctx, x, y, ((f32)(width)), ((f32)(height)), c);
		return;
	}
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_line_strip();
	sokol__sgl__v2f(x * ctx->scale, y * ctx->scale);
	sokol__sgl__v2f(x2 * ctx->scale, y2 * ctx->scale);
	sokol__sgl__end();
}

void gg__Context_draw_line_with_config(gg__Context* ctx, f32 x, f32 y, f32 x2, f32 y2, gg__PenConfig config) {
	if (config.color.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	if (config.thickness <= 0) {
		return;
	}
	f32 nx = x * ctx->scale;
	f32 ny = y * ctx->scale;
	f32 nx2 = x2 * ctx->scale;
	f32 ny2 = y2 * ctx->scale;
	f32 dx = nx2 - nx;
	f32 dy = ny2 - ny;
	f32 length = math__sqrtf(math__powf(x2 - x, 2) + math__powf(y2 - y, 2));
	f32 theta = ((f32)(math__atan2(dy, dx)));
	sokol__sgl__push_matrix();
	sokol__sgl__translate(nx, ny, 0);
	sokol__sgl__rotate(theta, 0, 0, 1);
	sokol__sgl__translate(-nx, -ny, 0);
	if (config.line_type == gg__PenLineType__solid) {
		gg__Context_draw_rect_filled(ctx, x, y, length, config.thickness, config.color);
	} else {
		int size = (config.line_type == gg__PenLineType__dotted ? (config.thickness) : (config.thickness * 3));
		int space = (size == 1 ? (2) : (size));
		f32 available = length;
		f32 start_x = x;
		for (int i = 0; available > 0; i++) {
			if (i % 2 == 0) {
				gg__Context_draw_rect_filled(ctx, start_x, y, size, config.thickness, config.color);
				available -= size;
				start_x += size;
				continue;
			}
			available -= space;
			start_x += space;
		}
	}
	sokol__sgl__pop_matrix();
}

void gg__Context_draw_poly_empty(gg__Context* ctx, Array_f32 points, gx__Color c) {
	// assert
	if (!(points.len % 2 == 0)) {
		VAssertMetaInfo v_assert_meta_info__t1 = {0};
		v_assert_meta_info__t1.fpath = _SLIT("/Users/rcqls/vlang/v/vlib/gg/draw.c.v");
		v_assert_meta_info__t1.line_nr = 129;
		v_assert_meta_info__t1.fn_name = _SLIT("draw_poly_empty");
		v_assert_meta_info__t1.src = _SLIT("points.len % 2 == 0");
		v_assert_meta_info__t1.op = _SLIT("==");
		v_assert_meta_info__t1.llabel = _SLIT("points.len % 2");
		v_assert_meta_info__t1.rlabel = _SLIT("0");
		v_assert_meta_info__t1.lvalue = string_clone(int_str(points.len % 2)) /* typeof: v.ast.InfixExpr type: ast.Type(0x7 = 7) */ ;
		v_assert_meta_info__t1.rvalue = string_clone(int_str(0)) /* typeof: v.ast.IntegerLiteral type: ast.Type(0x7 = 7) */ ;
		__print_assert_failure(&v_assert_meta_info__t1);
		_v_panic(_SLIT("Assertion failed..."));
	}
	int len = points.len / 2;
	// assert
	if (!(len >= 3)) {
		VAssertMetaInfo v_assert_meta_info__t2 = {0};
		v_assert_meta_info__t2.fpath = _SLIT("/Users/rcqls/vlang/v/vlib/gg/draw.c.v");
		v_assert_meta_info__t2.line_nr = 131;
		v_assert_meta_info__t2.fn_name = _SLIT("draw_poly_empty");
		v_assert_meta_info__t2.src = _SLIT("len >= 3");
		v_assert_meta_info__t2.op = _SLIT(">=");
		v_assert_meta_info__t2.llabel = _SLIT("len");
		v_assert_meta_info__t2.rlabel = _SLIT("3");
		v_assert_meta_info__t2.lvalue = string_clone(int_str(len)) /* typeof: v.ast.Ident type: ast.Type(0x7 = 7) */ ;
		v_assert_meta_info__t2.rvalue = string_clone(int_str(3)) /* typeof: v.ast.IntegerLiteral type: ast.Type(0x7 = 7) */ ;
		__print_assert_failure(&v_assert_meta_info__t2);
		_v_panic(_SLIT("Assertion failed..."));
	}
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_line_strip();
	for (int i = 0; i < len; ++i) {
		sokol__sgl__v2f((*(f32*)/*ee elem_sym */array_get(points, 2 * i)) * ctx->scale, (*(f32*)/*ee elem_sym */array_get(points, 2 * i + 1)) * ctx->scale);
	}
	sokol__sgl__v2f((*(f32*)/*ee elem_sym */array_get(points, 0)) * ctx->scale, (*(f32*)/*ee elem_sym */array_get(points, 1)) * ctx->scale);
	sokol__sgl__end();
}

void gg__Context_draw_convex_poly(gg__Context* ctx, Array_f32 points, gx__Color c) {
	// assert
	if (!(points.len % 2 == 0)) {
		VAssertMetaInfo v_assert_meta_info__t1 = {0};
		v_assert_meta_info__t1.fpath = _SLIT("/Users/rcqls/vlang/v/vlib/gg/draw.c.v");
		v_assert_meta_info__t1.line_nr = 150;
		v_assert_meta_info__t1.fn_name = _SLIT("draw_convex_poly");
		v_assert_meta_info__t1.src = _SLIT("points.len % 2 == 0");
		v_assert_meta_info__t1.op = _SLIT("==");
		v_assert_meta_info__t1.llabel = _SLIT("points.len % 2");
		v_assert_meta_info__t1.rlabel = _SLIT("0");
		v_assert_meta_info__t1.lvalue = string_clone(int_str(points.len % 2)) /* typeof: v.ast.InfixExpr type: ast.Type(0x7 = 7) */ ;
		v_assert_meta_info__t1.rvalue = string_clone(int_str(0)) /* typeof: v.ast.IntegerLiteral type: ast.Type(0x7 = 7) */ ;
		__print_assert_failure(&v_assert_meta_info__t1);
		_v_panic(_SLIT("Assertion failed..."));
	}
	int len = points.len / 2;
	// assert
	if (!(len >= 3)) {
		VAssertMetaInfo v_assert_meta_info__t2 = {0};
		v_assert_meta_info__t2.fpath = _SLIT("/Users/rcqls/vlang/v/vlib/gg/draw.c.v");
		v_assert_meta_info__t2.line_nr = 152;
		v_assert_meta_info__t2.fn_name = _SLIT("draw_convex_poly");
		v_assert_meta_info__t2.src = _SLIT("len >= 3");
		v_assert_meta_info__t2.op = _SLIT(">=");
		v_assert_meta_info__t2.llabel = _SLIT("len");
		v_assert_meta_info__t2.rlabel = _SLIT("3");
		v_assert_meta_info__t2.lvalue = string_clone(int_str(len)) /* typeof: v.ast.Ident type: ast.Type(0x7 = 7) */ ;
		v_assert_meta_info__t2.rvalue = string_clone(int_str(3)) /* typeof: v.ast.IntegerLiteral type: ast.Type(0x7 = 7) */ ;
		__print_assert_failure(&v_assert_meta_info__t2);
		_v_panic(_SLIT("Assertion failed..."));
	}
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_triangle_strip();
	f32 x0 = (*(f32*)/*ee elem_sym */array_get(points, 0)) * ctx->scale;
	f32 y0 = (*(f32*)/*ee elem_sym */array_get(points, 1)) * ctx->scale;
	for (int i = 1; i < (len / 2 + 1); ++i) {
		sokol__sgl__v2f(x0, y0);
		sokol__sgl__v2f((*(f32*)/*ee elem_sym */array_get(points, i * 4 - 2)) * ctx->scale, (*(f32*)/*ee elem_sym */array_get(points, i * 4 - 1)) * ctx->scale);
		sokol__sgl__v2f((*(f32*)/*ee elem_sym */array_get(points, i * 4)) * ctx->scale, (*(f32*)/*ee elem_sym */array_get(points, i * 4 + 1)) * ctx->scale);
	}
	if (len % 2 == 0) {
		sokol__sgl__v2f((*(f32*)/*ee elem_sym */array_get(points, 2 * len - 2)) * ctx->scale, (*(f32*)/*ee elem_sym */array_get(points, 2 * len - 1)) * ctx->scale);
	}
	sokol__sgl__end();
}

void gg__Context_draw_rect_empty(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, gx__Color c) {
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_line_strip();
	sokol__sgl__v2f(x * ctx->scale, y * ctx->scale);
	sokol__sgl__v2f((x + w) * ctx->scale, y * ctx->scale);
	sokol__sgl__v2f((x + w) * ctx->scale, (y + h) * ctx->scale);
	sokol__sgl__v2f(x * ctx->scale, (y + h) * ctx->scale);
	sokol__sgl__v2f(x * ctx->scale, (y - 1) * ctx->scale);
	sokol__sgl__end();
}

void gg__Context_draw_rect_filled(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, gx__Color c) {
	if (ctx->native_rendering) {
		darwin_draw_rect(x, ctx->height - (y + h), w, h, c);
		return;
	}
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_quads();
	sokol__sgl__v2f(x * ctx->scale, y * ctx->scale);
	sokol__sgl__v2f((x + w) * ctx->scale, y * ctx->scale);
	sokol__sgl__v2f((x + w) * ctx->scale, (y + h) * ctx->scale);
	sokol__sgl__v2f(x * ctx->scale, (y + h) * ctx->scale);
	sokol__sgl__end();
}

void gg__Context_draw_rounded_rect_empty(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, f32 radius, gx__Color c) {
	f32 theta = ((f32)(0));
	f32 xx = ((f32)(0));
	f32 yy = ((f32)(0));
	f32 r = radius * ctx->scale;
	f32 nx = x * ctx->scale;
	f32 ny = y * ctx->scale;
	f32 width = w * ctx->scale;
	f32 height = h * ctx->scale;
	f32 segments = 2 * _const_math__pi * r;
	f32 segdiv = segments / 4;
	int rb = 0;
	int lb = ((int)(rb + segdiv));
	int lt = ((int)(lb + segdiv));
	int rt = ((int)(lt + segdiv));
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_line_strip();
	f32 lx = nx + r;
	f32 ly = ny + r;
	f32 theta_coeff = 2 * ((f32)(_const_math__pi)) / segments;
	for (int i = lt; i < rt; ++i) {
		theta = theta_coeff * ((f32)(i));
		xx = r * math__cosf(theta);
		yy = r * math__sinf(theta);
		sokol__sgl__v2f(xx + lx, yy + ly);
	}
	f32 rx = nx + width - r;
	f32 ry = ny + r;
	for (int i = rt; i < ((int)(segments)); ++i) {
		theta = theta_coeff * ((f32)(i));
		xx = r * math__cosf(theta);
		yy = r * math__sinf(theta);
		sokol__sgl__v2f(xx + rx, yy + ry);
	}
	f32 rbx = rx;
	f32 rby = ny + height - r;
	for (int i = rb; i < lb; ++i) {
		theta = theta_coeff * ((f32)(i));
		xx = r * math__cosf(theta);
		yy = r * math__sinf(theta);
		sokol__sgl__v2f(xx + rbx, yy + rby);
	}
	f32 lbx = lx;
	f32 lby = ny + height - r;
	for (int i = lb; i < lt; ++i) {
		theta = theta_coeff * ((f32)(i));
		xx = r * math__cosf(theta);
		yy = r * math__sinf(theta);
		sokol__sgl__v2f(xx + lbx, yy + lby);
	}
	sokol__sgl__v2f(lx + xx, ly);
	sokol__sgl__end();
}

void gg__Context_draw_rounded_rect_filled(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, f32 radius, gx__Color c) {
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_triangle_strip();
	f32 theta = ((f32)(0));
	f32 xx = ((f32)(0));
	f32 yy = ((f32)(0));
	f32 r = radius * ctx->scale;
	f32 nx = x * ctx->scale;
	f32 ny = y * ctx->scale;
	f32 width = w * ctx->scale;
	f32 height = h * ctx->scale;
	f32 segments = 2 * _const_math__pi * r;
	f32 segdiv = segments / 4;
	int rb = 0;
	int lb = ((int)(rb + segdiv));
	int lt = ((int)(lb + segdiv));
	int rt = ((int)(lt + segdiv));
	f32 lx = nx + r;
	f32 ly = ny + r;
	for (int i = lt; i < rt; ++i) {
		theta = 2 * ((f32)(_const_math__pi)) * ((f32)(i)) / segments;
		xx = r * math__cosf(theta);
		yy = r * math__sinf(theta);
		sokol__sgl__v2f(xx + lx, yy + ly);
		sokol__sgl__v2f(lx, ly);
	}
	f32 rx = nx + width - r;
	f32 ry = ny + r;
	for (int i = rt; i < ((int)(segments)); ++i) {
		theta = 2 * ((f32)(_const_math__pi)) * ((f32)(i)) / segments;
		xx = r * math__cosf(theta);
		yy = r * math__sinf(theta);
		sokol__sgl__v2f(xx + rx, yy + ry);
		sokol__sgl__v2f(rx, ry);
	}
	f32 rbx = rx;
	f32 rby = ny + height - r;
	for (int i = rb; i < lb; ++i) {
		theta = 2 * ((f32)(_const_math__pi)) * ((f32)(i)) / segments;
		xx = r * math__cosf(theta);
		yy = r * math__sinf(theta);
		sokol__sgl__v2f(xx + rbx, yy + rby);
		sokol__sgl__v2f(rbx, rby);
	}
	f32 lbx = lx;
	f32 lby = ny + height - r;
	for (int i = lb; i < lt; ++i) {
		theta = 2 * ((f32)(_const_math__pi)) * ((f32)(i)) / segments;
		xx = r * math__cosf(theta);
		yy = r * math__sinf(theta);
		sokol__sgl__v2f(xx + lbx, yy + lby);
		sokol__sgl__v2f(lbx, lby);
	}
	sokol__sgl__v2f(lx + xx, ly);
	sokol__sgl__v2f(lx, ly);
	sokol__sgl__end();
	sokol__sgl__begin_quads();
	sokol__sgl__v2f(lx, ly);
	sokol__sgl__v2f(rx, ry);
	sokol__sgl__v2f(rbx, rby);
	sokol__sgl__v2f(lbx, lby);
	sokol__sgl__end();
}

void gg__Context_draw_triangle_empty(gg__Context* ctx, f32 x, f32 y, f32 x2, f32 y2, f32 x3, f32 y3, gx__Color c) {
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_line_strip();
	sokol__sgl__v2f(x * ctx->scale, y * ctx->scale);
	sokol__sgl__v2f(x2 * ctx->scale, y2 * ctx->scale);
	sokol__sgl__v2f(x3 * ctx->scale, y3 * ctx->scale);
	sokol__sgl__v2f(x * ctx->scale, y * ctx->scale);
	sokol__sgl__end();
}

void gg__Context_draw_triangle_filled(gg__Context* ctx, f32 x, f32 y, f32 x2, f32 y2, f32 x3, f32 y3, gx__Color c) {
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_triangles();
	sokol__sgl__v2f(x * ctx->scale, y * ctx->scale);
	sokol__sgl__v2f(x2 * ctx->scale, y2 * ctx->scale);
	sokol__sgl__v2f(x3 * ctx->scale, y3 * ctx->scale);
	sokol__sgl__end();
}

// Attr: [inline]
inline void gg__Context_draw_square_empty(gg__Context* ctx, f32 x, f32 y, f32 s, gx__Color c) {
	gg__Context_draw_rect_empty(ctx, x, y, s, s, c);
}

// Attr: [inline]
inline void gg__Context_draw_square_filled(gg__Context* ctx, f32 x, f32 y, f32 s, gx__Color c) {
	gg__Context_draw_rect_filled(ctx, x, y, s, s, c);
}

// Attr: [direct_array_access]
int gg__radius_to_segments(f32 r) {
	if (r < 30.0) {
		int ir = ((int)(math__ceil(r)));
		if (ir > 0 && ir < 17) {
			int _t1 = _const_gg__small_circle_segments[ir];
			return _t1;
		}
		int _t2 = ir;
		return _t2;
	}
	int _t3 = ((int)(math__ceil(2 * _const_math__pi * r / 8)));
	return _t3;
}

void gg__Context_draw_circle_empty(gg__Context* ctx, f32 x, f32 y, f32 radius, gx__Color c) {
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	f32 nx = x * ctx->scale;
	f32 ny = y * ctx->scale;
	f32 nr = radius * ctx->scale;
	f32 theta = ((f32)(0));
	f32 xx = ((f32)(0));
	f32 yy = ((f32)(0));
	int segments = gg__radius_to_segments(radius);
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_line_strip();
	for (int i = 0; i < segments + 1; i++) {
		theta = 2.0 * ((f32)(_const_math__pi)) * ((f32)(i)) / ((f32)(segments));
		xx = nr * math__cosf(theta);
		yy = nr * math__sinf(theta);
		sokol__sgl__v2f(xx + nx, yy + ny);
	}
	sokol__sgl__end();
}

void gg__Context_draw_circle_filled(gg__Context* ctx, f32 x, f32 y, f32 radius, gx__Color c) {
	gg__Context_draw_circle_with_segments(ctx, x, y, radius, gg__radius_to_segments(radius), c);
}

void gg__Context_draw_circle_with_segments(gg__Context* ctx, f32 x, f32 y, f32 radius, int segments, gx__Color c) {
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	f32 nx = x * ctx->scale;
	f32 ny = y * ctx->scale;
	f32 nr = radius * ctx->scale;
	f32 theta = ((f32)(0));
	f32 xx = ((f32)(0));
	f32 yy = ((f32)(0));
	sokol__sgl__begin_triangle_strip();
	for (int i = 0; i < segments + 1; i++) {
		theta = 2.0 * ((f32)(_const_math__pi)) * ((f32)(i)) / ((f32)(segments));
		xx = nr * math__cosf(theta);
		yy = nr * math__sinf(theta);
		sokol__sgl__v2f(xx + nx, yy + ny);
		sokol__sgl__v2f(nx, ny);
	}
	sokol__sgl__end();
}

void gg__Context_draw_circle_line(gg__Context* ctx, f32 x, f32 y, int radius, int segments, gx__Color c) {
	if (ctx->native_rendering) {
		darwin_draw_circle(x - radius + 1, ctx->height - (y + radius + 3), radius, c);
		return;
	}
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	f32 nx = x * ctx->scale;
	f32 ny = y * ctx->scale;
	f32 nr = radius * ctx->scale;
	f32 theta = ((f32)(0));
	f32 xx = ((f32)(0));
	f32 yy = ((f32)(0));
	sokol__sgl__begin_line_strip();
	for (int i = 0; i < segments + 1; i++) {
		theta = 2.0 * ((f32)(_const_math__pi)) * ((f32)(i)) / ((f32)(segments));
		xx = nr * math__cosf(theta);
		yy = nr * math__sinf(theta);
		sokol__sgl__v2f(xx + nx, yy + ny);
	}
	sokol__sgl__end();
}

void gg__Context_draw_slice_empty(gg__Context* ctx, f32 x, f32 y, f32 outer_radius, f32 start_angle, f32 end_angle, int segments, gx__Color c) {
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	f32 theta = ((f32)(end_angle / ((f32)(segments))));
	f32 tan_factor = math__tanf(theta);
	f32 rad_factor = math__cosf(theta);
	f32 nx = x * ctx->scale;
	f32 ny = y * ctx->scale;
	f32 xx = outer_radius * math__cosf(start_angle);
	f32 yy = outer_radius * math__sinf(start_angle);
	sokol__sgl__begin_line_strip();
	sokol__sgl__v2f(nx, ny);
	for (int i = 0; i < segments + 1; i++) {
		sokol__sgl__v2f(xx + nx, yy + ny);
		f32 tx = -yy;
		f32 ty = xx;
		xx += tx * tan_factor;
		yy += ty * tan_factor;
		xx *= rad_factor;
		yy *= rad_factor;
	}
	sokol__sgl__v2f(nx, ny);
	sokol__sgl__end();
}

void gg__Context_draw_slice_filled(gg__Context* ctx, f32 x, f32 y, f32 radius, f32 start_angle, f32 end_angle, int segments, gx__Color c) {
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	f32 nx = x * ctx->scale;
	f32 ny = y * ctx->scale;
	f32 theta = ((f32)(end_angle / ((f32)(segments))));
	f32 tan_factor = math__tanf(theta);
	f32 rad_factor = math__cosf(theta);
	f32 xx = radius * math__cosf(start_angle);
	f32 yy = radius * math__sinf(start_angle);
	sokol__sgl__begin_triangle_strip();
	for (int i = 0; i < segments + 1; i++) {
		sokol__sgl__v2f(xx + nx, yy + ny);
		sokol__sgl__v2f(nx, ny);
		f32 tx = -yy;
		f32 ty = xx;
		xx += tx * tan_factor;
		yy += ty * tan_factor;
		xx *= rad_factor;
		yy *= rad_factor;
	}
	sokol__sgl__end();
}

void gg__Context_draw_arc_empty(gg__Context* ctx, f32 x, f32 y, f32 inner_radius, f32 thickness, f32 start_angle, f32 end_angle, int segments, gx__Color c) {
	if (start_angle == end_angle || inner_radius <= 0.0) {
		return;
	}
	f32 a1 = start_angle;
	f32 a2 = end_angle;
	if (a2 < a1) {
		f32 _var_16944 = a1;
		f32 _var_16948 = a2;
		a1 = _var_16948;
		a2 = _var_16944;
	}
	if (inner_radius <= 0.0) {
		gg__Context_draw_slice_empty(ctx, x, y, ((int)(thickness)), a1, a2, segments, c);
		return;
	}
	f32 outer_radius = inner_radius + thickness;
	f32 step_length = (a2 - a1) / ((f32)(segments));
	f32 angle = a1;
	sokol__sgl__begin_line_strip();
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	for (int _t1 = 0; _t1 < segments; ++_t1) {
		f32 msa = ((f32)(math__sin(angle)));
		f32 mca = ((f32)(math__cos(angle)));
		f32 ms = ((f32)(math__sin(angle + step_length)));
		f32 mc = ((f32)(math__cos(angle + step_length)));
		sokol__sgl__v2f(x + msa * outer_radius, y + mca * outer_radius);
		sokol__sgl__v2f(x + ms * outer_radius, y + mc * outer_radius);
		angle += step_length;
	}
	for (int _t2 = 0; _t2 < segments; ++_t2) {
		f32 msa = ((f32)(math__sin(angle)));
		f32 mca = ((f32)(math__cos(angle)));
		f32 msb = ((f32)(math__sin(angle - step_length)));
		f32 mcb = ((f32)(math__cos(angle - step_length)));
		sokol__sgl__v2f(x + msa * inner_radius, y + mca * inner_radius);
		sokol__sgl__v2f(x + msb * inner_radius, y + mcb * inner_radius);
		angle -= step_length;
	}
	f32 msa = ((f32)(math__sin(angle)));
	f32 mca = ((f32)(math__cos(angle)));
	sokol__sgl__v2f(x + msa * inner_radius, y + mca * inner_radius);
	sokol__sgl__v2f(x + msa * outer_radius, y + mca * outer_radius);
	sokol__sgl__end();
}

void gg__Context_draw_arc_filled(gg__Context* ctx, f32 x, f32 y, f32 inner_radius, f32 thickness, f32 start_angle, f32 end_angle, int segments, gx__Color c) {
	if (start_angle == end_angle || inner_radius <= 0.0) {
		return;
	}
	f32 a1 = start_angle;
	f32 a2 = end_angle;
	if (a2 < a1) {
		f32 _var_18855 = a1;
		f32 _var_18859 = a2;
		a1 = _var_18859;
		a2 = _var_18855;
	}
	if (inner_radius <= 0.0) {
		gg__Context_draw_slice_filled(ctx, x, y, ((int)(thickness)), a1, a2, segments, c);
	}
	f32 outer_radius = inner_radius + thickness;
	f32 step_length = (a2 - a1) / ((f32)(segments));
	f32 angle = a1;
	sokol__sgl__begin_quads();
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	for (int _t1 = 0; _t1 < segments; ++_t1) {
		f32 msa = ((f32)(math__sin(angle)));
		f32 mca = ((f32)(math__cos(angle)));
		sokol__sgl__v2f(x + msa * inner_radius, y + mca * inner_radius);
		sokol__sgl__v2f(x + msa * outer_radius, y + mca * outer_radius);
		f32 ms = ((f32)(math__sin(angle + step_length)));
		f32 mc = ((f32)(math__cos(angle + step_length)));
		sokol__sgl__v2f(x + ms * outer_radius, y + mc * outer_radius);
		sokol__sgl__v2f(x + ms * inner_radius, y + mc * inner_radius);
		angle += step_length;
	}
	sokol__sgl__end();
}

void gg__Context_draw_ellipse_empty(gg__Context* ctx, f32 x, f32 y, f32 rw, f32 rh, gx__Color c) {
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_line_strip();
	for (int i = 0; i < 360; i += 10) {
		sokol__sgl__v2f(x + math__sinf(((f32)(math__radians(i)))) * rw, y + math__cosf(((f32)(math__radians(i)))) * rh);
		sokol__sgl__v2f(x + math__sinf(((f32)(math__radians(i + 10)))) * rw, y + math__cosf(((f32)(math__radians(i + 10)))) * rh);
	}
	sokol__sgl__end();
}

void gg__Context_draw_ellipse_filled(gg__Context* ctx, f32 x, f32 y, f32 rw, f32 rh, gx__Color c) {
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_triangle_strip();
	for (int i = 0; i < 360; i += 10) {
		sokol__sgl__v2f(x, y);
		sokol__sgl__v2f(x + math__sinf(((f32)(math__radians(i)))) * rw, y + math__cosf(((f32)(math__radians(i)))) * rh);
		sokol__sgl__v2f(x + math__sinf(((f32)(math__radians(i + 10)))) * rw, y + math__cosf(((f32)(math__radians(i + 10)))) * rh);
	}
	sokol__sgl__end();
}

void gg__Context_draw_cubic_bezier(gg__Context* ctx, Array_f32 points, gx__Color c) {
	gg__Context_draw_cubic_bezier_in_steps(ctx, points, ((u32)(30 * ctx->scale)), c);
}

void gg__Context_draw_cubic_bezier_in_steps(gg__Context* ctx, Array_f32 points, u32 steps, gx__Color c) {
	// assert
	if (!(steps > 0U)) {
		VAssertMetaInfo v_assert_meta_info__t1 = {0};
		v_assert_meta_info__t1.fpath = _SLIT("/Users/rcqls/vlang/v/vlib/gg/draw.c.v");
		v_assert_meta_info__t1.line_nr = 740;
		v_assert_meta_info__t1.fn_name = _SLIT("draw_cubic_bezier_in_steps");
		v_assert_meta_info__t1.src = _SLIT("steps > 0");
		v_assert_meta_info__t1.op = _SLIT(">");
		v_assert_meta_info__t1.llabel = _SLIT("steps");
		v_assert_meta_info__t1.rlabel = _SLIT("0");
		v_assert_meta_info__t1.lvalue = string_clone(u32_str(steps)) /* typeof: v.ast.Ident type: ast.Type(0xc = 12) */ ;
		v_assert_meta_info__t1.rvalue = string_clone(u32_str(0U)) /* typeof: v.ast.IntegerLiteral type: ast.Type(0xc = 12) */ ;
		__print_assert_failure(&v_assert_meta_info__t1);
		_v_panic(_SLIT("Assertion failed..."));
	}
	// assert
	if (!(points.len == 8)) {
		VAssertMetaInfo v_assert_meta_info__t2 = {0};
		v_assert_meta_info__t2.fpath = _SLIT("/Users/rcqls/vlang/v/vlib/gg/draw.c.v");
		v_assert_meta_info__t2.line_nr = 741;
		v_assert_meta_info__t2.fn_name = _SLIT("draw_cubic_bezier_in_steps");
		v_assert_meta_info__t2.src = _SLIT("points.len == 8");
		v_assert_meta_info__t2.op = _SLIT("==");
		v_assert_meta_info__t2.llabel = _SLIT("points.len");
		v_assert_meta_info__t2.rlabel = _SLIT("8");
		v_assert_meta_info__t2.lvalue = string_clone(int_str(points.len)) /* typeof: v.ast.SelectorExpr type: ast.Type(0x7 = 7) */ ;
		v_assert_meta_info__t2.rvalue = string_clone(int_str(8)) /* typeof: v.ast.IntegerLiteral type: ast.Type(0x7 = 7) */ ;
		__print_assert_failure(&v_assert_meta_info__t2);
		_v_panic(_SLIT("Assertion failed..."));
	}
	if (c.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	sokol__sgl__c4b(c.r, c.g, c.b, c.a);
	sokol__sgl__begin_line_strip();
	f32 p1_x = (*(f32*)/*ee elem_sym */array_get(points, 0));
	f32 p1_y = (*(f32*)/*ee elem_sym */array_get(points, 1));
	f32 p2_x = (*(f32*)/*ee elem_sym */array_get(points, 6));
	f32 p2_y = (*(f32*)/*ee elem_sym */array_get(points, 7));
	f32 ctrl_p1_x = (*(f32*)/*ee elem_sym */array_get(points, 2));
	f32 ctrl_p1_y = (*(f32*)/*ee elem_sym */array_get(points, 3));
	f32 ctrl_p2_x = (*(f32*)/*ee elem_sym */array_get(points, 4));
	f32 ctrl_p2_y = (*(f32*)/*ee elem_sym */array_get(points, 5));
	f32 step = ((f32)(1.0)) / steps;
	sokol__sgl__v2f(p1_x * ctx->scale, p1_y * ctx->scale);
	for (f32 u = ((f32)(0.0)); u <= ((f32)(1.0)); u += step) {
		f32 pow_2_u = u * u;
		f32 pow_3_u = pow_2_u * u;
		f32 x = pow_3_u * (p2_x + 3 * (ctrl_p1_x - ctrl_p2_x) - p1_x) + 3 * pow_2_u * (p1_x - 2 * ctrl_p1_x + ctrl_p2_x) + 3 * u * (ctrl_p1_x - p1_x) + p1_x;
		f32 y = pow_3_u * (p2_y + 3 * (ctrl_p1_y - ctrl_p2_y) - p1_y) + 3 * pow_2_u * (p1_y - 2 * ctrl_p1_y + ctrl_p2_y) + 3 * u * (ctrl_p1_y - p1_y) + p1_y;
		sokol__sgl__v2f(x * ctx->scale, y * ctx->scale);
	}
	sokol__sgl__v2f(p2_x * ctx->scale, p2_y * ctx->scale);
	sokol__sgl__end();
}

// Attr: [deprecated]
void gg__Context_set_pixel(gg__Context* ctx, f32 x, f32 y, gx__Color c) {
	gg__Context_draw_pixel(ctx, x, y, c);
}

// Attr: [deprecated]
void gg__Context_set_pixels(gg__Context* ctx, Array_f32 points, gx__Color c) {
	gg__Context_draw_pixels(ctx, points, c);
}

// Attr: [deprecated]
void gg__Context_draw_empty_poly(gg__Context* ctx, Array_f32 points, gx__Color c) {
	gg__Context_draw_poly_empty(ctx, points, c);
}

// Attr: [deprecated]
void gg__Context_draw_rect(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, gx__Color c) {
	gg__Context_draw_rect_filled(ctx, x, y, w, h, c);
}

// Attr: [deprecated]
void gg__Context_draw_empty_rect(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, gx__Color c) {
	gg__Context_draw_rect_empty(ctx, x, y, w, h, c);
}

// Attr: [deprecated]
void gg__Context_draw_empty_rounded_rect(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, f32 radius, gx__Color c) {
	gg__Context_draw_rounded_rect_empty(ctx, x, y, w, h, radius, c);
}

// Attr: [deprecated]
void gg__Context_draw_rounded_rect(gg__Context* ctx, f32 x, f32 y, f32 w, f32 h, f32 radius, gx__Color c) {
	gg__Context_draw_rounded_rect_filled(ctx, x, y, w, h, radius, c);
}

// Attr: [deprecated]
void gg__Context_draw_empty_triangle(gg__Context* ctx, f32 x, f32 y, f32 x2, f32 y2, f32 x3, f32 y3, gx__Color c) {
	gg__Context_draw_triangle_empty(ctx, x, y, x2, y2, x3, y3, c);
}

// Attr: [deprecated]
void gg__Context_draw_triangle(gg__Context* ctx, f32 x, f32 y, f32 x2, f32 y2, f32 x3, f32 y3, gx__Color c) {
	gg__Context_draw_triangle_filled(ctx, x, y, x2, y2, x3, y3, c);
}

// Attr: [deprecated]
void gg__Context_draw_empty_square(gg__Context* ctx, f32 x, f32 y, f32 s, gx__Color c) {
	gg__Context_draw_square_empty(ctx, x, y, s, c);
}

// Attr: [deprecated]
void gg__Context_draw_square(gg__Context* ctx, f32 x, f32 y, f32 s, gx__Color c) {
	gg__Context_draw_square_filled(ctx, x, y, s, c);
}

// Attr: [deprecated]
void gg__Context_draw_circle(gg__Context* ctx, f32 x, f32 y, f32 radius, gx__Color c) {
	gg__Context_draw_circle_filled(ctx, x, y, radius, c);
}

// Attr: [deprecated]
void gg__Context_draw_empty_slice(gg__Context* ctx, f32 x, f32 y, f32 radius, f32 start_angle, f32 end_angle, int segments, gx__Color c) {
	gg__Context_draw_slice_empty(ctx, x, y, radius, start_angle, end_angle, segments, c);
}

// Attr: [deprecated]
void gg__Context_draw_slice(gg__Context* ctx, f32 x, f32 y, f32 radius, f32 start_angle, f32 end_angle, int segments, gx__Color c) {
	gg__Context_draw_slice_filled(ctx, x, y, radius, start_angle, end_angle, segments, c);
}

// Attr: [deprecated]
void gg__Context_draw_empty_arc(gg__Context* ctx, f32 x, f32 y, f32 inner_radius, f32 thickness, f32 start_angle, f32 end_angle, int segments, gx__Color c) {
	gg__Context_draw_arc_empty(ctx, x, y, inner_radius, thickness, start_angle, end_angle, segments, c);
}

// Attr: [deprecated]
void gg__Context_draw_arc(gg__Context* ctx, f32 x, f32 y, f32 inner_radius, f32 thickness, f32 start_angle, f32 end_angle, int segments, gx__Color c) {
	gg__Context_draw_arc_filled(ctx, x, y, inner_radius, thickness, start_angle, end_angle, segments, c);
}

// Attr: [deprecated]
void gg__Context_draw_empty_ellipse(gg__Context* ctx, f32 x, f32 y, f32 rw, f32 rh, gx__Color c) {
	gg__Context_draw_ellipse_empty(ctx, x, y, rw, rh, c);
}

// Attr: [deprecated]
void gg__Context_draw_ellipse(gg__Context* ctx, f32 x, f32 y, f32 rw, f32 rh, gx__Color c) {
	gg__Context_draw_ellipse_filled(ctx, x, y, rw, rh, c);
}

// TypeDecl
void gg__gg_init_sokol_window(voidptr user_data) {
	gg__Context* ctx = ((gg__Context*)(user_data));
	sokol__gfx__Desc desc = sokol__sapp__create_desc();
	sokol__gfx__setup(&desc);
	sokol__sgl__Desc sgl_desc = ((sokol__sgl__Desc){.max_vertices = 0,.max_commands = 0,.pipeline_pool_size = 0,.color_format = 0,.depth_format = 0,.sample_count = 0,.face_winding = 0,});
	sokol__sgl__setup(&sgl_desc);
	gg__Context_set_scale(ctx);
	#if !defined(__ANDROID__)
	bool exists = os__is_file(ctx->config.font_path);
	#else
	#endif
	;
	if ((ctx->config.font_path).len != 0 && !exists) {
		ctx->render_text = false;
	} else if ((ctx->config.font_path).len != 0 && exists) {
		Option_gg__FT_ptr _t1 = gg__new_ft(((gg__FTConfig){.font_path = ctx->config.font_path,.custom_bold_font_path = ctx->config.custom_bold_font_path,.scale = ctx->scale,.font_size = 0,.bytes_normal = __new_array(0, 0, sizeof(u8)),.bytes_bold = __new_array(0, 0, sizeof(u8)),.bytes_mono = __new_array(0, 0, sizeof(u8)),.bytes_italic = __new_array(0, 0, sizeof(u8)),}));
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 		ctx->ft =  (*(gg__FT**)_t1.data);
		ctx->font_inited = true;
	} else {
		if (ctx->config.font_bytes_normal.len > 0) {
			Option_gg__FT_ptr _t2 = gg__new_ft(((gg__FTConfig){.font_path = (string){.str=(byteptr)"", .is_lit=1},.custom_bold_font_path = (string){.str=(byteptr)"", .is_lit=1},.scale = sokol__sapp__dpi_scale(),.font_size = 0,.bytes_normal = ctx->config.font_bytes_normal,.bytes_bold = ctx->config.font_bytes_bold,.bytes_mono = ctx->config.font_bytes_mono,.bytes_italic = ctx->config.font_bytes_italic,}));
			if (_t2.state != 0) { /*or block*/ 
				IError err = _t2.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
 			ctx->ft =  (*(gg__FT**)_t2.data);
			ctx->font_inited = true;
		} else {
			string sfont = os__font__default();
			if ((ctx->config.font_path).len != 0) {
				eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("font file \""), 0xfe10, {.d_s = ctx->config.font_path}}, {_SLIT("\" does not exist, the system font ("), 0xfe10, {.d_s = sfont}}, {_SLIT(") was used instead."), 0, { .d_c = 0 }}})));
			}
			Option_gg__FT_ptr _t3 = gg__new_ft(((gg__FTConfig){.font_path = sfont,.custom_bold_font_path = ctx->config.custom_bold_font_path,.scale = sokol__sapp__dpi_scale(),.font_size = 0,.bytes_normal = __new_array(0, 0, sizeof(u8)),.bytes_bold = __new_array(0, 0, sizeof(u8)),.bytes_mono = __new_array(0, 0, sizeof(u8)),.bytes_italic = __new_array(0, 0, sizeof(u8)),}));
			if (_t3.state != 0) { /*or block*/ 
				IError err = _t3.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
 			ctx->ft =  (*(gg__FT**)_t3.data);
			ctx->font_inited = true;
		}
	}
	sokol__gfx__PipelineDesc pipdesc = ((sokol__gfx__PipelineDesc){._start_canary = 0,.shader = {0},.layout = {0},.depth = {0},.stencil = {0},.color_count = 0,.colors = {0},.primitive_type = 0,.index_type = 0,.cull_mode = 0,.face_winding = 0,.sample_count = 0,.blend_color = {0},.alpha_to_coverage_enabled = 0,.label = "alpha_image",._end_canary = 0,});
	vmemset(&pipdesc, 0, ((int)(sizeof(sokol__gfx__PipelineDesc))));
	sokol__gfx__ColorState color_state = ((sokol__gfx__ColorState){.pixel_format = 0,.write_mask = 0,.blend = ((sokol__gfx__BlendState){.enabled = true,.src_factor_rgb = sokol__gfx__BlendFactor__src_alpha,.dst_factor_rgb = sokol__gfx__BlendFactor__one_minus_src_alpha,.op_rgb = 0,.src_factor_alpha = 0,.dst_factor_alpha = 0,.op_alpha = 0,}),});
	pipdesc.colors[0] = color_state;
	ctx->timage_pip = sokol__sgl__make_pipeline(&pipdesc);
	if (ctx->config.init_fn != (voidptr)((voidptr)(0))) {
		ctx->config.init_fn(ctx->user_data);
	}
	if (ctx->native_rendering) {
		return;
	}
	for (int i = 0; i < ctx->image_cache.len; ++i) {
		if ((*(gg__Image*)/*ee elem_sym */array_get(ctx->image_cache, i)).simg.id == 0U) {
			gg__Image_init_sokol_image(&(*(gg__Image*)/*ee elem_sym */array_get(ctx->image_cache, i)));
		}
	}
}

void gg__gg_frame_fn(voidptr user_data) {
	gg__Context* ctx = ((gg__Context*)(user_data));
	ctx->frame++;
	if (ctx->config.frame_fn == (voidptr)((voidptr)(0))) {
		return;
	}
	if (ctx->native_rendering) {
	}
	;
	if (ctx->ui_mode && !ctx->needs_refresh) {
		ctx->ticks++;
		if (ctx->ticks > 3) {
			return;
		}
	}
	ctx->config.frame_fn(ctx->user_data);
	ctx->needs_refresh = false;
}

void gg__gg_event_fn(voidptr ce, voidptr user_data) {
	gg__Event* e = ((gg__Event*)(ce));
	gg__Context* ctx = ((gg__Context*)(user_data));
	if (ctx->ui_mode) {
		gg__Context_refresh_ui(ctx);
	}
	if (e->typ == sokol__sapp__EventType__mouse_down) {
		int bitplace = ((int)(e->mouse_button));
		ctx->mbtn_mask |= ((u8)(1 << bitplace));
		ctx->mouse_buttons = ((gg__MouseButtons)(ctx->mbtn_mask));
	}
	if (e->typ == sokol__sapp__EventType__mouse_up) {
		int bitplace = ((int)(e->mouse_button));
		ctx->mbtn_mask &= ~(((u8)(1 << bitplace)));
		ctx->mouse_buttons = ((gg__MouseButtons)(ctx->mbtn_mask));
	}
	if (e->typ == sokol__sapp__EventType__mouse_move && e->mouse_button == gg__MouseButton__invalid) {
		if ((ctx->mbtn_mask & 0x01) > 0) {
			e->mouse_button = gg__MouseButton__left;
		}
		if ((ctx->mbtn_mask & 0x02) > 0) {
			e->mouse_button = gg__MouseButton__right;
		}
		if ((ctx->mbtn_mask & 0x04) > 0) {
			e->mouse_button = gg__MouseButton__middle;
		}
	}
	ctx->mouse_pos_x = ((int)(e->mouse_x / ctx->scale));
	ctx->mouse_pos_y = ((int)(e->mouse_y / ctx->scale));
	ctx->mouse_dx = ((int)(e->mouse_dx / ctx->scale));
	ctx->mouse_dy = ((int)(e->mouse_dy / ctx->scale));
	ctx->scroll_x = ((int)(e->scroll_x / ctx->scale));
	ctx->scroll_y = ((int)(e->scroll_y / ctx->scale));
	ctx->key_modifiers = ((gg__Modifier)(e->modifiers));
	ctx->key_repeat = e->key_repeat;
	if (e->typ == sokol__sapp__EventType__key_down || e->typ == sokol__sapp__EventType__key_up) {
		int key_idx = ((int)(e->key_code)) % _const_gg__key_code_max;
		bool prev = ctx->pressed_keys[v_fixed_index(key_idx, 512)];
		bool next = e->typ == sokol__sapp__EventType__key_down;
		ctx->pressed_keys[v_fixed_index(key_idx, 512)] = next;
		ctx->pressed_keys_edge[v_fixed_index(key_idx, 512)] = prev != next;
	}
	if (ctx->config.event_fn != (voidptr)((voidptr)(0))) {
		ctx->config.event_fn(e, ctx->config.user_data);
	}
	switch (e->typ) {
		case sokol__sapp__EventType__mouse_move: 
			{
				if (ctx->config.move_fn != (voidptr)((voidptr)(0))) {
					ctx->config.move_fn(e->mouse_x / ctx->scale, e->mouse_y / ctx->scale, ctx->config.user_data);
				}
				break;
			}
		case sokol__sapp__EventType__mouse_down: 
			{
				if (ctx->config.click_fn != (voidptr)((voidptr)(0))) {
					ctx->config.click_fn(e->mouse_x / ctx->scale, e->mouse_y / ctx->scale, e->mouse_button, ctx->config.user_data);
				}
				break;
			}
		case sokol__sapp__EventType__mouse_up: 
			{
				if (ctx->config.unclick_fn != (voidptr)((voidptr)(0))) {
					ctx->config.unclick_fn(e->mouse_x / ctx->scale, e->mouse_y / ctx->scale, e->mouse_button, ctx->config.user_data);
				}
				break;
			}
		case sokol__sapp__EventType__mouse_leave: 
			{
				if (ctx->config.leave_fn != (voidptr)((voidptr)(0))) {
					ctx->config.leave_fn(e, ctx->config.user_data);
				}
				break;
			}
		case sokol__sapp__EventType__mouse_enter: 
			{
				if (ctx->config.enter_fn != (voidptr)((voidptr)(0))) {
					ctx->config.enter_fn(e, ctx->config.user_data);
				}
				break;
			}
		case sokol__sapp__EventType__mouse_scroll: 
			{
				if (ctx->config.scroll_fn != (voidptr)((voidptr)(0))) {
					ctx->config.scroll_fn(e, ctx->config.user_data);
				}
				break;
			}
		case sokol__sapp__EventType__key_down: 
			{
				if (ctx->config.keydown_fn != (voidptr)((voidptr)(0))) {
					ctx->config.keydown_fn(e->key_code, ((gg__Modifier)(e->modifiers)), ctx->config.user_data);
				}
				break;
			}
		case sokol__sapp__EventType__key_up: 
			{
				if (ctx->config.keyup_fn != (voidptr)((voidptr)(0))) {
					ctx->config.keyup_fn(e->key_code, ((gg__Modifier)(e->modifiers)), ctx->config.user_data);
				}
				break;
			}
		case sokol__sapp__EventType__char: 
			{
				if (ctx->config.char_fn != (voidptr)((voidptr)(0))) {
					ctx->config.char_fn(e->char_code, ctx->config.user_data);
				}
				break;
			}
		case sokol__sapp__EventType__resized: 
			{
				if (ctx->config.resized_fn != (voidptr)((voidptr)(0))) {
					ctx->config.resized_fn(e, ctx->config.user_data);
				}
				break;
			}
		case sokol__sapp__EventType__quit_requested: 
			{
				if (ctx->config.quit_fn != (voidptr)((voidptr)(0))) {
					ctx->config.quit_fn(e, ctx->config.user_data);
				}
				break;
			}
		case sokol__sapp__EventType__invalid:
		case sokol__sapp__EventType__touches_began:
		case sokol__sapp__EventType__touches_moved:
		case sokol__sapp__EventType__touches_ended:
		case sokol__sapp__EventType__touches_cancelled:
		case sokol__sapp__EventType__iconified:
		case sokol__sapp__EventType__restored:
		case sokol__sapp__EventType__focused:
		case sokol__sapp__EventType__unfocused:
		case sokol__sapp__EventType__suspended:
		case sokol__sapp__EventType__resumed:
		case sokol__sapp__EventType__update_cursor:
		case sokol__sapp__EventType__clipboard_pasted:
		case sokol__sapp__EventType__files_droped:
		case sokol__sapp__EventType__num:
		default:
			{
				break;
			}
	}
	;
}

void gg__gg_cleanup_fn(voidptr user_data) {
	gg__Context* ctx = ((gg__Context*)(user_data));
	if (ctx->config.cleanup_fn != (voidptr)((voidptr)(0))) {
		ctx->config.cleanup_fn(ctx->config.user_data);
	}
	sokol__gfx__shutdown();
}

void gg__gg_fail_fn(char* msg, voidptr user_data) {
	gg__Context* ctx = ((gg__Context*)(user_data));
	string vmsg = tos3(msg);
	if (ctx->config.fail_fn != (voidptr)((voidptr)(0))) {
		ctx->config.fail_fn(vmsg, ctx->config.user_data);
	} else {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("gg error: "), 0xfe10, {.d_s = vmsg}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}

gg__Context* gg__new_context(gg__Config cfg) {
	gg__Context* ctx = ((gg__Context*)memdup(&(gg__Context){.render_text = true,
		.image_cache = __new_array(0, 0, sizeof(gg__Image)),
		.needs_refresh = true,
		.ticks = 0,
		.native_rendering = cfg.native_rendering,
		.scale = 1.0,
		.width = cfg.width,
		.height = cfg.height,
		.clear_pass = {0},
		.window = {0},
		.timage_pip = {0},
		.config = cfg,
		.user_data = cfg.user_data,
		.ft = 0,
		.font_inited = 0,
		.ui_mode = cfg.ui_mode,
		.frame = 0,
		.mbtn_mask = 0,
		.mouse_buttons = 0,
		.mouse_pos_x = 0,
		.mouse_pos_y = 0,
		.mouse_dx = 0,
		.mouse_dy = 0,
		.scroll_x = 0,
		.scroll_y = 0,
		.key_modifiers = 0,
		.key_repeat = 0,
		.pressed_keys = {0},
		.pressed_keys_edge = {0},
	}, sizeof(gg__Context)));
	if (isnil(cfg.user_data)) {
		ctx->user_data = ctx;
	}
	gg__Context_set_bg_color(ctx, cfg.bg_color);
	sokol__sapp__Desc window = ((sokol__sapp__Desc){
		.init_cb = 0,
		.frame_cb = 0,
		.cleanup_cb = 0,
		.event_cb = 0,
		.fail_cb = 0,
		.user_data = ctx,
		.init_userdata_cb = (voidptr)gg__gg_init_sokol_window,
		.frame_userdata_cb = (voidptr)gg__gg_frame_fn,
		.cleanup_userdata_cb = (voidptr)gg__gg_cleanup_fn,
		.event_userdata_cb = (voidptr)gg__gg_event_fn,
		.fail_userdata_cb = (voidptr)gg__gg_fail_fn,
		.width = cfg.width,
		.height = cfg.height,
		.sample_count = cfg.sample_count,
		.swap_interval = cfg.swap_interval,
		.high_dpi = true,
		.fullscreen = cfg.fullscreen,
		.alpha = 0,
		.window_title = ((char*)(cfg.window_title.str)),
		.user_cursor = 0,
		.enable_clipboard = 0,
		.clipboard_size = 0,
		.enable_dragndrop = cfg.enable_dragndrop,
		.max_dropped_files = cfg.max_dropped_files,
		.max_dropped_file_path_length = cfg.max_dropped_file_path_length,
		.icon = {0},
		.gl_force_gles2 = 0,
		.win32_console_utf8 = 0,
		.win32_console_create = 0,
		.win32_console_attach = 0,
		.html5_canvas_name = ((char*)(cfg.window_title.str)),
		.html5_canvas_resize = 0,
		.html5_preserve_drawing_buffer = 0,
		.html5_premultiplied_alpha = 0,
		.html5_ask_leave_site = 0,
		.ios_keyboard_resizes_canvas = 0,
		.__v_native_render = cfg.native_rendering,
	});
	ctx->window = window;
	gg__Context* _t1 = ctx;
	return _t1;
}

void gg__Context_run(gg__Context* ctx) {
	sokol__sapp__run(&ctx->window);
}

void gg__Context_quit(gg__Context* ctx) {
	sokol__sapp__request_quit();
}

void gg__Context_set_bg_color(gg__Context* ctx, gx__Color c) {
	ctx->clear_pass = sokol__gfx__create_clear_pass(((f32)(c.r)) / 255.0, ((f32)(c.g)) / 255.0, ((f32)(c.b)) / 255.0, ((f32)(c.a)) / 255.0);
}

void gg__Context_resize(gg__Context* ctx, int width, int height) {
	ctx->width = width;
	ctx->height = height;
}

void gg__Context_refresh_ui(gg__Context* ctx) {
	ctx->needs_refresh = true;
	ctx->ticks = 0;
}

void gg__Context_begin(gg__Context* ctx) {
	if (ctx->render_text && ctx->font_inited) {
		gg__FT_flush(ctx->ft);
	}
	sokol__sgl__defaults();
	sokol__sgl__matrix_mode_projection();
	sokol__sgl__ortho(0.0, ((f32)(sokol__sapp__width())), ((f32)(sokol__sapp__height())), 0.0, -1.0, 1.0);
}

void gg__Context_end(gg__Context* ctx) {
	sokol__gfx__begin_default_pass((voidptr)&/*qq*/ctx->clear_pass, sokol__sapp__width(), sokol__sapp__height());
	sokol__sgl__draw();
	sokol__gfx__end_pass();
	sokol__gfx__commit();
}

void gg__Context_set_scale(gg__Context* ctx) {
	f32 s = sokol__sapp__dpi_scale();
	if (s < 0.1) {
		s = 1.0;
	}
	ctx->scale = s;
}

gg__Size gg__Context_window_size(gg__Context* ctx) {
	f32 s = ctx->scale;
	gg__Size _t1 = ((gg__Size){.width = ((int)(sokol__sapp__width() / s)),.height = ((int)(sokol__sapp__height() / s)),});
	return _t1;
}

f32 gg__dpi_scale(void) {
	f32 s = sokol__sapp__dpi_scale();
	if (s < 0.1) {
		s = 1.0;
	}
	f32 _t1 = s;
	return _t1;
}

bool gg__high_dpi(void) {
	bool _t1 = sapp_high_dpi();
	return _t1;
}

gg__Size gg__screen_size(void) {
	gg__Size _t1 = gg_get_screen_size();
	return _t1;
	gg__Size _t2 = ((gg__Size){.width = 0,.height = 0,});
	return _t2;
}

gg__Size gg__window_size(void) {
	f32 s = gg__dpi_scale();
	gg__Size _t1 = ((gg__Size){.width = ((int)(sokol__sapp__width() / s)),.height = ((int)(sokol__sapp__height() / s)),});
	return _t1;
}

gg__Size gg__window_size_real_pixels(void) {
	gg__Size _t1 = ((gg__Size){.width = sokol__sapp__width(),.height = sokol__sapp__height(),});
	return _t1;
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
gg__Image gg__Context_create_image(gg__Context* ctx, string file) {
	if (!os__exists(file)) {
		gg__Image _t1 = ((gg__Image){.id = 0,.width = 0,.height = 0,.nr_channels = 0,.ok = 0,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},.simg_ok = 0,.simg = {0},.path = (string){.str=(byteptr)"", .is_lit=1},});
		return _t1;
	}
	if (ctx->native_rendering) {
		gg__Image *img = HEAP(gg__Image, (darwin_create_image(file)));
		(*(img)).id = ctx->image_cache.len;
		array_push((array*)&ctx->image_cache, _MOV((gg__Image[]){ (*(img)) }));
		gg__Image _t3 = (*(img));
		return _t3;
	}
	if (!sokol__gfx__is_valid()) {
		Option_stbi__Image _t4 = stbi__load(file);
		if (_t4.state != 0) { /*or block*/ 
			IError err = _t4.err;
			gg__Image _t5 = ((gg__Image){.id = 0,.width = 0,.height = 0,.nr_channels = 0,.ok = 0,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},.simg_ok = 0,.simg = {0},.path = (string){.str=(byteptr)"", .is_lit=1},});
			return _t5;
		}
		
 		stbi__Image stb_img =  (*(stbi__Image*)_t4.data);
		gg__Image *img = HEAP(gg__Image, (((gg__Image){
			.id = ctx->image_cache.len,
			.width = stb_img.width,
			.height = stb_img.height,
			.nr_channels = stb_img.nr_channels,
			.ok = false,
			.data = stb_img.data,
			.ext = stb_img.ext,
			.simg_ok = 0,
			.simg = {0},
			.path = file,
		})));
		array_push((array*)&ctx->image_cache, _MOV((gg__Image[]){ (*(img)) }));
		gg__Image _t7 = (*(img));
		return _t7;
	}
	gg__Image *img = HEAP(gg__Image, (gg__create_image(file)));
	(*(img)).id = ctx->image_cache.len;
	array_push((array*)&ctx->image_cache, _MOV((gg__Image[]){ (*(img)) }));
	gg__Image _t9 = (*(img));
	return _t9;
}

gg__Image* gg__Image_init_sokol_image(gg__Image* img) {
	sokol__gfx__ImageDesc img_desc = ((sokol__gfx__ImageDesc){
		._start_canary = 0,
		.type = 0,
		.render_target = 0,
		.width = img->width,
		.height = img->height,
		.num_slices = 0,
		.num_mipmaps = 0,
		.usage = 0,
		.pixel_format = 0,
		.sample_count = 0,
		.min_filter = 0,
		.mag_filter = 0,
		.wrap_u = sokol__gfx__Wrap__clamp_to_edge,
		.wrap_v = sokol__gfx__Wrap__clamp_to_edge,
		.wrap_w = 0,
		.border_color = 0,
		.max_anisotropy = 0,
		.min_lod = 0,
		.max_lod = 0,
		.data = {0},
		.label = img->path.str,
		.gl_textures = {0},
		.gl_texture_target = 0,
		.mtl_textures = {0},
		.d3d11_texture = 0,
		.d3d11_shader_resource_view = 0,
		.wgpu_texture = 0,
		._end_canary = 0,
	});
	img_desc.data.subimage[0][0] = ((sokol__gfx__Range){.ptr = img->data,.size = ((usize)(img->nr_channels * img->width * img->height)),});
	img->simg = sokol__gfx__make_image(&img_desc);
	img->simg_ok = true;
	img->ok = true;
	gg__Image* _t1 = img;
	return _t1;
}

void gg__Context_draw_image(gg__Context* ctx, f32 x, f32 y, f32 width, f32 height, gg__Image* img_) {
	if (img_->id >= ctx->image_cache.len) {
		eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("gg: draw_image() bad img id "), 0xfe07, {.d_i32 = img_->id}}, {_SLIT(" (img cache len = "), 0xfe07, {.d_i32 = ctx->image_cache.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
		return;
	}
	if (ctx->native_rendering) {
		if (img_->width == 0) {
			return;
		}
		if (!os__exists(img_->path)) {
			return;
		}
		darwin_draw_image(x, ctx->height - (y + height), width, height, img_);
		return;
	}
	gg__Context_draw_image_with_config(ctx, ((gg__DrawImageConfig){.flip_x = 0,.flip_y = 0,.img = img_,.img_id = 0,.img_rect = ((gg__Rect){.x = x,.y = y,.width = width,.height = height,}),.part_rect = ((gg__Rect){.x = 0,.y = 0,.width = img_->width,.height = img_->height,}),.rotate = 0,.z = 0,.color = _const_gx__white,}));
}

int gg__Context_new_streaming_image(gg__Context* ctx, int w, int h, int channels, gg__StreamingImageConfig sicfg) {
	gg__Image *img = HEAP(gg__Image, (((gg__Image){.id = 0,.width = 0,.height = 0,.nr_channels = 0,.ok = 0,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},.simg_ok = 0,.simg = {0},.path = (string){.str=(byteptr)"", .is_lit=1},})));
	(*(img)).width = w;
	(*(img)).height = h;
	(*(img)).nr_channels = channels;
	sokol__gfx__ImageDesc img_desc = ((sokol__gfx__ImageDesc){
		._start_canary = 0,
		.type = 0,
		.render_target = 0,
		.width = (*(img)).width,
		.height = (*(img)).height,
		.num_slices = 1,
		.num_mipmaps = 1,
		.usage = sokol__gfx__Usage__stream,
		.pixel_format = sicfg.pixel_format,
		.sample_count = 0,
		.min_filter = sicfg.min_filter,
		.mag_filter = sicfg.mag_filter,
		.wrap_u = sicfg.wrap_u,
		.wrap_v = sicfg.wrap_v,
		.wrap_w = 0,
		.border_color = 0,
		.max_anisotropy = 0,
		.min_lod = 0,
		.max_lod = 0,
		.data = {0},
		.label = (*(img)).path.str,
		.gl_textures = {0},
		.gl_texture_target = 0,
		.mtl_textures = {0},
		.d3d11_texture = 0,
		.d3d11_shader_resource_view = 0,
		.wgpu_texture = 0,
		._end_canary = 0,
	});
	img_desc.data.subimage[0][0] = ((sokol__gfx__Range){.ptr = 0,.size = ((usize)(0)),});
	(*(img)).simg = sokol__gfx__make_image(&img_desc);
	(*(img)).simg_ok = true;
	(*(img)).ok = true;
	int img_idx = gg__Context_cache_image(ctx, (*(img)));
	int _t1 = img_idx;
	return _t1;
}

void gg__Context_update_pixel_data(gg__Context* ctx, int cached_image_idx, u8* buf) {
	gg__Image* image = gg__Context_get_cached_image_by_idx(ctx, cached_image_idx);
	gg__Image_update_pixel_data(image, buf);
}

void gg__Image_update_pixel_data(gg__Image* img, u8* buf) {
	sokol__gfx__ImageData data = ((sokol__gfx__ImageData){.subimage = {0},});
	data.subimage[0][0].ptr = buf;
	data.subimage[0][0].size = ((usize)(img->width * img->height * img->nr_channels));
	sokol__gfx__update_image(img->simg, &data);
}

gg__Image gg__Context_create_image_with_size(gg__Context* ctx, string file, int width, int height) {
	if (!sokol__gfx__is_valid()) {
		Option_stbi__Image _t1 = stbi__load(file);
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			gg__Image _t2 = ((gg__Image){.id = 0,.width = 0,.height = 0,.nr_channels = 0,.ok = 0,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},.simg_ok = 0,.simg = {0},.path = (string){.str=(byteptr)"", .is_lit=1},});
			return _t2;
		}
		
 		stbi__Image stb_img =  (*(stbi__Image*)_t1.data);
		gg__Image *img = HEAP(gg__Image, (((gg__Image){
			.id = ctx->image_cache.len,
			.width = width,
			.height = height,
			.nr_channels = stb_img.nr_channels,
			.ok = false,
			.data = stb_img.data,
			.ext = stb_img.ext,
			.simg_ok = 0,
			.simg = {0},
			.path = file,
		})));
		array_push((array*)&ctx->image_cache, _MOV((gg__Image[]){ (*(img)) }));
		gg__Image _t4 = (*(img));
		return _t4;
	}
	gg__Image *img = HEAP(gg__Image, (gg__create_image(file)));
	(*(img)).id = ctx->image_cache.len;
	array_push((array*)&ctx->image_cache, _MOV((gg__Image[]){ (*(img)) }));
	gg__Image _t6 = (*(img));
	return _t6;
}

gg__Image gg__create_image(string file) {
	if (!os__exists(file)) {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("gg.create_image(): file not found: "), 0xfe10, {.d_s = file}}, {_SLIT0, 0, { .d_c = 0 }}})));
		gg__Image _t1 = ((gg__Image){.id = 0,.width = 0,.height = 0,.nr_channels = 0,.ok = 0,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},.simg_ok = 0,.simg = {0},.path = (string){.str=(byteptr)"", .is_lit=1},});
		return _t1;
	}
	Option_stbi__Image _t2 = stbi__load(file);
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		gg__Image _t3 = ((gg__Image){.id = 0,.width = 0,.height = 0,.nr_channels = 0,.ok = 0,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},.simg_ok = 0,.simg = {0},.path = (string){.str=(byteptr)"", .is_lit=1},});
		return _t3;
	}
	
 	stbi__Image stb_img =  (*(stbi__Image*)_t2.data);
	gg__Image *img = HEAP(gg__Image, (((gg__Image){
		.id = 0,
		.width = stb_img.width,
		.height = stb_img.height,
		.nr_channels = stb_img.nr_channels,
		.ok = stb_img.ok,
		.data = stb_img.data,
		.ext = stb_img.ext,
		.simg_ok = 0,
		.simg = {0},
		.path = file,
	})));
	gg__Image_init_sokol_image(&(*(img)));
	gg__Image _t4 = (*(img));
	return _t4;
}

gg__Image gg__Context_create_image_from_memory(gg__Context* ctx, u8* buf, int bufsize) {
	Option_stbi__Image _t1 = stbi__load_from_memory(buf, bufsize);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		gg__Image _t2 = ((gg__Image){.id = 0,.width = 0,.height = 0,.nr_channels = 0,.ok = 0,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},.simg_ok = 0,.simg = {0},.path = (string){.str=(byteptr)"", .is_lit=1},});
		return _t2;
	}
	
 	stbi__Image stb_img =  (*(stbi__Image*)_t1.data);
	gg__Image *img = HEAP(gg__Image, (((gg__Image){
		.id = ctx->image_cache.len,
		.width = stb_img.width,
		.height = stb_img.height,
		.nr_channels = stb_img.nr_channels,
		.ok = stb_img.ok,
		.data = stb_img.data,
		.ext = stb_img.ext,
		.simg_ok = 0,
		.simg = {0},
		.path = (string){.str=(byteptr)"", .is_lit=1},
	})));
	array_push((array*)&ctx->image_cache, _MOV((gg__Image[]){ (*(img)) }));
	gg__Image _t4 = (*(img));
	return _t4;
}

gg__Image gg__Context_create_image_from_byte_array(gg__Context* ctx, Array_u8 b) {
	gg__Image _t1 = gg__Context_create_image_from_memory(ctx, b.data, b.len);
	return _t1;
}

void gg__Context_draw_image_with_config(gg__Context* ctx, gg__DrawImageConfig config) {
	int id = (!isnil(config.img) ? (config.img->id) : (config.img_id));
	if (id >= ctx->image_cache.len) {
		eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("gg: draw_image() bad img id "), 0xfe07, {.d_i32 = id}}, {_SLIT(" (img cache len = "), 0xfe07, {.d_i32 = ctx->image_cache.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
		return;
	}
	gg__Image* img = &(*(gg__Image*)/*ee elem_sym */array_get(ctx->image_cache, id));
	if (!img->simg_ok) {
		return;
	}
	gg__Rect img_rect = config.img_rect;
	if (img_rect.width == 0 && img_rect.height == 0) {
		img_rect = ((gg__Rect){.x = img_rect.x,.y = img_rect.y,.width = img->width,.height = img->height,});
	}
	gg__Rect part_rect = config.part_rect;
	if (part_rect.width == 0 && part_rect.height == 0) {
		part_rect = ((gg__Rect){.x = part_rect.x,.y = part_rect.y,.width = img->width,.height = img->height,});
	}
	f32 u0 = part_rect.x / img->width;
	f32 v0 = part_rect.y / img->height;
	f32 u1 = (part_rect.x + part_rect.width) / img->width;
	f32 v1 = (part_rect.y + part_rect.height) / img->height;
	f32 x0 = img_rect.x * ctx->scale;
	f32 y0 = img_rect.y * ctx->scale;
	f32 x1 = (img_rect.x + img_rect.width) * ctx->scale;
	f32 y1 = (img_rect.y + img_rect.height) * ctx->scale;
	if (img_rect.height == 0) {
		f32 scale = ((f32)(img->width)) / ((f32)(img_rect.width));
		y1 = ((f32)(img_rect.y + ((int)(((f32)(img->height)) / scale)))) * ctx->scale;
	}
	bool flip_x = config.flip_x;
	bool flip_y = config.flip_y;
	f32 u0f = (!flip_x ? (u0) : (u1));
	f32 u1f = (!flip_x ? (u1) : (u0));
	f32 v0f = (!flip_y ? (v0) : (v1));
	f32 v1f = (!flip_y ? (v1) : (v0));
	sokol__sgl__load_pipeline(ctx->timage_pip);
	sokol__sgl__enable_texture();
	sokol__sgl__texture(img->simg);
	if (config.rotate != 0) {
		f32 width = img_rect.width * ctx->scale;
		f32 height = ((img_rect.height > 0 ? (img_rect.height) : (img->height))) * ctx->scale;
		sokol__sgl__push_matrix();
		sokol__sgl__translate(x0 + (width / 2), y0 + (height / 2), 0);
		sokol__sgl__rotate(sokol__sgl__rad(-config.rotate), 0, 0, 1);
		sokol__sgl__translate(-x0 - (width / 2), -y0 - (height / 2), 0);
	}
	sokol__sgl__begin_quads();
	sokol__sgl__c4b(config.color.r, config.color.g, config.color.b, config.color.a);
	sokol__sgl__v3f_t2f(x0, y0, config.z, u0f, v0f);
	sokol__sgl__v3f_t2f(x1, y0, config.z, u1f, v0f);
	sokol__sgl__v3f_t2f(x1, y1, config.z, u1f, v1f);
	sokol__sgl__v3f_t2f(x0, y1, config.z, u0f, v1f);
	sokol__sgl__end();
	if (config.rotate != 0) {
		sokol__sgl__pop_matrix();
	}
	sokol__sgl__disable_texture();
}

int gg__Context_cache_image(gg__Context* ctx, gg__Image _v_toheap_img) {
gg__Image* img = HEAP(gg__Image, _v_toheap_img);
	array_push((array*)&ctx->image_cache, _MOV((gg__Image[]){ (*(img)) }));
	int image_idx = ctx->image_cache.len - 1;
	(*(gg__Image*)/*ee elem_sym */array_get(ctx->image_cache, image_idx)).id = image_idx;
	int _t2 = image_idx;
	return _t2;
}

gg__Image* gg__Context_get_cached_image_by_idx(gg__Context* ctx, int image_idx) {
	gg__Image* _t1 = &(*(gg__Image*)/*ee elem_sym */array_get(ctx->image_cache, image_idx));
	return _t1;
}

void gg__Context_remove_cached_image_by_idx(gg__Context* ctx, int image_idx) {
	array_delete(&ctx->image_cache, image_idx);
}

void gg__Context_draw_image_part(gg__Context* ctx, gg__Rect img_rect, gg__Rect part_rect, gg__Image* img_) {
	gg__Context_draw_image_with_config(ctx, ((gg__DrawImageConfig){.flip_x = 0,.flip_y = 0,.img = img_,.img_id = 0,.img_rect = img_rect,.part_rect = part_rect,.rotate = 0,.z = 0,.color = _const_gx__white,}));
}

void gg__Context_draw_image_flipped(gg__Context* ctx, f32 x, f32 y, f32 width, f32 height, gg__Image* img_) {
	gg__Context_draw_image_with_config(ctx, ((gg__DrawImageConfig){.flip_x = true,.flip_y = 0,.img = img_,.img_id = 0,.img_rect = ((gg__Rect){.x = x,.y = y,.width = width,.height = height,}),.part_rect = {0},.rotate = 0,.z = 0,.color = _const_gx__white,}));
}

void gg__Context_draw_image_by_id(gg__Context* ctx, f32 x, f32 y, f32 width, f32 height, int id) {
	gg__Context_draw_image_with_config(ctx, ((gg__DrawImageConfig){.flip_x = 0,.flip_y = 0,.img = ((voidptr)(0)),.img_id = id,.img_rect = ((gg__Rect){.x = x,.y = y,.width = width,.height = height,}),.part_rect = {0},.rotate = 0,.z = 0,.color = _const_gx__white,}));
}

void gg__Context_draw_image_3d(gg__Context* ctx, f32 x, f32 y, f32 z, f32 width, f32 height, gg__Image* img_) {
	gg__Context_draw_image_with_config(ctx, ((gg__DrawImageConfig){.flip_x = 0,.flip_y = 0,.img = img_,.img_id = 0,.img_rect = ((gg__Rect){.x = x,.y = y,.width = width,.height = height,}),.part_rect = {0},.rotate = 0,.z = z,.color = _const_gx__white,}));
}

// TypeDecl
gg__SSRecorderSettings* gg__new_gg_recorder_settings(void) {
	#if defined(CUSTOM_DEFINE_gg_record)
	{
	}
	#else
	{
		gg__SSRecorderSettings* _t1 = ((gg__SSRecorderSettings*)memdup(&(gg__SSRecorderSettings){.stop_at_frame = -1,.screenshot_frames = __new_array(0, 0, sizeof(u64)),.screenshot_folder = (string){.str=(byteptr)"", .is_lit=1},.screenshot_prefix = (string){.str=(byteptr)"", .is_lit=1},}, sizeof(gg__SSRecorderSettings)));
		return _t1;
	}
	#endif
	return 0;
}

Option_gg__FT_ptr gg__new_ft(gg__FTConfig c) {
	if ((c.font_path).len == 0) {
		if (c.bytes_normal.len > 0) {
			fontstash__Context* fons = sokol__sfons__create(512, 512, 1);
			Array_u8 bytes_normal = c.bytes_normal;
			Array_u8 _t1; /* if prepend */
			if (c.bytes_bold.len > 0) {
				_t1 = c.bytes_bold;
			} else {
				;
				_t1 = bytes_normal;
			}
			Array_u8 bytes_bold =  _t1;
			Array_u8 _t2; /* if prepend */
			if (c.bytes_mono.len > 0) {
				_t2 = c.bytes_mono;
			} else {
				;
				_t2 = bytes_normal;
			}
			Array_u8 bytes_mono =  _t2;
			Array_u8 _t3; /* if prepend */
			if (c.bytes_italic.len > 0) {
				_t3 = c.bytes_italic;
			} else {
				;
				_t3 = bytes_normal;
			}
			Array_u8 bytes_italic =  _t3;
			Option_gg__FT_ptr _t4;
			opt_ok(&(gg__FT*[]) { ((gg__FT*)memdup(&(gg__FT){.fons = fons,
				.font_normal = fontstash__Context_add_font_mem(fons, _SLIT("sans"), bytes_normal, false),
				.font_bold = fontstash__Context_add_font_mem(fons, _SLIT("sans"), bytes_bold, false),
				.font_mono = fontstash__Context_add_font_mem(fons, _SLIT("sans"), bytes_mono, false),
				.font_italic = fontstash__Context_add_font_mem(fons, _SLIT("sans"), bytes_italic, false),
				.scale = c.scale,
			}, sizeof(gg__FT))) }, (Option*)(&_t4), sizeof(gg__FT*));
			return _t4;
		} else {
		}
	}
	if ((c.font_path).len == 0 || !os__exists(c.font_path)) {
		#if !defined(__ANDROID__)
		{
			println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed to load font \""), 0xfe10, {.d_s = c.font_path}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
			return (Option_gg__FT_ptr){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		#endif
	}
	string normal_path = c.font_path;
	Array_u8 bytes = __new_array_with_default(0, 0, sizeof(u8), 0);
	#if defined(__ANDROID__)
	{
	}
	#else
	{
		Option_Array_u8 _t6 = os__read_bytes(c.font_path);
		if (_t6.state != 0) { /*or block*/ 
			IError err = _t6.err;
			println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed to load font \""), 0xfe10, {.d_s = c.font_path}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
			return (Option_gg__FT_ptr){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		bytes =  (*(Array_u8*)_t6.data);
	}
	#endif
	string bold_path = ((c.custom_bold_font_path).len != 0 ? (c.custom_bold_font_path) : (os__font__get_path_variant(c.font_path, os__font__Variant__bold)));
	Option_Array_u8 _t8 = os__read_bytes(bold_path);
	if (_t8.state != 0) { /*or block*/ 
		IError err = _t8.err;
		;
		bold_path = c.font_path;
		*(Array_u8*) _t8.data = bytes;
	}
	
 	Array_u8 bytes_bold =  (*(Array_u8*)_t8.data);
	string mono_path = os__font__get_path_variant(c.font_path, os__font__Variant__mono);
	Option_Array_u8 _t9 = os__read_bytes(mono_path);
	if (_t9.state != 0) { /*or block*/ 
		IError err = _t9.err;
		;
		mono_path = c.font_path;
		*(Array_u8*) _t9.data = bytes;
	}
	
 	Array_u8 bytes_mono =  (*(Array_u8*)_t9.data);
	string italic_path = os__font__get_path_variant(c.font_path, os__font__Variant__italic);
	Option_Array_u8 _t10 = os__read_bytes(italic_path);
	if (_t10.state != 0) { /*or block*/ 
		IError err = _t10.err;
		;
		italic_path = c.font_path;
		*(Array_u8*) _t10.data = bytes;
	}
	
 	Array_u8 bytes_italic =  (*(Array_u8*)_t10.data);
	fontstash__Context* fons = sokol__sfons__create(512, 512, 1);
	;
	;
	;
	;
	Option_gg__FT_ptr _t11;
	opt_ok(&(gg__FT*[]) { ((gg__FT*)memdup(&(gg__FT){.fons = fons,
		.font_normal = fontstash__Context_add_font_mem(fons, _SLIT("sans"), bytes, false),
		.font_bold = fontstash__Context_add_font_mem(fons, _SLIT("sans"), bytes_bold, false),
		.font_mono = fontstash__Context_add_font_mem(fons, _SLIT("sans"), bytes_mono, false),
		.font_italic = fontstash__Context_add_font_mem(fons, _SLIT("sans"), bytes_italic, false),
		.scale = c.scale,
	}, sizeof(gg__FT))) }, (Option*)(&_t11), sizeof(gg__FT*));
	return _t11;
}

void gg__Context_set_cfg(gg__Context* ctx, gx__TextCfg cfg) {
	if (!ctx->font_inited) {
		return;
	}
	if (cfg.bold) {
		fontstash__Context_set_font(ctx->ft->fons, ctx->ft->font_bold);
	} else if (cfg.mono) {
		fontstash__Context_set_font(ctx->ft->fons, ctx->ft->font_mono);
	} else if (cfg.italic) {
		fontstash__Context_set_font(ctx->ft->fons, ctx->ft->font_italic);
	} else {
		fontstash__Context_set_font(ctx->ft->fons, ctx->ft->font_normal);
	}
	f32 scale = (ctx->ft->scale == 0 ? (((f32)(1))) : (ctx->ft->scale));
	int size = (cfg.mono ? (cfg.size - 2) : (cfg.size));
	fontstash__Context_set_size(ctx->ft->fons, scale * ((f32)(size)));
	fontstash__Context_set_align(ctx->ft->fons, (((int)(cfg.align)) | ((int)(cfg.vertical_align))));
	u32 color = sokol__sfons__rgba(cfg.color.r, cfg.color.g, cfg.color.b, cfg.color.a);
	if (cfg.color.a != 255) {
		sokol__sgl__load_pipeline(ctx->timage_pip);
	}
	fontstash__Context_set_color(ctx->ft->fons, color);
	f32 ascender = ((f32)(0.0));
	f32 descender = ((f32)(0.0));
	f32 lh = ((f32)(0.0));
	fontstash__Context_vert_metrics(ctx->ft->fons, &ascender, &descender, &lh);
}

void gg__Context_draw_text(gg__Context* ctx, int x, int y, string text_, gx__TextCfg cfg) {
	if (ctx->native_rendering) {
		if (cfg.align == _const_gx__align_right) {
			int width = gg__Context_text_width(ctx, text_);
			darwin_draw_string(x - width, ctx->height - y, text_, cfg);
		} else {
			darwin_draw_string(x, ctx->height - y, text_, cfg);
		}
		return;
	}
	if (!ctx->font_inited) {
		eprintln(_SLIT("gg: draw_text(): font not initialized"));
		return;
	}
	gg__Context_set_cfg(ctx, cfg);
	f32 scale = (ctx->ft->scale == 0 ? (((f32)(1))) : (ctx->ft->scale));
	fontstash__Context_draw_text(ctx->ft->fons, x * scale, y * scale, text_);
}

void gg__Context_draw_text_def(gg__Context* ctx, int x, int y, string text) {
	gg__Context_draw_text(ctx, x, y, text, ((gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,}));
}

void gg__FT_flush(gg__FT* ft) {
	sokol__sfons__flush(ft->fons);
}

int gg__Context_text_width(gg__Context* ctx, string s) {
	if (ctx->native_rendering) {
		int _t1 = darwin_text_width(s);
		return _t1;
	}
	if (!ctx->font_inited) {
		int _t2 = 0;
		return _t2;
	}
	Array_fixed_f32_4 buf = {0};
	fontstash__Context_text_bounds(ctx->ft->fons, 0, 0, s, &buf[0]);
	if (string_ends_with(s, _SLIT(" "))) {
		int _t3 = ((int)((buf[2] - buf[0]) / ctx->scale)) + gg__Context_text_width(ctx, _SLIT("i"));
		return _t3;
	}
	int res = ((int)((buf[2] - buf[0]) / ctx->scale));
	if (ctx->native_rendering) {
		int _t4 = res * 2;
		return _t4;
	}
	int _t5 = ((int)((buf[2] - buf[0]) / ctx->scale));
	return _t5;
}

int gg__Context_text_height(gg__Context* ctx, string s) {
	if (!ctx->font_inited) {
		int _t1 = 0;
		return _t1;
	}
	Array_fixed_f32_4 buf = {0};
	fontstash__Context_text_bounds(ctx->ft->fons, 0, 0, s, &buf[0]);
	int _t2 = ((int)((buf[3] - buf[1]) / ctx->scale));
	return _t2;
}

multi_return_int_int gg__Context_text_size(gg__Context* ctx, string s) {
	if (!ctx->font_inited) {
		return (multi_return_int_int){.arg0=0, .arg1=0};
	}
	Array_fixed_f32_4 buf = {0};
	fontstash__Context_text_bounds(ctx->ft->fons, 0, 0, s, &buf[0]);
	return (multi_return_int_int){.arg0=((int)((buf[2] - buf[0]) / ctx->scale)), .arg1=((int)((buf[3] - buf[1]) / ctx->scale))};
}

void gg__Context_draw_text_default(gg__Context* ctx, int x, int y, string text) {
	f32 scale = (ctx->ft->scale == 0 ? (((f32)(1))) : (ctx->ft->scale));
	fontstash__Context_draw_text(ctx->ft->fons, x * scale, y * scale, text);
}

void gg__Context_scissor_rect(gg__Context* ctx, int x, int y, int w, int h) {
	sokol__sgl__scissor_rect(x, y, w, h, true);
}

bool gg__Context_has_text_style(gg__Context* ctx) {
	bool _t1 = false;
	return _t1;
}

void gg__Context_set_text_style(gg__Context* ctx, string font_name, string font_path, int size, gx__Color color, int align, int vertical_align) {
}

// Attr: [inline]
inline bool gg__MouseButtons_is_empty(gg__MouseButtons* e) {
	bool _t1 = ((int)(*e)) == 0;
	return _t1;
}

// Attr: [inline]
inline bool gg__MouseButtons_has(gg__MouseButtons* e, gg__MouseButtons flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) != 0;
	return _t1;
}

// Attr: [inline]
inline bool gg__MouseButtons_all(gg__MouseButtons* e, gg__MouseButtons flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) == ((int)(flag));
	return _t1;
}

// Attr: [inline]
inline void gg__MouseButtons_set(gg__MouseButtons* e, gg__MouseButtons flag) {
	{ // Unsafe block
		*e = ((gg__MouseButtons)((((int)(*e)) | (((int)(flag))))));
	}
}

// Attr: [inline]
inline void gg__MouseButtons_clear(gg__MouseButtons* e, gg__MouseButtons flag) {
	{ // Unsafe block
		*e = ((gg__MouseButtons)((((int)(*e)) & ~(((int)(flag))))));
	}
}

// Attr: [inline]
inline void gg__MouseButtons_toggle(gg__MouseButtons* e, gg__MouseButtons flag) {
	{ // Unsafe block
		*e = ((gg__MouseButtons)((((int)(*e)) ^ (((int)(flag))))));
	}
}

// Attr: [inline]
inline bool gg__Modifier_is_empty(gg__Modifier* e) {
	bool _t1 = ((int)(*e)) == 0;
	return _t1;
}

// Attr: [inline]
inline bool gg__Modifier_has(gg__Modifier* e, gg__Modifier flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) != 0;
	return _t1;
}

// Attr: [inline]
inline bool gg__Modifier_all(gg__Modifier* e, gg__Modifier flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) == ((int)(flag));
	return _t1;
}

// Attr: [inline]
inline void gg__Modifier_set(gg__Modifier* e, gg__Modifier flag) {
	{ // Unsafe block
		*e = ((gg__Modifier)((((int)(*e)) | (((int)(flag))))));
	}
}

// Attr: [inline]
inline void gg__Modifier_clear(gg__Modifier* e, gg__Modifier flag) {
	{ // Unsafe block
		*e = ((gg__Modifier)((((int)(*e)) & ~(((int)(flag))))));
	}
}

// Attr: [inline]
inline void gg__Modifier_toggle(gg__Modifier* e, gg__Modifier flag) {
	{ // Unsafe block
		*e = ((gg__Modifier)((((int)(*e)) ^ (((int)(flag))))));
	}
}

// TypeDecl
f64 ui__linear(f64 x) {
	f64 _t1 = x;
	return _t1;
}

f64 ui__ease_in_quad(f64 x) {
	f64 _t1 = x * x;
	return _t1;
}

f64 ui__ease_out_quad(f64 x) {
	f64 _t1 = x * (2.0 - x);
	return _t1;
}

f64 ui__ease_in_out_quad(f64 x) {
	f64 _t1 = (x < .5 ? (2.0 * x * x) : (-1.0 + (4.0 - 2.0 * x) * x));
	return _t1;
}

f64 ui__ease_in_cubic(f64 x) {
	f64 _t1 = x * x * x;
	return _t1;
}

f64 ui__ease_out_cubic(f64 x) {
	f64 _t1 = (x - 1.0) * (x - 1.0) * (x - 1.0) + 1;
	return _t1;
}

f64 ui__ease_in_out_cubic(f64 x) {
	f64 _t1 = (x < .5 ? (4.0 * x * x * x) : ((x - 1.0) * (2.0 * x - 2.0) * (2.0 * x - 2.0) + 1.0));
	return _t1;
}

f64 ui__ease_in_quart(f64 x) {
	f64 _t1 = x * x * x * x;
	return _t1;
}

f64 ui__ease_out_quart(f64 x) {
	f64 _t1 = 1.0 - (x - 1.0) * (x - 1.0) * (x - 1.0) * (x - 1.0);
	return _t1;
}

f64 ui__ease_in_out_quart(f64 x) {
	f64 _t1 = (x < 0.5 ? (8.0 * x * x * x * x) : (1.0 - 8.0 * (x - 1.0) * (x - 1.0) * (x - 1.0) * (x - 1.0)));
	return _t1;
}

f64 ui__ease_in_quint(f64 x) {
	f64 _t1 = x * x * x * x * x;
	return _t1;
}

f64 ui__ease_out_quint(f64 x) {
	f64 _t1 = 1.0 + (x - 1.0) * (x - 1.0) * (x - 1.0) * (x - 1.0) * (x - 1.0);
	return _t1;
}

f64 ui__ease_in_out_quint(f64 x) {
	f64 _t1 = (x < 0.5 ? (16.0 * x * x * x * x * x) : (1.0 + 16.0 * (x - 1.0) * (x - 1.0) * (x - 1.0) * (x - 1.0) * (x - 1.0)));
	return _t1;
}

ui__EasingFunction ui__easing(ui__EasingType easingtype) {
	switch (easingtype) {
		case ui__EasingType__linear: 
			{
				ui__EasingFunction _t1 = (voidptr)ui__linear;
				return _t1;
				break;
			}
		case ui__EasingType__ease_in_quad: 
			{
				ui__EasingFunction _t2 = (voidptr)ui__ease_in_quad;
				return _t2;
				break;
			}
		case ui__EasingType__ease_out_quad: 
			{
				ui__EasingFunction _t3 = (voidptr)ui__ease_out_quad;
				return _t3;
				break;
			}
		case ui__EasingType__ease_in_out_quad: 
			{
				ui__EasingFunction _t4 = (voidptr)ui__ease_in_out_quad;
				return _t4;
				break;
			}
		case ui__EasingType__ease_in_cubic: 
			{
				ui__EasingFunction _t5 = (voidptr)ui__ease_in_cubic;
				return _t5;
				break;
			}
		case ui__EasingType__ease_out_cubic: 
			{
				ui__EasingFunction _t6 = (voidptr)ui__ease_out_cubic;
				return _t6;
				break;
			}
		case ui__EasingType__ease_in_out_cubic: 
			{
				ui__EasingFunction _t7 = (voidptr)ui__ease_in_out_cubic;
				return _t7;
				break;
			}
		case ui__EasingType__ease_in_quart: 
			{
				ui__EasingFunction _t8 = (voidptr)ui__ease_in_quart;
				return _t8;
				break;
			}
		case ui__EasingType__ease_out_quart: 
			{
				ui__EasingFunction _t9 = (voidptr)ui__ease_out_quart;
				return _t9;
				break;
			}
		case ui__EasingType__ease_in_out_quart: 
			{
				ui__EasingFunction _t10 = (voidptr)ui__ease_in_out_quart;
				return _t10;
				break;
			}
		case ui__EasingType__ease_in_quint: 
			{
				ui__EasingFunction _t11 = (voidptr)ui__ease_in_quint;
				return _t11;
				break;
			}
		case ui__EasingType__ease_out_quint: 
			{
				ui__EasingFunction _t12 = (voidptr)ui__ease_out_quint;
				return _t12;
				break;
			}
		case ui__EasingType__ease_in_out_quint: 
			{
				ui__EasingFunction _t13 = (voidptr)ui__ease_in_out_quint;
				return _t13;
				break;
			}
	}
	;
	return 0;
}

void ui__debug_draw_bb_stack(ui__Stack* s) {
	gx__Color col = _const_gx__red;
	if (s->direction == ui__Direction__row) {
		col = _const_gx__green;
	}
	multi_return_int_int mr_159 = ui__Stack_size(s);
	int w = mr_159.arg0;
	int h = mr_159.arg1;
	println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("debug_draw_bb_stack ["), 0xfe10, {.d_s = ui__Direction_str(s->direction)}}, {_SLIT("] w, h = s.size()"), 0, { .d_c = 0 }}})));
	println( str_intp(7, _MOV((StrIntpData[]){{_SLIT("  in: (s.x("), 0xfe07, {.d_i32 = s->x}}, {_SLIT(") - s.margin(.left)("), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__left)}}, {_SLIT("), s.y("), 0xfe07, {.d_i32 = s->y}}, {_SLIT(") - s.margin(.top)("), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__top)}}, {_SLIT("), w("), 0xfe07, {.d_i32 = w}}, {_SLIT("), h("), 0xfe07, {.d_i32 = h}}, {_SLIT("))"), 0, { .d_c = 0 }}})));
	println( str_intp(9, _MOV((StrIntpData[]){{_SLIT(" out: (s.x("), 0xfe07, {.d_i32 = s->x}}, {_SLIT("), s.y("), 0xfe07, {.d_i32 = s->y}}, {_SLIT("), w("), 0xfe07, {.d_i32 = w}}, {_SLIT(") - s.margin(.left)("), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__left)}}, {_SLIT(") - s.margin(.right)("), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__right)}}, {_SLIT("), h("), 0xfe07, {.d_i32 = h}}, {_SLIT(") - s.margin(.top)("), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__top)}}, {_SLIT(") - s.margin(.bottom)("), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__bottom)}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	gg__Context_draw_rect_empty(s->ui->gg, s->x - ui__Stack_margin(s, ui__Side__left), s->y - ui__Stack_margin(s, ui__Side__top), w, h, col);
	gg__Context_draw_rect_empty(s->ui->gg, s->x, s->y, w - ui__Stack_margin(s, ui__Side__left) - ui__Stack_margin(s, ui__Side__right), h - ui__Stack_margin(s, ui__Side__top) - ui__Stack_margin(s, ui__Side__bottom), col);
}

void ui__debug_draw_bb_widget(ui__Widget* wi, ui__UI* ui) {
	gx__Color col = _const_gx__black;
	multi_return_int_int mr_851 = ui__Widget_name_table[wi->_typ]._method_size(wi->_object);
	int w = mr_851.arg0;
	int h = mr_851.arg1;
	println( str_intp(6, _MOV((StrIntpData[]){{_SLIT("bb: "), 0xfe10, {.d_s = charptr_vstring_literal( /* ui.Widget */ v_typeof_interface_ui__Widget( (wi)->_typ ))}}, {_SLIT(" ("), 0xfe07, {.d_i32 = (*(wi->x))}}, {_SLIT(", "), 0xfe07, {.d_i32 = (*(wi->y))}}, {_SLIT(" ,"), 0xfe07, {.d_i32 = w}}, {_SLIT(", "), 0xfe07, {.d_i32 = h}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	gg__Context_draw_rect_empty(ui->gg, (*(wi->x)), (*(wi->y)), w, h, col);
}

void ui__debug_draw_bb_text(int x, int y, int w, int h, ui__UI* ui) {
	gx__Color col = _const_gx__gray;
	gg__Context_draw_rect_empty(ui->gg, x, y, w, h, col);
}

void ui__debug_show_cache(ui__Stack* s, int depth, string txt) {
	if (depth == 0) {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Show cache "), 0xfe10, {.d_s = s->id}}, {_SLIT(" =>"), 0, { .d_c = 0 }}})));
	}
	string tab = string_repeat(_SLIT("  "), depth);
	println( str_intp(7, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tab}}, {_SLIT(" ("), 0xfe07, {.d_i32 = depth}}, {_SLIT(") Stack "), 0xfe10, {.d_s = s->id}}, {_SLIT(" with "), 0xfe07, {.d_i32 = s->children.len}}, {_SLIT(" children: ("), 0xfe07, {.d_i32 = s->cache.fixed_widths.len}}, {_SLIT(", "), 0xfe07, {.d_i32 = s->cache.fixed_heights.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	multi_return_int_int mr_1770 = ui__Stack_free_size(s);
	int free_width = mr_1770.arg0;
	int free_height = mr_1770.arg1;
	multi_return_int_int mr_1810 = ui__Stack_adj_size(s);
	int adj_width = mr_1810.arg0;
	int adj_height = mr_1810.arg1;
	multi_return_int_int mr_1851 = ui__Stack_size(s);
	int real_width = mr_1851.arg0;
	int real_height = mr_1851.arg1;
	println( str_intp(8, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tab}}, {_SLIT("   free size: ("), 0xfe07, {.d_i32 = free_width}}, {_SLIT(", "), 0xfe07, {.d_i32 = free_height}}, {_SLIT(") adj_size: ("), 0xfe07, {.d_i32 = adj_width}}, {_SLIT(", "), 0xfe07, {.d_i32 = adj_height}}, {_SLIT(") real_size: ("), 0xfe07, {.d_i32 = real_width}}, {_SLIT(", "), 0xfe07, {.d_i32 = real_height}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	println( str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tab}}, {_SLIT("   types: (widths: "), 0xfe10, {.d_s = Array_ui__ChildSize_str(s->cache.width_type)}}, {_SLIT(", heights: "), 0xfe10, {.d_s = Array_ui__ChildSize_str(s->cache.height_type)}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	println( str_intp(7, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tab}}, {_SLIT("   margins: ("), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__top)}}, {_SLIT(", "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__bottom)}}, {_SLIT(", "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__left)}}, {_SLIT(", "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__right)}}, {_SLIT(") total_spacing: "), 0xfe07, {.d_i32 = ui__Stack_total_spacing(s)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	println( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tab}}, {_SLIT("   margin"), 0, { .d_c = 0 }}})));
	multi_return_Array_int_Array_int mr_2271 = ui__Stack_children_sizes(s);
	Array_int widths = mr_2271.arg0;
	Array_int heights = mr_2271.arg1;
	println(txt);
	for (int i = 0; i < s->children.len; ++i) {
		ui__Widget* child = ((ui__Widget*)s->children.data) + i;
		string name = charptr_vstring_literal( /* ui.Widget */ v_typeof_interface_ui__Widget( (child)->_typ ));
		if ((child)->_typ == _ui__Widget_ui__Stack_index) {
			string tmp =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tab}}, {_SLIT("      ("), 0xfe07, {.d_i32 = depth}}, {_SLIT("-"), 0xfe07, {.d_i32 = i}}, {_SLIT(") Stack "), 0xfe10, {.d_s = (child->_ui__Stack)->id}}, {_SLIT(" :"), 0, { .d_c = 0 }}}));
			tmp = /*f*/string__plus(tmp,  str_intp(6, _MOV((StrIntpData[]){{_SLIT("\n"), 0xfe10, {.d_s = tab}}, {_SLIT("      fixed("), 0xfe07, {.d_i32 = (*(int*)/*ee elem_sym */array_get(s->cache.fixed_widths, i))}}, {_SLIT(","), 0xfe07, {.d_i32 = (*(int*)/*ee elem_sym */array_get(s->cache.fixed_heights, i))}}, {_SLIT(") weight: ("), 0x1fe0f, {.d_f64 = (*(f64*)/*ee elem_sym */array_get(s->cache.weight_widths, i))}}, {_SLIT(","), 0x1fe0f, {.d_f64 = (*(f64*)/*ee elem_sym */array_get(s->cache.weight_heights, i))}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			tmp = /*f*/string__plus(tmp,  str_intp(4, _MOV((StrIntpData[]){{_SLIT("\n"), 0xfe10, {.d_s = tab}}, {_SLIT("      size: ("), 0xfe07, {.d_i32 = (*(int*)/*ee elem_sym */array_get(widths, i))}}, {_SLIT(","), 0xfe07, {.d_i32 = (*(int*)/*ee elem_sym */array_get(heights, i))}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			ui__debug_show_cache((child->_ui__Stack), depth + 1, tmp);
		} else {
			multi_return_int_int mr_2729 = ui__Widget_name_table[child->_typ]._method_size(child->_object);
			int w = mr_2729.arg0;
			int h = mr_2729.arg1;
			println( str_intp(11, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = tab}}, {_SLIT("      ("), 0xfe07, {.d_i32 = depth}}, {_SLIT("-"), 0xfe07, {.d_i32 = i}}, {_SLIT(") Widget "), 0xfe10, {.d_s = name}}, {_SLIT(" size("), 0xfe07, {.d_i32 = w}}, {_SLIT(", "), 0xfe07, {.d_i32 = h}}, {_SLIT(") fixed("), 0xfe07, {.d_i32 = (*(int*)/*ee elem_sym */array_get(s->cache.fixed_widths, i))}}, {_SLIT(","), 0xfe07, {.d_i32 = (*(int*)/*ee elem_sym */array_get(s->cache.fixed_heights, i))}}, {_SLIT(") weight("), 0x1fe0f, {.d_f64 = (*(f64*)/*ee elem_sym */array_get(s->cache.weight_widths, i))}}, {_SLIT(","), 0x1fe0f, {.d_f64 = (*(f64*)/*ee elem_sym */array_get(s->cache.weight_heights, i))}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
		}
	}
}

void ui__debug_show_size(ui__Stack* s, string t) {
	print( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = t}}, {_SLIT("size of Stack "), 0xfe10, {.d_s = _SLIT("&ui.Stack")}}, {_SLIT0, 0, { .d_c = 0 }}})));
	printf(" %p: ", s);
	println( str_intp(3, _MOV((StrIntpData[]){{_SLIT(" ("), 0xfe07, {.d_i32 = s->width}}, {_SLIT(", "), 0xfe07, {.d_i32 = s->height}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
}

void ui__debug_show_sizes(ui__Stack* s, string t) {
	ui__Layout parent = s->parent;
	multi_return_int_int mr_3165 = ui__Stack_size(s);
	int sw = mr_3165.arg0;
	int sh = mr_3165.arg1;
	print( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = t}}, {_SLIT("Stack "), 0xfe10, {.d_s = _SLIT("&ui.Stack")}}, {_SLIT0, 0, { .d_c = 0 }}})));
	printf(" %p", *s);
	println( str_intp(8, _MOV((StrIntpData[]){{_SLIT(" => size ("), 0xfe07, {.d_i32 = sw}}, {_SLIT(", "), 0xfe07, {.d_i32 = sh}}, {_SLIT("), ("), 0xfe07, {.d_i32 = s->width}}, {_SLIT(", "), 0xfe07, {.d_i32 = s->height}}, {_SLIT(")  adj: ("), 0xfe07, {.d_i32 = s->adj_width}}, {_SLIT(", "), 0xfe07, {.d_i32 = s->adj_height}}, {_SLIT(") spacing: "), 0xfe10, {.d_s = Array_f32_str(s->spacings)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if ((parent)._typ == _ui__Layout_ui__Stack_index) {
		printf(" %p", (parent._ui__Stack));
		println( str_intp(6, _MOV((StrIntpData[]){{_SLIT("=> size ("), 0xfe07, {.d_i32 = (parent._ui__Stack)->width}}, {_SLIT(", "), 0xfe07, {.d_i32 = (parent._ui__Stack)->height}}, {_SLIT(")  adj: ("), 0xfe07, {.d_i32 = (parent._ui__Stack)->adj_width}}, {_SLIT(", "), 0xfe07, {.d_i32 = (parent._ui__Stack)->adj_height}}, {_SLIT(") spacing: "), 0xfe10, {.d_s = Array_f32_str((parent._ui__Stack)->spacings)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	} else if ((parent)._typ == _ui__Layout_ui__Window_index) {
		println( str_intp(5, _MOV((StrIntpData[]){{_SLIT("	parent: Window => size ("), 0xfe07, {.d_i32 = (parent._ui__Window)->width}}, {_SLIT(", "), 0xfe07, {.d_i32 = (parent._ui__Window)->height}}, {_SLIT(")  orig: ("), 0xfe07, {.d_i32 = (parent._ui__Window)->orig_width}}, {_SLIT(", "), 0xfe07, {.d_i32 = (parent._ui__Window)->orig_height}}, {_SLIT(") "), 0, { .d_c = 0 }}})));
	}
	for (int i = 0; i < s->children.len; ++i) {
		ui__Widget* child = ((ui__Widget*)s->children.data) + i;
		multi_return_int_int mr_3763 = ui__Widget_name_table[child->_typ]._method_size(child->_object);
		int w = mr_3763.arg0;
		int h = mr_3763.arg1;
		print( str_intp(3, _MOV((StrIntpData[]){{_SLIT("		"), 0xfe07, {.d_i32 = i}}, {_SLIT(") "), 0xfe10, {.d_s = charptr_vstring_literal( /* ui.Widget */ v_typeof_interface_ui__Widget( (child)->_typ ))}}, {_SLIT0, 0, { .d_c = 0 }}})));
		printf(" %p", *child);
		println( str_intp(3, _MOV((StrIntpData[]){{_SLIT(" size => "), 0xfe07, {.d_i32 = w}}, {_SLIT(", "), 0xfe07, {.d_i32 = h}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}

void ui__debug_set_children_sizes(ui__Stack* s, Array_int widths, Array_int heights, ui__CachedSizes c) {
	println( str_intp(5, _MOV((StrIntpData[]){{_SLIT("scs: pos: ("), 0xfe07, {.d_i32 = s->x}}, {_SLIT(", "), 0xfe07, {.d_i32 = s->y}}, {_SLIT(") real: ("), 0xfe07, {.d_i32 = s->real_width}}, {_SLIT(", "), 0xfe07, {.d_i32 = s->real_height}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	int total = 0;
	if (s->direction == ui__Direction__row) {
		println( str_intp(5, _MOV((StrIntpData[]){{_SLIT("SumRule("), 0xfe10, {.d_s = s->id}}, {_SLIT(") left: "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__left)}}, {_SLIT(" = "), 0x1fe0e, {.d_f32 = s->margins.left}}, {_SLIT(" * "), 0xfe07, {.d_i32 = s->real_width}}, {_SLIT0, 0, { .d_c = 0 }}})));
		total += ui__Stack_margin(s, ui__Side__left);
		for (int i = 0; i < s->children.len; ++i) {
			ui__Widget child = ((ui__Widget*)s->children.data)[i];
			println( str_intp(5, _MOV((StrIntpData[]){{_SLIT("+ w["), 0xfe07, {.d_i32 = i}}, {_SLIT("]: "), 0xfe07, {.d_i32 = (*(int*)/*ee elem_sym */array_get(widths, i))}}, {_SLIT(" "), 0x1fe0f, {.d_f64 = (*(f64*)/*ee elem_sym */array_get(c.weight_widths, i))}}, {_SLIT(" ("), 0xfe10, {.d_s = (*(child.id))}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			total += (*(int*)/*ee elem_sym */array_get(widths, i));
			if (i == s->children.len - 1) {
				println( str_intp(4, _MOV((StrIntpData[]){{_SLIT("+ right: "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__right)}}, {_SLIT(" = "), 0x1fe0e, {.d_f32 = s->margins.right}}, {_SLIT(" * "), 0xfe07, {.d_i32 = s->real_width}}, {_SLIT0, 0, { .d_c = 0 }}})));
				total += ui__Stack_margin(s, ui__Side__right);
			} else {
				println( str_intp(4, _MOV((StrIntpData[]){{_SLIT("+ spacing["), 0xfe07, {.d_i32 = i}}, {_SLIT("]: "), 0xfe07, {.d_i32 = ui__Stack_spacing(s, i)}}, {_SLIT(" "), 0x1fe0e, {.d_f32 = (*(f32*)/*ee elem_sym */array_get(s->spacings, i))}}, {_SLIT0, 0, { .d_c = 0 }}})));
				total += ui__Stack_spacing(s, i);
			}
		}
		println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("= "), 0xfe07, {.d_i32 = total}}, {_SLIT(" == "), 0xfe07, {.d_i32 = s->real_width}}, {_SLIT0, 0, { .d_c = 0 }}})));
		println( str_intp(5, _MOV((StrIntpData[]){{_SLIT("MaxRule("), 0xfe10, {.d_s = s->id}}, {_SLIT(")  top: "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__top)}}, {_SLIT(" = "), 0x1fe0e, {.d_f32 = s->margins.top}}, {_SLIT(" * "), 0xfe07, {.d_i32 = s->real_height}}, {_SLIT0, 0, { .d_c = 0 }}})));
		total = 0;
		for (int i = 0; i < s->children.len; ++i) {
			if ((*(int*)/*ee elem_sym */array_get(heights, i)) > total) {
				total = (*(int*)/*ee elem_sym */array_get(heights, i));
			}
			println( str_intp(5, _MOV((StrIntpData[]){{_SLIT("max "), 0xfe07, {.d_i32 = total}}, {_SLIT(" | current w["), 0xfe07, {.d_i32 = i}}, {_SLIT("]: "), 0xfe07, {.d_i32 = (*(int*)/*ee elem_sym */array_get(heights, i))}}, {_SLIT(" "), 0x1fe0f, {.d_f64 = (*(f64*)/*ee elem_sym */array_get(c.weight_heights, i))}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		println( str_intp(4, _MOV((StrIntpData[]){{_SLIT(" bottom: "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__bottom)}}, {_SLIT(" = "), 0x1fe0e, {.d_f32 = s->margins.bottom}}, {_SLIT(" * "), 0xfe07, {.d_i32 = s->real_height}}, {_SLIT0, 0, { .d_c = 0 }}})));
		println( str_intp(6, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe07, {.d_i32 = s->real_height}}, {_SLIT(" == "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__top) + total + ui__Stack_margin(s, ui__Side__bottom)}}, {_SLIT(" = "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__top)}}, {_SLIT(" + "), 0xfe07, {.d_i32 = total}}, {_SLIT(" + "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__bottom)}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
	} else {
		println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("SumRule("), 0xfe10, {.d_s = s->id}}, {_SLIT(")  top: "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__top)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		total += ui__Stack_margin(s, ui__Side__top);
		for (int i = 0; i < s->children.len; ++i) {
			ui__Widget child = ((ui__Widget*)s->children.data)[i];
			println( str_intp(5, _MOV((StrIntpData[]){{_SLIT("+ w["), 0xfe07, {.d_i32 = i}}, {_SLIT("]: "), 0xfe07, {.d_i32 = (*(int*)/*ee elem_sym */array_get(heights, i))}}, {_SLIT(" "), 0x1fe0f, {.d_f64 = (*(f64*)/*ee elem_sym */array_get(c.weight_heights, i))}}, {_SLIT(" ("), 0xfe10, {.d_s = (*(child.id))}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			total += (*(int*)/*ee elem_sym */array_get(heights, i));
			if (i == s->children.len - 1) {
				println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("+ bottom: "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__bottom)}}, {_SLIT(" "), 0x1fe0e, {.d_f32 = s->margins.bottom}}, {_SLIT0, 0, { .d_c = 0 }}})));
				total += ui__Stack_margin(s, ui__Side__bottom);
			} else {
				println( str_intp(4, _MOV((StrIntpData[]){{_SLIT("+ spacing["), 0xfe07, {.d_i32 = i}}, {_SLIT("]: "), 0xfe07, {.d_i32 = ui__Stack_spacing(s, i)}}, {_SLIT(" "), 0x1fe0e, {.d_f32 = (*(f32*)/*ee elem_sym */array_get(s->spacings, i))}}, {_SLIT0, 0, { .d_c = 0 }}})));
				total += ui__Stack_spacing(s, i);
			}
		}
		println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("= "), 0xfe07, {.d_i32 = total}}, {_SLIT(" == "), 0xfe07, {.d_i32 = s->real_height}}, {_SLIT0, 0, { .d_c = 0 }}})));
		println( str_intp(5, _MOV((StrIntpData[]){{_SLIT("MaxRule("), 0xfe10, {.d_s = s->id}}, {_SLIT(")  top: "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__left)}}, {_SLIT(" = "), 0x1fe0e, {.d_f32 = s->margins.left}}, {_SLIT(" * "), 0xfe07, {.d_i32 = s->real_width}}, {_SLIT0, 0, { .d_c = 0 }}})));
		total = 0;
		for (int i = 0; i < s->children.len; ++i) {
			if ((*(int*)/*ee elem_sym */array_get(widths, i)) > total) {
				total = (*(int*)/*ee elem_sym */array_get(widths, i));
			}
			println( str_intp(5, _MOV((StrIntpData[]){{_SLIT("max "), 0xfe07, {.d_i32 = total}}, {_SLIT(" | current w["), 0xfe07, {.d_i32 = i}}, {_SLIT("]: "), 0xfe07, {.d_i32 = (*(int*)/*ee elem_sym */array_get(widths, i))}}, {_SLIT(" "), 0x1fe0f, {.d_f64 = (*(f64*)/*ee elem_sym */array_get(c.weight_widths, i))}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		println( str_intp(4, _MOV((StrIntpData[]){{_SLIT(" right: "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__right)}}, {_SLIT(" = "), 0x1fe0e, {.d_f32 = s->margins.right}}, {_SLIT(" * "), 0xfe07, {.d_i32 = s->real_width}}, {_SLIT0, 0, { .d_c = 0 }}})));
		println( str_intp(6, _MOV((StrIntpData[]){{_SLIT(" "), 0xfe07, {.d_i32 = s->real_width}}, {_SLIT(" == "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__left) + total + ui__Stack_margin(s, ui__Side__right)}}, {_SLIT(" = "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__left)}}, {_SLIT(" + "), 0xfe07, {.d_i32 = total}}, {_SLIT(" + "), 0xfe07, {.d_i32 = ui__Stack_margin(s, ui__Side__right)}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
	}
}

bool ui__is_empty_text_cfg(gx__TextCfg t) {
	bool _t1 = string__eq(gx__TextCfg_str(t), gx__TextCfg_str(_const_ui__empty_text_cfg));
	return _t1;
}

multi_return_int_int ui__text_size_T_ui__Button(ui__Button* widget, string text) {
	gg__Context_set_cfg(widget->ui->gg, widget->text_cfg);
	multi_return_int_int _t1 = gg__Context_text_size(widget->ui->gg, text);
	return _t1;
}
multi_return_int_int ui__text_size_T_ui__Label(ui__Label* widget, string text) {
	gg__Context_set_cfg(widget->ui->gg, widget->text_cfg);
	multi_return_int_int _t1 = gg__Context_text_size(widget->ui->gg, text);
	return _t1;
}
multi_return_int_int ui__text_size_T_ui__Rectangle(ui__Rectangle* widget, string text) {
	gg__Context_set_cfg(widget->ui->gg, widget->text_cfg);
	multi_return_int_int _t1 = gg__Context_text_size(widget->ui->gg, text);
	return _t1;
}
multi_return_int_int ui__text_size_T_ui__TextBox(ui__TextBox* widget, string text) {
	gg__Context_set_cfg(widget->ui->gg, widget->text_cfg);
	multi_return_int_int _t1 = gg__Context_text_size(widget->ui->gg, text);
	return _t1;
}

int ui__text_width_T_ui__CheckBox(ui__CheckBox* w, string text) {
	gg__Context_set_cfg(w->ui->gg, w->text_cfg);
	int _t1 = gg__Context_text_width(w->ui->gg, text);
	return _t1;
}
int ui__text_width_T_ui__ListBox(ui__ListBox* w, string text) {
	gg__Context_set_cfg(w->ui->gg, w->text_cfg);
	int _t1 = gg__Context_text_width(w->ui->gg, text);
	return _t1;
}
int ui__text_width_T_ui__Radio(ui__Radio* w, string text) {
	gg__Context_set_cfg(w->ui->gg, w->text_cfg);
	int _t1 = gg__Context_text_width(w->ui->gg, text);
	return _t1;
}
int ui__text_width_T_ui__TextBox(ui__TextBox* w, string text) {
	gg__Context_set_cfg(w->ui->gg, w->text_cfg);
	int _t1 = gg__Context_text_width(w->ui->gg, text);
	return _t1;
}

int ui__text_height_T_ui__ListBox(ui__ListBox* w, string text) {
	gg__Context_set_cfg(w->ui->gg, w->text_cfg);
	int _t1 = gg__Context_text_height(w->ui->gg, text);
	return _t1;
}
int ui__text_height_T_ui__TextBox(ui__TextBox* w, string text) {
	gg__Context_set_cfg(w->ui->gg, w->text_cfg);
	int _t1 = gg__Context_text_height(w->ui->gg, text);
	return _t1;
}

void ui__draw_text_T_ui__Rectangle(ui__Rectangle* w, int x, int y, string text_) {
	ui__Window* window = w->ui->window;
	if (w->text_size > 0) {
		multi_return_int_int mr_757 = ui__Window_size(window);
		int win_height = mr_757.arg1;
		gx__TextCfg tc = ((gx__TextCfg){w->text_cfg.color,.size = ui__text_size_as_int(w->text_size, win_height),w->text_cfg.align,w->text_cfg.vertical_align,w->text_cfg.max_width,w->text_cfg.family,w->text_cfg.bold,w->text_cfg.mono,w->text_cfg.italic,});
		gg__Context_draw_text(w->ui->gg, x, y, text_, tc);
	} else {
		gg__Context_draw_text(w->ui->gg, x, y, text_, w->text_cfg);
	}
}

void ui__init_text_cfg(ui__DrawText* w) {
	if (ui__is_empty_text_cfg((*(w->text_cfg)))) {
		(*(w->text_cfg)) = (*(w->ui))->window->text_cfg;
	}
	if ((*(w->text_size)) > 0) {
		multi_return_int_int mr_1749 = ui__Window_size((*(w->ui))->window);
		int win_height = mr_1749.arg1;
		(*(w->text_cfg)) = ((gx__TextCfg){(*(w->text_cfg)).color,.size = ui__text_size_as_int((*(w->text_size)), win_height),(*(w->text_cfg)).align,(*(w->text_cfg)).vertical_align,(*(w->text_cfg)).max_width,(*(w->text_cfg)).family,(*(w->text_cfg)).bold,(*(w->text_cfg)).mono,(*(w->text_cfg)).italic,});
	}
}

multi_return_int_int ui__get_text_size(ui__DrawText w, string text_) {
	gg__Context_set_cfg((*(w.ui))->gg, (*(w.text_cfg)));
	multi_return_int_int _t1 = gg__Context_text_size((*(w.ui))->gg, text_);
	return _t1;
}

void ui__set_text_cfg_color(ui__DrawText* w, gx__Color color) {
	(*(w->text_cfg)) = ((gx__TextCfg){.color = color,(*(w->text_cfg)).size,(*(w->text_cfg)).align,(*(w->text_cfg)).vertical_align,(*(w->text_cfg)).max_width,(*(w->text_cfg)).family,(*(w->text_cfg)).bold,(*(w->text_cfg)).mono,(*(w->text_cfg)).italic,});
}

void ui__set_text_cfg_size(ui__DrawText* w, int size) {
	(*(w->text_cfg)) = ((gx__TextCfg){(*(w->text_cfg)).color,.size = size,(*(w->text_cfg)).align,(*(w->text_cfg)).vertical_align,(*(w->text_cfg)).max_width,(*(w->text_cfg)).family,(*(w->text_cfg)).bold,(*(w->text_cfg)).mono,(*(w->text_cfg)).italic,});
}

void ui__set_text_cfg_style(ui__DrawText* w, bool bold, bool italic, bool mono) {
	(*(w->text_cfg)) = ((gx__TextCfg){(*(w->text_cfg)).color,(*(w->text_cfg)).size,(*(w->text_cfg)).align,(*(w->text_cfg)).vertical_align,(*(w->text_cfg)).max_width,(*(w->text_cfg)).family,.bold = bold,.mono = mono,.italic = italic,});
}

void ui__set_text_cfg_align(ui__DrawText* w, gx__HorizontalAlign align) {
	(*(w->text_cfg)) = ((gx__TextCfg){(*(w->text_cfg)).color,(*(w->text_cfg)).size,.align = align,(*(w->text_cfg)).vertical_align,(*(w->text_cfg)).max_width,(*(w->text_cfg)).family,(*(w->text_cfg)).bold,(*(w->text_cfg)).mono,(*(w->text_cfg)).italic,});
}

void ui__set_text_cfg_vertical_align(ui__DrawText* w, gx__VerticalAlign align) {
	(*(w->text_cfg)) = ((gx__TextCfg){(*(w->text_cfg)).color,(*(w->text_cfg)).size,(*(w->text_cfg)).align,.vertical_align = align,(*(w->text_cfg)).max_width,(*(w->text_cfg)).family,(*(w->text_cfg)).bold,(*(w->text_cfg)).mono,(*(w->text_cfg)).italic,});
}

void ui__draw_text_lines(ui__DrawText w, int x, int y, Array_string lines) {
	int th = 0;
	for (int _t1 = 0; _t1 < lines.len; ++_t1) {
		string line = ((string*)lines.data)[_t1];
		gg__Context_draw_text((*(w.ui))->gg, x, y + th, line, (*(w.text_cfg)));
		multi_return_int_int mr_3186 = ui__get_text_size(w, line);
		int tmp = mr_3186.arg1;
		th += tmp;
	}
}

void ui__update_text_size(ui__DrawText* w) {
	if ((*(w->text_size)) > 0) {
		multi_return_int_int mr_3306 = ui__Window_size((*(w->ui))->window);
		int win_height = mr_3306.arg1;
		(*(w->text_cfg)) = ((gx__TextCfg){(*(w->text_cfg)).color,.size = ui__text_size_as_int((*(w->text_size)), win_height),(*(w->text_cfg)).align,(*(w->text_cfg)).vertical_align,(*(w->text_cfg)).max_width,(*(w->text_cfg)).family,(*(w->text_cfg)).bold,(*(w->text_cfg)).mono,(*(w->text_cfg)).italic,});
	}
}

int ui__text_size_as_int(f64 size, int win_height) {
	int _t1 = (size > 0 && size < 1 ? (((int)(size * win_height))) : size == ((int)(size)) ? (((int)(size))) : (0));
	return _t1;
}

bool ui__point_inside_T_ui__CanvasLayout(ui__CanvasLayout* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->width && y >= wy && y <= wy + w->height;
	return _t1;
}
bool ui__point_inside_T_ui__Group(ui__Group* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->width && y >= wy && y <= wy + w->height;
	return _t1;
}
bool ui__point_inside_T_ui__Stack(ui__Stack* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->width && y >= wy && y <= wy + w->height;
	return _t1;
}
bool ui__point_inside_T_ui__Button(ui__Button* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->width && y >= wy && y <= wy + w->height;
	return _t1;
}
bool ui__point_inside_T_ui__Canvas(ui__Canvas* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->width && y >= wy && y <= wy + w->height;
	return _t1;
}
bool ui__point_inside_T_ui__CheckBox(ui__CheckBox* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->width && y >= wy && y <= wy + w->height;
	return _t1;
}
bool ui__point_inside_T_ui__Grid(ui__Grid* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->width && y >= wy && y <= wy + w->height;
	return _t1;
}
bool ui__point_inside_T_ui__ListBox(ui__ListBox* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->width && y >= wy && y <= wy + w->height;
	return _t1;
}
bool ui__point_inside_T_ui__Menu(ui__Menu* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->width && y >= wy && y <= wy + w->height;
	return _t1;
}
bool ui__point_inside_T_ui__Picture(ui__Picture* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->width && y >= wy && y <= wy + w->height;
	return _t1;
}
bool ui__point_inside_T_ui__ProgressBar(ui__ProgressBar* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->width && y >= wy && y <= wy + w->height;
	return _t1;
}
bool ui__point_inside_T_ui__Rectangle(ui__Rectangle* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->width && y >= wy && y <= wy + w->height;
	return _t1;
}
bool ui__point_inside_T_ui__Slider(ui__Slider* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->width && y >= wy && y <= wy + w->height;
	return _t1;
}
bool ui__point_inside_T_ui__Switch(ui__Switch* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->width && y >= wy && y <= wy + w->height;
	return _t1;
}
bool ui__point_inside_T_ui__TextBox(ui__TextBox* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->width && y >= wy && y <= wy + w->height;
	return _t1;
}

bool ui__point_inside_adj_T_ui__CanvasLayout(ui__CanvasLayout* w, f64 x, f64 y) {
	int wx = w->x + w->offset_x;
	int wy = w->y + w->offset_y;
	bool _t1 = x >= wx && x <= wx + w->adj_width && y >= wy && y <= wy + w->adj_height;
	return _t1;
}

gx__Color ui__hsv_to_rgb(f64 h, f64 s, f64 v) {
	f64 c = v * s;
	f64 x = c * (1.0 - math__abs_T_f64(math__fmod(h * 6.0, 2.0) - 1.0));
	f64 m = v - c;
	f64 r = 0.0;
	f64 g = 0.0;
	f64 b = 0.0;
	f64 h6 = h * 6.0;
	if (h6 < 1.0) {
		r = c;
		g = x;
	} else if (h6 < 2.0) {
		r = x;
		g = c;
	} else if (h6 < 3.0) {
		g = c;
		b = x;
	} else if (h6 < 4.0) {
		g = x;
		b = c;
	} else if (h6 < 5.0) {
		r = x;
		b = c;
	} else {
		r = c;
		b = x;
	}
	gx__Color _t1 = gx__rgb(((u8)((r + m) * 255.0)), ((u8)((g + m) * 255.0)), ((u8)((b + m) * 255.0)));
	return _t1;
}

gx__Color ui__hsl_to_rgb(f64 h, f64 s, f64 l) {
	f64 c = (1.0 - math__abs_T_f64(2.0 * l - 1.0)) * s;
	f64 x = c * (1.0 - math__abs_T_f64(math__fmod(h * 6.0, 2.0) - 1.0));
	f64 m = l - c / 2.0;
	f64 r = 0.0;
	f64 g = 0.0;
	f64 b = 0.0;
	f64 h6 = h * 6.0;
	if (h6 < 1.0) {
		r = c;
		g = x;
	} else if (h6 < 2.0) {
		r = x;
		g = c;
	} else if (h6 < 3.0) {
		g = c;
		b = x;
	} else if (h6 < 4.0) {
		g = x;
		b = c;
	} else if (h6 < 5.0) {
		r = x;
		b = c;
	} else {
		r = c;
		b = x;
	}
	gx__Color _t1 = gx__rgb(((u8)((r + m) * 255.0)), ((u8)((g + m) * 255.0)), ((u8)((b + m) * 255.0)));
	return _t1;
}

multi_return_f64_f64_f64 ui__rgb_to_hsv(gx__Color col) {
	f64 r = ((f64)(col.r)) / 255.0;
	f64 g = ((f64)(col.g)) / 255.0;
	f64 b = ((f64)(col.b)) / 255.0;
	f64 v = f64_max(f64_max(r, g), b);
	f64 m = -f64_max(f64_max(-r, -g), -b);
	f64 d = v - m;
	f64 h = 0.0;
	f64 s = 0.0;
	if (v == m) {
		h = 0;
	} else if (v == r) {
		if (g > b) {
			h = ((g - b) / d) / 6.0;
		} else {
			h = (6.0 - (g - b) / d) / 6;
		}
	} else if (v == g) {
		h = ((b - r) / d + 2.0) / 6.0;
	} else if (v == b) {
		h = ((r - g) / d + 4.0) / 6.0;
	}
	if (v != 0) {
		s = d / v;
	}
	if (h > 1.0) {
		h = 2.0 - h;
	}
	return (multi_return_f64_f64_f64){.arg0=h, .arg1=s, .arg2=v};
}

multi_return_f64_f64_f64 ui__rgb_to_hsl(gx__Color col) {
	f64 r = ((f64)(col.r)) / 255.0;
	f64 g = ((f64)(col.g)) / 255.0;
	f64 b = ((f64)(col.b)) / 255.0;
	f64 v = f64_max(f64_max(r, g), b);
	f64 m = -f64_max(f64_max(-r, -g), -b);
	f64 d = v - m;
	f64 h = 0.0;
	f64 s = 0.0;
	if (v == m) {
		h = 0;
	} else if (v == r) {
		if (g > b) {
			h = ((g - b) / d) / 6.0;
		} else {
			h = (6.0 - (g - b) / d) / 6;
		}
	} else if (v == g) {
		h = ((b - r) / d + 2.0) / 6.0;
	} else if (v == b) {
		h = ((r - g) / d + 4.0) / 6.0;
	}
	f64 l = (v + m) / 2.0;
	if (v != 0) {
		s = d / (1.0 - math__abs_T_f64(2 * l - 1.0));
	}
	return (multi_return_f64_f64_f64){.arg0=h, .arg1=s, .arg2=l};
}

struct sg_image ui__create_texture(int w, int h, u8* buf) {
	struct sg_image_desc img_desc = ((struct sg_image_desc){
		._start_canary = 0,
		.type = 0,
		.render_target = 0,
		.width = w,
		.height = h,
		.num_slices = 0,
		.num_mipmaps = 0,
		.usage = 0,
		.pixel_format = 0,
		.sample_count = 0,
		.min_filter = sokol__gfx__Filter__linear,
		.mag_filter = sokol__gfx__Filter__linear,
		.wrap_u = sokol__gfx__Wrap__clamp_to_edge,
		.wrap_v = sokol__gfx__Wrap__clamp_to_edge,
		.wrap_w = 0,
		.border_color = 0,
		.max_anisotropy = 0,
		.min_lod = 0,
		.max_lod = 0,
		.data = {0},
		.label = ((u8*)(0)),
		.gl_textures = {0},
		.gl_texture_target = 0,
		.mtl_textures = {0},
		.d3d11_texture = 0,
		.d3d11_shader_resource_view = 0,
		.wgpu_texture = 0,
		._end_canary = 0,
	});
	int sz = w * h * 4;
	img_desc.data.subimage[0][0] = ((struct sg_range){.ptr = buf,.size = ((usize)(sz)),});
	struct sg_image sg_img = sg_make_image(&img_desc);
	struct sg_image _t1 = sg_img;
	return _t1;
}

void ui__destroy_texture(struct sg_image sg_img) {
	sg_destroy_image(sg_img);
}

struct sg_image ui__create_dynamic_texture(int w, int h) {
	struct sg_image_desc img_desc = ((struct sg_image_desc){
		._start_canary = 0,
		.type = 0,
		.render_target = 0,
		.width = w,
		.height = h,
		.num_slices = 0,
		.num_mipmaps = 0,
		.usage = sokol__gfx__Usage__dynamic,
		.pixel_format = 0,
		.sample_count = 0,
		.min_filter = sokol__gfx__Filter__linear,
		.mag_filter = sokol__gfx__Filter__linear,
		.wrap_u = sokol__gfx__Wrap__clamp_to_edge,
		.wrap_v = sokol__gfx__Wrap__clamp_to_edge,
		.wrap_w = 0,
		.border_color = 0,
		.max_anisotropy = 0,
		.min_lod = 0,
		.max_lod = 0,
		.data = {0},
		.label = ((u8*)(0)),
		.gl_textures = {0},
		.gl_texture_target = 0,
		.mtl_textures = {0},
		.d3d11_texture = 0,
		.d3d11_shader_resource_view = 0,
		.wgpu_texture = 0,
		._end_canary = 0,
	});
	struct sg_image sg_img = sg_make_image(&img_desc);
	struct sg_image _t1 = sg_img;
	return _t1;
}

void ui__update_text_texture(struct sg_image sg_img, int w, int h, u8* buf) {
	int sz = w * h * 4;
	struct sg_image_data tmp_sbc = ((struct sg_image_data){.subimage = {0},});
	tmp_sbc.subimage[0][0] = ((struct sg_range){.ptr = buf,.size = ((usize)(sz)),});
	sg_update_image(sg_img, &tmp_sbc);
}

void ui__CanvasLayout_draw_texture(ui__CanvasLayout* c, struct sg_image simg) {
	gg__Context* ctx = c->ui->gg;
	int cx = c->x + c->offset_x;
	int cy = c->y + c->offset_y;
	f32 u0 = ((f32)(0.0));
	f32 v0 = ((f32)(0.0));
	f32 u1 = ((f32)(1.0));
	f32 v1 = ((f32)(1.0));
	f32 x0 = ((f32)(cx * ctx->scale));
	f32 y0 = ((f32)(cy * ctx->scale));
	f32 x1 = ((f32)((cx + c->width) * ctx->scale));
	f32 y1 = ((f32)((cy + c->height) * ctx->scale));
	sokol__sgl__load_pipeline(ctx->timage_pip);
	sokol__sgl__enable_texture();
	sokol__sgl__texture(simg);
	sokol__sgl__begin_quads();
	sokol__sgl__c4b(255, 255, 255, 255);
	sokol__sgl__v2f_t2f(x0, y0, u0, v0);
	sokol__sgl__v2f_t2f(x1, y0, u1, v0);
	sokol__sgl__v2f_t2f(x1, y1, u1, v1);
	sokol__sgl__v2f_t2f(x0, y1, u0, v1);
	sokol__sgl__end();
	sokol__sgl__disable_texture();
}

int ui__compare_sorted_widget(ui__SortedWidget* a, ui__SortedWidget* b) {
	if ((*(a->w.z_index)) < (*(b->w.z_index))) {
		int _t1 = -1;
		return _t1;
	} else if ((*(a->w.z_index)) > (*(b->w.z_index))) {
		int _t2 = 1;
		return _t2;
	} else if (a->i < b->i) {
		int _t3 = -1;
		return _t3;
	} else {
		int _t4 = 1;
		return _t4;
	}
	return 0;
}

void ui__Stack_sorted_drawing_children(ui__Stack* s) {
	Array_ui__SortedWidget dc = __new_array_with_default(0, 0, sizeof(ui__SortedWidget), 0);
	Array_ui__Widget sorted = __new_array_with_default(0, 0, sizeof(ui__Widget), 0);
	for (int i = 0; i < s->drawing_children.len; ++i) {
		ui__Widget child = ((ui__Widget*)s->drawing_children.data)[i];
		array_push((array*)&dc, _MOV((ui__SortedWidget[]){ ((ui__SortedWidget){.i = i,.w = child,}) }));
	}
	array_sort_with_compare(&dc, (voidptr)ui__compare_sorted_widget);
	for (int _t2 = 0; _t2 < dc.len; ++_t2) {
		ui__SortedWidget child = ((ui__SortedWidget*)dc.data)[_t2];
		array_push((array*)&sorted, _MOV((ui__Widget[]){ child.w }));
	}
	s->drawing_children = sorted;
}

void ui__CanvasLayout_sorted_drawing_children(ui__CanvasLayout* c) {
	Array_ui__SortedWidget dc = __new_array_with_default(0, 0, sizeof(ui__SortedWidget), 0);
	Array_ui__Widget sorted = __new_array_with_default(0, 0, sizeof(ui__Widget), 0);
	for (int i = 0; i < c->drawing_children.len; ++i) {
		ui__Widget child = ((ui__Widget*)c->drawing_children.data)[i];
		array_push((array*)&dc, _MOV((ui__SortedWidget[]){ ((ui__SortedWidget){.i = i,.w = child,}) }));
	}
	array_sort_with_compare(&dc, (voidptr)ui__compare_sorted_widget);
	for (int _t2 = 0; _t2 < dc.len; ++_t2) {
		ui__SortedWidget child = ((ui__SortedWidget*)dc.data)[_t2];
		array_push((array*)&sorted, _MOV((ui__Widget[]){ child.w }));
	}
	c->drawing_children = sorted;
}

void ui__EventMngr_add_receiver(ui__EventMngr* em, ui__Widget widget, Array_string evt_types) {
	for (int _t1 = 0; _t1 < evt_types.len; ++_t1) {
		string evt_type = ((string*)evt_types.data)[_t1];
		Array_string _t2 = {0};
		Array_ui__Widget _t2_orig = (*(Array_ui__Widget*)map_get(ADDR(map, em->receivers), &(string[]){evt_type}, &(Array_ui__Widget[]){ __new_array(0, 0, sizeof(ui__Widget)) }));
		int _t2_len = _t2_orig.len;
		_t2 = __new_array(0, _t2_len, sizeof(string));

		for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
			ui__Widget it = ((ui__Widget*) _t2_orig.data)[_t3];
			string ti = (*(it.id));
			array_push((array*)&_t2, &ti);
		}
		if (!Array_string_contains(_t2, (*(widget.id)))) {
			array_push((array*)&(*(Array_ui__Widget*)map_get_and_set((map*)&em->receivers, &(string[]){evt_type}, &(Array_ui__Widget[]){ __new_array(0, 0, sizeof(ui__Widget)) })), _MOV((ui__Widget[]){ widget }));
		}
		ui__EventMngr_sorted_receivers(em, evt_type);
	}
}

void ui__EventMngr_rm_receiver(ui__EventMngr* em, ui__Widget widget, Array_string evt_types) {
	for (int _t1 = 0; _t1 < evt_types.len; ++_t1) {
		string evt_type = ((string*)evt_types.data)[_t1];
		Array_string _t2 = {0};
		Array_ui__Widget _t2_orig = (*(Array_ui__Widget*)map_get(ADDR(map, em->receivers), &(string[]){evt_type}, &(Array_ui__Widget[]){ __new_array(0, 0, sizeof(ui__Widget)) }));
		int _t2_len = _t2_orig.len;
		_t2 = __new_array(0, _t2_len, sizeof(string));

		for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
			ui__Widget it = ((ui__Widget*) _t2_orig.data)[_t3];
			string ti = (*(it.id));
			array_push((array*)&_t2, &ti);
		}
		int ind = Array_string_index(_t2, (*(widget.id)));
		if (ind >= 0) {
			array_delete(&(*(Array_ui__Widget*)map_get(ADDR(map, em->receivers), &(string[]){evt_type}, &(Array_ui__Widget[]){ __new_array(0, 0, sizeof(ui__Widget)) })), ind);
		}
		ui__EventMngr_sorted_receivers(em, evt_type);
	}
}

void ui__EventMngr_point_inside_receivers_mouse_event(ui__EventMngr* em, ui__MouseEvent e, string evt_type) {
	array_clear(&(*(Array_ui__Widget*)map_get(ADDR(map, em->point_inside), &(string[]){evt_type}, &(Array_ui__Widget[]){ __new_array(0, 0, sizeof(ui__Widget)) })));
	ui__EventMngr_sorted_receivers(em, evt_type);
	Array_ui__Widget _t1 = (*(Array_ui__Widget*)map_get(ADDR(map, em->receivers), &(string[]){evt_type}, &(Array_ui__Widget[]){ __new_array(0, 0, sizeof(ui__Widget)) }));
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		ui__Widget* w = ((ui__Widget*)_t1.data) + _t2;
		if (!(*(w->hidden)) && ui__Widget_name_table[w->_typ]._method_point_inside(w->_object, e.x, e.y) && !ui__Widget_has_parent_deactivated(w)) {
			array_push((array*)&(*(Array_ui__Widget*)map_get_and_set((map*)&em->point_inside, &(string[]){evt_type}, &(Array_ui__Widget[]){ __new_array(0, 0, sizeof(ui__Widget)) })), _MOV((ui__Widget[]){ *w }));
		}
	}
}

void ui__EventMngr_point_inside_receivers_scroll(ui__EventMngr* em, ui__ScrollEvent e) {
	string evt_type = _const_ui__events.on_scroll;
	array_clear(&(*(Array_ui__Widget*)map_get(ADDR(map, em->point_inside), &(string[]){evt_type}, &(Array_ui__Widget[]){ __new_array(0, 0, sizeof(ui__Widget)) })));
	ui__EventMngr_sorted_receivers(em, evt_type);
	Array_ui__Widget _t1 = (*(Array_ui__Widget*)map_get(ADDR(map, em->receivers), &(string[]){evt_type}, &(Array_ui__Widget[]){ __new_array(0, 0, sizeof(ui__Widget)) }));
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		ui__Widget* w = ((ui__Widget*)_t1.data) + _t2;
		if (I_ui__Widget_is_I_ui__ScrollableWidget(*w)) {
			ui__ScrollableWidget sw = I_ui__Widget_as_I_ui__ScrollableWidget(*w);
			if (!(*(w->hidden)) && ui__has_scrollview(sw) && ui__ScrollView_point_inside((*(sw.scrollview)), e.mouse_x, e.mouse_y, ui__ScrollViewPart__view) && !ui__Widget_has_parent_deactivated(w)) {
				array_push((array*)&(*(Array_ui__Widget*)map_get_and_set((map*)&em->point_inside, &(string[]){evt_type}, &(Array_ui__Widget[]){ __new_array(0, 0, sizeof(ui__Widget)) })), _MOV((ui__Widget[]){ *w }));
			}
		} else {
			if (!(*(w->hidden)) && ui__Widget_name_table[w->_typ]._method_point_inside(w->_object, e.mouse_x, e.mouse_y) && !ui__Widget_has_parent_deactivated(w)) {
				array_push((array*)&(*(Array_ui__Widget*)map_get_and_set((map*)&em->point_inside, &(string[]){evt_type}, &(Array_ui__Widget[]){ __new_array(0, 0, sizeof(ui__Widget)) })), _MOV((ui__Widget[]){ *w }));
			}
		}
	}
}

void ui__EventMngr_sorted_receivers(ui__EventMngr* em, string evt_type) {
	Array_ui__SortedWidget sw = __new_array_with_default(0, 0, sizeof(ui__SortedWidget), 0);
	Array_ui__Widget sorted = __new_array_with_default(0, 0, sizeof(ui__Widget), 0);
	Array_ui__Widget _t1 = (*(Array_ui__Widget*)map_get(ADDR(map, em->receivers), &(string[]){evt_type}, &(Array_ui__Widget[]){ __new_array(0, 0, sizeof(ui__Widget)) }));
	for (int i = 0; i < _t1.len; ++i) {
		ui__Widget child = ((ui__Widget*)_t1.data)[i];
		array_push((array*)&sw, _MOV((ui__SortedWidget[]){ ((ui__SortedWidget){.i = i,.w = child,}) }));
	}
	array_sort_with_compare(&sw, (voidptr)ui__compare_sorted_widget);
	for (int _t3 = 0; _t3 < sw.len; ++_t3) {
		ui__SortedWidget child = ((ui__SortedWidget*)sw.data)[_t3];
		array_push((array*)&sorted, _MOV((ui__Widget[]){ child.w }));
	}
	map_set(&em->receivers, &(string[]){evt_type}, &(Array_ui__Widget[]) { array_reverse(sorted) });
}

bool ui__Window_is_top_widget(ui__Window _v_toheap_w, ui__Widget widget, string evt_type) {
ui__Window* w = HEAP(ui__Window, _v_toheap_w);
	Array_ui__Widget pi = (*(Array_ui__Widget*)map_get(ADDR(map, (*(w)).evt_mngr.point_inside), &(string[]){evt_type}, &(Array_ui__Widget[]){ __new_array(0, 0, sizeof(ui__Widget)) }));
	if ((*(w)).child_window != 0) {
		Array_ui__Widget _t1 = {0};
		Array_ui__Widget _t1_orig = pi;
		int _t1_len = _t1_orig.len;
		_t1 = __new_array(0, _t1_len, sizeof(ui__Widget));

		for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
			ui__Widget it = ((ui__Widget*) _t1_orig.data)[_t2];
			if (ui__Layout_has_child_id(ADDR(ui__Layout, /*&ui.Layout*/I_ui__Window_to_Interface_ui__Layout((*(w)).child_window)), (*(it.id)))) {
				array_push((array*)&_t1, &it);
			}
		}
		pi =_t1;
	}
	bool _t3 = pi.len >= 1 && string__eq((*((*(ui__Widget*)array_first(pi)).id)), (*(widget.id)));
	return _t3;
}

Array_string ui__Window_point_inside_receivers(ui__Window _v_toheap_w, string evt_type) {
ui__Window* w = HEAP(ui__Window, _v_toheap_w);
	Array_string _t2 = {0};
	Array_ui__Widget _t2_orig = (*(Array_ui__Widget*)map_get(ADDR(map, (*(w)).evt_mngr.point_inside), &(string[]){evt_type}, &(Array_ui__Widget[]){ __new_array(0, 0, sizeof(ui__Widget)) }));
	int _t2_len = _t2_orig.len;
	_t2 = __new_array(0, _t2_len, sizeof(string));

	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		ui__Widget it = ((ui__Widget*) _t2_orig.data)[_t3];
		string ti = (*(it.id));
		array_push((array*)&_t2, &ti);
	}
	Array_string _t1 =_t2;
	return _t1;
}

int ui__get_num_dropped_files(void) {
	int _t1 = sokol__sapp__get_num_dropped_files();
	return _t1;
}

string ui__get_dropped_file_path(int i) {
	string _t1 = sokol__sapp__get_dropped_file_path(i);
	return _t1;
}

gg__Rect ui__intersection_rect(gg__Rect r1, gg__Rect r2) {
	f32 tl_x = math__max_T_f32(r1.x, r2.x);
	f32 tl_y = math__max_T_f32(r1.y, r2.y);
	f32 br_x = math__min_T_f32(r1.x + r1.width, r2.x + r2.width);
	f32 br_y = math__min_T_f32(r1.y + r1.height, r2.y + r2.height);
	gg__Rect r = ((gg__Rect){.x = ((f32)(tl_x)),.y = ((f32)(tl_y)),.width = ((f32)(br_x - tl_x)),.height = ((f32)(br_y - tl_y)),});
	gg__Rect _t1 = r;
	return _t1;
}

bool ui__is_empty_intersection(gg__Rect r1, gg__Rect r2) {
	gg__Rect r = ui__intersection_rect(r1, r2);
	bool _t1 = r.width < 0 || r.height < 0;
	return _t1;
}

gg__Rect ui__union_rect(gg__Rect r1, gg__Rect r2) {
	f32 tl_x = math__min_T_f32(r1.x, r2.x);
	f32 tl_y = math__min_T_f32(r1.y, r2.y);
	f32 br_x = math__max_T_f32(r1.x + r1.width, r2.x + r2.width);
	f32 br_y = math__max_T_f32(r1.y + r1.height, r2.y + r2.height);
	gg__Rect r = ((gg__Rect){.x = ((f32)(tl_x)),.y = ((f32)(tl_y)),.width = ((f32)(br_x - tl_x)),.height = ((f32)(br_y - tl_y)),});
	gg__Rect _t1 = r;
	return _t1;
}

void ui__offset_start(ui__Widget* w) {
	(*(w->x)) += (*(w->offset_x));
	(*(w->y)) += (*(w->offset_y));
}

void ui__offset_end(ui__Widget* w) {
	(*(w->x)) -= (*(w->offset_x));
	(*(w->y)) -= (*(w->offset_y));
}

void ui__drag_register(ui__Widget w, ui__UI* ui, ui__MouseEvent* e) {
	if (ui__shift_key(e->mods)) {
		ui__Window* window = ui->window;
		if (window->dragger.activated) {
			if ((*(w.z_index)) > (*(window->dragger.widget.z_index))) {
				window->dragger.widget = w;
				window->dragger.start_x = e->x - (*(w.offset_x));
				window->dragger.start_y = e->y - (*(w.offset_y));
				window->dragger.pos_x = e->x;
				window->dragger.pos_y = e->y;
				window->dragger.time = time__now();
			}
		} else {
			window->dragger.activated = true;
			window->dragger.widget = w;
			window->dragger.start_x = e->x - (*(w.offset_x));
			window->dragger.start_y = e->y - (*(w.offset_y));
			window->dragger.pos_x = e->x;
			window->dragger.pos_y = e->y;
			window->dragger.time = time__now();
		}
	}
}

void ui__drag_child(ui__Window* window, f64 x, f64 y) {
	ui__Widget w = window->dragger.widget;
	sokol__sapp__show_mouse(false);
	#if defined(CUSTOM_DEFINE_speed)
	{
	}
	#else
	{
		(*(w.offset_x)) = ((int)(x - window->dragger.start_x));
		(*(w.offset_y)) = ((int)(y - window->dragger.start_y));
	}
	#endif
}

void ui__drop_child(ui__Window* window) {
	sokol__sapp__show_mouse(true);
	window->dragger.activated = false;
}

void ui__set_offset(ui__Widget* w, int ox, int oy) {
	(*(w->offset_x)) = ox;
	(*(w->offset_y)) = oy;
	if ((w)->_typ == _ui__Widget_ui__Stack_index) {
		for (int _t1 = 0; _t1 < (w->_ui__Stack)->children.len; ++_t1) {
			ui__Widget* child = ((ui__Widget*)(w->_ui__Stack)->children.data) + _t1;
			ui__set_offset(child, ox, oy);
		}
	} else if ((w)->_typ == _ui__Widget_ui__Group_index) {
		for (int _t2 = 0; _t2 < (w->_ui__Group)->children.len; ++_t2) {
			ui__Widget* child = ((ui__Widget*)(w->_ui__Group)->children.data) + _t2;
			ui__set_offset(child, ox, oy);
		}
	} else if ((w)->_typ == _ui__Widget_ui__CanvasLayout_index) {
		for (int _t3 = 0; _t3 < (w->_ui__CanvasLayout)->children.len; ++_t3) {
			ui__Widget* child = ((ui__Widget*)(w->_ui__CanvasLayout)->children.data) + _t3;
			ui__set_offset(child, ox, oy);
		}
	}
}

ui__Widget ui__at(int x, int y, ui__Widget w) {
	ui__Widget w2 = w;
	(*(w2.x)) = x;
	(*(w2.y)) = y;
	ui__Widget _t1 = w2;
	return _t1;
}

// TypeDecl
multi_return_bool_ref_ui__ScrollView ui__scrollview(ui__Widget w) {
	if ((w)._typ == _ui__Widget_ui__Stack_index) {
		if ((w._ui__Stack)->has_scrollview) {
			return (multi_return_bool_ref_ui__ScrollView){.arg0=true, .arg1=(w._ui__Stack)->scrollview};
		}
	} else if ((w)._typ == _ui__Widget_ui__CanvasLayout_index) {
		if ((w._ui__CanvasLayout)->has_scrollview) {
			return (multi_return_bool_ref_ui__ScrollView){.arg0=true, .arg1=(w._ui__CanvasLayout)->scrollview};
		}
	} else if ((w)._typ == _ui__Widget_ui__ListBox_index) {
		if ((w._ui__ListBox)->has_scrollview) {
			return (multi_return_bool_ref_ui__ScrollView){.arg0=true, .arg1=(w._ui__ListBox)->scrollview};
		}
	} else if ((w)._typ == _ui__Widget_ui__TextBox_index) {
		if ((w._ui__TextBox)->has_scrollview) {
			return (multi_return_bool_ref_ui__ScrollView){.arg0=true, .arg1=(w._ui__TextBox)->scrollview};
		}
	}
	return (multi_return_bool_ref_ui__ScrollView){.arg0=false, .arg1=((ui__ScrollView*)(0))};
}

bool ui__has_scrollview(ui__ScrollableWidget w) {
	bool _t1 = (*(w.has_scrollview));
	return _t1;
}

bool ui__has_scrollview_or_parent_scrollview(ui__ScrollableWidget w) {
	bool _t1 = (*(w.scrollview)) != 0;
	return _t1;
}

bool ui__scrollview_is_active(ui__ScrollableWidget* w) {
	bool _t1 = (*(w->has_scrollview)) && ui__ScrollView_is_active((*(w->scrollview)));
	return _t1;
}

void ui__scrollview_need_update(ui__ScrollableWidget* w) {
	if ((*(w->has_scrollview))) {
		(*(w->scrollview))->children_to_update = true;
	}
}

void ui__scrollview_add_T_ui__CanvasLayout(ui__CanvasLayout* w) {
	ui__ScrollView* sv = ((ui__ScrollView*)memdup(&(ui__ScrollView){.widget = /*&ui.ScrollableWidget*/I_ui__CanvasLayout_to_Interface_ui__ScrollableWidget(w),.btn_color_x = _const_ui__scrollbar_button_color,.btn_color_y = _const_ui__scrollbar_button_color,.sb_w = 0,.btn_x = 0,.btn_w = 0,.sb_h = 0,.btn_y = 0,.btn_h = 0,.offset_x = 0,.offset_y = 0,.active_x = 0,.active_y = 0,.dragging = 0,.drag_offset = 0,.orig_offset = 0,.children_to_update = 0,.is_focused = 0,.orig_x = 0,.orig_y = 0,.width = 0,.height = 0,.adj_width = 0,.adj_height = 0,.win_width = 0,.win_height = 0,.ui = 0,.scissor_rect = {0},.parent = w->parent,.delta_mouse = 50,}, sizeof(ui__ScrollView)));
	sv->widget = /*&ui.ScrollableWidget*/I_ui__CanvasLayout_to_Interface_ui__ScrollableWidget(w);
	w->scrollview = sv;
	w->has_scrollview = true;
}
void ui__scrollview_add_T_ui__Stack(ui__Stack* w) {
	ui__ScrollView* sv = ((ui__ScrollView*)memdup(&(ui__ScrollView){.widget = /*&ui.ScrollableWidget*/I_ui__Stack_to_Interface_ui__ScrollableWidget(w),.btn_color_x = _const_ui__scrollbar_button_color,.btn_color_y = _const_ui__scrollbar_button_color,.sb_w = 0,.btn_x = 0,.btn_w = 0,.sb_h = 0,.btn_y = 0,.btn_h = 0,.offset_x = 0,.offset_y = 0,.active_x = 0,.active_y = 0,.dragging = 0,.drag_offset = 0,.orig_offset = 0,.children_to_update = 0,.is_focused = 0,.orig_x = 0,.orig_y = 0,.width = 0,.height = 0,.adj_width = 0,.adj_height = 0,.win_width = 0,.win_height = 0,.ui = 0,.scissor_rect = {0},.parent = w->parent,.delta_mouse = 50,}, sizeof(ui__ScrollView)));
	sv->widget = /*&ui.ScrollableWidget*/I_ui__Stack_to_Interface_ui__ScrollableWidget(w);
	w->scrollview = sv;
	w->has_scrollview = true;
}
void ui__scrollview_add_T_ui__ListBox(ui__ListBox* w) {
	ui__ScrollView* sv = ((ui__ScrollView*)memdup(&(ui__ScrollView){.widget = /*&ui.ScrollableWidget*/I_ui__ListBox_to_Interface_ui__ScrollableWidget(w),.btn_color_x = _const_ui__scrollbar_button_color,.btn_color_y = _const_ui__scrollbar_button_color,.sb_w = 0,.btn_x = 0,.btn_w = 0,.sb_h = 0,.btn_y = 0,.btn_h = 0,.offset_x = 0,.offset_y = 0,.active_x = 0,.active_y = 0,.dragging = 0,.drag_offset = 0,.orig_offset = 0,.children_to_update = 0,.is_focused = 0,.orig_x = 0,.orig_y = 0,.width = 0,.height = 0,.adj_width = 0,.adj_height = 0,.win_width = 0,.win_height = 0,.ui = 0,.scissor_rect = {0},.parent = w->parent,.delta_mouse = 50,}, sizeof(ui__ScrollView)));
	sv->widget = /*&ui.ScrollableWidget*/I_ui__ListBox_to_Interface_ui__ScrollableWidget(w);
	w->scrollview = sv;
	w->has_scrollview = true;
}
void ui__scrollview_add_T_ui__TextBox(ui__TextBox* w) {
	ui__ScrollView* sv = ((ui__ScrollView*)memdup(&(ui__ScrollView){.widget = /*&ui.ScrollableWidget*/I_ui__TextBox_to_Interface_ui__ScrollableWidget(w),.btn_color_x = _const_ui__scrollbar_button_color,.btn_color_y = _const_ui__scrollbar_button_color,.sb_w = 0,.btn_x = 0,.btn_w = 0,.sb_h = 0,.btn_y = 0,.btn_h = 0,.offset_x = 0,.offset_y = 0,.active_x = 0,.active_y = 0,.dragging = 0,.drag_offset = 0,.orig_offset = 0,.children_to_update = 0,.is_focused = 0,.orig_x = 0,.orig_y = 0,.width = 0,.height = 0,.adj_width = 0,.adj_height = 0,.win_width = 0,.win_height = 0,.ui = 0,.scissor_rect = {0},.parent = w->parent,.delta_mouse = 50,}, sizeof(ui__ScrollView)));
	sv->widget = /*&ui.ScrollableWidget*/I_ui__TextBox_to_Interface_ui__ScrollableWidget(w);
	w->scrollview = sv;
	w->has_scrollview = true;
}

void ui__scrollview_widget_set_orig_xy(ui__Widget w) {
	if ((w)._typ == _ui__Widget_ui__Stack_index) {
		if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__Stack_to_Interface_ui__ScrollableWidget((w._ui__Stack)))) {
			ui__scrollview_set_orig_xy_T_ui__Stack((w._ui__Stack));
		}
		for (int _t1 = 0; _t1 < (w._ui__Stack)->children.len; ++_t1) {
			ui__Widget child = ((ui__Widget*)(w._ui__Stack)->children.data)[_t1];
			ui__scrollview_widget_set_orig_xy(child);
		}
	} else if ((w)._typ == _ui__Widget_ui__CanvasLayout_index) {
		if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__CanvasLayout_to_Interface_ui__ScrollableWidget((w._ui__CanvasLayout)))) {
			ui__scrollview_set_orig_xy_T_ui__CanvasLayout((w._ui__CanvasLayout));
		}
		for (int _t2 = 0; _t2 < (w._ui__CanvasLayout)->children.len; ++_t2) {
			ui__Widget child = ((ui__Widget*)(w._ui__CanvasLayout)->children.data)[_t2];
			ui__scrollview_widget_set_orig_xy(child);
		}
	} else if ((w)._typ == _ui__Widget_ui__ListBox_index) {
		if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__ListBox_to_Interface_ui__ScrollableWidget((w._ui__ListBox)))) {
			ui__scrollview_set_orig_xy_T_ui__ListBox((w._ui__ListBox));
		}
	} else if ((w)._typ == _ui__Widget_ui__TextBox_index) {
		if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__TextBox_to_Interface_ui__ScrollableWidget((w._ui__TextBox)))) {
			ui__scrollview_set_orig_xy_T_ui__TextBox((w._ui__TextBox));
		}
	}
}

void ui__scrollview_set_orig_xy_T_ui__Stack(ui__Stack* w) {
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__Stack_to_Interface_ui__ScrollableWidget(w))) {
		ui__ScrollView* sv = w->scrollview;
		sv->orig_x = w->x;
		sv->orig_y = w->y;
		sv->offset_x = 0;
		sv->offset_y = 0;
		if (sv->active_x) {
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_x);
		}
		if (sv->active_y) {
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_y);
		}
	}
}
void ui__scrollview_set_orig_xy_T_ui__CanvasLayout(ui__CanvasLayout* w) {
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__CanvasLayout_to_Interface_ui__ScrollableWidget(w))) {
		ui__ScrollView* sv = w->scrollview;
		sv->orig_x = w->x;
		sv->orig_y = w->y;
		sv->offset_x = 0;
		sv->offset_y = 0;
		if (sv->active_x) {
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_x);
		}
		if (sv->active_y) {
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_y);
		}
	}
}
void ui__scrollview_set_orig_xy_T_ui__ListBox(ui__ListBox* w) {
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__ListBox_to_Interface_ui__ScrollableWidget(w))) {
		ui__ScrollView* sv = w->scrollview;
		sv->orig_x = w->x;
		sv->orig_y = w->y;
		sv->offset_x = 0;
		sv->offset_y = 0;
		if (sv->active_x) {
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_x);
		}
		if (sv->active_y) {
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_y);
		}
	}
}
void ui__scrollview_set_orig_xy_T_ui__TextBox(ui__TextBox* w) {
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__TextBox_to_Interface_ui__ScrollableWidget(w))) {
		ui__ScrollView* sv = w->scrollview;
		sv->orig_x = w->x;
		sv->orig_y = w->y;
		sv->offset_x = 0;
		sv->offset_y = 0;
		if (sv->active_x) {
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_x);
		}
		if (sv->active_y) {
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_y);
		}
	}
}

void ui__scrollview_delegate_parent_scrollview_T_ui__CanvasLayout(ui__CanvasLayout* w) {
	ui__Layout parent = w->parent;
	if ((parent)._typ == _ui__Layout_ui__Stack_index) {
		w->scrollview = (parent._ui__Stack)->scrollview;
	} else if ((parent)._typ == _ui__Layout_ui__CanvasLayout_index) {
		w->scrollview = (parent._ui__CanvasLayout)->scrollview;
	}
}
void ui__scrollview_delegate_parent_scrollview_T_ui__Stack(ui__Stack* w) {
	ui__Layout parent = w->parent;
	if ((parent)._typ == _ui__Layout_ui__Stack_index) {
		w->scrollview = (parent._ui__Stack)->scrollview;
	} else if ((parent)._typ == _ui__Layout_ui__CanvasLayout_index) {
		w->scrollview = (parent._ui__CanvasLayout)->scrollview;
	}
}

void ui__scrollview_update_T_ui__TextBox(ui__TextBox* w) {
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__TextBox_to_Interface_ui__ScrollableWidget(w))) {
		ui__ScrollView* sw = w->scrollview;
		ui__ScrollView_update(sw);
	}
}
void ui__scrollview_update_T_ui__CanvasLayout(ui__CanvasLayout* w) {
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__CanvasLayout_to_Interface_ui__ScrollableWidget(w))) {
		ui__ScrollView* sw = w->scrollview;
		ui__ScrollView_update(sw);
	}
}
void ui__scrollview_update_T_ui__Stack(ui__Stack* w) {
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__Stack_to_Interface_ui__ScrollableWidget(w))) {
		ui__ScrollView* sw = w->scrollview;
		ui__ScrollView_update(sw);
	}
}
void ui__scrollview_update_T_ui__ListBox(ui__ListBox* w) {
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__ListBox_to_Interface_ui__ScrollableWidget(w))) {
		ui__ScrollView* sw = w->scrollview;
		ui__ScrollView_update(sw);
	}
}

void ui__scrollview_draw_begin_T_ui__CanvasLayout(ui__CanvasLayout* w) {
	if (ui__scrollview_is_active(HEAP(ui__ScrollableWidget, /*&ui.ScrollableWidget*/I_ui__CanvasLayout_to_Interface_ui__ScrollableWidget(w)))) {
		ui__ScrollView* sv = w->scrollview;
		if (sv->children_to_update) {
			multi_return_int_int mr_3641 = ui__ScrollView_orig_xy(sv);
			int svx = mr_3641.arg0;
			int svy = mr_3641.arg1;
			if (sv->active_x) {
				w->x = svx - sv->offset_x;
			}
			if (sv->active_y) {
				w->y = svy - sv->offset_y;
			}
			ui__CanvasLayout_set_children_pos(w);
			sv->children_to_update = false;
		}
		ui__ScrollView_clip(sv);
	}
}
void ui__scrollview_draw_begin_T_ui__Stack(ui__Stack* w) {
	if (ui__scrollview_is_active(HEAP(ui__ScrollableWidget, /*&ui.ScrollableWidget*/I_ui__Stack_to_Interface_ui__ScrollableWidget(w)))) {
		ui__ScrollView* sv = w->scrollview;
		if (sv->children_to_update) {
			multi_return_int_int mr_3641 = ui__ScrollView_orig_xy(sv);
			int svx = mr_3641.arg0;
			int svy = mr_3641.arg1;
			if (sv->active_x) {
				w->x = svx - sv->offset_x;
			}
			if (sv->active_y) {
				w->y = svy - sv->offset_y;
			}
			ui__Stack_set_children_pos(w);
			sv->children_to_update = false;
		}
		ui__ScrollView_clip(sv);
	}
}
void ui__scrollview_draw_begin_T_ui__ListBox(ui__ListBox* w) {
	if (ui__scrollview_is_active(HEAP(ui__ScrollableWidget, /*&ui.ScrollableWidget*/I_ui__ListBox_to_Interface_ui__ScrollableWidget(w)))) {
		ui__ScrollView* sv = w->scrollview;
		if (sv->children_to_update) {
			multi_return_int_int mr_3641 = ui__ScrollView_orig_xy(sv);
			int svx = mr_3641.arg0;
			int svy = mr_3641.arg1;
			if (sv->active_x) {
				w->x = svx - sv->offset_x;
			}
			if (sv->active_y) {
				w->y = svy - sv->offset_y;
			}
			ui__ListBox_set_children_pos(w);
			sv->children_to_update = false;
		}
		ui__ScrollView_clip(sv);
	}
}
void ui__scrollview_draw_begin_T_ui__TextBox(ui__TextBox* w) {
	if (ui__scrollview_is_active(HEAP(ui__ScrollableWidget, /*&ui.ScrollableWidget*/I_ui__TextBox_to_Interface_ui__ScrollableWidget(w)))) {
		ui__ScrollView* sv = w->scrollview;
		if (sv->children_to_update) {
			multi_return_int_int mr_3641 = ui__ScrollView_orig_xy(sv);
			int svx = mr_3641.arg0;
			int svy = mr_3641.arg1;
			if (sv->active_x) {
				w->x = svx - sv->offset_x;
			}
			if (sv->active_y) {
				w->y = svy - sv->offset_y;
			}
			ui__TextBox_set_children_pos(w);
			sv->children_to_update = false;
		}
		ui__ScrollView_clip(sv);
	}
}

void ui__scrollview_draw_end_T_ui__CanvasLayout(ui__CanvasLayout* w) {
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__CanvasLayout_to_Interface_ui__ScrollableWidget(w))) {
		ui__ScrollView* sv = w->scrollview;
		ui__ScrollView_draw(sv);
	}
}
void ui__scrollview_draw_end_T_ui__Stack(ui__Stack* w) {
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__Stack_to_Interface_ui__ScrollableWidget(w))) {
		ui__ScrollView* sv = w->scrollview;
		ui__ScrollView_draw(sv);
	}
}
void ui__scrollview_draw_end_T_ui__ListBox(ui__ListBox* w) {
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__ListBox_to_Interface_ui__ScrollableWidget(w))) {
		ui__ScrollView* sv = w->scrollview;
		ui__ScrollView_draw(sv);
	}
}
void ui__scrollview_draw_end_T_ui__TextBox(ui__TextBox* w) {
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__TextBox_to_Interface_ui__ScrollableWidget(w))) {
		ui__ScrollView* sv = w->scrollview;
		ui__ScrollView_draw(sv);
	}
}

void ui__scrollview_reset_T_ui__TextBox(ui__TextBox* w) {
	ui__ScrollView* sv = w->scrollview;
	multi_return_int_int mr_4016 = ui__ScrollView_orig_xy(sv);
	int svx = mr_4016.arg0;
	int svy = mr_4016.arg1;
	if (!sv->active_x) {
		sv->offset_x = 0;
		w->x = svx;
	}
	if (!sv->active_y) {
		sv->offset_y = 0;
		w->y = svy;
	}
	ui__TextBox_set_children_pos(w);
}

void ui__ScrollView_init(ui__ScrollView* sv, ui__Layout parent) {
	ui__ScrollableWidget widget = sv->widget;
	ui__UI* ui = (*(widget.ui));
	sv->ui = ui;
	sv->parent = parent;
	gg__Size size = gg__window_size_real_pixels();
	sv->scissor_rect = ((gg__Rect){.x = ((f32)(0)),.y = ((f32)(0)),.width = ((f32)(size.width)),.height = ((f32)(size.height)),});
	eventbus__Subscriber* subscriber = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_click, (voidptr)ui__scrollview_click, sv);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_scroll, (voidptr)ui__scrollview_scroll, sv);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_key_down, (voidptr)ui__scrollview_key_down, sv);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_down, (voidptr)ui__scrollview_mouse_down, sv);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_up, (voidptr)ui__scrollview_mouse_up, sv);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_move, (voidptr)ui__scrollview_mouse_move, sv);
}

// Attr: [manualfree]
void ui__ScrollView_cleanup(ui__ScrollView* sv) {
	eventbus__Subscriber* subscriber = ui__Layout_name_table[sv->parent._typ]._method_get_subscriber(sv->parent._object);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_click, sv);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_scroll, sv);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_key_down, sv);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_down, sv);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_up, sv);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_move, sv);
	ui__ScrollView_free(sv);
}

// Attr: [unsafe]
void ui__ScrollView_free(ui__ScrollView* sv) {
	_v_free(sv);
}

multi_return_int_int ui__ScrollView_parent_offset(ui__ScrollView* sv) {
	int ox = 0;
	int oy = 0;
	ui__Layout parent = sv->parent;
	if ((parent)._typ == _ui__Layout_ui__Stack_index) {
		if ((parent._ui__Stack)->scrollview != ((voidptr)(0))) {
			ui__ScrollView* psv = (parent._ui__Stack)->scrollview;
			if (psv->active_x) {
				ox += psv->offset_x;
			}
			if (psv->active_y) {
				oy += psv->offset_y;
			}
			multi_return_int_int mr_6978 = ui__ScrollView_parent_offset(psv);
			int pox = mr_6978.arg0;
			int poy = mr_6978.arg1;
			ox += pox;
			oy += poy;
		}
	} else if ((parent)._typ == _ui__Layout_ui__CanvasLayout_index) {
		if ((parent._ui__CanvasLayout)->scrollview != ((voidptr)(0))) {
			ui__ScrollView* psv = (parent._ui__CanvasLayout)->scrollview;
			if (psv->active_x) {
				ox += psv->offset_x;
			}
			if (psv->active_y) {
				oy += psv->offset_y;
			}
			multi_return_int_int mr_7244 = ui__ScrollView_parent_offset(psv);
			int pox = mr_7244.arg0;
			int poy = mr_7244.arg1;
			ox += pox;
			oy += poy;
		}
	}
	return (multi_return_int_int){.arg0=ox, .arg1=oy};
}

multi_return_int_int ui__ScrollView_orig_xy(ui__ScrollView* sv) {
	multi_return_int_int mr_7373 = ui__ScrollView_parent_offset(sv);
	int ox = mr_7373.arg0;
	int oy = mr_7373.arg1;
	return (multi_return_int_int){.arg0=sv->orig_x - ox, .arg1=sv->orig_y - oy};
}

gg__Rect ui__ScrollView_parent_scissor_rect(ui__ScrollView* sv) {
	ui__Layout parent = sv->parent;
	gg__Size size = gg__window_size_real_pixels();
	gg__Rect scissor_rect = ((gg__Rect){.x = ((f32)(0)),.y = ((f32)(0)),.width = ((f32)(size.width)),.height = ((f32)(size.height)),});
	if ((parent)._typ == _ui__Layout_ui__Stack_index) {
		if ((parent._ui__Stack)->scrollview != ((voidptr)(0))) {
			ui__ScrollView* psv = (parent._ui__Stack)->scrollview;
			scissor_rect = psv->scissor_rect;
		}
	} else if ((parent)._typ == _ui__Layout_ui__CanvasLayout_index) {
		if ((parent._ui__CanvasLayout)->scrollview != ((voidptr)(0))) {
			ui__ScrollView* psv = (parent._ui__CanvasLayout)->scrollview;
			scissor_rect = psv->scissor_rect;
		}
	}
	gg__Rect _t1 = scissor_rect;
	return _t1;
}

void ui__ScrollView_update(ui__ScrollView* sv) {
	multi_return_int_int mr_7980 = ui__ScrollableWidget_name_table[sv->widget._typ]._method_size(sv->widget._object);
	sv->width = mr_7980.arg0;
	sv->height = mr_7980.arg1;
	multi_return_int_int mr_8028 = ui__ScrollableWidget_name_table[sv->widget._typ]._method_adj_size(sv->widget._object);
	sv->adj_width = mr_8028.arg0;
	sv->adj_height = mr_8028.arg1;
	sv->active_x = sv->adj_width > sv->width;
	sv->active_y = sv->adj_height > sv->height;
	if (sv->active_x) {
		sv->sb_w = sv->width - _const_ui__scrollbar_size;
		sv->btn_w = ((int)(((f32)(sv->width)) / ((f32)(sv->adj_width)) * ((f32)(sv->sb_w))));
	}
	if (sv->active_y) {
		sv->sb_h = sv->height - _const_ui__scrollbar_size;
		sv->btn_h = ((int)(((f32)(sv->height)) / ((f32)(sv->adj_height)) * ((f32)(sv->sb_h))));
	}
}

bool ui__ScrollView_is_active(ui__ScrollView* sv) {
	bool _t1 = sv->active_x || sv->active_y;
	return _t1;
}

bool ui__ScrollView_children_point_inside(ui__ScrollView* sv, f64 x, f64 y, ui__ScrollViewPart mode) {
	ui__ScrollableWidget w = sv->widget;
	if ((w)._typ == _ui__ScrollableWidget_ui__Stack_index) {
		for (int _t1 = 0; _t1 < (w._ui__Stack)->children.len; ++_t1) {
			ui__Widget child = ((ui__Widget*)(w._ui__Stack)->children.data)[_t1];
			multi_return_bool_ref_ui__ScrollView mr_8771 = ui__scrollview(child);
			bool ok = mr_8771.arg0;
			ui__ScrollView* csv = mr_8771.arg1;
			if (ok) {
				bool _t2 = ui__ScrollView_point_inside(csv, x, y, mode) || ui__ScrollView_children_point_inside(csv, x, y, mode);
				return _t2;
			}
		}
	} else if ((w)._typ == _ui__ScrollableWidget_ui__CanvasLayout_index) {
		for (int _t3 = 0; _t3 < (w._ui__CanvasLayout)->children.len; ++_t3) {
			ui__Widget child = ((ui__Widget*)(w._ui__CanvasLayout)->children.data)[_t3];
			multi_return_bool_ref_ui__ScrollView mr_8963 = ui__scrollview(child);
			bool ok = mr_8963.arg0;
			ui__ScrollView* csv = mr_8963.arg1;
			if (ok) {
				bool _t4 = ui__ScrollView_point_inside(csv, x, y, mode) || ui__ScrollView_children_point_inside(csv, x, y, mode);
				return _t4;
			}
		}
	}
	bool _t5 = false;
	return _t5;
}

bool ui__ScrollView_point_inside(ui__ScrollView* sv, f64 x, f64 y, ui__ScrollViewPart mode) {
	int x_min = 0;
	int y_min = 0;
	int x_max = 0;
	int y_max = 0;
	multi_return_int_int mr_9248 = ui__ScrollView_orig_xy(sv);
	int svx = mr_9248.arg0;
	int svy = mr_9248.arg1;
	switch (mode) {
		case ui__ScrollViewPart__view: 
			{
				x_min = svx + (*(sv->widget.offset_x));
				y_min = svy + (*(sv->widget.offset_y));
				x_max = x_min + sv->width;
				y_max = y_min + sv->height;
				break;
			}
		case ui__ScrollViewPart__bar_x: 
			{
				x_min = svx;
				y_min = svy + sv->height - _const_ui__scrollbar_size;
				x_max = x_min + sv->sb_w;
				y_max = y_min + _const_ui__scrollbar_size;
				break;
			}
		case ui__ScrollViewPart__bar_y: 
			{
				x_min = svx + sv->width - _const_ui__scrollbar_size;
				y_min = svy;
				x_max = x_min + _const_ui__scrollbar_size;
				y_max = y_min + sv->sb_h;
				break;
			}
		case ui__ScrollViewPart__btn_x: 
			{
				x_min = svx + sv->btn_x;
				y_min = svy + sv->height - _const_ui__scrollbar_size;
				x_max = x_min + sv->btn_w;
				y_max = y_min + _const_ui__scrollbar_size;
				break;
			}
		case ui__ScrollViewPart__btn_y: 
			{
				x_min = svx + sv->width - _const_ui__scrollbar_size;
				y_min = svy + sv->btn_y;
				x_max = x_min + _const_ui__scrollbar_size;
				y_max = y_min + sv->btn_h;
				break;
			}
		case ui__ScrollViewPart__bar: 
			{
				bool _t1 = ui__ScrollView_point_inside(sv, x, y, ui__ScrollViewPart__bar_x) || ui__ScrollView_point_inside(sv, x, y, ui__ScrollViewPart__bar_y);
				return _t1;
				break;
			}
	}
	;
	bool _t2 = x >= x_min && x <= x_max && y >= y_min && y <= y_max;
	return _t2;
}

void ui__ScrollView_change_value(ui__ScrollView* sv, ui__ScrollViewPart mode) {
	sv->children_to_update = true;
	if (mode == ui__ScrollViewPart__btn_x) {
		if (sv->offset_x < 0) {
			sv->offset_x = 0;
		}
		multi_return_int_f32 mr_10428 = ui__ScrollView_coef_x(sv);
		int max_offset_x = mr_10428.arg0;
		f32 a_x = mr_10428.arg1;
		if (sv->offset_x > max_offset_x) {
			sv->offset_x = max_offset_x;
		}
		sv->btn_x = ((int)(((f32)(sv->offset_x)) * a_x));
	} else if (mode == ui__ScrollViewPart__btn_y) {
		if (sv->offset_y < 0) {
			sv->offset_y = 0;
		}
		multi_return_int_f32 mr_10646 = ui__ScrollView_coef_y(sv);
		int max_offset_y = mr_10646.arg0;
		f32 a_y = mr_10646.arg1;
		if (sv->offset_y > max_offset_y) {
			sv->offset_y = max_offset_y;
		}
		sv->btn_y = ((int)(((f32)(sv->offset_y)) * a_y));
	}
	ui__ScrollableWidget sw = sv->widget;
	if ((sw)._typ == _ui__ScrollableWidget_ui__TextBox_index) {
		if ((sw._ui__TextBox)->has_scrollview) {
			ui__TextView_scroll_changed(&(sw._ui__TextBox)->tv);
		}
	}
	if ((*(sw.on_scroll_change)) != (voidptr)((ui__ScrollViewChangedFn)(0))) {
		(*sw.on_scroll_change)(sw);
	}
}

void ui__ScrollView_clip(ui__ScrollView* sv) {
	if (ui__ScrollView_is_active(sv)) {
		multi_return_int_int mr_11150 = ui__ScrollView_orig_xy(sv);
		int svx = mr_11150.arg0;
		int svy = mr_11150.arg1;
		gg__Rect sr = ((gg__Rect){.x = svx * gg__dpi_scale(),.y = svy * gg__dpi_scale(),.width = sv->width * gg__dpi_scale(),.height = sv->height * gg__dpi_scale(),});
		gg__Rect psr = ui__ScrollView_parent_scissor_rect(sv);
		gg__Rect scissor_rect = ui__intersection_rect(sr, psr);
		sokol__sgl__scissor_rect(((int)(scissor_rect.x)), ((int)(scissor_rect.y)), ((int)(scissor_rect.width)), ((int)(scissor_rect.height)), true);
		sv->scissor_rect = scissor_rect;
	} else {
		if (!sv->active_x) {
			sv->offset_x = 0;
		}
		if (!sv->active_y) {
			sv->offset_y = 0;
		}
	}
}

void ui__ScrollView_draw(ui__ScrollView* sv) {
	gg__Rect scissor_rect = ui__ScrollView_parent_scissor_rect(sv);
	sokol__sgl__scissor_rect(((int)(scissor_rect.x)), ((int)(scissor_rect.y)), ((int)(scissor_rect.width)), ((int)(scissor_rect.height)), true);
	multi_return_int_int mr_11855 = ui__ScrollView_orig_xy(sv);
	int svx = mr_11855.arg0;
	int svy = mr_11855.arg1;
	if (sv->active_x) {
		gg__Context_draw_rounded_rect_filled(sv->ui->gg, svx, svy + sv->height - _const_ui__scrollbar_size, sv->sb_w, _const_ui__scrollbar_size, _const_ui__scrollbar_size / 3, _const_ui__scrollbar_background_color);
		gg__Context_draw_rounded_rect_filled(sv->ui->gg, svx + sv->btn_x, svy + sv->height - _const_ui__scrollbar_size, sv->btn_w, _const_ui__scrollbar_size, _const_ui__scrollbar_size / 3, sv->btn_color_x);
	}
	if (sv->active_y) {
		gg__Context_draw_rounded_rect_filled(sv->ui->gg, svx + sv->width - _const_ui__scrollbar_size, svy, _const_ui__scrollbar_size, sv->sb_h, _const_ui__scrollbar_size / 3, _const_ui__scrollbar_background_color);
		gg__Context_draw_rounded_rect_filled(sv->ui->gg, svx + sv->width - _const_ui__scrollbar_size, svy + sv->btn_y, _const_ui__scrollbar_size, sv->btn_h, _const_ui__scrollbar_size / 3, sv->btn_color_y);
	}
}

void ui__ScrollView_set(ui__ScrollView* sv, int val, ui__ScrollViewPart mode) {
	if (ui__ScrollView_is_active(sv)) {
		if (sv->active_x && mode == ui__ScrollViewPart__btn_x) {
			sv->offset_x = val;
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_x);
		} else if (sv->active_y && mode == ui__ScrollViewPart__btn_y) {
			sv->offset_y = val;
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_y);
		}
	}
}

void ui__ScrollView_scroll_to_end_y(ui__ScrollView* sv) {
	multi_return_int_f32 mr_12990 = ui__ScrollView_coef_y(sv);
	int max_offset_y = mr_12990.arg0;
	ui__ScrollView_set(sv, max_offset_y, ui__ScrollViewPart__btn_y);
}

void ui__ScrollView_inc(ui__ScrollView* sv, int delta, ui__ScrollViewPart mode) {
	if (ui__ScrollView_is_active(sv)) {
		if (sv->active_x && mode == ui__ScrollViewPart__btn_x) {
			sv->offset_x += delta;
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_x);
		} else if (sv->active_y && mode == ui__ScrollViewPart__btn_y) {
			sv->offset_y += delta;
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_y);
		}
	}
}

void ui__scrollview_scroll(ui__ScrollView* sv, ui__ScrollEvent* e, voidptr zzz) {
	if (ui__ScrollView_is_active(sv) && ui__ScrollView_point_inside(sv, e->mouse_x, e->mouse_y, ui__ScrollViewPart__view) && !ui__ScrollView_children_point_inside(sv, e->mouse_x, e->mouse_y, ui__ScrollViewPart__view)) {
		ui__ScrollableWidget sw = sv->widget;
		if (I_ui__ScrollableWidget_is_I_ui__Widget(sw)) {
			ui__Widget w = I_ui__ScrollableWidget_as_I_ui__Widget(sw);
			if (ui__Window_is_top_widget(/*rec*/*sv->ui->window, w, _const_ui__events.on_scroll)) {
				if (sv->active_x) {
					sv->offset_x -= ((int)(e->x * sv->delta_mouse));
					ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_x);
				}
				if (sv->active_y) {
					sv->offset_y -= ((int)(e->y * sv->delta_mouse));
					ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_y);
				}
			}
		}
	}
}

void ui__scrollview_click(ui__ScrollView* sv, ui__MouseEvent* e, voidptr zzz) {
	if (!ui__ScrollView_is_active(sv)) {
		return;
	}
	sv->is_focused = ui__ScrollView_point_inside(sv, e->x, e->y, ui__ScrollViewPart__view) && !ui__ScrollView_children_point_inside(sv, e->x, e->y, ui__ScrollViewPart__view);
	if (sv->active_x && ui__ScrollView_point_inside(sv, e->x, e->y, ui__ScrollViewPart__bar_x)) {
		sv->is_focused = true;
		multi_return_int_f32 mr_14214 = ui__ScrollView_coef_x(sv);
		f32 a_x = mr_14214.arg1;
		sv->offset_x = ((int)((e->x - sv->orig_x - sv->btn_w / 2) / a_x));
		ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_x);
	} else if (sv->active_y && ui__ScrollView_point_inside(sv, e->x, e->y, ui__ScrollViewPart__bar_y)) {
		sv->is_focused = true;
		multi_return_int_f32 mr_14409 = ui__ScrollView_coef_y(sv);
		f32 a_y = mr_14409.arg1;
		sv->offset_y = ((int)((e->y - sv->orig_y - sv->btn_h / 2) / a_y));
		ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_y);
	}
}

void ui__scrollview_mouse_down(ui__ScrollView* sv, ui__MouseEvent* e, voidptr zzz) {
	if (!ui__ScrollView_is_active(sv)) {
		return;
	}
	if (((int)(e->button)) == 0) {
		if (sv->active_x && ui__ScrollView_point_inside(sv, e->x, e->y, ui__ScrollViewPart__btn_x)) {
			sv->dragging = 1;
			sv->drag_offset = e->x;
			sv->orig_offset = sv->offset_x;
		} else if (sv->active_y && ui__ScrollView_point_inside(sv, e->x, e->y, ui__ScrollViewPart__btn_y)) {
			sv->dragging = 2;
			sv->drag_offset = e->y;
			sv->orig_offset = sv->offset_y;
		}
	}
}

void ui__scrollview_mouse_up(ui__ScrollView* sv, ui__MouseEvent* e, voidptr zzz) {
	if (!ui__ScrollView_is_active(sv)) {
		return;
	}
	sv->dragging = 0;
	sv->drag_offset = 0;
}

void ui__scrollview_mouse_move(ui__ScrollView* sv, ui__MouseMoveEvent* e, voidptr zzz) {
	if (!ui__ScrollView_is_active(sv)) {
		return;
	}
	sv->btn_color_x = (ui__ScrollView_point_inside(sv, e->x, e->y, ui__ScrollViewPart__btn_x) ? (_const_ui__scrollbar_focused_button_color) : (_const_ui__scrollbar_button_color));
	sv->btn_color_y = (ui__ScrollView_point_inside(sv, e->x, e->y, ui__ScrollViewPart__btn_y) ? (_const_ui__scrollbar_focused_button_color) : (_const_ui__scrollbar_button_color));
	if (!sv->ui->btn_down[0]) {
		sv->dragging = 0;
	} else if (sv->dragging > 0) {
		if (sv->dragging == 1) {
			multi_return_int_f32 mr_15845 = ui__ScrollView_coef_x(sv);
			f32 a_x = mr_15845.arg1;
			sv->offset_x = sv->orig_offset + ((int)(((f32)(e->x - sv->drag_offset)) / a_x));
		} else {
			multi_return_int_f32 mr_15952 = ui__ScrollView_coef_y(sv);
			f32 a_y = mr_15952.arg1;
			sv->offset_y = sv->orig_offset + ((int)(((f32)(e->y - sv->drag_offset)) / a_y));
		}
		ui__ScrollView_change_value(sv, ((ui__ScrollViewPart)(sv->dragging)));
	}
}

void ui__scrollview_key_down(ui__ScrollView* sv, ui__KeyEvent* e, voidptr zzz) {
	if (!ui__ScrollView_is_active(sv) || !sv->is_focused || (sv->widget)._typ == _ui__ScrollableWidget_ui__TextBox_index) {
		return;
	}

	if (e->key == (ui__Key__up)) {
		if (sv->active_y) {
			sv->offset_y -= _const_ui__scrollview_delta_key;
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_y);
		}
	}
	else if (e->key == (ui__Key__down)) {
		if (sv->active_y) {
			sv->offset_y += _const_ui__scrollview_delta_key;
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_y);
		}
	}
	else if (e->key == (ui__Key__left)) {
		if (sv->active_x) {
			sv->offset_x -= _const_ui__scrollview_delta_key;
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_x);
		}
	}
	else if (e->key == (ui__Key__right)) {
		if (sv->active_x) {
			sv->offset_x += _const_ui__scrollview_delta_key;
			ui__ScrollView_change_value(sv, ui__ScrollViewPart__btn_x);
		}
	}
	else {
	};
}

multi_return_int_f32 ui__ScrollView_coef_x(ui__ScrollView* sv) {
	int max_offset_x = sv->adj_width - sv->width + 2 * _const_ui__scrollbar_size;
	return (multi_return_int_f32){.arg0=max_offset_x, .arg1=((f32)(sv->sb_w - sv->btn_w)) / ((f32)(max_offset_x))};
}

multi_return_int_f32 ui__ScrollView_coef_y(ui__ScrollView* sv) {
	int max_offset_y = (sv->adj_height - sv->height + 2 * _const_ui__scrollbar_size);
	return (multi_return_int_f32){.arg0=max_offset_y, .arg1=((f32)(sv->sb_h - sv->btn_h)) / ((f32)(max_offset_y))};
}

// TypeDecl
Array_f32 ui__Size_as_f32_array(ui__Size size, int len) {
	Array_f32 res = __new_array_with_default(0, 0, sizeof(f32), 0);
	if (size._typ == 166 /* []f64 */) {
		for (int _t1 = 0; _t1 < (*size._Array_f64).len; ++_t1) {
			f64 v = ((f64*)(*size._Array_f64).data)[_t1];
			array_push((array*)&res, _MOV((f32[]){ ((f32)(v)) }));
		}
	}
	else if (size._typ == 16 /* f64 */) {
		res = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(f32), _MOV((f32[1]){((f32)((*size._f64)))})), len, 0);
	}
	;
	Array_f32 _t3 = res;
	return _t3;
}

int ui__relative_size_from_parent(int size, int parent_free_size) {
	int _t2; /* if prepend */
	if (size == -100) {
		_t2 = parent_free_size;
	} else if (size < 0) {
		f32 percent = ((f32)(-size)) / 100;
		int new_size = ((int)(percent * parent_free_size));
		println( str_intp(5, _MOV((StrIntpData[]){{_SLIT("relative size: "), 0xfe07, {.d_i32 = size}}, {_SLIT(" "), 0xfe07, {.d_i32 = new_size}}, {_SLIT(" -> "), 0x1fe0e, {.d_f32 = percent}}, {_SLIT(" * "), 0xfe07, {.d_i32 = parent_free_size}}, {_SLIT(") "), 0, { .d_c = 0 }}})));
		_t2 = new_size;
	} else {
		_t2 = size;
	}
	int _t1 =  _t2;
	return _t1;
}

bool ui__is_children_have_widget(Array_ui__Widget children) {
	Array_ui__Widget _t1 = {0};
	Array_ui__Widget _t1_orig = children;
	int _t1_len = _t1_orig.len;
	_t1 = __new_array(0, _t1_len, sizeof(ui__Widget));

	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		ui__Widget it = ((ui__Widget*) _t1_orig.data)[_t2];
		if (!((it)._typ == _ui__Widget_ui__Stack_index || (it)._typ == _ui__Widget_ui__Group_index)) {
			array_push((array*)&_t1, &it);
		}
	}
	Array_ui__Widget tmp =_t1;
	bool _t3 = tmp.len > 0;
	return _t3;
}

// Attr: [unsafe]
void ui__CachedSizes_free(ui__CachedSizes* c) {
	{ // Unsafe block
		array_free(&c->width_type);
		array_free(&c->height_type);
		array_free(&c->adj_widths);
		array_free(&c->adj_heights);
		array_free(&c->fixed_widths);
		array_free(&c->fixed_heights);
		array_free(&c->weight_widths);
		array_free(&c->weight_heights);
		_v_free(c);
	}
}

ui__Margins ui__margins(f64 m, ui__Margin ms) {
	ui__Margins margin = ((ui__Margins){.top = ((f32)(m)),.right = ((f32)(m)),.bottom = ((f32)(m)),.left = ((f32)(m)),});
	if (ms.left != 0 || ms.right != 0 || ms.top != 0 || ms.bottom != 0) {
		margin = ((ui__Margins){.top = ((f32)(ms.top)),.right = ((f32)(ms.right)),.bottom = ((f32)(ms.bottom)),.left = ((f32)(ms.left)),});
	}
	ui__Margins _t1 = margin;
	return _t1;
}

Array_f32 ui__spacings(f64 sp, Array_f64 sps, int len) {
	if (len < 0) {
		Array_f32 _t1 = __new_array_with_default(0, 0, sizeof(f32), 0);
		return _t1;
	}
	Array_f32 spacing = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(f32), _MOV((f32[1]){((f32)(sp))})), len, 0);
	if (sps.len == len) {
		Array_f32 _t2 = {0};
		Array_f64 _t2_orig = sps;
		int _t2_len = _t2_orig.len;
		_t2 = __new_array(0, _t2_len, sizeof(f32));

		for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
			f64 it = ((f64*) _t2_orig.data)[_t3];
			f32 ti = ((f32)(it));
			array_push((array*)&_t2, &ti);
		}
		spacing =_t2;
	}
	Array_f32 _t4 = spacing;
	return _t4;
}

f32 ui__relative_size(f32 size, int w, int h) {
	f32 _t1 = (size < 1 ? (size * ((f32)(math__min_T_int(w, h)))) : (size));
	return _t1;
}

multi_return_int_int ui__text_xminmax_from_pos_T_ui__TextBox(ui__TextBox* w, string text, int x1, int x2) {
	Array_rune ustr = string_runes(text);
	multi_return_int_int mr_410 = (x1 < x2 ? ((multi_return_int_int){.arg0=x1,.arg1=x2}) : ((multi_return_int_int){.arg0=x2,.arg1=x1}));
	int x_min = mr_410.arg0;
	int x_max = mr_410.arg1;
	if (x_max > ustr.len) {
		x_max = ustr.len;
	}
	if (x_min < 0) {
		x_min = 0;
	}
	string left = Array_rune_string(array_slice(ustr, 0, x_min));
	Array_rune _t1;
		string right = Array_rune_string((_t1 = ustr, array_slice(_t1, x_max, _t1.len)));
	int ww = ui__text_width_T_ui__TextBox(w, text);
	int lw = ui__text_width_T_ui__TextBox(w, left);
	int rw = ui__text_width_T_ui__TextBox(w, right);
	return (multi_return_int_int){.arg0=lw, .arg1=ww - lw - rw};
}

int ui__text_pos_from_x_T_ui__TextBox(ui__TextBox* w, string text, int x) {
	if (x <= 0) {
		int _t1 = 0;
		return _t1;
	}
	int prev_width = 0;
	Array_rune ustr = string_runes(text);
	for (int i = 0; i < ustr.len; ++i) {
		int width = ui__text_width_T_ui__TextBox(w, Array_rune_string(array_slice(ustr, 0, i)));
		int width2 = (i < ustr.len ? (ui__text_width_T_ui__TextBox(w, Array_rune_string(array_slice(ustr, 0, (i + 1))))) : (width));
		if ((prev_width + width) / 2 <= x && x <= (width + width2) / 2) {
			int _t2 = i;
			return _t2;
		}
		prev_width = width;
	}
	int _t3 = ustr.len;
	return _t3;
}

string ui__word_wrap_join(Array_string lines, Array_int ind) {
	string res = _SLIT("");
	for (int i = 0; i < lines.len; ++i) {
		string line = ((string*)lines.data)[i];
		string sp = (i == 0 ? (_SLIT("")) : (*(int*)/*ee elem_sym */array_get(ind, i)) > 0 ? (_SLIT(" ")) : (_SLIT("\n")));
		res = /*f*/string__plus(res, string__plus(sp, line));
	}
	string _t1 = res;
	return _t1;
}

int ui__text_lines_pos_at(Array_string lines, int i, int j) {
	int pos = 0;
	for (int k = 0; k < j; ++k) {
		pos += string_runes((*(string*)/*ee elem_sym */array_get(lines, k))).len + 1;
	}
	pos += i;
	int _t1 = pos;
	return _t1;
}

multi_return_int_int ui__text_lines_row_column_at(Array_string lines, int pos) {
	if (pos == 0) {
		return (multi_return_int_int){.arg0=0, .arg1=0};
	}
	int j = 0;
	int total_len = 0;
	int ustr_len = 0;
	for (int _t2 = 0; _t2 < lines.len; ++_t2) {
		string line = ((string*)lines.data)[_t2];
		ustr_len = string_runes(line).len + 1;
		total_len += ustr_len;
		if (pos > total_len) {
			j++;
		} else {
			total_len -= ustr_len;
			break;
		}
	}
	return (multi_return_int_int){.arg0=pos - total_len, .arg1=j};
}

Array_string ui__word_wrap_to_lines(string s, int max_line_length) {
	Array_string words = string_split(s, _SLIT(" "));
	Array_string line = __new_array_with_default(0, 0, sizeof(string), 0);
	int line_len = 0;
	Array_string text_lines = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < words.len; ++_t1) {
		string word = ((string*)words.data)[_t1];
		int word_len = string_runes(word).len;
		if (line_len + word_len < max_line_length) {
			array_push((array*)&line, _MOV((string[]){ string_clone(word) }));
			line_len += word_len + 1;
			continue;
		} else {
			array_push((array*)&text_lines, _MOV((string[]){ string_clone(Array_string_join(line, _SLIT(" "))) }));
			line = __new_array_with_default(0, 0, sizeof(string), 0);
			line_len = 0;
		}
	}
	if (line_len > 0) {
		array_push((array*)&text_lines, _MOV((string[]){ string_clone(Array_string_join(line, _SLIT(" "))) }));
	}
	Array_string _t5 = text_lines;
	return _t5;
}

Array_string ui__word_wrap_text_to_lines(string s, int max_line_length) {
	Array_string lines = string_split(s, _SLIT("\n"));
	Array_string word_wrapped_lines = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < lines.len; ++_t1) {
		string line = ((string*)lines.data)[_t1];
		_PUSH_MANY(&word_wrapped_lines, (ui__word_wrap_to_lines(line, max_line_length)), _t2, Array_string);
	}
	Array_string _t3 = word_wrapped_lines;
	return _t3;
}

multi_return_int_int ui__text_lines_size(Array_string lines, ui__UI* ui) {
	int width = 0;
	int height = 0;
	int tw = 0;
	int th = 0;
	for (int _t1 = 0; _t1 < lines.len; ++_t1) {
		string line = ((string*)lines.data)[_t1];
		multi_return_int_int mr_4330 = gg__Context_text_size(ui->gg, line);
		tw = mr_4330.arg0;
		th = mr_4330.arg1;
		if (tw > width) {
			width = tw;
		}
		height += th;
	}
	return (multi_return_int_int){.arg0=width, .arg1=height};
}

// Attr: [unsafe]
void ui__Tooltip_free(ui__Tooltip* t) {
	{ // Unsafe block
		for (int _t1 = 0; _t1 < t->TextLines.lines.len; ++_t1) {
			string line = ((string*)t->TextLines.lines.data)[_t1];
			string_free(&line);
		}
		array_free(&t->TextLines.lines);
	}
}

// Attr: [unsafe]
void ui__TooltipMessage_free(ui__TooltipMessage* t) {
	string_free(&t->text);
}

void ui__start_tooltip(ui__Widget* w, string id, ui__TooltipMessage msg, ui__UI* wui) {
	ui__Window* win = wui->window;
	win->tooltip.id = id;
	if (!win->tooltip.active) {
		if (win->tooltip.ui == 0) {
			{ // Unsafe block
				win->tooltip.ui = wui;
			}
		}
		win->tooltip.TextLines.lines = ui__word_wrap_text_to_lines(msg.text, 70);
		multi_return_int_int mr_6073 = ui__text_lines_size(win->tooltip.TextLines.lines, wui);
		win->tooltip.TextLines.width = mr_6073.arg0;
		win->tooltip.TextLines.height = mr_6073.arg1;
		win->tooltip.TextLines.width += 2 * _const_ui__tooltip_margin;
		win->tooltip.TextLines.height += 2 * _const_ui__tooltip_margin;
		ui__set_text_cfg_color(HEAP(ui__DrawText, /*&ui.DrawText*/I_ui__Tooltip_to_Interface_ui__DrawText(&win->tooltip)), win->tooltip.color);
		ui__set_text_cfg_style(HEAP(ui__DrawText, /*&ui.DrawText*/I_ui__Tooltip_to_Interface_ui__DrawText(&win->tooltip)), true, true, false);
		win->tooltip.active = true;
		multi_return_int_int mr_6367 = ui__Widget_name_table[w->_typ]._method_size(w->_object);
		int width = mr_6367.arg0;
		int height = mr_6367.arg1;

		if (msg.side == (ui__Side__top)) {
			win->tooltip.TextLines.x = (*(w->x)) + (*(w->offset_x)) + width / 2 - win->tooltip.TextLines.width / 2;
			win->tooltip.TextLines.y = (*(w->y)) + (*(w->offset_y)) - win->tooltip.TextLines.height - _const_ui__tooltip_margin;
		}
		else if (msg.side == (ui__Side__right)) {
			win->tooltip.TextLines.x = (*(w->x)) + (*(w->offset_x)) + width + _const_ui__tooltip_margin;
			win->tooltip.TextLines.y = (*(w->y)) + (*(w->offset_y)) + height / 2 - win->tooltip.TextLines.height / 2;
		}
		else {
		};
	}
}

void ui__stop_tooltip(string id, ui__UI* wui) {
	ui__Window* win = wui->window;
	if (win->tooltip.active && string__eq(win->tooltip.id, id)) {
		win->tooltip.active = false;
	}
}

void ui__draw_tooltip(ui__Window _v_toheap_win) {
ui__Window* win = HEAP(ui__Window, _v_toheap_win);
	if ((*(win)).tooltip.active) {
		gg__Context_draw_rounded_rect_filled((*(win)).ui->gg, (*(win)).tooltip.TextLines.x, (*(win)).tooltip.TextLines.y, (*(win)).tooltip.TextLines.width, (*(win)).tooltip.TextLines.height, .3, (*(win)).tooltip.bg_color);
		ui__draw_text_lines(/*&ui.DrawText*/I_ui__Tooltip_to_Interface_ui__DrawText(&(*(win)).tooltip), (*(win)).tooltip.TextLines.x + _const_ui__tooltip_margin, (*(win)).tooltip.TextLines.y, (*(win)).tooltip.TextLines.lines);
	}
}

void ui__Window_append_tooltip(ui__Window* w, ui__Widget child, ui__TooltipMessage tooltip) {
	array_push((array*)&w->widgets_tooltip, _MOV((ui__Widget[]){ child }));
	array_push((array*)&w->tooltips, _MOV((ui__TooltipMessage[]){ tooltip }));
}

void ui__Window_update_tooltip(ui__Window* w, ui__MouseMoveEvent* e) {
	for (int i = 0; i < w->widgets_tooltip.len; ++i) {
		ui__Widget* child = ((ui__Widget*)w->widgets_tooltip.data) + i;
		string id = ui__Widget_id(child);
		if (!(*(child->hidden))) {
			if (ui__Widget_name_table[child->_typ]._method_point_inside(child->_object, e->x, e->y)) {
				ui__start_tooltip(child, id, (*(ui__TooltipMessage*)/*ee elem_sym */array_get(w->tooltips, i)), w->ui);
			} else {
				ui__stop_tooltip(id, w->ui);
			}
			if (w->dragger.activated) {
				ui__stop_tooltip(id, w->ui);
			}
		}
	}
}

void ui__Window_add_message_dialog(ui__Window* win) {
	ui__Stack* dlg = ui__column(((ui__ColumnParams){
		.id = _SLIT("_msg_dlg_col"),
		.width = 0,
		.height = 0,
		.alignment = ui__HorizontalAlignment__center,
		.spacing = 10,
		.spacings = __new_array_with_default(0, 0, sizeof(f64), 0),
		.stretch = 0,
		.margin = ((ui__Margin){.top = 5,.right = 5,.bottom = 5,.left = 5,}),
		.margin_ = 0,
		.widths = f64_to_sumtype_ui__Size(ADDR(f64, (_const_ui__compact))),
		.heights = f64_to_sumtype_ui__Size(ADDR(f64, (_const_ui__compact))),
		.alignments = (ui__HorizontalAlignments){.left = __new_array(0, 0, sizeof(int)),.center = __new_array(0, 0, sizeof(int)),.right = __new_array(0, 0, sizeof(int)),},
		.align = (ui__Alignments){.center = __new_array(0, 0, sizeof(int)),.left_top = __new_array(0, 0, sizeof(int)),.top = __new_array(0, 0, sizeof(int)),.right_top = __new_array(0, 0, sizeof(int)),.right = __new_array(0, 0, sizeof(int)),.right_bottom = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),.left_bottom = __new_array(0, 0, sizeof(int)),.left = __new_array(0, 0, sizeof(int)),},
		.bg_color = ((gx__Color){.r = 140,.g = 210,.b = 240,.a = 100,}),
		.bg_radius = .3,
		.title = (string){.str=(byteptr)"", .is_lit=1},
		.scrollview = 0,
		.children = new_array_from_c_array(2, 2, sizeof(ui__Widget), _MOV((ui__Widget[2]){/*&ui.Widget*/I_ui__Label_to_Interface_ui__Widget(ui__label(((ui__LabelParams){.id = _SLIT("_msg_dlg_lab"),.width = 0,.height = 0,.z_index = 0,.text = _SLIT(" Hello World"),.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,}))), /*&ui.Widget*/I_ui__Button_to_Interface_ui__Widget(ui__button(((ui__ButtonParams){.id = _SLIT("_msg_dlg_btn"),.text = _SLIT("OK"),.icon_path = (string){.str=(byteptr)"", .is_lit=1},.onclick = (voidptr)ui__message_dialog_click,.on_key_down = 0,.height = 0,.width = 100,.z_index = 0,.movable = 0,.hoverable = 0,.tooltip = (string){.str=(byteptr)"", .is_lit=1},.tooltip_side = ui__Side__top,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,.bg_color = 0,.theme = string_to_sumtype_ui__ColorThemeCfg(ADDR(string, (_SLIT("classic")))),.radius = .3,.padding = 0,})))})),
	}));
	dlg->is_root_layout = false;
	array_push((array*)&win->children, _MOV((ui__Widget[]){ /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget(dlg) }));
	ui__Stack_set_visible(dlg, false);
}

void ui__message_dialog_click(voidptr app, ui__Button* b) {
	ui__Stack* dlg = ui__Window_stack(b->ui->window, _SLIT("_msg_dlg_col"));
	ui__Stack_set_visible(dlg, false);
}

void ui__Window_message(ui__Window* win, string s) {
	if (win->native_message) {
		ui__message_box(s);
	} else {
		ui__Stack* dlg = ui__Window_stack(win, _SLIT("_msg_dlg_col"));
		ui__Label* msg = ui__Window_label(win, _SLIT("_msg_dlg_lab"));
		ui__Label_set_text(msg, s);
		multi_return_int_int mr_8816 = ui__text_lines_size(string_split(s, _SLIT("\n")), win->ui);
		int tw = mr_8816.arg0;
		int th = mr_8816.arg1;
		ui__Label_propose_size(msg, tw, th);
		if (tw < 200) {
			tw = 200;
		}
		th += 50;
		ui__Stack_propose_size(dlg, tw, th);
		multi_return_int_int mr_8999 = ui__Window_size(win);
		int ww = mr_8999.arg0;
		int wh = mr_8999.arg1;
		ui__Stack_set_pos(dlg, ww / 2 - tw / 2, wh / 2 - th / 2);
		ui__Stack_set_visible(dlg, true);
		ui__Stack_update_layout(dlg);
	}
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
ui__SyntaxHighLighter* ui__syntaxhighlighter(void) {
	ui__SyntaxHighLighter* _t1 = ((ui__SyntaxHighLighter*)memdup(&(ui__SyntaxHighLighter){.tv = 0,.ustr = __new_array(0, 0, sizeof(rune)),.chunks = new_map(sizeof(string), sizeof(Array_ui__Chunk), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.lang = (string){.str=(byteptr)"", .is_lit=1},.lang_exts = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.style = _SLIT("default"),.styles = new_map(sizeof(string), sizeof(ui__SyntaxStyle), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.is_multiline = new_map(sizeof(string), sizeof(ui__SyntaxMapBool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.keywords = new_map(sizeof(string), sizeof(ui__SyntaxMapStrings), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.singleline = new_map(sizeof(string), sizeof(ui__SyntaxMapStrings), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.multiline = new_map(sizeof(string), sizeof(ui__SyntaxMapArrayStrings), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.between_one_rune = new_map(sizeof(string), sizeof(ui__SyntaxMapRunes), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.i = 0,.j = 0,.start = 0,.y = 0,}, sizeof(ui__SyntaxHighLighter)));
	return _t1;
}

void ui__SyntaxHighLighter_init(ui__SyntaxHighLighter* sh, ui__TextView* tv) {
	{ // Unsafe block
		sh->tv = tv;
	}
	sh->styles = new_map(sizeof(string), sizeof(ui__SyntaxStyle), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	sh->keywords = new_map(sizeof(string), sizeof(ui__SyntaxMapStrings), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	sh->singleline = new_map(sizeof(string), sizeof(ui__SyntaxMapStrings), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	sh->multiline = new_map(sizeof(string), sizeof(ui__SyntaxMapArrayStrings), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	sh->between_one_rune = new_map(sizeof(string), sizeof(ui__SyntaxMapRunes), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	sh->is_multiline = new_map(sizeof(string), sizeof(ui__SyntaxMapBool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	sh->lang_exts = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 2, sizeof(string), sizeof(Array_string), _MOV((string[2]){_SLIT("v"), _SLIT("c"), }), _MOV((Array_string[2]){new_array_from_c_array(3, 3, sizeof(string), _MOV((string[3]){_SLIT(".v"), _SLIT(".vv"), _SLIT(".vsh")})), new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT(".h"), _SLIT(".c")})), }));
	ui__SyntaxHighLighter_load_v(sh);
	ui__SyntaxHighLighter_load_c(sh);
	ui__SyntaxHighLighter_set_lang(sh, _SLIT(""));
	ui__SyntaxHighLighter_load_default_style(sh);
	ui__TextView_update_style(sh->tv, ((ui__TextStyleParams){.id = _const_ui__no_string,.font_name = _SLIT("fixed"),.color = _const_ui__no_color,.size = 18,.align = ui__TextHorizontalAlign__none,.vertical_align = ui__TextVerticalAlign__none,}));
}

void ui__SyntaxHighLighter_set_lang(ui__SyntaxHighLighter* sh, string ext) {
	sh->lang = _SLIT("");
	if (ext.len == 0) {
		return;
	}
	ui__SyntaxMapStrings _t1 = sh->lang_exts;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string lang = /*key*/ *(string*)DenseArray_key(&_t1.key_values, _t2);
		lang = string_clone(lang);
		Array_string exts = (*(Array_string*)DenseArray_value(&_t1.key_values, _t2));
		if (Array_string_contains(exts, ext)) {
			sh->lang = lang;
			return;
		}
	}
}

bool ui__SyntaxHighLighter_is_lang_loaded(ui__SyntaxHighLighter* sh) {
	bool _t1 = (sh->lang).len != 0;
	return _t1;
}

void ui__SyntaxHighLighter_load_default_style(ui__SyntaxHighLighter* sh) {
	map_set(&sh->styles, &(string[]){_SLIT("default")}, &(ui__SyntaxStyle[]) { new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 8, sizeof(string), sizeof(ui__SyntaxChunk), _MOV((string[8]){_SLIT("comment"), _SLIT("keyword"), _SLIT("control"), _SLIT("decl"), _SLIT("types"), _SLIT("string"), _SLIT("symbols"), _SLIT("numeric"), }), _MOV((ui__SyntaxChunk[8]){((ui__SyntaxChunk){.color = _const_gx__gray,.font = _SLIT("fixed"),}), ((ui__SyntaxChunk){.color = _const_gx__orange,.font = _SLIT("fixed_bold"),}), ((ui__SyntaxChunk){.color = _const_gx__orange,.font = _SLIT("fixed_bold"),}), ((ui__SyntaxChunk){.color = _const_gx__black,.font = _SLIT("fixed_bold"),}), ((ui__SyntaxChunk){.color = _const_gx__purple,.font = _SLIT("fixed_bold"),}), ((ui__SyntaxChunk){.color = _const_gx__dark_green,.font = _SLIT("fixed_bold_italic"),}), ((ui__SyntaxChunk){.color = _const_gx__red,.font = _SLIT("fixed_bold"),}), ((ui__SyntaxChunk){.color = _const_gx__blue,.font = _SLIT("fixed_bold"),}), })) });
}

void ui__SyntaxHighLighter_load_v(ui__SyntaxHighLighter* sh) {
	map_set(&sh->keywords, &(string[]){_SLIT("v")}, &(ui__SyntaxMapStrings[]) { new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 6, sizeof(string), sizeof(Array_string), _MOV((string[6]){_SLIT("types"), _SLIT("decl"), _SLIT("control"), _SLIT("keyword"), _SLIT("symbols"), _SLIT("numeric"), }), _MOV((Array_string[6]){string_split(_SLIT("int,i8,i16,i64,i128,u8,u16,u32,u64,u128,f32,f64,bool,u8,byteptr,charptr,voidptr,string,ustring,rune"), _SLIT(",")), string_split(_SLIT("[,],{,},mut:,pub:,pub mut:,mut,pub,unsafe,default,struct,type,enum,struct,union,const"), _SLIT(",")), string_split((string__plus(string__plus(string__plus(_SLIT("in,is,or,as,in,is,or,break,continue,match,if,else,for,go,goto,defer,return,shared,select,rlock,lock,atomic,asm"), _SLIT(",$")), _SLIT("if,$")), _SLIT("else"))), _SLIT(",")), string_split(_SLIT("fn,module,import,interface,map,assert,sizeof,typeof,__offsetof"), _SLIT(",")), string_split(_SLIT("||,&&,&,=,:=,==,<=,>=,>,<,!"), _SLIT(",")), string_split(_SLIT("0,1,2,3,4,5,6,7,8,9,."), _SLIT(",")), })) });
	map_set(&sh->singleline, &(string[]){_SLIT("v")}, &(ui__SyntaxMapStrings[]) { new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(Array_string), _MOV((string[1]){_SLIT("comment"), }), _MOV((Array_string[1]){new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("//"), _SLIT("#")})), })) });
	map_set(&sh->multiline, &(string[]){_SLIT("v")}, &(ui__SyntaxMapArrayStrings[]) { new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(Array_Array_string), _MOV((string[1]){_SLIT("comment"), }), _MOV((Array_Array_string[1]){new_array_from_c_array(1, 1, sizeof(Array_string), _MOV((Array_string[1]){new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("/*"), _SLIT("*/")}))})), })) });
	map_set(&sh->between_one_rune, &(string[]){_SLIT("v")}, &(ui__SyntaxMapRunes[]) { new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(Array_rune), _MOV((string[1]){_SLIT("string"), }), _MOV((Array_rune[1]){new_array_from_c_array(3, 3, sizeof(rune), _MOV((rune[3]){'\'', '"', '`'})), })) });
	map_set(&sh->is_multiline, &(string[]){_SLIT("v")}, &(ui__SyntaxMapBool[]) { new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(bool), _MOV((string[1]){_SLIT("/*"), }), _MOV((bool[1]){false, })) });
}

void ui__SyntaxHighLighter_load_c(ui__SyntaxHighLighter* sh) {
	map_set(&sh->keywords, &(string[]){_SLIT("c")}, &(ui__SyntaxMapStrings[]) { new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 4, sizeof(string), sizeof(Array_string), _MOV((string[4]){_SLIT("types"), _SLIT("decl"), _SLIT("control"), _SLIT("keyword"), }), _MOV((Array_string[4]){string_split(_SLIT("int|i8|i16|i64|i128|u8|u16|u32|u64|u128|f32|f64|bool|u8|byteptr|charptr|voidptr|string|ustring|rune"), _SLIT("|")), string_split(_SLIT("mut|pub|unsafe|default|module|import|const|interface"), _SLIT("|")), string_split((string__plus(string__plus(string__plus(_SLIT("enum|in|is|or|as|in|is|or|break|continue|match|if|else|for|go|goto|defer|return|shared|select|rlock|lock|atomic|asm"), _SLIT("|$")), _SLIT("if|$")), _SLIT("else"))), _SLIT("|")), string_split(_SLIT("fn|type|enum|struct|union|interface|map|assert|sizeof|typeof|__offsetof"), _SLIT("|")), })) });
	map_set(&sh->singleline, &(string[]){_SLIT("c")}, &(ui__SyntaxMapStrings[]) { new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(Array_string), _MOV((string[1]){_SLIT("comment"), }), _MOV((Array_string[1]){new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("//"), _SLIT("#")})), })) });
	map_set(&sh->multiline, &(string[]){_SLIT("c")}, &(ui__SyntaxMapArrayStrings[]) { new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(Array_Array_string), _MOV((string[1]){_SLIT("comment"), }), _MOV((Array_Array_string[1]){new_array_from_c_array(1, 1, sizeof(Array_string), _MOV((Array_string[1]){new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT("/*"), _SLIT("*/")}))})), })) });
	map_set(&sh->between_one_rune, &(string[]){_SLIT("c")}, &(ui__SyntaxMapRunes[]) { new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(Array_rune), _MOV((string[1]){_SLIT("string"), }), _MOV((Array_rune[1]){new_array_from_c_array(3, 3, sizeof(rune), _MOV((rune[3]){'\'', '"', '`'})), })) });
	map_set(&sh->is_multiline, &(string[]){_SLIT("c")}, &(ui__SyntaxMapBool[]) { new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(bool), _MOV((string[1]){_SLIT("/*"), }), _MOV((bool[1]){false, })) });
}

void ui__SyntaxHighLighter_parse_chunks(ui__SyntaxHighLighter* sh, int j, int y, string line) {
	if (!ui__SyntaxHighLighter_is_lang_loaded(sh)) {
		return;
	}
	sh->j = j;
	sh->y = y;
	if (j == 0) {
		ui__SyntaxMapBool _t1 = (*(ui__SyntaxMapBool*)map_get(ADDR(map, sh->is_multiline), &(string[]){sh->lang}, &(ui__SyntaxMapBool[]){ new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string) }));
		int _t3 = _t1.key_values.len;
		for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
			int _t4 = _t1.key_values.len - _t3;
			_t3 = _t1.key_values.len;
			if (_t4 < 0) {
				_t2 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&_t1.key_values, _t2);
			k = string_clone(k);
			map_set(&(*(ui__SyntaxMapBool*)map_get_and_set((map*)&sh->is_multiline, &(string[]){sh->lang}, &(ui__SyntaxMapBool[]){ new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string) })), &(string[]){k}, &(bool[]) { false });
		}
	}
	sh->ustr = string_runes(line);
	string l = string_trim_space(line);
	ui__SyntaxMapStrings _t5 = (*(ui__SyntaxMapStrings*)map_get(ADDR(map, sh->singleline), &(string[]){sh->lang}, &(ui__SyntaxMapStrings[]){ new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string) }));
	int _t7 = _t5.key_values.len;
	for (int _t6 = 0; _t6 < _t7; ++_t6 ) {
		int _t8 = _t5.key_values.len - _t7;
		_t7 = _t5.key_values.len;
		if (_t8 < 0) {
			_t6 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t5.key_values, _t6)) {continue;}
		string typ = /*key*/ *(string*)DenseArray_key(&_t5.key_values, _t6);
		typ = string_clone(typ);
		Array_string vals = (*(Array_string*)DenseArray_value(&_t5.key_values, _t6));
		for (int _t9 = 0; _t9 < vals.len; ++_t9) {
			string val = ((string*)vals.data)[_t9];
			if (ui__SyntaxHighLighter_parse_chunk_oneline_comment(sh, typ, val, l)) {
				return;
			}
		}
	}
	ui__SyntaxMapArrayStrings _t10 = (*(ui__SyntaxMapArrayStrings*)map_get(ADDR(map, sh->multiline), &(string[]){sh->lang}, &(ui__SyntaxMapArrayStrings[]){ new_map(sizeof(string), sizeof(Array_Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string) }));
	int _t12 = _t10.key_values.len;
	for (int _t11 = 0; _t11 < _t12; ++_t11 ) {
		int _t13 = _t10.key_values.len - _t12;
		_t12 = _t10.key_values.len;
		if (_t13 < 0) {
			_t11 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t10.key_values, _t11)) {continue;}
		string typ = /*key*/ *(string*)DenseArray_key(&_t10.key_values, _t11);
		typ = string_clone(typ);
		Array_Array_string vals = (*(Array_Array_string*)DenseArray_value(&_t10.key_values, _t11));
		for (int _t14 = 0; _t14 < vals.len; ++_t14) {
			Array_string val = ((Array_string*)vals.data)[_t14];
			if (ui__SyntaxHighLighter_parse_chunk_multiline_comment(sh, typ, (*(string*)/*ee elem_sym */array_get(val, 0)), (*(string*)/*ee elem_sym */array_get(val, 1)), l)) {
				return;
			}
		}
	}
	sh->i = 0;
	for (;;) {
		if (!(sh->i < sh->ustr.len)) break;
		sh->start = sh->i;
		ui__SyntaxMapRunes _t15 = (*(ui__SyntaxMapRunes*)map_get(ADDR(map, sh->between_one_rune), &(string[]){sh->lang}, &(ui__SyntaxMapRunes[]){ new_map(sizeof(string), sizeof(Array_rune), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string) }));
		int _t17 = _t15.key_values.len;
		for (int _t16 = 0; _t16 < _t17; ++_t16 ) {
			int _t18 = _t15.key_values.len - _t17;
			_t17 = _t15.key_values.len;
			if (_t18 < 0) {
				_t16 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t15.key_values, _t16)) {continue;}
			string typ = /*key*/ *(string*)DenseArray_key(&_t15.key_values, _t16);
			typ = string_clone(typ);
			Array_rune vals = (*(Array_rune*)DenseArray_value(&_t15.key_values, _t16));
			for (int _t19 = 0; _t19 < vals.len; ++_t19) {
				rune val = ((rune*)vals.data)[_t19];
				ui__SyntaxHighLighter_parse_chunk_between_one_rune(sh, typ, val);
			}
		}
		ui__SyntaxMapStrings _t20 = (*(ui__SyntaxMapStrings*)map_get(ADDR(map, sh->keywords), &(string[]){sh->lang}, &(ui__SyntaxMapStrings[]){ new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string) }));
		int _t22 = _t20.key_values.len;
		for (int _t21 = 0; _t21 < _t22; ++_t21 ) {
			int _t23 = _t20.key_values.len - _t22;
			_t22 = _t20.key_values.len;
			if (_t23 < 0) {
				_t21 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t20.key_values, _t21)) {continue;}
			string keyword = /*key*/ *(string*)DenseArray_key(&_t20.key_values, _t21);
			keyword = string_clone(keyword);
			ui__SyntaxHighLighter_parse_chunk_keyword(sh, keyword);
		}
		sh->i++;
	}
}

bool ui__SyntaxHighLighter_parse_chunk_oneline_comment(ui__SyntaxHighLighter* sh, string typ, string comment_sep, string line_trim) {
	if (string_starts_with(line_trim, comment_sep)) {
		ui__SyntaxHighLighter_add_chunk(sh, typ, sh->y, 0, sh->ustr.len);
		bool _t1 = true;
		return _t1;
	} else {
		bool _t2 = false;
		return _t2;
	}
	return 0;
}

bool ui__SyntaxHighLighter_parse_chunk_multiline_comment(ui__SyntaxHighLighter* sh, string typ, string comment_start, string comment_stop, string line_trim) {
	if (string_starts_with(line_trim, comment_start)) {
		map_set(&(*(ui__SyntaxMapBool*)map_get_and_set((map*)&sh->is_multiline, &(string[]){sh->lang}, &(ui__SyntaxMapBool[]){ new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string) })), &(string[]){comment_start}, &(bool[]) { !string_ends_with(line_trim, comment_stop) });
		ui__SyntaxHighLighter_add_chunk(sh, typ, sh->y, 0, sh->ustr.len);
		bool _t1 = true;
		return _t1;
	}
	if ((*(bool*)map_get(ADDR(map, (*(ui__SyntaxMapBool*)map_get(ADDR(map, sh->is_multiline), &(string[]){sh->lang}, &(ui__SyntaxMapBool[]){ new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string) }))), &(string[]){comment_start}, &(bool[]){ 0 })) && !string_contains(line_trim, comment_stop)) {
		ui__SyntaxHighLighter_add_chunk(sh, typ, sh->y, 0, sh->ustr.len);
		bool _t2 = true;
		return _t2;
	}
	if ((*(bool*)map_get(ADDR(map, (*(ui__SyntaxMapBool*)map_get(ADDR(map, sh->is_multiline), &(string[]){sh->lang}, &(ui__SyntaxMapBool[]){ new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string) }))), &(string[]){comment_start}, &(bool[]){ 0 })) && string_contains(line_trim, comment_stop) && string_ends_with(line_trim, comment_stop)) {
		map_set(&(*(ui__SyntaxMapBool*)map_get_and_set((map*)&sh->is_multiline, &(string[]){sh->lang}, &(ui__SyntaxMapBool[]){ new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string) })), &(string[]){comment_start}, &(bool[]) { false });
		ui__SyntaxHighLighter_add_chunk(sh, typ, sh->y, 0, sh->ustr.len);
		bool _t3 = true;
		return _t3;
	}
	bool _t4 = false;
	return _t4;
}

void ui__SyntaxHighLighter_parse_chunk_between_one_rune(ui__SyntaxHighLighter* sh, string typ, rune sep) {
	if ((*(rune*)/*ee elem_sym */array_get(sh->ustr, sh->i)) == sep) {
		sh->i++;
		for (;;) {
			if (!(sh->i < sh->ustr.len - 1 && (*(rune*)/*ee elem_sym */array_get(sh->ustr, sh->i)) != sep)) break;
			sh->i++;
		}
		if (sh->i >= sh->ustr.len) {
			sh->i = sh->ustr.len - 1;
		}
		ui__SyntaxHighLighter_add_chunk(sh, typ, sh->y, sh->start, sh->i + 1);
	}
}

void ui__SyntaxHighLighter_parse_chunk_keyword(ui__SyntaxHighLighter* sh, string typ) {
	for (;;) {
		if (!(sh->i < sh->ustr.len && ui__is_alpha_and_symbols(((int)((*(rune*)/*ee elem_sym */array_get(sh->ustr, sh->i))))))) break;
		sh->i++;
	}
	string word = Array_rune_string(array_slice(sh->ustr, sh->start, sh->i));
	if (Array_string_contains((*(Array_string*)map_get(ADDR(map, (*(ui__SyntaxMapStrings*)map_get(ADDR(map, sh->keywords), &(string[]){sh->lang}, &(ui__SyntaxMapStrings[]){ new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string) }))), &(string[]){typ}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) })), word)) {
		ui__SyntaxHighLighter_add_chunk(sh, typ, sh->y, sh->start, sh->i);
	}
}

void ui__SyntaxHighLighter_add_chunk(ui__SyntaxHighLighter* sh, string typ, int y, int start, int end) {
	int x = sh->tv->tb->x + sh->tv->left_margin + ui__TextView_text_width(sh->tv, Array_rune_string(array_slice(sh->ustr, 0, start)));
	string text = Array_rune_string(array_slice(sh->ustr, start, end));
	ui__Chunk chunk = ((ui__Chunk){.x = x,.y = y,.text = text,});
	array_push((array*)&(*(Array_ui__Chunk*)map_get_and_set((map*)&sh->chunks, &(string[]){typ}, &(Array_ui__Chunk[]){ __new_array(0, 0, sizeof(ui__Chunk)) })), _MOV((ui__Chunk[]){ chunk }));
}

void ui__SyntaxHighLighter_draw_chunks(ui__SyntaxHighLighter* sh) {
	if (!ui__SyntaxHighLighter_is_lang_loaded(sh)) {
		return;
	}
	ui__TextView* tv = sh->tv;
	ui__SyntaxStyle style = (*(ui__SyntaxStyle*)map_get(ADDR(map, sh->styles), &(string[]){sh->style}, &(ui__SyntaxStyle[]){ new_map(sizeof(string), sizeof(ui__SyntaxChunk), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string) }));
	Array_string _t1 = map_keys(&style);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		string typ = ((string*)_t1.data)[_t2];
		gx__Color color = (*(ui__SyntaxChunk*)map_get(ADDR(map, style), &(string[]){typ}, &(ui__SyntaxChunk[]){ (ui__SyntaxChunk){.color = (gx__Color){.r = 0,.g = 0,.b = 0,.a = 255,},.font = (string){.str=(byteptr)"", .is_lit=1},} })).color;
		string font = (*(ui__SyntaxChunk*)map_get(ADDR(map, style), &(string[]){typ}, &(ui__SyntaxChunk[]){ (ui__SyntaxChunk){.color = (gx__Color){.r = 0,.g = 0,.b = 0,.a = 255,},.font = (string){.str=(byteptr)"", .is_lit=1},} })).font;
		Array_ui__Chunk _t3 = (*(Array_ui__Chunk*)map_get(ADDR(map, sh->chunks), &(string[]){typ}, &(Array_ui__Chunk[]){ __new_array(0, 0, sizeof(ui__Chunk)) }));
		for (int _t4 = 0; _t4 < _t3.len; ++_t4) {
			ui__Chunk chunk = ((ui__Chunk*)_t3.data)[_t4];
			gg__Context_draw_rect_filled(tv->tb->ui->gg, chunk.x, chunk.y, ui__TextView_text_width(tv, chunk.text), tv->line_height, tv->tb->bg_color);
			ui__TextView_draw_styled_text(tv, chunk.x, chunk.y, chunk.text, ((ui__TextStyleParams){.id = _const_ui__no_string,.font_name = font,.color = color,.size = -1,.align = ui__TextHorizontalAlign__none,.vertical_align = ui__TextVerticalAlign__none,}));
		}
	}
}

void ui__SyntaxHighLighter_reset_chunks(ui__SyntaxHighLighter* sh) {
	if (!ui__SyntaxHighLighter_is_lang_loaded(sh)) {
		return;
	}
	sh->chunks = new_map(sizeof(string), sizeof(Array_ui__Chunk), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string);
	Array_string _t1 = map_keys(&(*(ui__SyntaxStyle*)map_get(ADDR(map, sh->styles), &(string[]){sh->style}, &(ui__SyntaxStyle[]){ new_map(sizeof(string), sizeof(ui__SyntaxChunk), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string) })));
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		string typ = ((string*)_t1.data)[_t2];
		map_set(&sh->chunks, &(string[]){typ}, &(Array_ui__Chunk[]) { __new_array_with_default(0, 0, sizeof(ui__Chunk), 0) });
	}
}

bool ui__is_alpha(u8 r) {
	bool _t1 = (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9');
	return _t1;
}

bool ui__is_whitespace(u8 r) {
	bool _t1 = r == ' ' || r == '\t';
	return _t1;
}

bool ui__is_alpha_underscore(int r) {
	bool _t1 = ui__is_alpha(((u8)(r))) || ((u8)(r)) == '_' || ((u8)(r)) == '#' || ((u8)(r)) == '$' || ((u8)(r)) == ':' || ((u8)(r)) == '=' || ((u8)(r)) == '&' || ((u8)(r)) == '<' || ((u8)(r)) == '>' || ((u8)(r)) == '!';
	return _t1;
}

bool ui__is_alpha_and_symbols(int r) {
	bool _t1 = ui__is_alpha(((u8)(r))) || (((u8)(r)) == '_' || ((u8)(r)) == '#' || ((u8)(r)) == '$' || ((u8)(r)) == ':' || ((u8)(r)) == '=' || ((u8)(r)) == '&' || ((u8)(r)) == '<' || ((u8)(r)) == '>' || ((u8)(r)) == '!' || ((u8)(r)) == '|' || ((u8)(r)) == '+' || ((u8)(r)) == '-' || ((u8)(r)) == '[' || ((u8)(r)) == ']' || ((u8)(r)) == '{' || ((u8)(r)) == '}' || ((u8)(r)) == '(' || ((u8)(r)) == ')');
	return _t1;
}

void ui__TextView_init(ui__TextView* tv, ui__TextBox* tb) {
	tv->tb = tb;
	tv->text = tb->text;
	ui__TextView_update_line_height(tv);
	ui__TextView_refresh_visible_lines(tv);
	ui__TextView_update_lines(tv);
	ui__TextView_cancel_selection(tv);
	ui__TextView_sync_text_pos(tv);
	tv->sh = ui__syntaxhighlighter();
	ui__SyntaxHighLighter_init(tv->sh, tv);
}

multi_return_int_int ui__TextView_size(ui__TextView* tv) {
	ui__TextView_load_style(tv);
	int w = 0;
	int h = _const_ui__textbox_padding_y * 2 + tv->line_height * tv->tlv.lines.len;
	Array_string _t1 = array_slice(tv->tlv.lines, tv->tlv.from_j, (tv->tlv.to_j + 1));
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		string line = ((string*)_t1.data)[_t2];
		int lw = ui__TextView_text_width(tv, line);
		if (lw > w) {
			w = lw;
		}
	}
	w += tv->left_margin + _const_ui__textview_margin;
	return (multi_return_int_int){.arg0=w, .arg1=h};
}

void ui__TextView_info(ui__TextView* tv) {
	println( str_intp(4, _MOV((StrIntpData[]){{_SLIT("cursor: "), 0xfe07, {.d_i32 = tv->cursor_pos}}, {_SLIT(" -> ("), 0xfe07, {.d_i32 = tv->tlv.cursor_pos_i}}, {_SLIT(", "), 0xfe07, {.d_i32 = tv->tlv.cursor_pos_j}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	println( str_intp(7, _MOV((StrIntpData[]){{_SLIT("sel: ("), 0xfe07, {.d_i32 = tv->sel_start}}, {_SLIT(", "), 0xfe07, {.d_i32 = tv->sel_end}}, {_SLIT(") -> ("), 0xfe07, {.d_i32 = tv->tlv.sel_start_i}}, {_SLIT(", "), 0xfe07, {.d_i32 = tv->tlv.sel_start_j}}, {_SLIT(", "), 0xfe07, {.d_i32 = tv->tlv.sel_end_i}}, {_SLIT(", "), 0xfe07, {.d_i32 = tv->tlv.sel_end_j}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
}

bool ui__TextView_is_wordwrap(ui__TextView* tv) {
	bool _t1 = tv->tb->is_wordwrap;
	return _t1;
}

void ui__TextView_set_wordwrap(ui__TextView* tv, bool state) {
	tv->tb->is_wordwrap = state;
	ui__TextView_sync_text_pos(tv);
	ui__TextView_refresh_visible_lines(tv);
	ui__TextView_update_lines(tv);
	ui__TextView_sync_text_lines(tv);
}

void ui__TextView_switch_wordwrap(ui__TextView* tv) {
	ui__TextView_set_wordwrap(tv, !tv->tb->is_wordwrap);
}

string ui__TextView_line(ui__TextView* tv, int j) {
	int jj = j;
	if (jj < 0) {
		jj = 0;
	} else if (jj == tv->tlv.lines.len) {
		jj = tv->tlv.lines.len - 1;
	}
	string _t1 = (*(string*)/*ee elem_sym */array_get(tv->tlv.lines, jj));
	return _t1;
}

string ui__TextView_current_line(ui__TextView* tv) {
	string _t1 = (*(string*)/*ee elem_sym */array_get(tv->tlv.lines, tv->tlv.cursor_pos_j));
	return _t1;
}

string ui__TextView_sel_start_line(ui__TextView* tv) {
	string _t1 = (*(string*)/*ee elem_sym */array_get(tv->tlv.lines, tv->tlv.sel_start_j));
	return _t1;
}

string ui__TextView_sel_end_line(ui__TextView* tv) {
	string _t1 = (*(string*)/*ee elem_sym */array_get(tv->tlv.lines, tv->tlv.sel_end_j));
	return _t1;
}

bool ui__TextView_is_sel_active(ui__TextView* tv) {
	bool _t1 = (tv->tb->is_focused || tv->tb->read_only) && tv->tb->sel_active && tv->sel_end >= 0;
	return _t1;
}

void ui__TextView_sync_text_pos(ui__TextView* tv) {
	tv->cursor_pos = ui__TextView_text_pos_at(tv, tv->tlv.cursor_pos_i, tv->tlv.cursor_pos_j);
	if (tv->tlv.sel_end_j == -1) {
		tv->sel_start = 0;
		tv->sel_end = -1;
	} else {
		tv->sel_start = ui__TextView_text_pos_at(tv, tv->tlv.sel_start_i, tv->tlv.sel_start_j);
		tv->sel_end = ui__TextView_text_pos_at(tv, tv->tlv.sel_end_i, tv->tlv.sel_end_j);
	}
}

void ui__TextView_sync_text_lines(ui__TextView* tv) {
	multi_return_int_int mr_3784 = ui__TextView_text_line_at(tv, tv->cursor_pos);
	tv->tlv.cursor_pos_i = mr_3784.arg0;
	tv->tlv.cursor_pos_j = mr_3784.arg1;
	if (tv->sel_end == -1) {
		tv->tlv.sel_start_i = 0;
		tv->tlv.sel_start_j = -1;
		tv->tlv.sel_end_i = 0;
		tv->tlv.sel_end_j = -1;
	} else {
		multi_return_int_int mr_3985 = ui__TextView_text_line_at(tv, tv->sel_start);
		tv->tlv.sel_start_i = mr_3985.arg0;
		tv->tlv.sel_start_j = mr_3985.arg1;
		multi_return_int_int mr_4054 = ui__TextView_text_line_at(tv, tv->sel_end);
		tv->tlv.sel_end_i = mr_4054.arg0;
		tv->tlv.sel_end_j = mr_4054.arg1;
	}
}

void ui__TextView_visible_lines(ui__TextView* tv) {
	int j1 = 0;
	int j2 = 0;
	if (tv->tb->has_scrollview) {
		j1 = tv->tb->scrollview->offset_y / tv->line_height;
		if (j1 < 0) {
			j1 = 0;
		}
	}
	if (tv->tb->has_scrollview) {
		j2 = (tv->tb->scrollview->offset_y + tv->tb->height) / tv->line_height;
	} else {
		j2 = tv->tb->height / tv->line_height;
	}
	int jmax = tv->tlv.lines.len - 1;
	if (j1 > jmax) {
		j1 = jmax;
	}
	if (j2 > jmax) {
		j2 = jmax;
	}
	tv->tlv.from_j = j1;
	tv->tlv.to_j = j2;
	ui__TextView_update_all_visible_lines(tv);
}

void ui__TextView_refresh_visible_lines(ui__TextView* tv) {
	tv->tlv.refresh_visible_lines = true;
}

void ui__TextView_update_all_visible_lines(ui__TextView* tv) {
	if (tv->tlv.refresh_visible_lines) {
		array_clear(&tv->tlv.from_i);
		array_clear(&tv->tlv.to_i);
		for (int j = tv->tlv.from_j; j < tv->tlv.to_j + 1; ++j) {
			array_push((array*)&tv->tlv.from_i, _MOV((int[]){ ui__TextView_text_pos_from_x(tv, (*(string*)/*ee elem_sym */array_get(tv->tlv.lines, j)), tv->tb->scrollview->offset_x) }));
			array_push((array*)&tv->tlv.to_i, _MOV((int[]){ ui__TextView_text_pos_from_x(tv, (*(string*)/*ee elem_sym */array_get(tv->tlv.lines, j)), tv->tb->scrollview->offset_x + tv->tb->width) }));
		}
		tv->tlv.refresh_visible_lines = false;
	}
}

void ui__TextView_update_lines(ui__TextView* tv) {
	if (ui__TextView_is_wordwrap(tv)) {
		ui__TextView_word_wrap_text(tv);
	} else {
		tv->tlv.lines = string_split((*tv->text), _SLIT("\n"));
	}
	if (tv->tb->has_scrollview) {
		ui__TextView_visible_lines(tv);
	}
	ui__TextView_sync_text_lines(tv);
	ui__TextView_update_left_margin(tv);
	if (tv->tb->has_scrollview) {
		ui__scrollview_update_T_ui__TextBox(tv->tb);
	}
}

void ui__TextView_update_left_margin(ui__TextView* tv) {
	tv->left_margin = _const_ui__textview_margin;
	if (tv->tb->is_line_number) {
		tv->left_margin += _const_ui__textview_margin + ui__TextView_text_width(tv, int_str(tv->tlv.lines.len));
	}
}

void ui__TextView_scroll_changed(ui__TextView* tv) {
	ui__TextView_refresh_visible_lines(tv);
	ui__TextView_update_lines(tv);
}

void ui__TextView_draw_textlines(ui__TextView* tv) {
	if (tv->tb->is_sync) {
		ui__TextView_refresh_visible_lines(tv);
		ui__TextView_update_lines(tv);
	}
	ui__TextView_draw_selection(tv);
	ui__TextView_load_style(tv);
	int y = tv->tb->y + _const_ui__textbox_padding_y;
	if (tv->tb->has_scrollview) {
		y += (tv->tlv.from_j) * tv->line_height;
	}
	ui__SyntaxHighLighter_reset_chunks(tv->sh);
	Array_string _t1 = array_slice(tv->tlv.lines, tv->tlv.from_j, (tv->tlv.to_j + 1));
	for (int j = 0; j < _t1.len; ++j) {
		string line = ((string*)_t1.data)[j];
		ui__TextView_draw_visible_line(tv, j, y, line);
		if (tv->tb->is_line_number) {
			ui__TextView_draw_line_number(tv, j, y);
		}
		ui__SyntaxHighLighter_parse_chunks(tv->sh, j, y, line);
		y += tv->line_height;
	}
	ui__SyntaxHighLighter_draw_chunks(tv->sh);
	if (tv->tb->is_focused && !tv->tb->read_only && tv->tb->ui->show_cursor && !ui__TextView_is_sel_active(tv)) {
		gg__Context_draw_rect_filled(tv->tb->ui->gg, ui__TextView_cursor_x(tv), ui__TextView_cursor_y(tv), 1, tv->line_height, _const_gx__black);
	}
}

void ui__TextView_draw_visible_line(ui__TextView* tv, int j, int y, string text) {
	if (j == tv->tlv.from_i.len) {
		ui__TextView_refresh_visible_lines(tv);
		ui__TextView_visible_lines(tv);
	}
	int imin = (*(int*)/*ee elem_sym */array_get(tv->tlv.from_i, j));
	int imax = (*(int*)/*ee elem_sym */array_get(tv->tlv.to_i, j));
	Array_rune ustr = string_runes(text);
	ui__TextView_draw_styled_text(tv, tv->tb->x + tv->left_margin + ui__TextView_text_width(tv, Array_rune_string(array_slice(ustr, 0, imin))), y, Array_rune_string(array_slice(ustr, imin, imax)), ((ui__TextStyleParams){.id = _const_ui__no_string,.font_name = _const_ui__no_string,.color = _const_gx__black,.size = -1,.align = ui__TextHorizontalAlign__none,.vertical_align = ui__TextVerticalAlign__none,}));
}

void ui__TextView_draw_selection(ui__TextView* tv) {
	if (!ui__TextView_is_sel_active(tv)) {
		return;
	}
	if (tv->tlv.sel_start_j == tv->tlv.sel_end_j) {
		multi_return_int_int mr_7546 = ui__TextView_text_xminmax_from_pos(tv, ui__TextView_sel_start_line(tv), tv->tlv.sel_start_i, tv->tlv.sel_end_i);
		int sel_from = mr_7546.arg0;
		int sel_width = mr_7546.arg1;
		gg__Context_draw_rect_filled(tv->tb->ui->gg, tv->tb->x + tv->left_margin + sel_from, tv->tb->y + _const_ui__textbox_padding_y + tv->tlv.sel_start_j * tv->line_height, sel_width, tv->line_height, _const_ui__selection_color);
	} else {
		multi_return_int_int_int_int mr_7945 = ui__TextView_ordered_lines_selection(tv);
		int start_i = mr_7945.arg0;
		int end_i = mr_7945.arg1;
		int start_j = mr_7945.arg2;
		int end_j = mr_7945.arg3;
		string ustr = ui__TextView_line(tv, start_j);
		multi_return_int_int mr_8063 = ui__TextView_text_xminmax_from_pos(tv, ustr, start_i, ustr.len);
		int sel_from = mr_8063.arg0;
		int sel_width = mr_8063.arg1;
		gg__Context_draw_rect_filled(tv->tb->ui->gg, tv->tb->x + tv->left_margin + sel_from, tv->tb->y + _const_ui__textbox_padding_y + start_j * tv->line_height, sel_width, tv->line_height, _const_ui__selection_color);
		if (end_j - start_j > 1) {
			for (int j = (start_j + 1); j < end_j; ++j) {
				ustr = ui__TextView_line(tv, j);
				multi_return_int_int mr_8434 = ui__TextView_text_xminmax_from_pos(tv, ustr, 0, string_runes(ustr).len);
				sel_from = mr_8434.arg0;
				sel_width = mr_8434.arg1;
				gg__Context_draw_rect_filled(tv->tb->ui->gg, tv->tb->x + tv->left_margin + sel_from, tv->tb->y + _const_ui__textbox_padding_y + j * tv->line_height, sel_width, tv->line_height, _const_ui__selection_color);
			}
		}
		ustr = ui__TextView_line(tv, end_j);
		multi_return_int_int mr_8747 = ui__TextView_text_xminmax_from_pos(tv, ustr, 0, end_i);
		sel_from = mr_8747.arg0;
		sel_width = mr_8747.arg1;
		gg__Context_draw_rect_filled(tv->tb->ui->gg, tv->tb->x + tv->left_margin + sel_from, tv->tb->y + _const_ui__textbox_padding_y + end_j * tv->line_height, sel_width, tv->line_height, _const_ui__selection_color);
	}
}

void ui__TextView_draw_line_number(ui__TextView* tv, int i, int y) {
	ui__TextView_draw_styled_text(tv, tv->tb->x + _const_ui__textview_margin, y, int_str((tv->tlv.from_j + i + 1)), ((ui__TextStyleParams){.id = _const_ui__no_string,.font_name = _const_ui__no_string,.color = _const_gx__gray,.size = -1,.align = ui__TextHorizontalAlign__none,.vertical_align = ui__TextVerticalAlign__none,}));
}

void ui__TextView_insert(ui__TextView* tv, string s) {
	Array_rune ustr = string_runes(/*rec*/*tv->text);
	array_insert_many(&ustr, tv->cursor_pos, string_runes(s).data, string_runes(s).len);
	{ // Unsafe block
		*tv->text = Array_rune_string(ustr);
	}
	ui__TextView_refresh_visible_lines(tv);
	ui__TextView_update_lines(tv);
}

void ui__TextView_delete_cur_char(ui__TextView* tv) {
	Array_rune ustr = string_runes(/*rec*/*tv->text);
	array_delete(&ustr, tv->cursor_pos);
	{ // Unsafe block
		*tv->text = Array_rune_string(ustr);
	}
	ui__TextView_refresh_visible_lines(tv);
	ui__TextView_update_lines(tv);
}

void ui__TextView_delete_prev_char(ui__TextView* tv) {
	if (tv->cursor_pos <= 0) {
		tv->cursor_pos = 0;
		return;
	}
	Array_rune ustr = string_runes(/*rec*/*tv->text);
	tv->cursor_pos--;
	array_delete(&ustr, tv->cursor_pos);
	{ // Unsafe block
		*tv->text = Array_rune_string(ustr);
	}
	ui__TextView_refresh_visible_lines(tv);
	ui__TextView_update_lines(tv);
}

void ui__TextView_delete_selection(ui__TextView* tv) {
	if (tv->sel_start > tv->sel_end) {
		int _var_9869 = tv->sel_start;
		int _var_9883 = tv->sel_end;
		tv->sel_start = _var_9883;
		tv->sel_end = _var_9869;
	}
	Array_rune ustr = string_runes(/*rec*/*tv->text);
	array_delete_many(&ustr, tv->sel_start, tv->sel_end - tv->sel_start);
	tv->cursor_pos = tv->sel_start;
	tv->sel_end = -1;
	{ // Unsafe block
		*tv->text = Array_rune_string(ustr);
	}
	ui__TextView_refresh_visible_lines(tv);
	ui__TextView_update_lines(tv);
	ui__TextBox* tb = tv->tb;
	ui__scrollview_reset_T_ui__TextBox(tb);
	ui__TextView_cancel_selection(tv);
}

void ui__TextView_start_selection(ui__TextView* tv, int x, int y) {
	if (y <= 0) {
		tv->tlv.cursor_pos_j = 0;
	} else {
		tv->tlv.cursor_pos_j = y / tv->line_height;
		if (tv->tlv.cursor_pos_j > tv->tlv.lines.len - 1) {
			tv->tlv.cursor_pos_j = tv->tlv.lines.len - 1;
		}
	}
	tv->tlv.cursor_pos_i = ui__TextView_text_pos_from_x(tv, ui__TextView_current_line(tv), x);
	if (tv->tb->dragging) {
		tv->tlv.sel_start_i = tv->tlv.cursor_pos_i;
		tv->tlv.sel_start_j = tv->tlv.cursor_pos_j;
		tv->tlv.sel_end_i = tv->tlv.cursor_pos_i;
		tv->tlv.sel_end_j = tv->tlv.cursor_pos_j;
	}
	ui__TextView_sync_text_pos(tv);
	ui__TextView_visible_lines(tv);
}

void ui__TextView_end_selection(ui__TextView* tv, int x, int y) {
	if (y <= 0) {
		tv->tlv.sel_end_j = 0;
	} else {
		tv->tlv.sel_end_j = y / tv->line_height;
		if (tv->tlv.sel_end_j > tv->tlv.lines.len - 1) {
			tv->tlv.sel_end_j = tv->tlv.lines.len - 1;
		}
	}
	tv->tlv.sel_end_i = ui__TextView_text_pos_from_x(tv, (*(string*)/*ee elem_sym */array_get(tv->tlv.lines, tv->tlv.sel_end_j)), x);
	ui__TextView_sync_text_pos(tv);
}

void ui__TextView_extend_selection(ui__TextView* tv, int x, int y) {
	if (y <= 0) {
		tv->tlv.cursor_pos_j = 0;
	} else {
		tv->tlv.cursor_pos_j = y / tv->line_height;
		if (tv->tlv.cursor_pos_j > tv->tlv.lines.len - 1) {
			tv->tlv.cursor_pos_j = tv->tlv.lines.len - 1;
		}
	}
	tv->tlv.cursor_pos_i = ui__TextView_text_pos_from_x(tv, ui__TextView_current_line(tv), x);
	ui__TextView_sync_text_pos(tv);
	if (tv->tb->twosided_sel) {
		multi_return_int_int mr_11866 = ui__TextView_ordered_pos_selection(tv);
		tv->sel_start = mr_11866.arg0;
		tv->sel_end = mr_11866.arg1;
		if (tv->cursor_pos < tv->sel_start) {
			tv->sel_start = tv->cursor_pos;
		} else if (tv->cursor_pos > tv->sel_end) {
			tv->sel_end = tv->cursor_pos;
		}
	} else {
		tv->sel_end = tv->cursor_pos;
	}
	ui__TextView_sync_text_lines(tv);
}

void ui__TextView_cancel_selection(ui__TextView* tv) {
	tv->sel_start = 0;
	tv->sel_end = -1;
	tv->tb->sel_active = false;
	ui__TextView_sync_text_lines(tv);
}

void ui__TextView_move_cursor(ui__TextView* tv, ui__Side side) {

	if (side == (ui__Side__left)) {
		tv->cursor_pos--;
		if (tv->cursor_pos < 0) {
			tv->cursor_pos = 0;
		}
		ui__TextView_sync_text_lines(tv);
	}
	else if (side == (ui__Side__right)) {
		tv->cursor_pos++;
		Array_rune ustr = string_runes(/*rec*/*tv->text);
		if (tv->cursor_pos > ustr.len) {
			tv->cursor_pos = ustr.len;
		}
		ui__TextView_sync_text_lines(tv);
	}
	else if (side == (ui__Side__top)) {
		tv->tlv.cursor_pos_j--;
		if (tv->tlv.cursor_pos_j < 0) {
			tv->tlv.cursor_pos_j = 0;
		}
		Array_rune ustr = string_runes(ui__TextView_current_line(tv));
		if (ustr.len == 0) {
			tv->tlv.cursor_pos_i = 0;
		} else if (tv->tlv.cursor_pos_i >= ustr.len) {
			tv->tlv.cursor_pos_i = ustr.len - 1;
		}
		ui__TextView_sync_text_pos(tv);
	}
	else if (side == (ui__Side__bottom)) {
		tv->tlv.cursor_pos_j++;
		if (tv->tlv.cursor_pos_j >= tv->tlv.lines.len) {
			tv->tlv.cursor_pos_j = tv->tlv.lines.len - 1;
		}
		Array_rune ustr = string_runes(ui__TextView_current_line(tv));
		if (tv->tlv.cursor_pos_i > ustr.len) {
			tv->tlv.cursor_pos_i = ustr.len;
		}
		ui__TextView_sync_text_pos(tv);
	};
}

void ui__TextView_cursor_allways_visible(ui__TextView* tv) {
	if (!tv->tb->has_scrollview) {
		return;
	}
	if (tv->tlv.cursor_pos_j <= tv->tlv.from_j) {
		ui__TextView_scroll_y_to_cursor(tv, false);
	} else if (tv->tlv.cursor_pos_j >= tv->tlv.to_j) {
		ui__TextView_scroll_y_to_cursor(tv, true);
	}
	Array_rune ustr = string_runes((*(string*)/*ee elem_sym */array_get(tv->tlv.lines, tv->tlv.cursor_pos_j)));
	int ulen = ui__TextView_text_width(tv, Array_rune_string(array_slice(ustr, 0, (tv->tlv.cursor_pos_i))));
	if (ulen <= tv->tb->scrollview->offset_x) {
		ui__TextView_scroll_x_to_cursor(tv, false);
	} else if (ulen >= tv->tb->scrollview->offset_x + tv->tb->width - _const_ui__scrollbar_size) {
		ui__TextView_scroll_x_to_cursor(tv, true);
	}
}

void ui__TextView_key_char(ui__TextView* tv, ui__KeyEvent* e) {
bool ui__TextView_key_char_defer_0 = false;
	string s = utf32_to_str(e->codepoint);
	if (!(((int)(e->codepoint)) == 0 || ((int)(e->codepoint)) == 9 || ((int)(e->codepoint)) == 13 || ((int)(e->codepoint)) == 27 || ((int)(e->codepoint)) == 127) && !(e->mods == ui__KeyMod__ctrl || e->mods == ui__KeyMod__super)) {
		if (tv->tb->read_only) {
			return;
		}
		if (ui__TextView_is_sel_active(tv)) {
			ui__TextView_delete_selection(tv);
		}
		ui__Focusable_lock_focus(/*&ui.Focusable*/I_ui__TextBox_to_Interface_ui__Focusable(tv->tb));
		ui__TextView_insert(tv, s);
		tv->cursor_pos++;
		ui__TextView_sync_text_lines(tv);
	} else if (e->mods == ui__KeyMod__ctrl || e->mods == ui__KeyMod__super) {

		if (string__eq(s, _SLIT("a"))) {
			ui__TextView_do_select_all(tv);
		}
		else if (string__eq(s, _SLIT("c"))) {
			ui__TextView_do_copy(tv);
		}
		else if (string__eq(s, _SLIT("v"))) {
			ui__TextView_do_paste(tv);
		}
		else if (string__eq(s, _SLIT("x"))) {
			ui__TextView_do_cut(tv);
		}
		else if (string__eq(s, _SLIT("-"))) {
			ui__TextView_do_zoom_down(tv);
		}
		else if (string__eq(s, _SLIT("=")) || string__eq(s, _SLIT("+"))) {
			ui__TextView_do_zoom_up(tv);
		}
		else {
		};
	}
	ui__TextView_key_char_defer_0 = true;
	if (tv->tb->read_only) {
		// Defer begin
		if (ui__TextView_key_char_defer_0) {
			if (tv->tb->on_change != (voidptr)((ui__TextBoxChangeFn)(0))) {
				if (e->key == ui__Key__backspace) {
					tv->tb->on_change(*tv->text, tv->tb->ui->window->state);
				}
			}
		}
		// Defer end
		return;
	}
	ui__TextView_cursor_allways_visible(tv);
// Defer begin
if (ui__TextView_key_char_defer_0) {
	if (tv->tb->on_change != (voidptr)((ui__TextBoxChangeFn)(0))) {
		if (e->key == ui__Key__backspace) {
			tv->tb->on_change(*tv->text, tv->tb->ui->window->state);
		}
	}
}
// Defer end
}

void ui__TextView_key_down(ui__TextView* tv, ui__KeyEvent* e) {
bool ui__TextView_key_down_defer_0 = false;
	ui__TextView_key_down_defer_0 = true;
	if (tv->tb->read_only) {
		// Defer begin
		if (ui__TextView_key_down_defer_0) {
			if (tv->tb->on_change != (voidptr)((ui__TextBoxChangeFn)(0))) {
				if (e->key == ui__Key__backspace) {
					tv->tb->on_change(*tv->text, tv->tb->ui->window->state);
				}
			}
		}
		// Defer end
		return;
	}
	switch (e->key) {
		case ui__Key__enter: 
			{
				ui__TextView_insert(tv, _SLIT("\n"));
				tv->cursor_pos++;
				ui__TextView_sync_text_lines(tv);
				ui__TextView_cursor_adjust_after_newline(tv);
				ui__TextView_cursor_allways_visible(tv);
				break;
			}
		case ui__Key__tab: 
			{
				if (!ui__Window_unlocked_focus(tv->tb->ui->window)) {
					if (ui__TextView_is_sel_active(tv)) {
						ui__TextView_do_indent(tv, e->mods == ui__KeyMod__shift);
					} else {
						ui__TextView_insert(tv, _SLIT("  "));
						tv->cursor_pos += 2;
					}
					ui__TextView_sync_text_lines(tv);
					ui__TextView_cursor_adjust_after_newline(tv);
					ui__TextView_cursor_allways_visible(tv);
				}
				break;
			}
		case ui__Key__backspace: 
			{
				tv->tb->ui->show_cursor = true;
				if ((*tv->text).len == 0) {
					// Defer begin
					if (ui__TextView_key_down_defer_0) {
						if (tv->tb->on_change != (voidptr)((ui__TextBoxChangeFn)(0))) {
							if (e->key == ui__Key__backspace) {
								tv->tb->on_change(*tv->text, tv->tb->ui->window->state);
							}
						}
					}
					// Defer end
					return;
				}
				if (ui__TextView_is_sel_active(tv)) {
					ui__TextView_delete_selection(tv);
				} else if (e->mods == ui__KeyMod__super || e->mods == ui__KeyMod__ctrl) {
				} else {
					ui__TextView_delete_prev_char(tv);
				}
				ui__TextView_cursor_allways_visible(tv);
				break;
			}
		case ui__Key__delete: 
			{
				tv->tb->ui->show_cursor = true;
				ui__TextView_delete_cur_char(tv);
				ui__TextView_cursor_allways_visible(tv);
				break;
			}
		case ui__Key__left: 
		case ui__Key__right: 
		case ui__Key__up: 
		case ui__Key__down: 
			{
				ui__Side dir = ((e->key == (ui__Key__left)) ? (ui__Side__left) : (e->key == (ui__Key__right)) ? (ui__Side__right) : (e->key == (ui__Key__up)) ? (ui__Side__top) : (ui__Side__bottom));
				if (ui__shift_key(e->mods)) {
					if (!ui__TextView_is_sel_active(tv)) {
						tv->tb->sel_active = true;
						tv->sel_start = tv->cursor_pos;
						tv->tb->ui->show_cursor = false;
					}
					ui__TextView_move_cursor(tv, dir);
					tv->sel_end = tv->cursor_pos;
					ui__TextView_sync_text_lines(tv);
				} else {
					ui__TextView_cancel_selection(tv);
					tv->tb->ui->show_cursor = true;
					ui__TextView_move_cursor(tv, dir);
				}
				ui__TextView_cursor_allways_visible(tv);
				break;
			}
		case ui__Key__escape: 
			{
				if (ui__Window_unlocked_focus(tv->tb->ui->window)) {
					ui__Focusable_lock_focus(/*&ui.Focusable*/I_ui__TextBox_to_Interface_ui__Focusable(tv->tb));
				} else {
					if (!ui__TextView_is_sel_active(tv)) {
						ui__Focusable_unlock_focus(/*&ui.Focusable*/I_ui__TextBox_to_Interface_ui__Focusable(tv->tb));
					}
					ui__TextView_cancel_selection(tv);
					tv->tb->ui->show_cursor = true;
				}
				break;
			}
		case ui__Key__invalid:
		case ui__Key__space:
		case ui__Key__apostrophe:
		case ui__Key__comma:
		case ui__Key__minus:
		case ui__Key__period:
		case ui__Key__slash:
		case ui__Key___0:
		case ui__Key___1:
		case ui__Key___2:
		case ui__Key___3:
		case ui__Key___4:
		case ui__Key___5:
		case ui__Key___6:
		case ui__Key___7:
		case ui__Key___8:
		case ui__Key___9:
		case ui__Key__semicolon:
		case ui__Key__equal:
		case ui__Key__a:
		case ui__Key__b:
		case ui__Key__c:
		case ui__Key__d:
		case ui__Key__e:
		case ui__Key__f:
		case ui__Key__g:
		case ui__Key__h:
		case ui__Key__i:
		case ui__Key__j:
		case ui__Key__k:
		case ui__Key__l:
		case ui__Key__m:
		case ui__Key__n:
		case ui__Key__o:
		case ui__Key__p:
		case ui__Key__q:
		case ui__Key__r:
		case ui__Key__s:
		case ui__Key__t:
		case ui__Key__u:
		case ui__Key__v:
		case ui__Key__w:
		case ui__Key__x:
		case ui__Key__y:
		case ui__Key__z:
		case ui__Key__left_bracket:
		case ui__Key__backslash:
		case ui__Key__right_bracket:
		case ui__Key__grave_accent:
		case ui__Key__world_1:
		case ui__Key__world_2:
		case ui__Key__insert:
		case ui__Key__page_up:
		case ui__Key__page_down:
		case ui__Key__home:
		case ui__Key__end:
		case ui__Key__caps_lock:
		case ui__Key__scroll_lock:
		case ui__Key__num_lock:
		case ui__Key__print_screen:
		case ui__Key__pause:
		case ui__Key__f1:
		case ui__Key__f2:
		case ui__Key__f3:
		case ui__Key__f4:
		case ui__Key__f5:
		case ui__Key__f6:
		case ui__Key__f7:
		case ui__Key__f8:
		case ui__Key__f9:
		case ui__Key__f10:
		case ui__Key__f11:
		case ui__Key__f12:
		case ui__Key__f13:
		case ui__Key__f14:
		case ui__Key__f15:
		case ui__Key__f16:
		case ui__Key__f17:
		case ui__Key__f18:
		case ui__Key__f19:
		case ui__Key__f20:
		case ui__Key__f21:
		case ui__Key__f22:
		case ui__Key__f23:
		case ui__Key__f24:
		case ui__Key__f25:
		case ui__Key__kp_0:
		case ui__Key__kp_1:
		case ui__Key__kp_2:
		case ui__Key__kp_3:
		case ui__Key__kp_4:
		case ui__Key__kp_5:
		case ui__Key__kp_6:
		case ui__Key__kp_7:
		case ui__Key__kp_8:
		case ui__Key__kp_9:
		case ui__Key__kp_decimal:
		case ui__Key__kp_divide:
		case ui__Key__kp_multiply:
		case ui__Key__kp_subtract:
		case ui__Key__kp_add:
		case ui__Key__kp_enter:
		case ui__Key__kp_equal:
		case ui__Key__left_shift:
		case ui__Key__left_control:
		case ui__Key__left_alt:
		case ui__Key__left_super:
		case ui__Key__right_shift:
		case ui__Key__right_control:
		case ui__Key__right_alt:
		case ui__Key__right_super:
		case ui__Key__menu:
		default:
			{
				break;
			}
	}
	;
// Defer begin
if (ui__TextView_key_down_defer_0) {
	if (tv->tb->on_change != (voidptr)((ui__TextBoxChangeFn)(0))) {
		if (e->key == ui__Key__backspace) {
			tv->tb->on_change(*tv->text, tv->tb->ui->window->state);
		}
	}
}
// Defer end
}

void ui__TextView_do_indent(ui__TextView* tv, bool shift) {
	if (ui__TextView_is_sel_active(tv)) {
		int cursor_pos = tv->cursor_pos;
		for (int j = tv->tlv.sel_start_j; j < (tv->tlv.sel_end_j + 1); ++j) {
			tv->tlv.cursor_pos_i = 0;
			tv->tlv.cursor_pos_j = j;
			ui__TextView_sync_text_pos(tv);
			if (shift) {
				if (string__eq(string_substr((*(string*)/*ee elem_sym */array_get(tv->tlv.lines, j)), 0, 2), _SLIT("  "))) {
					tv->sel_end -= 2;
					ui__TextView_delete_cur_char(tv);
					ui__TextView_delete_cur_char(tv);
				}
			} else {
				tv->sel_end += 2;
				ui__TextView_insert(tv, _SLIT("  "));
			}
		}
		tv->cursor_pos = cursor_pos;
		ui__TextView_sync_text_lines(tv);
	}
}

void ui__TextView_do_select_all(ui__TextView* tv) {
	if (tv->tb->read_only && !tv->tb->is_selectable) {
		return;
	}
	tv->sel_start = 0;
	tv->sel_end = string_runes(/*rec*/*tv->text).len;
	ui__TextView_sync_text_lines(tv);
	tv->tb->ui->show_cursor = false;
	tv->tb->sel_active = true;
	return;
}

void ui__TextView_do_copy(ui__TextView* tv) {
	if (ui__TextView_is_sel_active(tv)) {
		Array_rune ustr = string_runes(/*rec*/*tv->text);
		multi_return_int_int mr_18427 = ui__TextView_ordered_pos_selection(tv);
		int sel_start = mr_18427.arg0;
		int sel_end = mr_18427.arg1;
		clipboard__Clipboard_copy(tv->tb->ui->clipboard, Array_rune_string(array_slice(ustr, sel_start, sel_end)));
	}
}

void ui__TextView_do_paste(ui__TextView* tv) {
	if (tv->tb->read_only) {
		return;
	}
	ui__TextView_insert(tv, clipboard__Clipboard_paste(tv->tb->ui->clipboard));
}

void ui__TextView_do_cut(ui__TextView* tv) {
	if (tv->tb->read_only) {
		return;
	}
	if (ui__TextView_is_sel_active(tv)) {
		Array_rune ustr = string_runes(/*rec*/*tv->text);
		multi_return_int_int mr_18780 = ui__TextView_ordered_pos_selection(tv);
		int sel_start = mr_18780.arg0;
		int sel_end = mr_18780.arg1;
		clipboard__Clipboard_copy(tv->tb->ui->clipboard, Array_rune_string(array_slice(ustr, sel_start, sel_end)));
		ui__TextView_delete_selection(tv);
	}
}

void ui__TextView_do_zoom_down(ui__TextView* tv) {
	if (tv->tb->read_only && !tv->tb->is_selectable) {
		return;
	}
	int text_size = ui__DrawTextWidget_font_size(/*&ui.DrawTextWidget*/I_ui__TextBox_to_Interface_ui__DrawTextWidget(tv->tb));
	text_size -= 2;
	if (text_size < 8) {
		text_size = 8;
	}
	ui__TextView_update_style(tv, ((ui__TextStyleParams){.id = _const_ui__no_string,.font_name = _const_ui__no_string,.color = _const_ui__no_color,.size = text_size,.align = ui__TextHorizontalAlign__none,.vertical_align = ui__TextVerticalAlign__none,}));
	ui__TextView_update_line_height(tv);
	ui__TextView_update_lines(tv);
}

void ui__TextView_do_zoom_up(ui__TextView* tv) {
	if (tv->tb->read_only && !tv->tb->is_selectable) {
		return;
	}
	int text_size = ui__DrawTextWidget_font_size(/*&ui.DrawTextWidget*/I_ui__TextBox_to_Interface_ui__DrawTextWidget(tv->tb));
	text_size += 2;
	if (text_size > 48) {
		text_size = 48;
	}
	ui__TextView_update_style(tv, ((ui__TextStyleParams){.id = _const_ui__no_string,.font_name = _const_ui__no_string,.color = _const_ui__no_color,.size = text_size,.align = ui__TextHorizontalAlign__none,.vertical_align = ui__TextVerticalAlign__none,}));
	ui__TextView_update_line_height(tv);
	ui__TextView_update_lines(tv);
}

void ui__TextView_do_logview(ui__TextView* tv, ui__LogViewParams cfg) {
	if (!tv->tb->has_scrollview) {
		println(_SLIT("Warning: use of task do_logview requires textbox to have 'scrollview: true'"));
		return;
	}
	if (tv->tlv.to_j + cfg.nb_lines > tv->tlv.lines.len) {
		ui__TextView_scroll_y_to_end(tv);
	}
}

int ui__TextView_cursor_y(ui__TextView* tv) {
	int _t1 = tv->tb->y + _const_ui__textbox_padding_y + tv->tlv.cursor_pos_j * tv->line_height;
	return _t1;
}

int ui__TextView_cursor_x(ui__TextView* tv) {
	Array_rune ustr = string_runes(ui__TextView_current_line(tv));
	int cursor_x = tv->tb->x + tv->left_margin;
	if (ustr.len > 0) {
		string left = Array_rune_string(array_slice(ustr, 0, tv->tlv.cursor_pos_i));
		cursor_x += ui__TextView_text_width(tv, left);
	}
	int _t1 = cursor_x;
	return _t1;
}

multi_return_int_int ui__TextView_cursor_xy(ui__TextView* tv) {
	return (multi_return_int_int){.arg0=ui__TextView_cursor_x(tv), .arg1=ui__TextView_cursor_y(tv)};
}

void ui__TextView_cursor_adjust_after_newline(ui__TextView* tv) {
	if (tv->tb->has_scrollview) {
		if (tv->tb->scrollview->active_y && !ui__ScrollView_point_inside(tv->tb->scrollview, ui__TextView_cursor_x(tv), ui__TextView_cursor_y(tv) + tv->line_height, ui__ScrollViewPart__view)) {
			ui__ScrollView_inc(tv->tb->scrollview, tv->line_height, ui__ScrollViewPart__btn_y);
		}
	}
}

void ui__TextView_scroll_x_to_cursor(ui__TextView* tv, bool end) {
	if (tv->tb->scrollview->active_x) {
		int delta = (end ? (tv->tb->width - 2 * _const_ui__scrollbar_size) : (0));
		Array_rune ustr = string_runes((*(string*)/*ee elem_sym */array_get(tv->tlv.lines, tv->tlv.cursor_pos_j)));
		int ulen = ui__TextView_text_width(tv, Array_rune_string(array_slice(ustr, 0, tv->tlv.cursor_pos_i)));
		ui__ScrollView_set(tv->tb->scrollview, ulen - delta, ui__ScrollViewPart__btn_x);
	}
}

void ui__TextView_scroll_y_to_cursor(ui__TextView* tv, bool end) {
	if (tv->tb->scrollview->active_y) {
		int delta = (end ? (tv->tb->height - tv->line_height / 2 - tv->line_height) : (0));
		ui__ScrollView_set(tv->tb->scrollview, tv->tlv.cursor_pos_j * tv->line_height - delta, ui__ScrollViewPart__btn_y);
	}
}

void ui__TextView_scroll_y_to_end(ui__TextView* tv) {
	if (tv->tb->scrollview->active_y) {
		ui__ScrollView_set(tv->tb->scrollview, (tv->tlv.lines.len) * tv->line_height, ui__ScrollViewPart__btn_y);
	}
}

void ui__TextView_word_wrap_text(ui__TextView* tv) {
	Array_string lines = string_split((*tv->text), _SLIT("\n"));
	Array_string word_wrapped_lines = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < lines.len; ++_t1) {
		string line = ((string*)lines.data)[_t1];
		Array_string ww_lines = ui__TextView_word_wrap_line(tv, line);
		_PUSH_MANY(&word_wrapped_lines, (ww_lines), _t2, Array_string);
	}
	tv->tlv.lines = word_wrapped_lines;
}

Array_string ui__TextView_word_wrap_line(ui__TextView* tv, string s) {
	if ((s).len == 0) {
		Array_string _t1 = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("")}));
		return _t1;
	}
	Array_string words = string_split(s, _SLIT(" "));
	int max_line_width = tv->tb->width;
	string line = _SLIT("");
	int line_width = 0;
	Array_string text_lines = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int i = 0; i < words.len; ++i) {
		string word = ((string*)words.data)[i];
		if (i == 0) {
			line = word;
			line_width = ui__TextView_text_width(tv, word);
		} else {
			int word_width = ui__TextView_text_width(tv, string__plus(_SLIT(" "), word));
			if (line_width + word_width < max_line_width) {
				line = /*f*/string__plus(line, string__plus(_SLIT(" "), word));
				line_width += word_width;
			} else {
				array_push((array*)&text_lines, _MOV((string[]){ string_clone(line) }));
				line = word;
				line_width = word_width;
			}
		}
	}
	if (line_width > 0) {
		array_push((array*)&text_lines, _MOV((string[]){ string_clone(line) }));
	}
	Array_string _t4 = text_lines;
	return _t4;
}

int ui__TextView_text_pos_at(ui__TextView* tv, int i, int j) {
	int pos = 0;
	Array_string lines = tv->tlv.lines;
	int jj = (j >= lines.len ? (lines.len) : (j));
	for (int k = 0; k < jj; ++k) {
		pos += string_runes((*(string*)/*ee elem_sym */array_get(lines, k))).len + 1;
	}
	pos += i;
	int _t1 = pos;
	return _t1;
}

multi_return_int_int ui__TextView_text_line_at(ui__TextView* tv, int pos) {
	if (pos == 0) {
		return (multi_return_int_int){.arg0=0, .arg1=0};
	}
	Array_string lines = tv->tlv.lines;
	int i = 0;
	int j = 0;
	int total_len = 0;
	int ustr_len = 0;
	for (int _t2 = 0; _t2 < lines.len; ++_t2) {
		string line = ((string*)lines.data)[_t2];
		ustr_len = string_runes(line).len + 1;
		total_len += ustr_len;
		if (pos > total_len) {
			j++;
		} else {
			total_len -= ustr_len;
			break;
		}
	}
	i = pos - total_len;
	if (i > string_runes(ui__TextView_line(tv, j)).len) {
		j++;
		i = 0;
	}
	return (multi_return_int_int){.arg0=i, .arg1=j};
}

multi_return_int_int ui__TextView_ordered_pos_selection(ui__TextView* tv) {
	multi_return_int_int _t1 = (tv->sel_start < tv->sel_end ? ((multi_return_int_int){.arg0=tv->sel_start,.arg1=tv->sel_end}) : ((multi_return_int_int){.arg0=tv->sel_end,.arg1=tv->sel_start}));
	return _t1;
}

multi_return_int_int_int_int ui__TextView_ordered_lines_selection(ui__TextView* tv) {
	multi_return_int_int_int_int _t1 = (tv->tlv.sel_start_j < tv->tlv.sel_end_j ? ((multi_return_int_int_int_int){.arg0=tv->tlv.sel_start_i,.arg1=tv->tlv.sel_end_i,.arg2=tv->tlv.sel_start_j,.arg3=tv->tlv.sel_end_j}) : ((multi_return_int_int_int_int){.arg0=tv->tlv.sel_end_i,.arg1=tv->tlv.sel_start_i,.arg2=tv->tlv.sel_end_j,.arg3=tv->tlv.sel_start_j}));
	return _t1;
}

multi_return_int_int ui__TextView_text_xminmax_from_pos(ui__TextView* tv, string text, int x1, int x2) {
	ui__TextView_load_style(tv);
	Array_rune ustr = string_runes(text);
	multi_return_int_int mr_23875 = (x1 < x2 ? ((multi_return_int_int){.arg0=x1,.arg1=x2}) : ((multi_return_int_int){.arg0=x2,.arg1=x1}));
	int x_min = mr_23875.arg0;
	int x_max = mr_23875.arg1;
	if (x_max > ustr.len) {
		x_max = ustr.len;
	}
	if (x_min < 0) {
		x_min = 0;
	}
	string left = Array_rune_string(array_slice(ustr, 0, x_min));
	Array_rune _t1;
		string right = Array_rune_string((_t1 = ustr, array_slice(_t1, x_max, _t1.len)));
	int ww = ui__TextView_text_width(tv, text);
	int lw = ui__TextView_text_width(tv, left);
	int rw = ui__TextView_text_width(tv, right);
	return (multi_return_int_int){.arg0=lw, .arg1=ww - lw - rw};
}

int ui__TextView_text_pos_from_x(ui__TextView* tv, string text, int x) {
	if (x <= 0) {
		int _t1 = 0;
		return _t1;
	}
	int xx = 0;
	if (x >= tv->left_margin) {
		xx = x - tv->left_margin;
	}
	ui__TextView_load_style(tv);
	f64 prev_width = 0.0;
	Array_rune ustr = string_runes(text);
	f64 width = 0.0;
	f64 width_cur = 0.0;
	for (int i = 0; i < ustr.len; ++i) {
		width += width_cur;
		width_cur = ui__TextView_text_width_additive(tv, Array_rune_string(array_slice(ustr, i, (i + 1))));
		f64 width2 = (i < ustr.len ? (width + width_cur) : (width));
		if ((prev_width + width) / 2 <= xx && xx <= (width + width2) / 2) {
			int _t2 = i;
			return _t2;
		}
		prev_width = width;
	}
	int _t3 = ustr.len;
	return _t3;
}

string ui__TextView_fix_tab_char(ui__TextView* tv, string txt) {
	string _t1 = string_replace(txt, _SLIT("\t"), string_repeat(_SLIT(" "), 4));
	return _t1;
}

void ui__TextView_draw_text(ui__TextView* tv, int x, int y, string text) {
	ui__DrawTextWidget_draw_text(/*&ui.DrawTextWidget*/I_ui__TextBox_to_Interface_ui__DrawTextWidget(tv->tb), x, y, ui__TextView_fix_tab_char(tv, text));
}

void ui__TextView_draw_styled_text(ui__TextView* tv, int x, int y, string text, ui__TextStyleParams ts) {
	ui__DrawTextWidget_draw_styled_text(/*&ui.DrawTextWidget*/I_ui__TextBox_to_Interface_ui__DrawTextWidget(tv->tb), x, y, ui__TextView_fix_tab_char(tv, text), ts);
}

int ui__TextView_text_width(ui__TextView* tv, string text) {
	int _t1 = ui__DrawTextWidget_text_width(/*&ui.DrawTextWidget*/I_ui__TextBox_to_Interface_ui__DrawTextWidget(tv->tb), ui__TextView_fix_tab_char(tv, text));
	return _t1;
}

f64 ui__TextView_text_width_additive(ui__TextView* tv, string text) {
	f64 _t1 = ui__DrawTextWidget_text_width_additive(/*&ui.DrawTextWidget*/I_ui__TextBox_to_Interface_ui__DrawTextWidget(tv->tb), ui__TextView_fix_tab_char(tv, text));
	return _t1;
}

int ui__TextView_text_height(ui__TextView* tv, string text) {
	int _t1 = ui__DrawTextWidget_text_width(/*&ui.DrawTextWidget*/I_ui__TextBox_to_Interface_ui__DrawTextWidget(tv->tb), text);
	return _t1;
}

multi_return_int_int ui__TextView_text_size(ui__TextView* tv, string text) {
	multi_return_int_int _t1 = ui__DrawTextWidget_text_size(/*&ui.DrawTextWidget*/I_ui__TextBox_to_Interface_ui__DrawTextWidget(tv->tb), text);
	return _t1;
}

void ui__TextView_update_line_height(ui__TextView* tv) {
	ui__TextView_load_style(tv);
	tv->line_height = ((int)(((f64)(ui__TextView_text_height(tv, _SLIT("W")))) * 1.5));
}

void ui__TextView_update_style(ui__TextView* tv, ui__TextStyleParams ts) {
	ui__DrawTextWidget dtw = /*&ui.DrawTextWidget*/I_ui__TextBox_to_Interface_ui__DrawTextWidget(tv->tb);
	ui__DrawTextWidget_update_style(&dtw, ts);
}

void ui__TextView_load_style(ui__TextView* tv) {
	ui__DrawTextWidget_load_style(/*&ui.DrawTextWidget*/I_ui__TextBox_to_Interface_ui__DrawTextWidget(tv->tb));
}

void ui__TextView_test_textwidth(ui__TextView* tv, string text) {
	Array_rune ustr = string_runes(text);
	f64 width = 0.0;
	f64 width_bad = 0.0;
	println(_SLIT("(text_width_additive vs text_width)"));
	for (int i = 0; i < ustr.len; ++i) {
		f64 tmp = ui__DrawTextWidget_text_width_additive(/*&ui.DrawTextWidget*/I_ui__TextBox_to_Interface_ui__DrawTextWidget(tv->tb), Array_rune_string(array_slice(ustr, i, (i + 1))));
		width += tmp;
		int tmp_bad = ui__DrawTextWidget_text_width(/*&ui.DrawTextWidget*/I_ui__TextBox_to_Interface_ui__DrawTextWidget(tv->tb), Array_rune_string(array_slice(ustr, i, (i + 1))));
		width_bad += tmp_bad;
		multi_return_int_int mr_27207 = ui__TextView_text_size(tv, Array_rune_string(array_slice(ustr, 0, i + 1)));
		int tmp2 = mr_27207.arg0;
		println( str_intp(10, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = Array_rune_string(array_slice(ustr, 0, i + 1))}}, {_SLIT(" -> "), 0xfe07, {.d_i32 = i}}, {_SLIT(") "), 0xfe10, {.d_s = Array_rune_string(array_slice(ustr, i, (i + 1)))}}, {_SLIT("  ("), 0x1fe0f, {.d_f64 = tmp}}, {_SLIT(" vs "), 0xfe07, {.d_i32 = tmp_bad}}, {_SLIT(")  ("), 0x1fe0f, {.d_f64 = width}}, {_SLIT(" == "), 0xfe07, {.d_i32 = tmp2}}, {_SLIT(" vs "), 0x1fe0f, {.d_f64 = width_bad}}, {_SLIT(" == "), 0xfe07, {.d_i32 = tmp2}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	}
}

// TypeDecl
// TypeDecl
ui__ColorTheme ui__color_theme(Array_ui__Color items) {
	Map_int_gx__Color theme = new_map(sizeof(int), sizeof(gx__Color), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop);
	for (int _t1 = 0; _t1 < items.len; ++_t1) {
		ui__Color item = ((ui__Color*)items.data)[_t1];
(*(gx__Color*)map_get_and_set((map*)&theme, &(int[]){item.id}, &(gx__Color[]){ (gx__Color){.r = 0,.g = 0,.b = 0,.a = 255,} })) = item.color;
	}
	ui__ColorTheme _t2 = theme;
	return _t2;
}

void ui__Window_register_color_theme(ui__Window* w, string name, ui__ColorTheme theme) {
	map_set(&w->color_themes, &(string[]){name}, &(ui__ColorTheme[]) { theme });
}

void ui__Window_register_default_color_themes(ui__Window* w) {
	map_set(&w->color_themes, &(string[]){_SLIT("classic")}, &(ui__ColorTheme[]) { ui__color_theme(new_array_from_c_array(3, 3, sizeof(ui__Color), _MOV((ui__Color[3]){((ui__Color){.id = 1,.color = _const_gx__white,}), ((ui__Color){.id = 2,.color = gx__rgb(119, 119, 119),}), ((ui__Color){.id = 3,.color = gx__rgb(219, 219, 219),})}))) });
	map_set(&w->color_themes, &(string[]){_SLIT("red")}, &(ui__ColorTheme[]) { ui__color_theme(new_array_from_c_array(3, 3, sizeof(ui__Color), _MOV((ui__Color[3]){((ui__Color){.id = 1,.color = _const_gx__light_red,}), ((ui__Color){.id = 2,.color = gx__rgb(119, 0, 0),}), ((ui__Color){.id = 3,.color = gx__rgb(219, 0, 0),})}))) });
	map_set(&w->color_themes, &(string[]){_SLIT("blue")}, &(ui__ColorTheme[]) { ui__color_theme(new_array_from_c_array(3, 3, sizeof(ui__Color), _MOV((ui__Color[3]){((ui__Color){.id = 1,.color = _const_gx__light_blue,}), ((ui__Color){.id = 2,.color = _const_gx__blue,}), ((ui__Color){.id = 3,.color = gx__rgb(119, 119, 219),})}))) });
}

gx__Color ui__color(Map_int_gx__Color theme, int id) {
	gx__Color _t1 = (*(gx__Color*)map_get(ADDR(map, theme), &(int[]){id}, &(gx__Color[]){ (gx__Color){.r = 0,.g = 0,.b = 0,.a = 255,} }));
	return _t1;
}

void ui__set_color(Map_int_gx__Color* theme, int id, gx__Color color) {
(*(gx__Color*)map_get_and_set((map*)theme, &(int[]){id}, &(gx__Color[]){ (gx__Color){.r = 0,.g = 0,.b = 0,.a = 255,} })) = color;
}

void ui__update_colors_from(Map_int_gx__Color* theme, Map_int_gx__Color theme2, Array_int ids) {
	for (int _t1 = 0; _t1 < ids.len; ++_t1) {
		int id = ((int*)ids.data)[_t1];
(*(gx__Color*)map_get_and_set((map*)theme, &(int[]){id}, &(gx__Color[]){ (gx__Color){.r = 0,.g = 0,.b = 0,.a = 255,} })) = (*(gx__Color*)map_get(ADDR(map, theme2), &(int[]){id}, &(gx__Color[]){ (gx__Color){.r = 0,.g = 0,.b = 0,.a = 255,} }));
	}
}

Map_int_gx__Color ui__theme(ui__ColorThemeWidget w) {
	Map_int_gx__Color theme = new_map(sizeof(int), sizeof(gx__Color), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop);
	ui__ColorThemeCfg theme_cfg = (*(w.theme_cfg));
	if ((theme_cfg)._typ == 20 /* string */) {
		theme = (*(ui__ColorTheme*)map_get(ADDR(map, (*(w.ui))->window->color_themes), &(string[]){(*theme_cfg._string)}, &(ui__ColorTheme[]){ new_map(sizeof(int), sizeof(gx__Color), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop) }));
	} else if ((theme_cfg)._typ == 212 /* ui.ColorTheme */) {
		theme = (*theme_cfg._ui__ColorTheme);
	}
	Map_int_gx__Color _t1 = theme;
	return _t1;
}

// TypeDecl
void ui__component_connect(voidptr comp, Array_ui__ComponentChild children) {
	Array_ui__ComponentChild c = array_clone_to_depth(&children, 0);
	for (int _t1 = 0; _t1 < c.len; ++_t1) {
		ui__ComponentChild* child = ((ui__ComponentChild*)c.data) + _t1;
		(*(child->component)) = comp;
	}
}

void ui__DrawTextWidget_add_font(ui__DrawTextWidget* w, string font_name, string font_path) {
	ui__UI_add_font((*(w->ui)), font_name, font_path);
}

void ui__DrawTextWidget_init_style(ui__DrawTextWidget* w, ui__TextStyleParams ts) {
	ui__DrawTextWidget_set_current_style(w, ts);
}

ui__TextStyle ui__DrawTextWidget_text_style(ui__DrawTextWidget w, ui__TextStyleParams ts) {
	ui__TextStyle ts_ = (string__eq(ts.id, _const_ui__no_string) ? ((*(w.text_styles)).current) : (ui__DrawTextWidget_style_by_id(w, ts.id)));
	ui__TextStyle _t1 = ((ui__TextStyle){ts_.id,.font_name = (string__eq(ts.font_name, _const_ui__no_string) ? (ts_.font_name) : (ts.font_name)),.color = (gx__Color_struct_eq(ts.color, _const_ui__no_color) ? (ts_.color) : (ts.color)),.size = (ts.size < 0 ? (ts_.size) : (ts.size)),.align = (ts.align == ui__TextHorizontalAlign__none ? (ts_.align) : (ts.align)),.vertical_align = (ts.vertical_align == ui__TextVerticalAlign__none ? (ts_.vertical_align) : (ts.vertical_align)),ts_.mono,});
	return _t1;
}

void ui__DrawTextWidget_add_style(ui__DrawTextWidget* w, ui__TextStyle ts) {
	string id = ts.id;
	if ((id).len == 0) {
		if ((ts.font_name).len == 0) {
			eprintln(_SLIT("Warning: nothing done in add_style since id or font_name missing"));
			return;
		}
		id = ts.font_name;
	}
(*(ui__TextStyle*)map_get_and_set((map*)&(*(w->text_styles)).hash, &(string[]){id}, &(ui__TextStyle[]){ (ui__TextStyle){.id = _const_ui__no_string,.font_name = _SLIT("system"),.color = _const_gx__black,.size = 16,.align = ui__TextHorizontalAlign__left,.vertical_align = ui__TextVerticalAlign__top,.mono = 0,} })) = ((ui__TextStyle){
		.id = id,
		.font_name = ts.font_name,
		.color = ts.color,
		.size = ts.size,
		.align = ts.align,
		.vertical_align = ts.vertical_align,
		.mono = ts.mono,
	});
}

void ui__DrawTextWidget_update_style(ui__DrawTextWidget* w, ui__TextStyleParams ts) {
	ui__TextStyle* ts_ = (_IN_MAP(ADDR(string, ts.id), ADDR(map, (*(w->text_styles)).hash)) ? (&((*(ui__TextStyle*)map_get(ADDR(map, (*(w->text_styles)).hash), &(string[]){ts.id}, &(ui__TextStyle[]){ (ui__TextStyle){.id = _const_ui__no_string,.font_name = _SLIT("system"),.color = _const_gx__black,.size = 16,.align = ui__TextHorizontalAlign__left,.vertical_align = ui__TextVerticalAlign__top,.mono = 0,} })))) : (&((*(w->text_styles)).current)));
	{ // Unsafe block
		*ts_ = ((ui__TextStyle){(*ts_).id,.font_name = (string__eq(ts.font_name, _const_ui__no_string) ? (ts_->font_name) : (ts.font_name)),.color = (gx__Color_struct_eq(ts.color, _const_ui__no_color) ? (ts_->color) : (ts.color)),.size = (ts.size < 0 ? (ts_->size) : (ts.size)),.align = (ts.align == ui__TextHorizontalAlign__none ? (ts_->align) : (ts.align)),.vertical_align = (ts.vertical_align == ui__TextVerticalAlign__none ? (ts_->vertical_align) : (ts.vertical_align)),(*ts_).mono,});
	}
}

void ui__DrawTextWidget_update_text_size(ui__DrawTextWidget* w, f64 size) {
	if (size > 0) {
		multi_return_int_int mr_3310 = ui__Window_size((*(w->ui))->window);
		int win_height = mr_3310.arg1;
		ui__TextStyle ts = (*(w->text_styles)).current;
		ts.size = ui__text_size_as_int(size, win_height);
	}
}

ui__TextStyle ui__DrawTextWidget_style_by_id(ui__DrawTextWidget w, string id) {
	ui__TextStyle* _t3 = (ui__TextStyle*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, (*(w.text_styles)).hash), &(string[]){id}));
	Option_ui__TextStyle _t2 = {0};
	if (_t3) {
		*((ui__TextStyle*)&_t2.data) = *((ui__TextStyle*)_t3);
	} else {
		_t2.state = 2; _t2.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t2.state != 0) { /*or block*/ 
		IError err = _t2.err;
		ui__TextStyle* _t5 = (ui__TextStyle*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, (*(w.ui))->text_styles), &(string[]){id}));
		Option_ui__TextStyle _t4 = {0};
		if (_t5) {
			*((ui__TextStyle*)&_t4.data) = *((ui__TextStyle*)_t5);
		} else {
			_t4.state = 2; _t4.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t4.state != 0) { /*or block*/ 
			err = _t4.err;
			*(ui__TextStyle*) _t4.data = (*(ui__TextStyle*)map_get(ADDR(map, (*(w.ui))->text_styles), &(string[]){_SLIT("_default_")}, &(ui__TextStyle[]){ (ui__TextStyle){.id = _const_ui__no_string,.font_name = _SLIT("system"),.color = _const_gx__black,.size = 16,.align = ui__TextHorizontalAlign__left,.vertical_align = ui__TextVerticalAlign__top,.mono = 0,} }));
		}
		
		*(ui__TextStyle*) _t2.data = *(ui__TextStyle*)_t4.data;
	}
	
	ui__TextStyle _t1 = *(ui__TextStyle*)_t2.data;
	return _t1;
}

ui__TextStyle ui__DrawTextWidget_current_style(ui__DrawTextWidget w) {
	ui__TextStyle _t1 = (*(w.text_styles)).current;
	return _t1;
}

void ui__DrawTextWidget_set_current_style(ui__DrawTextWidget* w, ui__TextStyleParams ts) {
	(*(w->text_styles)).current = ui__DrawTextWidget_text_style(/*rec*/*w, ts);
}

void ui__DrawTextWidget_load_style(ui__DrawTextWidget w) {
	ui__TextStyle ts = ui__DrawTextWidget_current_style(w);
	ui__DrawTextWidget_load_style_(w, ts);
}

void ui__DrawTextWidget_load_style_(ui__DrawTextWidget w, ui__TextStyle ts) {
	gg__Context* gg = (*(w.ui))->gg;
	fontstash__Context* fons = gg->ft->fons;
	fontstash__Context_set_font(fons, (*(int*)map_get(ADDR(map, (*(w.ui))->fonts.hash), &(string[]){ts.font_name}, &(int[]){ 0 })));
	f32 scale = (gg->ft->scale == 0 ? (((f32)(1))) : (gg->ft->scale));
	int size = (ts.mono ? (ts.size - 2) : (ts.size));
	fontstash__Context_set_size(fons, scale * ((f32)(size)));
	fontstash__Context_set_align(gg->ft->fons, (((int)(ts.align)) | ((int)(ts.vertical_align))));
	u32 color = sokol__sfons__rgba(ts.color.r, ts.color.g, ts.color.b, ts.color.a);
	if (ts.color.a != 255) {
		sokol__sgl__load_pipeline(gg->timage_pip);
	}
	fontstash__Context_set_color(gg->ft->fons, color);
	f32 ascender = ((f32)(0.0));
	f32 descender = ((f32)(0.0));
	f32 lh = ((f32)(0.0));
	fontstash__Context_vert_metrics(fons, &ascender, &descender, &lh);
}

int ui__DrawTextWidget_font_size(ui__DrawTextWidget w) {
	int _t1 = ui__DrawTextWidget_current_style(w).size;
	return _t1;
}

void ui__DrawTextWidget_draw_text(ui__DrawTextWidget w, int x, int y, string text) {
	f32 scale = ((*(w.ui))->gg->ft->scale == 0 ? (((f32)(1))) : ((*(w.ui))->gg->ft->scale));
	fontstash__Context_draw_text((*(w.ui))->gg->ft->fons, x * scale, y * scale, text);
}

void ui__DrawTextWidget_draw_styled_text(ui__DrawTextWidget w, int x, int y, string text, ui__TextStyleParams ts) {
	ui__DrawTextWidget_load_style_(w, ui__DrawTextWidget_text_style(w, ts));
	f32 scale = ((*(w.ui))->gg->ft->scale == 0 ? (((f32)(1))) : ((*(w.ui))->gg->ft->scale));
	fontstash__Context_draw_text((*(w.ui))->gg->ft->fons, x * scale, y * scale, text);
}

multi_return_int_int ui__DrawTextWidget_text_size(ui__DrawTextWidget w, string text) {
	multi_return_int_int _t1 = gg__Context_text_size((*(w.ui))->gg, text);
	return _t1;
}

int ui__DrawTextWidget_text_width(ui__DrawTextWidget w, string text) {
	int _t1 = gg__Context_text_width((*(w.ui))->gg, text);
	return _t1;
}

f64 ui__DrawTextWidget_text_width_additive(ui__DrawTextWidget w, string text) {
	gg__Context* ctx = (*(w.ui))->gg;
	f32 adv = fontstash__Context_text_bounds(ctx->ft->fons, 0, 0, text, ((f32*)(0)));
	f64 _t1 = adv / ctx->scale;
	return _t1;
}

int ui__DrawTextWidget_text_height(ui__DrawTextWidget w, string text) {
	int _t1 = gg__Context_text_height((*(w.ui))->gg, text);
	return _t1;
}

ui__TextStyle ui__TextStyles_style(ui__TextStyles* t, string id) {
	ui__TextStyle _t1 = (*(ui__TextStyle*)map_get(ADDR(map, t->hash), &(string[]){id}, &(ui__TextStyle[]){ (ui__TextStyle){.id = _const_ui__no_string,.font_name = _SLIT("system"),.color = _const_gx__black,.size = 16,.align = ui__TextHorizontalAlign__left,.vertical_align = ui__TextVerticalAlign__top,.mono = 0,} }));
	return _t1;
}

void ui__UI_add_font(ui__UI* ui, string font_name, string font_path) {
	fontstash__Context_reset_atlas(ui->gg->ft->fons, 512, 512);
	Option_Array_u8 _t1 = os__read_bytes(font_path);
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		*(Array_u8*) _t1.data = __new_array_with_default(0, 0, sizeof(u8), 0);
	}
	
 	Array_u8 bytes =  (*(Array_u8*)_t1.data);
	if (bytes.len > 0) {
		int font = fontstash__Context_add_font_mem(ui->gg->ft->fons, _SLIT("sans"), bytes, false);
		if (font >= 0) {
			map_set(&ui->fonts.hash, &(string[]){font_name}, &(int[]) { font });
		} else {
		}
	} else {
	}
}

void ui__UI_add_style(ui__UI* ui, ui__TextStyle ts) {
	string id = ts.id;
	if ((id).len == 0) {
		if ((ts.font_name).len == 0) {
			eprintln(_SLIT("Warning: nothing done in add_style since id or font_name missing"));
			return;
		}
		id = ts.font_name;
	}
(*(ui__TextStyle*)map_get_and_set((map*)&ui->text_styles, &(string[]){id}, &(ui__TextStyle[]){ (ui__TextStyle){.id = _const_ui__no_string,.font_name = _SLIT("system"),.color = _const_gx__black,.size = 16,.align = ui__TextHorizontalAlign__left,.vertical_align = ui__TextVerticalAlign__top,.mono = 0,} })) = ((ui__TextStyle){
		.id = id,
		.font_name = ts.font_name,
		.color = ts.color,
		.size = ts.size,
		.align = ts.align,
		.vertical_align = ts.vertical_align,
		.mono = ts.mono,
	});
}

void ui__UI_update_style(ui__UI* u, ui__TextStyleParams ts) {
	if (_IN_MAP(ADDR(string, ts.id), ADDR(map, u->text_styles))) {
		ui__TextStyle* ts_ = &((*(ui__TextStyle*)map_get(ADDR(map, u->text_styles), &(string[]){ts.id}, &(ui__TextStyle[]){ (ui__TextStyle){.id = _const_ui__no_string,.font_name = _SLIT("system"),.color = _const_gx__black,.size = 16,.align = ui__TextHorizontalAlign__left,.vertical_align = ui__TextVerticalAlign__top,.mono = 0,} })));
		{ // Unsafe block
			*ts_ = ((ui__TextStyle){(*ts_).id,.font_name = (string__eq(ts.font_name, _const_ui__no_string) ? (ts_->font_name) : (ts.font_name)),.color = (gx__Color_struct_eq(ts.color, _const_ui__no_color) ? (ts_->color) : (ts.color)),.size = (ts.size < 0 ? (ts_->size) : (ts.size)),(*ts_).align,(*ts_).vertical_align,(*ts_).mono,});
		}
	}
}

Array_string ui__font_path_list(void) {
	string font_root_path = _SLIT("");
	font_root_path = _SLIT("/System/Library/Fonts/*");
	Option_Array_string _t1 = os__glob(new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){ str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = font_root_path}}, {_SLIT("/*.ttf"), 0, { .d_c = 0 }}}))})));
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
 	Array_string font_paths =  (*(Array_string*)_t1.data);
	Array_string _t2 = font_paths;
	return _t2;
}

ui__FontSearcher ui__new_font_searcher(void) {
	Array_string paths = ui__font_path_list();
	Array_string _t1 = {0};
	Array_string _t1_orig = paths;
	int _t1_len = _t1_orig.len;
	_t1 = __new_array(0, _t1_len, sizeof(string));

	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		string it = ((string*) _t1_orig.data)[_t2];
		string ti = string_to_lower(it);
		array_push((array*)&_t1, &ti);
	}
	Array_string lpaths =_t1;
	ui__FontSearcher _t3 = ((ui__FontSearcher){.paths = paths,.lpaths = lpaths,});
	return _t3;
}

string ui__FontSearcher_search(ui__FontSearcher a, string word) {
	string wl = string_to_lower(word);
	for (int i = 0; i < a.lpaths.len; ++i) {
		string fpl = ((string*)a.lpaths.data)[i];
		if (string_contains(fpl, wl)) {
			string fp = (*(string*)/*ee elem_sym */array_get(a.paths, i));
			string _t1 = fp;
			return _t1;
		}
	}
	string _t2 = ui__font_default();
	return _t2;
}

string ui__font_default(void) {
	string _t1 = os__font__default();
	return _t1;
}

void ui__Window_add_font(ui__Window* w, string id, string font_path) {
	#if defined(_WIN32)
	{
	}
	#else
	{
		if (os__exists(font_path)) {
			ui__UI_add_font(w->ui, id, font_path);
			return;
		}
	}
	#endif
	ui__UI_add_font(w->ui, id, ui__font_default());
}

void ui__Window_init_styles(ui__Window* w) {
	ui__UI_add_font(w->ui, _SLIT("system"), ui__font_default());
	ui__UI_add_style(w->ui, ((ui__TextStyle){.id = _SLIT("_default_"),.font_name = _SLIT("system"),.color = _const_gx__black,.size = 16,.align = ui__TextHorizontalAlign__left,.vertical_align = ui__TextVerticalAlign__top,.mono = 0,}));
	ui__FontSearcher fs = ui__new_font_searcher();
	ui__Window_add_font(w, _SLIT("fixed"), ui__FontSearcher_search(fs, _SLIT("courier new.ttf")));
	ui__Window_add_font(w, _SLIT("fixed_bold"), ui__FontSearcher_search(fs, _SLIT("courier new bold.ttf")));
	ui__Window_add_font(w, _SLIT("fixed_italic"), ui__FontSearcher_search(fs, _SLIT("courier new italic.ttf")));
	ui__Window_add_font(w, _SLIT("fixed_bold_italic"), ui__FontSearcher_search(fs, _SLIT("courier new bold italic.ttf")));
}

bool ui__Focusable_has_focusable(ui__Focusable f) {
	bool focusable = true;
	if ((f)._typ == _ui__Focusable_ui__TextBox_index) {
		focusable = !(f._ui__TextBox)->read_only;
	}
	bool _t1 = focusable && !(*(f.hidden)) && ui__Window_unlocked_focus((*(f.ui))->window);
	return _t1;
}

void ui__Focusable_set_focus(ui__Focusable* f) {
	ui__Window* w = (*(f->ui))->window;
	if (!ui__Window_unlocked_focus(w)) {
		return;
	}
	if ((*(f->is_focused))) {
		return;
	}
	ui__Layout_unfocus_all(/*&ui.Layout*/I_ui__Window_to_Interface_ui__Layout(w));
	if (ui__Focusable_has_focusable(/*rec*/*f)) {
		(*(f->is_focused)) = true;
	}
}

void ui__Focusable_force_focus(ui__Focusable* f) {
	ui__Window* w = (*(f->ui))->window;
	if ((*(f->is_focused))) {
		return;
	}
	ui__Layout_unfocus_all(/*&ui.Layout*/I_ui__Window_to_Interface_ui__Layout(w));
	(*(f->is_focused)) = true;
}

void ui__Focusable_lock_focus(ui__Focusable f) {
	ui__Window* w = (*(f.ui))->window;
	w->locked_focus = (*(f.id));
}

void ui__Focusable_unlock_focus(ui__Focusable f) {
	ui__Window* w = (*(f.ui))->window;
	if (string__eq(w->locked_focus, (*(f.id)))) {
		w->locked_focus = _SLIT("");
	}
}

void ui__Layout_set_children_depth(ui__Layout* l, int z_index) {
	Array_ui__Widget _t1 = ui__Layout_name_table[l->_typ]._method_get_children(l->_object);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		ui__Widget* child = ((ui__Widget*)_t1.data) + _t2;
		if (I_ui__Widget_is_I_ui__Layout(*child)) {
			ui__Layout l2 = I_ui__Widget_as_I_ui__Layout(*child);
			ui__Layout_set_children_depth(&l2, z_index);
		}
		(*(child->z_index)) = z_index;
	}
}

void ui__Layout_incr_children_depth(ui__Layout* l, int z_inc) {
	Array_ui__Widget _t1 = ui__Layout_name_table[l->_typ]._method_get_children(l->_object);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		ui__Widget* child = ((ui__Widget*)_t1.data) + _t2;
		if (I_ui__Widget_is_I_ui__Layout(*child)) {
			ui__Layout l2 = I_ui__Widget_as_I_ui__Layout(*child);
			ui__Layout_incr_children_depth(&l2, z_inc);
		}
		(*(child->z_index)) += z_inc;
	}
}

bool ui__Layout_has_child_id(ui__Layout* l, string widget_id) {
	Array_ui__Widget _t1 = ui__Layout_name_table[l->_typ]._method_get_children(l->_object);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		ui__Widget child = ((ui__Widget*)_t1.data)[_t2];
		if (string__eq((*(child.id)), widget_id)) {
			bool _t3 = true;
			return _t3;
		}
		if (I_ui__Widget_is_I_ui__Layout(child)) {
			ui__Layout l2 = I_ui__Widget_as_I_ui__Layout(child);
			if (ui__Layout_has_child_id(&l2, widget_id)) {
				bool _t4 = true;
				return _t4;
			}
		}
	}
	bool _t5 = false;
	return _t5;
}

bool ui__Layout_has_child(ui__Layout* l, ui__Widget* widget) {
	bool _t1 = ui__Layout_has_child_id(l, (*(widget->id)));
	return _t1;
}

void ui__Layout_unfocus_all(ui__Layout layout) {
	Array_ui__Widget _t1 = ui__Layout_name_table[layout._typ]._method_get_children(layout._object);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		ui__Widget* child = ((ui__Widget*)_t1.data) + _t2;
		if (I_ui__Widget_is_I_ui__Layout(*child)) {
			ui__Layout l = I_ui__Widget_as_I_ui__Layout(*child);
			ui__Layout_unfocus_all(l);
		} else if (I_ui__Widget_is_I_ui__Focusable(*child)) {
			ui__Focusable f = I_ui__Widget_as_I_ui__Focusable(*child);
			ui__Focusable_name_table[f._typ]._method_unfocus(f._object);
		}
	}
}

bool ui__Layout_set_focus_next(ui__Layout layout) {
	bool focused_found = false;
	ui__Window* window = ui__Layout_name_table[layout._typ]._method_get_ui(layout._object)->window;
	Array_ui__Widget _t1 = ui__Layout_name_table[layout._typ]._method_get_children(layout._object);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		ui__Widget* child = ((ui__Widget*)_t1.data) + _t2;
		bool _t3; /* if prepend */
		if (I_ui__Widget_is_I_ui__Layout(*child)) {
			ui__Layout l = I_ui__Widget_as_I_ui__Layout(*child);
			_t3 = ui__Layout_set_focus_next(l);
		} else {
			_t3 = false;
		}
		focused_found =  _t3;
		if (focused_found) {
			break;
		}
		if (I_ui__Widget_is_I_ui__Focusable(*child)) {
			ui__Focusable f = I_ui__Widget_as_I_ui__Focusable(*child);
			if (ui__Focusable_has_focusable(f)) {
				if (window->do_focus) {
					ui__Focusable_name_table[f._typ]._method_focus(f._object);
					focused_found = true;
					window->do_focus = false;
					break;
				} else {
					window->do_focus = (*(f.is_focused));
				}
			}
		}
	}
	bool _t4 = focused_found;
	return _t4;
}

bool ui__Layout_set_focus_prev(ui__Layout layout) {
	bool focused_found = false;
	ui__Window* window = ui__Layout_name_table[layout._typ]._method_get_ui(layout._object)->window;
	Array_ui__Widget _t1 = array_reverse(ui__Layout_name_table[layout._typ]._method_get_children(layout._object));
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		ui__Widget* child = ((ui__Widget*)_t1.data) + _t2;
		bool _t3; /* if prepend */
		if (I_ui__Widget_is_I_ui__Layout(*child)) {
			ui__Layout l = I_ui__Widget_as_I_ui__Layout(*child);
			_t3 = ui__Layout_set_focus_prev(l);
		} else {
			_t3 = false;
		}
		focused_found =  _t3;
		if (focused_found) {
			break;
		}
		if (I_ui__Widget_is_I_ui__Focusable(*child)) {
			ui__Focusable f = I_ui__Widget_as_I_ui__Focusable(*child);
			if (ui__Focusable_has_focusable(f)) {
				if (window->do_focus) {
					ui__Focusable_name_table[f._typ]._method_focus(f._object);
					focused_found = true;
					window->do_focus = false;
					break;
				} else {
					window->do_focus = (*(f.is_focused));
				}
			}
		}
	}
	bool _t4 = focused_found;
	return _t4;
}

bool ui__Layout_set_focus_first(ui__Layout layout) {
	bool doit = false;
	Array_ui__Widget _t1 = ui__Layout_name_table[layout._typ]._method_get_children(layout._object);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		ui__Widget child = ((ui__Widget*)_t1.data)[_t2];
		bool _t3; /* if prepend */
		if (I_ui__Widget_is_I_ui__Layout(child)) {
			ui__Layout l = I_ui__Widget_as_I_ui__Layout(child);
			_t3 = ui__Layout_set_focus_first(l);
		} else if (I_ui__Widget_is_I_ui__Focusable(child)) {
			ui__Focusable f = I_ui__Widget_as_I_ui__Focusable(child);
			bool _t4; /* if prepend */
			if (ui__Focusable_has_focusable(f)) {
				ui__Focusable_name_table[f._typ]._method_focus(f._object);
				_t4 = true;
			} else {
				_t4 = false;
			}
			_t3 =  _t4;
		} else {
			_t3 = false;
		}
		doit =  _t3;
		if (doit) {
			break;
		}
	}
	bool _t5 = doit;
	return _t5;
}

bool ui__Layout_set_focus_last(ui__Layout layout) {
	bool doit = false;
	Array_ui__Widget _t1 = array_reverse(ui__Layout_name_table[layout._typ]._method_get_children(layout._object));
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		ui__Widget child = ((ui__Widget*)_t1.data)[_t2];
		bool _t3; /* if prepend */
		if (I_ui__Widget_is_I_ui__Layout(child)) {
			ui__Layout l = I_ui__Widget_as_I_ui__Layout(child);
			_t3 = ui__Layout_set_focus_last(l);
		} else if (I_ui__Widget_is_I_ui__Focusable(child)) {
			ui__Focusable f = I_ui__Widget_as_I_ui__Focusable(child);
			bool _t4; /* if prepend */
			if (ui__Focusable_has_focusable(f)) {
				ui__Focusable_name_table[f._typ]._method_focus(f._object);
				_t4 = true;
			} else {
				_t4 = false;
			}
			_t3 =  _t4;
		} else {
			_t3 = false;
		}
		doit =  _t3;
		if (doit) {
			break;
		}
	}
	bool _t5 = doit;
	return _t5;
}

bool ui__Layout_has_scrollview(ui__Layout l) {
	if (I_ui__Layout_is_I_ui__ScrollableWidget(l)) {
		ui__ScrollableWidget sw = I_ui__Layout_as_I_ui__ScrollableWidget(l);
		bool _t1 = ui__has_scrollview(sw);
		return _t1;
	} else {
		bool _t2 = false;
		return _t2;
	}
	return 0;
}

bool ui__Layout_has_scrollview_or_parent_scrollview(ui__Layout l) {
	if (I_ui__Layout_is_I_ui__ScrollableWidget(l)) {
		ui__ScrollableWidget sw = I_ui__Layout_as_I_ui__ScrollableWidget(l);
		bool _t1 = ui__has_scrollview_or_parent_scrollview(sw);
		return _t1;
	} else {
		bool _t2 = false;
		return _t2;
	}
	return 0;
}

void ui__Layout_debug_show_children_tree(ui__Layout l, int level) {
	if (level == 0) {
		println(string_repeat(_SLIT("_"), 80));
		if ((l)._typ == _ui__Layout_ui__Stack_index) {
			println( str_intp(4, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = string_repeat(_SLIT(" "), level)}}, {_SLIT(" root Stack "), 0xfe10, {.d_s = (l._ui__Stack)->id}}, {_SLIT(" "), 0xfe10, {.d_s = multi_return_int_int_str(ui__Stack_size((l._ui__Stack)))}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
	}
	Array_ui__Widget _t1 = ui__Layout_name_table[l._typ]._method_get_children(l._object);
	for (int i = 0; i < _t1.len; ++i) {
		ui__Widget* child = ((ui__Widget*)_t1.data) + i;
		println( str_intp(10, _MOV((StrIntpData[]){{_SLIT0, 0xfe10, {.d_s = string_repeat(_SLIT(" "), level)}}, {_SLIT(" "), 0xfe07, {.d_i32 = level}}, {_SLIT(":"), 0xfe07, {.d_i32 = i}}, {_SLIT(" -> "), 0xfe10, {.d_s = (*(child->id))}}, {_SLIT(" ("), 0xfe10, {.d_s = charptr_vstring_literal( /* ui.Widget */ v_typeof_interface_ui__Widget( (child)->_typ ))}}, {_SLIT(") ("), 0xfe07, {.d_i32 = (*(child->x))}}, {_SLIT(", "), 0xfe07, {.d_i32 = (*(child->y))}}, {_SLIT(") "), 0xfe10, {.d_s = multi_return_int_int_str(ui__Widget_name_table[child->_typ]._method_size(child->_object))}}, {_SLIT(" z_index: "), 0xfe07, {.d_i32 = (*(child->z_index))}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (I_ui__Widget_is_I_ui__Layout(*child)) {
			ui__Layout c = I_ui__Widget_as_I_ui__Layout(*child);
			ui__Layout_debug_show_children_tree(c, level + 1);
		}
	}
}

int ui__Widget_get_depth(ui__Widget* w) {
	int _t1 = (*(w->z_index));
	return _t1;
}

void ui__Widget_set_depth(ui__Widget* w, int z_index) {
	(*(w->z_index)) = z_index;
}

string ui__Widget_id(ui__Widget* child) {
	string _t1 = (*(child->id));
	return _t1;
}

bool ui__Widget_has_parent_deactivated(ui__Widget* w) {
	ui__Layout p = (*(w->parent));
	if ((p)._typ == _ui__Layout_ui__Stack_index) {
		bool _t1 = (p._ui__Stack)->z_index <= _const_ui__z_index_hidden || ui__Widget_has_parent_deactivated(ADDR(ui__Widget, /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget((p._ui__Stack))));
		return _t1;
	} else if ((p)._typ == _ui__Layout_ui__CanvasLayout_index) {
		bool _t2 = (p._ui__CanvasLayout)->z_index <= _const_ui__z_index_hidden || ui__Widget_has_parent_deactivated(ADDR(ui__Widget, /*&ui.Widget*/I_ui__CanvasLayout_to_Interface_ui__Widget((p._ui__CanvasLayout))));
		return _t2;
	} else if ((p)._typ == _ui__Layout_ui__Group_index) {
		bool _t3 = (p._ui__Group)->z_index <= _const_ui__z_index_hidden || ui__Widget_has_parent_deactivated(ADDR(ui__Widget, /*&ui.Widget*/I_ui__Group_to_Interface_ui__Widget((p._ui__Group))));
		return _t3;
	}
	bool _t4 = false;
	return _t4;
}

gg__Rect ui__Widget_bounds(ui__Widget* w) {
	multi_return_int_int mr_1416 = ui__Widget_name_table[w->_typ]._method_size(w->_object);
	int sw = mr_1416.arg0;
	int sh = mr_1416.arg1;
	gg__Rect _t1 = ((gg__Rect){.x = (*(w->x)),.y = (*(w->y)),.width = sw,.height = sh,});
	return _t1;
}

gg__Rect ui__Widget_scaled_bounds(ui__Widget* w) {
	multi_return_int_int mr_1521 = ui__Widget_name_table[w->_typ]._method_size(w->_object);
	int sw = mr_1521.arg0;
	int sh = mr_1521.arg1;
	f32 sc = gg__dpi_scale();
	gg__Rect _t1 = ((gg__Rect){.x = (*(w->x)) * sc,.y = (*(w->y)) * sc,.width = sw * sc,.height = sh * sc,});
	return _t1;
}

multi_return_bool_ui__Layout ui__Widget_subwindow_parent(ui__Widget w) {
	ui__Layout p = (*(w.parent));
	for (;;) {
		if ((p)._typ == _ui__Layout_ui__Window_index) {
			break;
		}
		if ((p)._typ == _ui__Layout_ui__SubWindow_index) {
			return (multi_return_bool_ui__Layout){.arg0=true, .arg1=p};
		}
		if (I_ui__Layout_is_I_ui__Widget(p)) {
			ui__Widget wp = I_ui__Layout_as_I_ui__Widget(p);
			p = (*(wp.parent));
			continue;
		}
		break;
	}
	return (multi_return_bool_ui__Layout){.arg0=false, .arg1=/*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack)};
}

bool ui__Widget_is_layout_with_children(ui__Widget w) {
	if (I_ui__Widget_is_I_ui__Layout(w)) {
		ui__Layout l = I_ui__Widget_as_I_ui__Layout(w);
		bool _t1 = ui__Layout_name_table[l._typ]._method_get_children(l._object).len > 0;
		return _t1;
	} else {
		bool _t2 = false;
		return _t2;
	}
	return 0;
}

bool ui__shift_key(ui__KeyMod mods) {
	bool _t1 = (((int)(mods)) & 1) == 1;
	return _t1;
}

bool ui__ctl_key(ui__KeyMod mods) {
	bool _t1 = (((int)(mods)) & 2) == 2;
	return _t1;
}

bool ui__alt_key(ui__KeyMod mods) {
	bool _t1 = (((int)(mods)) & 4) == 4;
	return _t1;
}

bool ui__super_key(ui__KeyMod mods) {
	bool _t1 = (((int)(mods)) & 8) == 8;
	return _t1;
}

bool ui__ctl_shift_key(ui__KeyMod mods) {
	bool _t1 = (((int)(mods)) & 3) == 3;
	return _t1;
}

bool ui__ctl_alt_key(ui__KeyMod mods) {
	bool _t1 = (((int)(mods)) & 6) == 6;
	return _t1;
}

bool ui__super_alt_key(ui__KeyMod mods) {
	bool _t1 = (((int)(mods)) & 12) == 12;
	return _t1;
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
ui__CanvasLayout* ui__canvas_layout(ui__CanvasLayoutParams c) {
	ui__CanvasLayout* canvas = ui__canvas_plus(c);
	canvas->children = c.children;
	for (int i = 0; i < c.children.len; ++i) {
		ui__Widget child = ((ui__Widget*)c.children.data)[i];
		(*(ui__XYPos*)map_get_and_set((map*)&canvas->pos_, &(int[]){i}, &(ui__XYPos[]){ (ui__XYPos){.x = 0,.y = 0,} })) = ((ui__XYPos){.x = (*(child.x)),.y = (*(child.y)),});
	}
	ui__CanvasLayout* _t1 = canvas;
	return _t1;
}

ui__CanvasLayout* ui__canvas_plus(ui__CanvasLayoutParams c) {
	ui__CanvasLayout* canvas = ((ui__CanvasLayout*)memdup(&(ui__CanvasLayout){.id = c.id,
		.children = __new_array(0, 0, sizeof(ui__Widget)),
		.drawing_children = __new_array(0, 0, sizeof(ui__Widget)),
		.width = c.width,
		.height = c.height,
		.x = 0,
		.y = 0,
		.offset_x = 0,
		.offset_y = 0,
		.z_index = c.z_index,
		.is_focused = 0,
		.ui = 0,
		.hidden = 0,
		.bg_color = c.bg_color,
		.bg_radius = ((f32)(c.bg_radius)),
		.adj_width = 0,
		.adj_height = 0,
		.full_width = c.full_width,
		.full_height = c.full_height,
		.text_styles = (ui__TextStyles){.current = (ui__TextStyle){.id = _const_ui__no_string,.font_name = _SLIT("system"),.color = _const_gx__black,.size = 16,.align = ui__TextHorizontalAlign__left,.vertical_align = ui__TextVerticalAlign__top,.mono = 0,},.hash = new_map(sizeof(string), sizeof(ui__TextStyle), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},
		.component = 0,
		.component_init = 0,
		.has_scrollview = 0,
		.scrollview = 0,
		.draw_fn = (voidptr)c.on_draw,
		.click_fn = (voidptr)c.on_click,
		.mouse_down_fn = (voidptr)c.on_mouse_down,
		.mouse_up_fn = (voidptr)c.on_mouse_up,
		.scroll_fn = ((ui__CanvasLayoutScrollFn)(0)),
		.mouse_move_fn = (voidptr)c.on_mouse_move,
		.key_down_fn = (voidptr)c.on_key_down,
		.char_fn = (voidptr)c.on_char,
		.full_size_fn = (voidptr)c.full_size_fn,
		.on_scroll_change = (voidptr)c.on_scroll_change,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.pos_ = new_map(sizeof(int), sizeof(ui__XYPos), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),
	}, sizeof(ui__CanvasLayout)));
	if (c.scrollview) {
		ui__scrollview_add_T_ui__CanvasLayout(canvas);
	}
	ui__CanvasLayout* _t1 = canvas;
	return _t1;
}

void ui__CanvasLayout_init(ui__CanvasLayout* c, ui__Layout parent) {
	c->parent = parent;
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	c->ui = ui;
	ui__CanvasLayout_init_size(c);
	eventbus__Subscriber* subscriber = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_click, (voidptr)ui__canvas_layout_click, c);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_down, (voidptr)ui__canvas_layout_mouse_down, c);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_up, (voidptr)ui__canvas_layout_mouse_up, c);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_move, (voidptr)ui__canvas_layout_mouse_move, c);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_scroll, (voidptr)ui__canvas_layout_scroll, c);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_key_down, (voidptr)ui__canvas_layout_key_down, c);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_char, (voidptr)ui__canvas_layout_char, c);
	ui__EventMngr_add_receiver(&c->ui->window->evt_mngr, /*&ui.Widget*/I_ui__CanvasLayout_to_Interface_ui__Widget(c), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(_const_ui__events.on_mouse_down)})));
	for (int _t1 = 0; _t1 < c->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)c->children.data) + _t1;
		ui__Widget_name_table[child->_typ]._method_init(child->_object, /*&ui.Layout*/I_ui__CanvasLayout_to_Interface_ui__Layout(c));
	}
	if (c->component_init != (voidptr)((ui__ComponentInitFn)(0))) {
		c->component_init(c);
	}
	ui__CanvasLayout_set_adjusted_size(c, ui);
	ui__CanvasLayout_set_children_pos(c);
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__CanvasLayout_to_Interface_ui__ScrollableWidget(c))) {
		ui__ScrollView_init(c->scrollview, parent);
		ui__EventMngr_add_receiver(&c->ui->window->evt_mngr, /*&ui.Widget*/I_ui__CanvasLayout_to_Interface_ui__Widget(c), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(_const_ui__events.on_scroll)})));
	} else {
		ui__scrollview_delegate_parent_scrollview_T_ui__CanvasLayout(c);
	}
}

// Attr: [manualfree]
void ui__CanvasLayout_cleanup(ui__CanvasLayout* c) {
	eventbus__Subscriber* subscriber = ui__Layout_name_table[c->parent._typ]._method_get_subscriber(c->parent._object);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_click, c);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_down, c);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_up, c);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_move, c);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_scroll, c);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_key_down, c);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_char, c);
	ui__EventMngr_rm_receiver(&c->ui->window->evt_mngr, /*&ui.Widget*/I_ui__CanvasLayout_to_Interface_ui__Widget(c), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(_const_ui__events.on_mouse_down)})));
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__CanvasLayout_to_Interface_ui__ScrollableWidget(c))) {
		ui__EventMngr_rm_receiver(&c->ui->window->evt_mngr, /*&ui.Widget*/I_ui__CanvasLayout_to_Interface_ui__Widget(c), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(_const_ui__events.on_scroll)})));
	}
	for (int _t1 = 0; _t1 < c->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)c->children.data) + _t1;
		ui__Widget_name_table[child->_typ]._method_cleanup(child->_object);
	}
	ui__CanvasLayout_free(c);
}

// Attr: [unsafe]
void ui__CanvasLayout_free(ui__CanvasLayout* c) {
	{ // Unsafe block
		string_free(&c->id);
		array_free(&c->drawing_children);
		array_free(&c->children);
		_v_free(c);
	}
}

void ui__CanvasLayout_init_size(ui__CanvasLayout* c) {
	ui__Layout parent = c->parent;
	if ((c->parent)._typ == _ui__Layout_ui__SubWindow_index) {
		multi_return_int_int mr_6744 = ui__CanvasLayout_adj_size(c);
		c->width = mr_6744.arg0;
		c->height = mr_6744.arg1;
	} else if ((c->parent)._typ == _ui__Layout_ui__Window_index) {
		multi_return_int_int mr_6811 = ui__Layout_name_table[parent._typ]._method_size(parent._object);
		c->width = mr_6811.arg0;
		c->height = mr_6811.arg1;
	}
	ui__scrollview_update_T_ui__CanvasLayout(c);
}

void ui__canvas_layout_click(ui__CanvasLayout* c, ui__MouseEvent* e, ui__Window* window) {
	if (!ui__Window_is_top_widget(/*rec*/*c->ui->window, /*&ui.Widget*/I_ui__CanvasLayout_to_Interface_ui__Widget(c), _const_ui__events.on_mouse_down)) {
		return;
	}
	c->is_focused = ui__CanvasLayout_point_inside(c, e->x, e->y);
	if (c->is_focused && c->click_fn != (voidptr)((voidptr)(0))) {
		ui__MouseEvent e2 = ((ui__MouseEvent){.x = e->x - c->x - c->offset_x,.y = e->y - c->y - c->offset_y,.button = e->button,.action = e->action,.mods = e->mods,});
		c->click_fn(e2, c);
	}
}

void ui__canvas_layout_mouse_down(ui__CanvasLayout* c, ui__MouseEvent* e, ui__Window* window) {
	if (!ui__Window_is_top_widget(/*rec*/*c->ui->window, /*&ui.Widget*/I_ui__CanvasLayout_to_Interface_ui__Widget(c), _const_ui__events.on_mouse_down)) {
		return;
	}
	if (ui__CanvasLayout_point_inside(c, e->x, e->y) && c->mouse_down_fn != (voidptr)((voidptr)(0))) {
		ui__MouseEvent e2 = ((ui__MouseEvent){.x = e->x - c->x - c->offset_x,.y = e->y - c->y - c->offset_y,.button = e->button,.action = e->action,.mods = e->mods,});
		c->mouse_down_fn(e2, c);
	}
}

void ui__canvas_layout_mouse_up(ui__CanvasLayout* c, ui__MouseEvent* e, ui__Window* window) {
	if (ui__CanvasLayout_point_inside(c, e->x, e->y) && c->mouse_up_fn != (voidptr)((voidptr)(0))) {
		ui__MouseEvent e2 = ((ui__MouseEvent){.x = e->x - c->x - c->offset_x,.y = e->y - c->y - c->offset_y,.button = e->button,.action = e->action,.mods = e->mods,});
		c->mouse_up_fn(e2, c);
	}
}

void ui__canvas_layout_mouse_move(ui__CanvasLayout* c, ui__MouseMoveEvent* e, ui__Window* window) {
	if (ui__CanvasLayout_point_inside(c, e->x, e->y) && c->mouse_move_fn != (voidptr)((voidptr)(0))) {
		ui__MouseMoveEvent e2 = ((ui__MouseMoveEvent){.x = e->x - c->x - c->offset_x,.y = e->y - c->y - c->offset_y,.mouse_button = e->mouse_button,});
		c->mouse_move_fn(e2, c);
	}
}

void ui__canvas_layout_scroll(ui__CanvasLayout* c, ui__ScrollEvent* e, ui__Window* window) {
	if (c->scroll_fn != (voidptr)((voidptr)(0))) {
		ui__ScrollEvent e2 = ((ui__ScrollEvent){.x = e->x - c->x - c->offset_x,.y = e->y - c->y - c->offset_y,.mouse_x = 0,.mouse_y = 0,});
		c->scroll_fn(e2, c);
	}
}

void ui__canvas_layout_key_down(ui__CanvasLayout* c, ui__KeyEvent* e, ui__Window* window) {
	if (c->hidden) {
		return;
	}
	if (!c->is_focused) {
		return;
	}
	if (c->key_down_fn != (voidptr)((voidptr)(0))) {
		c->key_down_fn(*e, c);
	}
}

void ui__canvas_layout_char(ui__CanvasLayout* c, ui__KeyEvent* e, ui__Window* window) {
	if (c->hidden) {
		return;
	}
	if (!c->is_focused) {
		return;
	}
	if (c->char_fn != (voidptr)((voidptr)(0))) {
		c->char_fn(*e, c);
	}
}

void ui__CanvasLayout_update_layout(ui__CanvasLayout* c) {
	ui__CanvasLayout_set_drawing_children(c);
}

void ui__CanvasLayout_set_adjusted_size(ui__CanvasLayout* c, ui__UI* gui) {
	if (c->full_width > 0 && c->full_height > 0) {
		c->adj_width = c->full_width;
		c->adj_height = c->full_height;
		return;
	} else if (c->full_width == -1 || c->full_height == -1) {
		multi_return_int_int mr_9706 = ui__CanvasLayout_full_size(c);
		int fw = mr_9706.arg0;
		int fh = mr_9706.arg1;
		if (fw > 0 && fh > 0) {
			c->adj_width = fw;
			c->adj_height = fh;
			return;
		}
	}
	int w = 0;
	int h = 0;
	for (int _t1 = 0; _t1 < c->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)c->children.data) + _t1;
		if ((*(child->z_index)) > _const_ui__z_index_hidden) {
			multi_return_int_int mr_9966 = ui__Widget_name_table[child->_typ]._method_size(child->_object);
			int child_width = mr_9966.arg0;
			int child_height = mr_9966.arg1;
			if ((*(child->x)) + child_width > w) {
				w = (*(child->x)) + child_width;
			}
			if ((*(child->y)) + child_height > h) {
				h = (*(child->y)) + child_height;
			}
		}
	}
	if (c->width > w) {
		w = c->width;
	}
	if (c->height > h) {
		h = c->height;
	}
	c->adj_width = w;
	c->adj_height = h;
}

void ui__CanvasLayout_set_children_pos(ui__CanvasLayout* c) {
	for (int i = 0; i < c->children.len; ++i) {
		ui__Widget* child = ((ui__Widget*)c->children.data) + i;
		ui__Widget_name_table[child->_typ]._method_set_pos(child->_object, (*(ui__XYPos*)map_get(ADDR(map, c->pos_), &(int[]){i}, &(ui__XYPos[]){ (ui__XYPos){.x = 0,.y = 0,} })).x + c->x + c->offset_x, (*(ui__XYPos*)map_get(ADDR(map, c->pos_), &(int[]){i}, &(ui__XYPos[]){ (ui__XYPos){.x = 0,.y = 0,} })).y + c->y + c->offset_y);
		if ((child)->_typ == _ui__Widget_ui__Stack_index) {
			ui__Stack_update_layout((child->_ui__Stack));
		}
	}
}

void ui__CanvasLayout_set_child_relative_pos(ui__CanvasLayout* c, string id, int x, int y) {
	for (int i = 0; i < c->children.len; ++i) {
		ui__Widget child = ((ui__Widget*)c->children.data)[i];
		if (string__eq((*(child.id)), id)) {
			(*(ui__XYPos*)map_get_and_set((map*)&c->pos_, &(int[]){i}, &(ui__XYPos[]){ (ui__XYPos){.x = 0,.y = 0,} })) = ((ui__XYPos){.x = x,.y = y,});
			ui__scrollview_need_update(HEAP(ui__ScrollableWidget, /*&ui.ScrollableWidget*/I_ui__CanvasLayout_to_Interface_ui__ScrollableWidget(c)));
		}
	}
}

void ui__CanvasLayout_set_pos(ui__CanvasLayout* c, int x, int y) {
	c->x = x;
	c->y = y;
	ui__CanvasLayout_set_children_pos(c);
}

multi_return_int_int ui__CanvasLayout_adj_size(ui__CanvasLayout* c) {
	return (multi_return_int_int){.arg0=c->adj_width, .arg1=c->adj_height};
}

multi_return_int_int ui__CanvasLayout_size(ui__CanvasLayout* c) {
	return (multi_return_int_int){.arg0=c->width, .arg1=c->height};
}

multi_return_int_int ui__CanvasLayout_full_size(ui__CanvasLayout* c) {
	int fw = c->full_width;
	int fh = c->full_height;
	if (c->full_width == -1 || c->full_height == -1) {
		if (c->full_size_fn == (voidptr)((voidptr)(0))) {
			return (multi_return_int_int){.arg0=0, .arg1=0};
		} else {
			multi_return_int_int mr_11404 = c->full_size_fn(c);
			int w = mr_11404.arg0;
			int h = mr_11404.arg1;
			if (c->full_width == -1) {
				fw = w;
			}
			if (c->full_height == -1) {
				fh = h;
			}
		}
	}
	return (multi_return_int_int){.arg0=fw, .arg1=fh};
}

multi_return_int_int ui__CanvasLayout_propose_size(ui__CanvasLayout* c, int w, int h) {
	c->width = w;
	c->height = h;
	ui__scrollview_update_T_ui__CanvasLayout(c);
	return (multi_return_int_int){.arg0=c->width, .arg1=c->height};
}

void ui__CanvasLayout_set_drawing_children(ui__CanvasLayout* c) {
	for (int _t1 = 0; _t1 < c->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)c->children.data) + _t1;
		if ((child)->_typ == _ui__Widget_ui__Stack_index) {
			ui__Stack_set_drawing_children((child->_ui__Stack));
		} else if ((child)->_typ == _ui__Widget_ui__CanvasLayout_index) {
			ui__CanvasLayout_set_drawing_children((child->_ui__CanvasLayout));
		}
		if ((*(child->z_index)) > c->z_index) {
			c->z_index = (*(child->z_index)) - 1;
		}
	}
	Array_ui__Widget _t2 = {0};
	Array_ui__Widget _t2_orig = c->children;
	int _t2_len = _t2_orig.len;
	_t2 = __new_array(0, _t2_len, sizeof(ui__Widget));

	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		ui__Widget it = ((ui__Widget*) _t2_orig.data)[_t3];
		if (!(*(it.hidden))) {
			array_push((array*)&_t2, &it);
		}
	}
	c->drawing_children =_t2;
	ui__CanvasLayout_sorted_drawing_children(c);
}

void ui__CanvasLayout_draw(ui__CanvasLayout* c) {
	if (c->hidden) {
		return;
	}
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__CanvasLayout_to_Interface_ui__Widget(c)));
	ui__Layout parent = c->parent;
	voidptr state = ui__Layout_name_table[parent._typ]._method_get_state(parent._object);
	ui__scrollview_draw_begin_T_ui__CanvasLayout(c);
	if (!gx__Color_struct_eq(c->bg_color, _const_ui__no_color)) {
		int w = c->width;
		int h = c->height;
		multi_return_int_int mr_12582 = ui__CanvasLayout_full_size(c);
		int fw = mr_12582.arg0;
		int fh = mr_12582.arg1;
		if (fw > 0 && fh > 0) {
			w = ((int)(((f32)(fw)) * c->ui->gg->scale));
			h = ((int)(((f32)(fh)) * c->ui->gg->scale));
		}
		if (c->bg_radius > 0) {
			f32 radius = ui__relative_size(c->bg_radius, w, h);
			ui__CanvasLayout_draw_rounded_rect_filled(c, 0, 0, w, h, radius, c->bg_color);
		} else {
			ui__CanvasLayout_draw_rect_filled(c, 0, 0, w, h, c->bg_color);
		}
	}
	if (c->draw_fn != (voidptr)((voidptr)(0))) {
		c->draw_fn(c, state);
	}
	if (c->scrollview != 0) {
		for (int _t1 = 0; _t1 < c->drawing_children.len; ++_t1) {
			ui__Widget* child = ((ui__Widget*)c->drawing_children.data) + _t1;
			if (I_ui__Widget_is_I_ui__Layout(*child) || !ui__is_empty_intersection(c->scrollview->scissor_rect, ui__Widget_scaled_bounds(child))) {
				ui__Widget_name_table[child->_typ]._method_draw(child->_object);
			}
		}
	} else {
		for (int _t2 = 0; _t2 < c->drawing_children.len; ++_t2) {
			ui__Widget* child = ((ui__Widget*)c->drawing_children.data) + _t2;
			ui__Widget_name_table[child->_typ]._method_draw(child->_object);
		}
	}
	ui__scrollview_draw_end_T_ui__CanvasLayout(c);
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__CanvasLayout_to_Interface_ui__Widget(c)));
}

void ui__CanvasLayout_set_visible(ui__CanvasLayout* c, bool state) {
	c->hidden = !state;
	for (int _t1 = 0; _t1 < c->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)c->children.data) + _t1;
		ui__Widget_name_table[child->_typ]._method_set_visible(child->_object, state);
	}
}

bool ui__CanvasLayout_point_inside(ui__CanvasLayout* c, f64 x, f64 y) {
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__CanvasLayout_to_Interface_ui__ScrollableWidget(c))) {
		bool _t1 = ui__point_inside_adj_T_ui__CanvasLayout(c, x, y);
		return _t1;
	} else {
		bool _t2 = ui__point_inside_T_ui__CanvasLayout(c, x, y);
		return _t2;
	}
	return 0;
}

ui__UI* ui__CanvasLayout_get_ui(ui__CanvasLayout* c) {
	ui__UI* _t1 = c->ui;
	return _t1;
}

void ui__CanvasLayout_resize(ui__CanvasLayout* c, int width, int height) {
	ui__CanvasLayout_propose_size(c, width, height);
}

voidptr ui__CanvasLayout_get_state(ui__CanvasLayout* c) {
	ui__Layout parent = c->parent;
	voidptr _t1 = ui__Layout_name_table[parent._typ]._method_get_state(parent._object);
	return _t1;
}

eventbus__Subscriber* ui__CanvasLayout_get_subscriber(ui__CanvasLayout* c) {
	ui__Layout parent = c->parent;
	eventbus__Subscriber* _t1 = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	return _t1;
}

Array_ui__Widget ui__CanvasLayout_get_children(ui__CanvasLayout* c) {
	Array_ui__Widget _t1 = c->children;
	return _t1;
}

int ui__CanvasLayout_child_index_by_id(ui__CanvasLayout* c, string id) {
	for (int i = 0; i < c->children.len; ++i) {
		ui__Widget child = ((ui__Widget*)c->children.data)[i];
		if (string__eq(ui__Widget_id(&child), id)) {
			int _t1 = i;
			return _t1;
		}
	}
	int _t2 = -1;
	return _t2;
}

void ui__CanvasLayout_draw_text_def(ui__CanvasLayout* c, int x, int y, string text) {
	gg__Context_draw_text_def(c->ui->gg, x + c->x + c->offset_x, y + c->y + c->offset_y, text);
}

void ui__CanvasLayout_draw_text(ui__CanvasLayout* c, int x, int y, string text) {
	ui__DrawTextWidget dtw = /*&ui.DrawTextWidget*/I_ui__CanvasLayout_to_Interface_ui__DrawTextWidget(c);
	ui__DrawTextWidget_draw_text(dtw, x + c->x + c->offset_x, y + c->y + c->offset_y, text);
}

void ui__CanvasLayout_draw_styled_text(ui__CanvasLayout* c, int x, int y, string text, ui__TextStyleParams ts) {
	ui__DrawTextWidget dtw = /*&ui.DrawTextWidget*/I_ui__CanvasLayout_to_Interface_ui__DrawTextWidget(c);
	ui__DrawTextWidget_draw_styled_text(dtw, x + c->x + c->offset_x, y + c->y + c->offset_y, text, ts);
}

void ui__CanvasLayout_draw_triangle_empty(ui__CanvasLayout* c, f32 x, f32 y, f32 x2, f32 y2, f32 x3, f32 y3, gx__Color color) {
	gg__Context_draw_triangle_empty(c->ui->gg, x + c->x + c->offset_x, y + c->y + c->offset_y, x2 + c->x + c->offset_x, y2 + c->y + c->offset_y, x3 + c->x + c->offset_x, y3 + c->y + c->offset_y, color);
}

void ui__CanvasLayout_draw_triangle_filled(ui__CanvasLayout* c, f32 x, f32 y, f32 x2, f32 y2, f32 x3, f32 y3, gx__Color color) {
	gg__Context_draw_triangle_filled(c->ui->gg, x + c->x + c->offset_x, y + c->y + c->offset_y, x2 + c->x + c->offset_x, y2 + c->y + c->offset_y, x3 + c->x + c->offset_x, y3 + c->y + c->offset_y, color);
}

void ui__CanvasLayout_draw_square_empty(ui__CanvasLayout* c, f32 x, f32 y, f32 s, gx__Color color) {
	ui__CanvasLayout_draw_rect_empty(c, x, y, s, s, color);
}

void ui__CanvasLayout_draw_square_filled(ui__CanvasLayout* c, f32 x, f32 y, f32 s, gx__Color color) {
	ui__CanvasLayout_draw_rect_filled(c, x, y, s, s, color);
}

void ui__CanvasLayout_draw_rect_empty(ui__CanvasLayout* c, f32 x, f32 y, f32 w, f32 h, gx__Color color) {
	gg__Context_draw_rect_empty(c->ui->gg, x + c->x + c->offset_x, y + c->y + c->offset_y, w, h, color);
}

void ui__CanvasLayout_draw_rect_filled(ui__CanvasLayout* c, f32 x, f32 y, f32 w, f32 h, gx__Color color) {
	gg__Context_draw_rect_filled(c->ui->gg, x + c->x + c->offset_x, y + c->y + c->offset_y, w, h, color);
}

void ui__CanvasLayout_draw_rounded_rect_filled(ui__CanvasLayout* c, f32 x, f32 y, f32 w, f32 h, f32 radius, gx__Color color) {
	f32 rad = ui__relative_size(radius, ((int)(w)), ((int)(h)));
	gg__Context_draw_rounded_rect_filled(c->ui->gg, x + c->x + c->offset_x, y + c->y + c->offset_y, w, h, rad, color);
}

void ui__CanvasLayout_draw_rounded_rect_empty(ui__CanvasLayout* c, f32 x, f32 y, f32 w, f32 h, f32 radius, gx__Color border_color) {
	f32 rad = ui__relative_size(radius, ((int)(w)), ((int)(h)));
	gg__Context_draw_rounded_rect_empty(c->ui->gg, x + c->x + c->offset_x, y + c->y + c->offset_y, w, h, rad, border_color);
}

void ui__CanvasLayout_draw_circle_line(ui__CanvasLayout* c, f32 x, f32 y, int r, int segments, gx__Color color) {
	gg__Context_draw_circle_line(c->ui->gg, x + c->x + c->offset_x, y + c->y + c->offset_y, r, segments, color);
}

void ui__CanvasLayout_draw_circle_empty(ui__CanvasLayout* c, f32 x, f32 y, f32 r, gx__Color color) {
	gg__Context_draw_circle_empty(c->ui->gg, x + c->x + c->offset_x, y + c->y + c->offset_y, r, color);
}

void ui__CanvasLayout_draw_circle_filled(ui__CanvasLayout* c, f32 x, f32 y, f32 r, gx__Color color) {
	gg__Context_draw_circle_filled(c->ui->gg, x + c->x + c->offset_x, y + c->y + c->offset_y, r, color);
}

void ui__CanvasLayout_draw_slice_empty(ui__CanvasLayout* c, f32 x, f32 y, f32 r, f32 start_angle, f32 end_angle, int segments, gx__Color color) {
	gg__Context_draw_slice_empty(c->ui->gg, x + c->x + c->offset_x, y + c->y + c->offset_y, r, start_angle, end_angle, segments, color);
}

void ui__CanvasLayout_draw_slice_filled(ui__CanvasLayout* c, f32 x, f32 y, f32 r, f32 start_angle, f32 end_angle, int segments, gx__Color color) {
	gg__Context_draw_slice_filled(c->ui->gg, x + c->x + c->offset_x, y + c->y + c->offset_y, r, start_angle, end_angle, segments, color);
}

void ui__CanvasLayout_draw_arc_empty(ui__CanvasLayout* c, f32 x, f32 y, f32 inner_radius, f32 thickness, f32 start_angle, f32 end_angle, int segments, gx__Color color) {
	gg__Context_draw_arc_empty(c->ui->gg, x + c->x + c->offset_x, y + c->y + c->offset_y, inner_radius, thickness, start_angle, end_angle, segments, color);
}

void ui__CanvasLayout_draw_arc_filled(ui__CanvasLayout* c, f32 x, f32 y, f32 inner_radius, f32 thickness, f32 start_angle, f32 end_angle, int segments, gx__Color color) {
	gg__Context_draw_arc_filled(c->ui->gg, x + c->x + c->offset_x, y + c->y + c->offset_y, inner_radius, thickness, start_angle, end_angle, segments, color);
}

void ui__CanvasLayout_draw_line(ui__CanvasLayout* c, f32 x, f32 y, f32 x2, f32 y2, gx__Color color) {
	gg__Context_draw_line(c->ui->gg, x + c->x + c->offset_x, y + c->y + c->offset_y, x2 + c->x + c->offset_x, y2 + c->y + c->offset_y, color);
}

void ui__CanvasLayout_draw_convex_poly(ui__CanvasLayout* c, Array_f32 points, gx__Color color) {
}

void ui__CanvasLayout_draw_empty_poly(ui__CanvasLayout* c, Array_f32 points, gx__Color color) {
}

ui__Stack* ui__column(ui__ColumnParams c) {
	ui__Stack* _t1 = ui__stack(((ui__StackParams){
		.id = c.id,
		.width = c.width,
		.height = c.height,
		.vertical_alignment = 0,
		.horizontal_alignment = c.alignment,
		.spacings = ui__spacings(c.spacing, c.spacings, c.children.len - 1),
		.spacing = 0,
		.stretch = c.stretch,
		.direction = ui__Direction__column,
		.margins = ui__margins(c.margin_, c.margin),
		.title = c.title,
		.widths = ui__Size_as_f32_array(c.widths, c.children.len),
		.heights = ui__Size_as_f32_array(c.heights, c.children.len),
		.align = c.align,
		.vertical_alignments = (ui__VerticalAlignments){.top = __new_array(0, 0, sizeof(int)),.center = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),},
		.horizontal_alignments = c.alignments,
		.bg_color = c.bg_color,
		.bg_radius = ((f32)(c.bg_radius)),
		.scrollview = c.scrollview,
		.children = c.children,
	}));
	return _t1;
}

ui__Group* ui__group(ui__GroupParams c) {
	ui__Group* g = ((ui__Group*)memdup(&(ui__Group){.id = c.id,
		.title = c.title,
		.height = c.height,
		.width = c.width,
		.x = c.x,
		.y = c.y,
		.offset_x = 0,
		.offset_y = 0,
		.z_index = 0,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.ui = 0,
		.children = c.children,
		.margin_left = 5,
		.margin_top = 10,
		.margin_right = 5,
		.margin_bottom = 5,
		.spacing = c.spacing,
		.adj_height = 0,
		.adj_width = 0,
		.hidden = 0,
		.component = 0,
		.debug_ids = __new_array(0, 0, sizeof(string)),
	}, sizeof(ui__Group)));
	ui__Group* _t1 = g;
	return _t1;
}

void ui__Group_init(ui__Group* g, ui__Layout parent) {
	g->parent = parent;
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	g->ui = ui;
	ui__Group_decode_size(g);
	for (int _t1 = 0; _t1 < g->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)g->children.data) + _t1;
		ui__Widget_name_table[child->_typ]._method_init(child->_object, /*&ui.Layout*/I_ui__Group_to_Interface_ui__Layout(g));
	}
	ui__Group_calculate_child_positions(g);
}

// Attr: [manualfree]
void ui__Group_cleanup(ui__Group* g) {
	for (int _t1 = 0; _t1 < g->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)g->children.data) + _t1;
		ui__Widget_name_table[child->_typ]._method_cleanup(child->_object);
	}
	ui__Group_free(g);
}

// Attr: [unsafe]
void ui__Group_free(ui__Group* g) {
	{ // Unsafe block
		string_free(&g->id);
		string_free(&g->title);
		array_free(&g->children);
		_v_free(g);
	}
}

void ui__Group_decode_size(ui__Group* g) {
	multi_return_int_int mr_1749 = ui__Layout_name_table[g->parent._typ]._method_size(g->parent._object);
	int parent_width = mr_1749.arg0;
	int parent_height = mr_1749.arg1;
	g->width = ui__relative_size_from_parent(g->width, parent_width);
	g->height = ui__relative_size_from_parent(g->height, parent_height);
}

void ui__Group_set_pos(ui__Group* g, int x, int y) {
	g->x = x;
	g->y = y;
	ui__Group_calculate_child_positions(g);
}

void ui__Group_calculate_child_positions(ui__Group* g) {
	Array_ui__Widget widgets = g->children;
	int start_x = g->x + g->margin_left;
	int start_y = g->y + g->margin_top;
	for (int _t1 = 0; _t1 < widgets.len; ++_t1) {
		ui__Widget* widget = ((ui__Widget*)widgets.data) + _t1;
		multi_return_int_int mr_2448 = ui__Widget_name_table[widget->_typ]._method_size(widget->_object);
		int wid_h = mr_2448.arg1;
		ui__Widget_name_table[widget->_typ]._method_set_pos(widget->_object, start_x, start_y);
		start_y = start_y + wid_h + g->spacing;
	}
}

void ui__Group_draw(ui__Group* g) {
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Group_to_Interface_ui__Widget(g)));
	gg__Context_draw_rect_empty(g->ui->gg, g->x, g->y, g->width, g->height, _const_gx__gray);
	string title = g->title;
	int text_width = gg__Context_text_width(g->ui->gg, title);
	if (text_width > (g->width - _const_ui__check_mark_size - 3)) {
		f32 proportion = ((f32)(g->width)) / ((f32)(text_width));
		int target_len = ((int)(math__floor(title.len * proportion))) - 5;
		title = (target_len < 0 ? (_SLIT("")) : (string__plus(string_substr(title, 0, target_len), _SLIT(".."))));
		text_width = gg__Context_text_width(g->ui->gg, title);
	}
	gg__Context_draw_rect_filled(g->ui->gg, g->x + _const_ui__check_mark_size, g->y - 5, text_width + 5, 10, g->ui->window->bg_color);
	gg__Context_draw_text_def(g->ui->gg, g->x + _const_ui__check_mark_size + 3, g->y - 7, title);
	for (int _t1 = 0; _t1 < g->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)g->children.data) + _t1;
		ui__Widget_name_table[child->_typ]._method_draw(child->_object);
	}
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Group_to_Interface_ui__Widget(g)));
}

bool ui__Group_point_inside(ui__Group* g, f64 x, f64 y) {
	bool _t1 = ui__point_inside_T_ui__Group(g, x, y);
	return _t1;
}

void ui__Group_set_visible(ui__Group* g, bool state) {
	g->hidden = !state;
}

ui__UI* ui__Group_get_ui(ui__Group* g) {
	ui__UI* _t1 = g->ui;
	return _t1;
}

void ui__Group_resize(ui__Group* g, int width, int height) {
}

voidptr ui__Group_get_state(ui__Group* g) {
	ui__Layout parent = g->parent;
	voidptr _t1 = ui__Layout_name_table[parent._typ]._method_get_state(parent._object);
	return _t1;
}

eventbus__Subscriber* ui__Group_get_subscriber(ui__Group* g) {
	ui__Layout parent = g->parent;
	eventbus__Subscriber* _t1 = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	return _t1;
}

void ui__Group_set_adjusted_size(ui__Group* g, int i, ui__UI* ui) {
	int h = 0;
	int w = 0;
	for (int _t1 = 0; _t1 < g->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)g->children.data) + _t1;
		multi_return_int_int mr_4096 = ui__Widget_name_table[child->_typ]._method_size(child->_object);
		int child_width = mr_4096.arg0;
		int child_height = mr_4096.arg1;
		h += child_height;
		if (child_width > w) {
			w = child_width;
		}
	}
	h += g->spacing * (g->children.len - 1);
	g->adj_width = w;
	g->adj_height = h;
}

multi_return_int_int ui__Group_adj_size(ui__Group* g) {
	return (multi_return_int_int){.arg0=g->adj_width, .arg1=g->adj_height};
}

multi_return_int_int ui__Group_propose_size(ui__Group* g, int w, int h) {
	g->width = w;
	g->height = h;
	return (multi_return_int_int){.arg0=g->width, .arg1=g->height};
}

multi_return_int_int ui__Group_size(ui__Group* g) {
	return (multi_return_int_int){.arg0=g->width, .arg1=g->height};
}

Array_ui__Widget ui__Group_get_children(ui__Group* g) {
	Array_ui__Widget _t1 = g->children;
	return _t1;
}

void ui__Group_update_layout(ui__Group* g) {
}

ui__Stack* ui__row(ui__RowParams c) {
	ui__Stack* _t1 = ui__stack(((ui__StackParams){
		.id = c.id,
		.width = c.width,
		.height = c.height,
		.vertical_alignment = c.alignment,
		.horizontal_alignment = 0,
		.spacings = ui__spacings(c.spacing, c.spacings, c.children.len - 1),
		.spacing = 0,
		.stretch = c.stretch,
		.direction = ui__Direction__row,
		.margins = ui__margins(c.margin_, c.margin),
		.title = c.title,
		.widths = ui__Size_as_f32_array(c.widths, c.children.len),
		.heights = ui__Size_as_f32_array(c.heights, c.children.len),
		.align = c.align,
		.vertical_alignments = c.alignments,
		.horizontal_alignments = (ui__HorizontalAlignments){.left = __new_array(0, 0, sizeof(int)),.center = __new_array(0, 0, sizeof(int)),.right = __new_array(0, 0, sizeof(int)),},
		.bg_color = c.bg_color,
		.bg_radius = ((f32)(c.bg_radius)),
		.scrollview = c.scrollview,
		.children = c.children,
	}));
	return _t1;
}

ui__Stack* ui__stack(ui__StackParams c) {
	ui__Stack* s = ((ui__Stack*)memdup(&(ui__Stack){.cache = (ui__CachedSizes){.width_type = __new_array(0, 0, sizeof(ui__ChildSize)),.height_type = __new_array(0, 0, sizeof(ui__ChildSize)),.adj_widths = __new_array(0, 0, sizeof(int)),.adj_heights = __new_array(0, 0, sizeof(int)),.fixed_widths = __new_array(0, 0, sizeof(int)),.fixed_heights = __new_array(0, 0, sizeof(int)),.fixed_width = 0,.fixed_height = 0,.min_width = 0,.min_height = 0,.weight_widths = __new_array(0, 0, sizeof(f64)),.weight_heights = __new_array(0, 0, sizeof(f64)),},
		.id = c.id,
		.offset_x = 0,
		.offset_y = 0,
		.x = 0,
		.y = 0,
		.width = c.width,
		.height = c.height,
		.z_index = 0,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.ui = 0,
		.vertical_alignment = c.vertical_alignment,
		.horizontal_alignment = c.horizontal_alignment,
		.spacings = c.spacings,
		.stretch = c.stretch,
		.direction = c.direction,
		.margins = c.margins,
		.real_x = -1,
		.real_y = -1,
		.real_width = 0,
		.real_height = 0,
		.adj_width = 0,
		.adj_height = 0,
		.fixed_width = 0,
		.fixed_height = 0,
		.title = c.title,
		.children = c.children,
		.drawing_children = __new_array(0, 0, sizeof(ui__Widget)),
		.widths = c.widths,
		.heights = c.heights,
		.vertical_alignments = c.vertical_alignments,
		.horizontal_alignments = c.horizontal_alignments,
		.alignments = c.align,
		.hidden = 0,
		.bg_color = c.bg_color,
		.bg_radius = c.bg_radius,
		.is_root_layout = true,
		.component = 0,
		.component_init = 0,
		.has_scrollview = 0,
		.scrollview = 0,
		.on_scroll_change = ((ui__ScrollViewChangedFn)(0)),
		.debug_ids = __new_array(0, 0, sizeof(string)),
	}, sizeof(ui__Stack)));
	if (c.width > 0) {
		s->fixed_width = c.width;
	}
	if (c.height > 0) {
		s->fixed_height = c.height;
	}
	if (c.scrollview) {
		ui__scrollview_add_T_ui__Stack(s);
	}
	ui__Stack* _t1 = s;
	return _t1;
}

void ui__Stack_init(ui__Stack* s, ui__Layout parent) {
	s->parent = parent;
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	s->ui = ui;
	ui__Stack_init_size(s);
	for (int _t1 = 0; _t1 < s->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)s->children.data) + _t1;
		ui__Widget_name_table[child->_typ]._method_init(child->_object, /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(s));
	}
	if (s->component_init != (voidptr)((ui__ComponentInitFn)(0))) {
		s->component_init(s);
	}
	if ((parent)._typ == _ui__Layout_ui__Window_index) {
		ui->window = (parent._ui__Window);
		ui__Window* window = (parent._ui__Window);
		if (s->is_root_layout) {
			window->root_layout = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(s);
			ui__Window_update_layout(window);
		} else {
			ui__Stack_update_layout(s);
		}
	} else {
		s->is_root_layout = false;
	}
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__Stack_to_Interface_ui__ScrollableWidget(s))) {
		ui__ScrollView_init(s->scrollview, parent);
		ui__EventMngr_add_receiver(&s->ui->window->evt_mngr, /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget(s), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(_const_ui__events.on_scroll)})));
	} else {
		ui__scrollview_delegate_parent_scrollview_T_ui__Stack(s);
	}
}

// Attr: [manualfree]
void ui__Stack_cleanup(ui__Stack* s) {
	for (int _t1 = 0; _t1 < s->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)s->children.data) + _t1;
		ui__Widget_name_table[child->_typ]._method_cleanup(child->_object);
	}
	{ // Unsafe block
		if (s->has_scrollview) {
			ui__ScrollView_cleanup(s->scrollview);
		}
		ui__Stack_free(s);
	}
}

// Attr: [unsafe]
void ui__Stack_free(ui__Stack* s) {
	{ // Unsafe block
		string_free(&s->id);
		array_free(&s->spacings);
		string_free(&s->title);
		array_free(&s->children);
		array_free(&s->drawing_children);
		array_free(&s->widths);
		array_free(&s->heights);
		_v_free(s);
	}
}

void ui__Stack_update_layout(ui__Stack* s) {
	ui__Stack_set_adjusted_size(s, 0, true, s->ui);
	ui__Stack_set_cache_sizes(s);
	ui__Stack_set_children_sizes(s);
	ui__Stack_update_pos(s);
	ui__Stack_set_drawing_children(s);
	ui__Stack_set_children_pos(s);
	ui__scrollview_widget_set_orig_xy(/*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget(s));
	if (s->is_root_layout) {
		ui__Window* window = s->ui->window;
		bool to_resize = (window->mode == ui__WindowSizeType__fullscreen || window->mode == ui__WindowSizeType__max_size || window->mode == ui__WindowSizeType__resizable);
		if (to_resize) {
			ui__Stack_resize(s, window->width, window->height);
		}
	}
}

void ui__Stack_update_layout_without_pos(ui__Stack* s) {
	ui__Stack_set_adjusted_size(s, 0, true, s->ui);
	ui__Stack_set_cache_sizes(s);
	ui__Stack_set_children_sizes(s);
	ui__Stack_set_drawing_children(s);
	ui__Stack_set_children_pos(s);
}

void ui__Stack_init_size(ui__Stack* s) {
	ui__Layout parent = s->parent;
	multi_return_int_int mr_7467 = ui__Layout_name_table[parent._typ]._method_size(parent._object);
	int parent_width = mr_7467.arg0;
	int parent_height = mr_7467.arg1;
	if (s->is_root_layout) {
		if ((s->parent)._typ == _ui__Layout_ui__SubWindow_index) {
			multi_return_int_int mr_7786 = ui__Stack_adj_size(s);
			s->real_width = mr_7786.arg0;
			s->real_height = mr_7786.arg1;
		} else {
			s->real_height = parent_height;
			s->real_width = parent_width;
		}
	}
	ui__scrollview_update_T_ui__Stack(s);
	s->height = s->real_height - ui__Stack_margin(s, ui__Side__top) - ui__Stack_margin(s, ui__Side__bottom);
	s->width = s->real_width - ui__Stack_margin(s, ui__Side__left) - ui__Stack_margin(s, ui__Side__right);
}

void ui__Stack_set_children_sizes(ui__Stack* s) {
	ui__CachedSizes* c = &s->cache;
	multi_return_Array_int_Array_int mr_8141 = ui__Stack_children_sizes(s);
	Array_int widths = mr_8141.arg0;
	Array_int heights = mr_8141.arg1;
	for (int i = 0; i < s->children.len; ++i) {
		ui__Widget* child = ((ui__Widget*)s->children.data) + i;
		multi_return_int_int mr_8290 = ui__Widget_name_table[child->_typ]._method_size(child->_object);
		int w = mr_8290.arg0;
		int h = mr_8290.arg1;
		if ((child)->_typ == _ui__Widget_ui__Stack_index || (child)->_typ == _ui__Widget_ui__Group_index || (child)->_typ == _ui__Widget_ui__CanvasLayout_index) {
			w = (*(int*)/*ee elem_sym */array_get(widths, i));
			h = (*(int*)/*ee elem_sym */array_get(heights, i));
		} else {
			if ((*(ui__ChildSize*)/*ee elem_sym */array_get(c->width_type, i)) == ui__ChildSize__fixed || (*(ui__ChildSize*)/*ee elem_sym */array_get(c->width_type, i)) == ui__ChildSize__stretch || (*(ui__ChildSize*)/*ee elem_sym */array_get(c->width_type, i)) == ui__ChildSize__weighted) {
				w = (*(int*)/*ee elem_sym */array_get(widths, i));
			}
			if ((*(ui__ChildSize*)/*ee elem_sym */array_get(c->height_type, i)) == ui__ChildSize__fixed || (*(ui__ChildSize*)/*ee elem_sym */array_get(c->height_type, i)) == ui__ChildSize__stretch || (*(ui__ChildSize*)/*ee elem_sym */array_get(c->height_type, i)) == ui__ChildSize__weighted) {
				h = (*(int*)/*ee elem_sym */array_get(heights, i));
			}
		}
		ui__Widget_name_table[child->_typ]._method_propose_size(child->_object, w, h);
		if ((child)->_typ == _ui__Widget_ui__Stack_index) {
			ui__Stack_set_children_sizes((child->_ui__Stack));
		}
	}
}

multi_return_Array_int_Array_int ui__Stack_children_sizes(ui__Stack* s) {
	Array_int mcw = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(int), _MOV((int[1]){0})), s->children.len, 0);
	Array_int mch = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(int), _MOV((int[1]){0})), s->children.len, 0);
	multi_return_int_int mr_9252 = ui__Stack_free_size(s);
	int free_width = mr_9252.arg0;
	int free_height = mr_9252.arg1;
	ui__CachedSizes* c = &s->cache;
	for (int i = 0; i < s->children.len; ++i) {
		ui__Widget child = ((ui__Widget*)s->children.data)[i];
		ui__ChildSize _t1 = (*(ui__ChildSize*)/*ee elem_sym */array_get(c->width_type, i));
		
		if (_t1 == (ui__ChildSize__weighted)) {
			f64 weight = (*(f64*)/*ee elem_sym */array_get(c->weight_widths, i));
			if ((*(child.z_index)) == _const_ui__z_index_hidden) {
				weight = 0;
			}
			array_set(&mcw, i, &(int[]) { ((int)(weight * ((f32)(s->real_width)))) });
			if (s->direction == ui__Direction__row) {
				free_width -= (*(int*)/*ee elem_sym */array_get(mcw, i));
			}
		}
		else if (_t1 == (ui__ChildSize__compact) || _t1 == (ui__ChildSize__fixed)) {
			if ((*(child.z_index)) != _const_ui__z_index_hidden) {
				array_set(&mcw, i, &(int[]) { (*(int*)/*ee elem_sym */array_get(c->fixed_widths, i)) });
			}
			if (s->direction == ui__Direction__row) {
				free_width -= (*(int*)/*ee elem_sym */array_get(mcw, i));
			}
		}
		else {
		};
		ui__ChildSize _t2 = (*(ui__ChildSize*)/*ee elem_sym */array_get(c->height_type, i));
		
		if (_t2 == (ui__ChildSize__weighted)) {
			f64 weight = (*(f64*)/*ee elem_sym */array_get(c->weight_heights, i));
			if ((*(child.z_index)) == _const_ui__z_index_hidden) {
				weight = 0;
			}
			array_set(&mch, i, &(int[]) { ((int)(weight * ((f32)(s->real_height)))) });
			if (s->direction == ui__Direction__column) {
				free_height -= (*(int*)/*ee elem_sym */array_get(mch, i));
			}
		}
		else if (_t2 == (ui__ChildSize__compact) || _t2 == (ui__ChildSize__fixed)) {
			if ((*(child.z_index)) != _const_ui__z_index_hidden) {
				array_set(&mch, i, &(int[]) { (*(int*)/*ee elem_sym */array_get(c->fixed_heights, i)) });
			}
			if (s->direction == ui__Direction__column) {
				free_height -= (*(int*)/*ee elem_sym */array_get(mch, i));
			}
		}
		else {
		};
	}
	for (int i = 0; i < s->children.len; ++i) {
		ui__Widget child = ((ui__Widget*)s->children.data)[i];
		ui__ChildSize _t3 = (*(ui__ChildSize*)/*ee elem_sym */array_get(c->width_type, i));
		
		if (_t3 == (ui__ChildSize__stretch)) {
			if (s->direction == ui__Direction__row) {
				f64 weight = (*(f64*)/*ee elem_sym */array_get(c->weight_widths, i)) / c->width_mass;
				array_set(&mcw, i, &(int[]) { ((int)(weight * ((f32)(free_width)))) });
			} else {
				array_set(&mcw, i, &(int[]) { free_width });
			}
		}
		else if (_t3 == (ui__ChildSize__weighted)) {
		}
		else if (_t3 == (ui__ChildSize__compact) || _t3 == (ui__ChildSize__fixed)) {
		}
		else if (_t3 == (ui__ChildSize__weighted_stretch)) {
			f64 weight = (*(f64*)/*ee elem_sym */array_get(c->weight_widths, i)) / c->width_mass;
			array_set(&mcw, i, &(int[]) { ((int)(weight * free_width)) });
		};
		ui__ChildSize _t4 = (*(ui__ChildSize*)/*ee elem_sym */array_get(c->height_type, i));
		
		if (_t4 == (ui__ChildSize__stretch)) {
			if (s->direction == ui__Direction__column) {
				f64 weight = (*(f64*)/*ee elem_sym */array_get(c->weight_heights, i)) / c->height_mass;
				array_set(&mch, i, &(int[]) { ((int)(weight * ((f32)(free_height)))) });
				#if defined(CUSTOM_DEFINE_cs)
				{
				}
				#else
				{
				}
				#endif
			} else {
				array_set(&mch, i, &(int[]) { free_height });
			}
		}
		else if (_t4 == (ui__ChildSize__weighted)) {
		}
		else if (_t4 == (ui__ChildSize__compact) || _t4 == (ui__ChildSize__fixed)) {
		}
		else if (_t4 == (ui__ChildSize__weighted_stretch)) {
			f64 weight = (*(f64*)/*ee elem_sym */array_get(c->weight_heights, i)) / c->height_mass;
			array_set(&mch, i, &(int[]) { ((int)(weight * ((f32)(free_height)))) });
		};
	}
	return (multi_return_Array_int_Array_int){.arg0=mcw, .arg1=mch};
}

void ui__Stack_set_cache_sizes(ui__Stack* s) {
	ui__Stack_default_sizes(s);
	int len = s->children.len;
	ui__CachedSizes* c = &s->cache;
	c->fixed_width = 0;
	c->fixed_height = 0;
	c->min_width = 0;
	c->min_height = 0;
	c->width_mass = 0.0;
	c->height_mass = 0.0;
	c->adj_widths = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(int), _MOV((int[1]){0})), len, 0);
	c->adj_heights = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(int), _MOV((int[1]){0})), len, 0);
	c->fixed_widths = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(int), _MOV((int[1]){0})), len, 0);
	c->fixed_heights = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(int), _MOV((int[1]){0})), len, 0);
	c->weight_widths = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(f64), _MOV((f64[1]){0.0})), len, 0);
	c->weight_heights = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(f64), _MOV((f64[1]){0.0})), len, 0);
	c->width_type = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(ui__ChildSize), _MOV((ui__ChildSize[1]){((ui__ChildSize)(0))})), len, 0);
	c->height_type = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(ui__ChildSize), _MOV((ui__ChildSize[1]){((ui__ChildSize)(0))})), len, 0);
	for (int i = 0; i < s->children.len; ++i) {
		ui__Widget* child = ((ui__Widget*)s->children.data) + i;
		f32* _t2 = (f32*)/*ee elem_ptr_typ */(array_get_with_check(s->widths, i));
		Option_f32 _t1 = {0};
		if (_t2) {
			*((f32*)&_t1.data) = *((f32*)_t2);
		} else {
			_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t1.state != 0) { /*or block*/ 
			IError err = _t1.err;
			*(f32*) _t1.data = 0.0;
		}
		
		f32 cw = *(f32*)_t1.data;
		f32* _t4 = (f32*)/*ee elem_ptr_typ */(array_get_with_check(s->heights, i));
		Option_f32 _t3 = {0};
		if (_t4) {
			*((f32*)&_t3.data) = *((f32*)_t4);
		} else {
			_t3.state = 2; _t3.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t3.state != 0) { /*or block*/ 
			IError err = _t3.err;
			*(f32*) _t3.data = 0.0;
		}
		
		f32 ch = *(f32*)_t3.data;
		multi_return_int_int mr_13942 = ui__Widget_name_table[child->_typ]._method_size(child->_object);
		int adj_child_width = mr_13942.arg0;
		int adj_child_height = mr_13942.arg1;
		if ((child)->_typ == _ui__Widget_ui__Stack_index) {
			multi_return_int_int mr_14022 = ui__Stack_adj_size((child->_ui__Stack));
			adj_child_width = mr_14022.arg0;
			adj_child_height = mr_14022.arg1;
		}
		if ((child)->_typ == _ui__Widget_ui__Group_index) {
			multi_return_int_int mr_14109 = ui__Group_adj_size((child->_ui__Group));
			adj_child_width = mr_14109.arg0;
			adj_child_height = mr_14109.arg1;
		}
		if (adj_child_width == 0 && cw == _const_ui__compact) {
			if ((child)->_typ != _ui__Widget_ui__Stack_index) {
				(*(f32*)/*ee elem_sym */array_get(s->widths, i)) = _const_ui__stretch;
				cw = _const_ui__stretch;
			}
		}
		if (adj_child_height == 0 && ch == _const_ui__compact) {
			if ((child)->_typ != _ui__Widget_ui__Stack_index) {
				(*(f32*)/*ee elem_sym */array_get(s->heights, i)) = _const_ui__stretch;
				ch = _const_ui__stretch;
			}
		}
		if (cw > 1) {
			(*(ui__ChildSize*)/*ee elem_sym */array_get(c->width_type, i)) = ui__ChildSize__fixed;
			(*(int*)/*ee elem_sym */array_get(c->fixed_widths, i)) = ((int)(cw));
			if (s->direction == ui__Direction__row) {
				c->fixed_width += (*(int*)/*ee elem_sym */array_get(c->fixed_widths, i));
				c->min_width += (*(int*)/*ee elem_sym */array_get(c->fixed_widths, i));
			} else {
				if ((*(int*)/*ee elem_sym */array_get(c->fixed_widths, i)) > c->fixed_width) {
					c->fixed_width = (*(int*)/*ee elem_sym */array_get(c->fixed_widths, i));
				}
				if ((*(int*)/*ee elem_sym */array_get(c->fixed_widths, i)) > c->min_width) {
					c->min_width = (*(int*)/*ee elem_sym */array_get(c->fixed_widths, i));
				}
			}
		} else if (cw > 0) {
			(*(ui__ChildSize*)/*ee elem_sym */array_get(c->width_type, i)) = ui__ChildSize__weighted;
			(*(f64*)/*ee elem_sym */array_get(c->weight_widths, i)) = cw;
			(*(int*)/*ee elem_sym */array_get(c->fixed_widths, i)) = adj_child_width;
			if (s->direction == ui__Direction__row) {
				c->min_width += (*(int*)/*ee elem_sym */array_get(c->fixed_widths, i));
			} else {
				if ((*(int*)/*ee elem_sym */array_get(c->fixed_widths, i)) > c->min_width) {
					c->min_width = (*(int*)/*ee elem_sym */array_get(c->fixed_widths, i));
				}
			}
		} else if (cw == 0) {
			(*(ui__ChildSize*)/*ee elem_sym */array_get(c->width_type, i)) = ui__ChildSize__compact;
			(*(int*)/*ee elem_sym */array_get(c->fixed_widths, i)) = adj_child_width;
			if (s->direction == ui__Direction__row) {
				c->fixed_width += (*(int*)/*ee elem_sym */array_get(c->fixed_widths, i));
				c->min_width += (*(int*)/*ee elem_sym */array_get(c->fixed_widths, i));
			} else {
				if ((*(int*)/*ee elem_sym */array_get(c->fixed_widths, i)) > c->fixed_width) {
					c->fixed_width = (*(int*)/*ee elem_sym */array_get(c->fixed_widths, i));
				}
				if ((*(int*)/*ee elem_sym */array_get(c->fixed_widths, i)) > c->min_width) {
					c->min_width = (*(int*)/*ee elem_sym */array_get(c->fixed_widths, i));
				}
			}
		} else if (cw >= -1) {
			(*(ui__ChildSize*)/*ee elem_sym */array_get(c->width_type, i)) = ui__ChildSize__weighted_stretch;
			(*(f64*)/*ee elem_sym */array_get(c->weight_widths, i)) = -cw;
			(*(int*)/*ee elem_sym */array_get(c->fixed_widths, i)) = adj_child_width;
			if (s->direction == ui__Direction__row) {
				c->width_mass += (*(f64*)/*ee elem_sym */array_get(c->weight_widths, i));
				c->min_width += (*(int*)/*ee elem_sym */array_get(c->fixed_widths, i));
			} else {
				if ((*(int*)/*ee elem_sym */array_get(c->fixed_widths, i)) > c->min_width) {
					c->min_width = (*(int*)/*ee elem_sym */array_get(c->fixed_widths, i));
				}
			}
		} else {
			(*(ui__ChildSize*)/*ee elem_sym */array_get(c->width_type, i)) = ui__ChildSize__stretch;
			if ((*(child->z_index)) == _const_ui__z_index_hidden) {
				cw = 0;
			}
			(*(f64*)/*ee elem_sym */array_get(c->weight_widths, i)) = cw / _const_ui__stretch;
			(*(int*)/*ee elem_sym */array_get(c->fixed_widths, i)) = adj_child_width;
			if (s->direction == ui__Direction__row) {
				c->width_mass += (*(f64*)/*ee elem_sym */array_get(c->weight_widths, i));
				c->min_width += (*(int*)/*ee elem_sym */array_get(c->fixed_widths, i));
			} else {
				if ((*(int*)/*ee elem_sym */array_get(c->fixed_widths, i)) > c->min_width) {
					c->min_width = (*(int*)/*ee elem_sym */array_get(c->fixed_widths, i));
				}
			}
		}
		if (ch > 1) {
			(*(ui__ChildSize*)/*ee elem_sym */array_get(c->height_type, i)) = ui__ChildSize__fixed;
			(*(int*)/*ee elem_sym */array_get(c->fixed_heights, i)) = ((int)(ch));
			if (s->direction == ui__Direction__column) {
				c->fixed_height += (*(int*)/*ee elem_sym */array_get(c->fixed_heights, i));
				c->min_height += (*(int*)/*ee elem_sym */array_get(c->fixed_heights, i));
			} else {
				if ((*(int*)/*ee elem_sym */array_get(c->fixed_heights, i)) > c->fixed_height) {
					c->fixed_height = (*(int*)/*ee elem_sym */array_get(c->fixed_heights, i));
				}
				if ((*(int*)/*ee elem_sym */array_get(c->fixed_heights, i)) > c->min_height) {
					c->min_height = (*(int*)/*ee elem_sym */array_get(c->fixed_heights, i));
				}
			}
		} else if (ch > 0) {
			(*(ui__ChildSize*)/*ee elem_sym */array_get(c->height_type, i)) = ui__ChildSize__weighted;
			(*(f64*)/*ee elem_sym */array_get(c->weight_heights, i)) = ch;
			(*(int*)/*ee elem_sym */array_get(c->fixed_heights, i)) = adj_child_height;
			if (s->direction == ui__Direction__column) {
				c->min_height += (*(int*)/*ee elem_sym */array_get(c->fixed_heights, i));
			} else {
				if ((*(int*)/*ee elem_sym */array_get(c->fixed_heights, i)) > c->min_height) {
					c->min_height = (*(int*)/*ee elem_sym */array_get(c->fixed_heights, i));
				}
			}
		} else if (ch == 0) {
			(*(ui__ChildSize*)/*ee elem_sym */array_get(c->height_type, i)) = ui__ChildSize__compact;
			(*(int*)/*ee elem_sym */array_get(c->fixed_heights, i)) = adj_child_height;
			if (s->direction == ui__Direction__column) {
				c->fixed_height += (*(int*)/*ee elem_sym */array_get(c->fixed_heights, i));
				c->min_height += (*(int*)/*ee elem_sym */array_get(c->fixed_heights, i));
			} else {
				if ((*(int*)/*ee elem_sym */array_get(c->fixed_heights, i)) > c->fixed_height) {
					c->fixed_height = (*(int*)/*ee elem_sym */array_get(c->fixed_heights, i));
				}
				if ((*(int*)/*ee elem_sym */array_get(c->fixed_heights, i)) > c->min_height) {
					c->min_height = (*(int*)/*ee elem_sym */array_get(c->fixed_heights, i));
				}
			}
		} else if (ch >= -1) {
			(*(ui__ChildSize*)/*ee elem_sym */array_get(c->height_type, i)) = ui__ChildSize__weighted_stretch;
			(*(f64*)/*ee elem_sym */array_get(c->weight_heights, i)) = -cw;
			(*(int*)/*ee elem_sym */array_get(c->fixed_heights, i)) = adj_child_height;
			if (s->direction == ui__Direction__column) {
				c->height_mass += (*(f64*)/*ee elem_sym */array_get(c->weight_heights, i));
				c->min_height += (*(int*)/*ee elem_sym */array_get(c->fixed_heights, i));
			} else {
				if ((*(int*)/*ee elem_sym */array_get(c->fixed_heights, i)) > c->min_height) {
					c->min_height = (*(int*)/*ee elem_sym */array_get(c->fixed_heights, i));
				}
			}
		} else {
			(*(ui__ChildSize*)/*ee elem_sym */array_get(c->height_type, i)) = ui__ChildSize__stretch;
			if ((*(child->z_index)) == _const_ui__z_index_hidden) {
				ch = 0;
			}
			(*(f64*)/*ee elem_sym */array_get(c->weight_heights, i)) = ch / _const_ui__stretch;
			(*(int*)/*ee elem_sym */array_get(c->fixed_heights, i)) = adj_child_height;
			if (s->direction == ui__Direction__column) {
				c->height_mass += (*(f64*)/*ee elem_sym */array_get(c->weight_heights, i));
				c->min_height += (*(int*)/*ee elem_sym */array_get(c->fixed_heights, i));
			} else {
				if ((*(int*)/*ee elem_sym */array_get(c->fixed_heights, i)) > c->min_height) {
					c->min_height = (*(int*)/*ee elem_sym */array_get(c->fixed_heights, i));
				}
			}
		}
		if ((child)->_typ == _ui__Widget_ui__Stack_index) {
			ui__Stack_set_cache_sizes((child->_ui__Stack));
		}
	}
}

void ui__Stack_default_sizes(ui__Stack* s) {
	f32 st = ((f32)(_const_ui__stretch));
	f32 p_equi = ((f32)(1)) / ((f32)(s->children.len));
	if (s->direction == ui__Direction__row) {
		int nb = s->heights.len;
		if (nb < s->children.len) {
			for (int i = 0; i < s->children.len; ++i) {
				if (i < nb) {
					continue;
				}
				array_push((array*)&s->heights, _MOV((f32[]){ st }));
			}
		}
		nb = s->widths.len;
		if (nb < s->children.len) {
			for (int i = 0; i < s->children.len; ++i) {
				if (i < nb) {
					continue;
				}
				f32 p = (ui__is_children_have_widget(s->children) ? (_const_ui__compact) : (p_equi));
				array_push((array*)&s->widths, _MOV((f32[]){ p }));
			}
		}
	} else {
		int nb = s->widths.len;
		if (nb < s->children.len) {
			for (int i = 0; i < s->children.len; ++i) {
				if (i < nb) {
					continue;
				}
				array_push((array*)&s->widths, _MOV((f32[]){ st }));
			}
		}
		nb = s->heights.len;
		if (nb < s->children.len) {
			for (int i = 0; i < s->children.len; ++i) {
				if (i < nb) {
					continue;
				}
				f32 p = (ui__is_children_have_widget(s->children) ? (_const_ui__compact) : (p_equi));
				array_push((array*)&s->heights, _MOV((f32[]){ p }));
			}
		}
	}
}

multi_return_int_int ui__Stack_adj_size(ui__Stack* s) {
	return (multi_return_int_int){.arg0=(s->fixed_width != 0 ? (s->fixed_width) : (s->adj_width)), .arg1=(s->fixed_height != 0 ? (s->fixed_height) : (s->adj_height))};
}

multi_return_int_int ui__Stack_propose_size(ui__Stack* s, int w, int h) {
	s->real_width = w;
	s->real_height = h;
	s->width = w - ui__Stack_margin(s, ui__Side__left) - ui__Stack_margin(s, ui__Side__right);
	s->height = h - ui__Stack_margin(s, ui__Side__top) - ui__Stack_margin(s, ui__Side__bottom);
	ui__scrollview_update_T_ui__Stack(s);
	return (multi_return_int_int){.arg0=s->real_width, .arg1=s->real_height};
}

multi_return_int_int ui__Stack_size(ui__Stack* s) {
	return (multi_return_int_int){.arg0=s->real_width, .arg1=s->real_height};
}

multi_return_int_int ui__Stack_free_size(ui__Stack* s) {
	int w = s->real_width - ui__Stack_margin(s, ui__Side__left) - ui__Stack_margin(s, ui__Side__right);
	int h = s->real_height - ui__Stack_margin(s, ui__Side__top) - ui__Stack_margin(s, ui__Side__bottom);
	if (s->direction == ui__Direction__row) {
		w -= ui__Stack_total_spacing(s);
	} else {
		h -= ui__Stack_total_spacing(s);
	}
	return (multi_return_int_int){.arg0=w, .arg1=h};
}

void ui__Stack_set_adjusted_size(ui__Stack* s, int i, bool force, ui__UI* gui) {
	int h = 0;
	int w = 0;
	for (int _t1 = 0; _t1 < s->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)s->children.data) + _t1;
		if ((*(child->z_index)) > _const_ui__z_index_hidden) {
			int child_width = 0;
			int child_height = 0;
			if ((child)->_typ == _ui__Widget_ui__Stack_index) {
				if (force || (child->_ui__Stack)->adj_width == 0) {
					ui__Stack_set_adjusted_size((child->_ui__Stack), i + 1, force, gui);
				}
				child_width = (child->_ui__Stack)->adj_width + ui__Stack_margin((child->_ui__Stack), ui__Side__left) + ui__Stack_margin((child->_ui__Stack), ui__Side__right);
				child_height = (child->_ui__Stack)->adj_height + ui__Stack_margin((child->_ui__Stack), ui__Side__top) + ui__Stack_margin((child->_ui__Stack), ui__Side__bottom);
				#if defined(CUSTOM_DEFINE_adj_size)
				{
				}
				#else
				{
				}
				#endif
			} else if ((child)->_typ == _ui__Widget_ui__Group_index) {
				if (force || (child->_ui__Group)->adj_width == 0) {
					ui__Group_set_adjusted_size((child->_ui__Group), i + 1, gui);
				}
				child_width = (child->_ui__Group)->adj_width + (child->_ui__Group)->margin_left + (child->_ui__Group)->margin_right;
				child_height = (child->_ui__Group)->adj_height + (child->_ui__Group)->margin_top + (child->_ui__Group)->margin_bottom;
				#if defined(CUSTOM_DEFINE_adj_size)
				{
				}
				#else
				{
				}
				#endif
			} else if ((child)->_typ == _ui__Widget_ui__CanvasLayout_index) {
				if (force || (child->_ui__CanvasLayout)->adj_width == 0) {
					ui__CanvasLayout_set_adjusted_size((child->_ui__CanvasLayout), gui);
				}
				child_width = (child->_ui__CanvasLayout)->adj_width;
				child_height = (child->_ui__CanvasLayout)->adj_height;
				#if defined(CUSTOM_DEFINE_adj_size)
				{
				}
				#else
				{
				}
				#endif
			} else {
				multi_return_int_int mr_24551 = ui__Widget_name_table[child->_typ]._method_size(child->_object);
				child_width = mr_24551.arg0;
				child_height = mr_24551.arg1;
			}
			if (s->direction == ui__Direction__column) {
				h += child_height;
				if (child_width > w) {
					w = child_width;
				}
			} else {
				w += child_width;
				if (child_height > h) {
					h = child_height;
				}
			}
		}
	}
	if (s->direction == ui__Direction__column) {
		h += ui__Stack_total_spacing(s);
	} else {
		w += ui__Stack_total_spacing(s);
	}
	s->adj_width = w;
	s->adj_height = h;
}

void ui__Stack_update_pos(ui__Stack* s) {
	s->x = s->real_x + ui__Stack_margin(s, ui__Side__left);
	s->y = s->real_y + ui__Stack_margin(s, ui__Side__top);
}

void ui__Stack_set_pos(ui__Stack* s, int x, int y) {
	if (s->real_x != x || s->real_y != y) {
		s->real_x = x;
		s->real_y = y;
	}
	ui__Stack_update_pos(s);
}

void ui__Stack_set_children_pos(ui__Stack* s) {
	int x = s->x;
	int y = s->y;
	Array_ui__Widget _t1 = {0};
	Array_ui__Widget _t1_orig = s->children;
	int _t1_len = _t1_orig.len;
	_t1 = __new_array(0, _t1_len, sizeof(ui__Widget));

	for (int _t2 = 0; _t2 < _t1_len; ++_t2) {
		ui__Widget it = ((ui__Widget*) _t1_orig.data)[_t2];
		if ((*(it.z_index)) > _const_ui__z_index_hidden) {
			array_push((array*)&_t1, &it);
		}
	}
	Array_ui__Widget children =_t1;
	for (int i = 0; i < children.len; ++i) {
		ui__Widget* child = ((ui__Widget*)children.data) + i;
		multi_return_int_int mr_26559 = ui__Widget_name_table[child->_typ]._method_size(child->_object);
		int child_width = mr_26559.arg0;
		int child_height = mr_26559.arg1;
		ui__Stack_set_child_pos(s, child, i, x, y);
		if (s->direction == ui__Direction__row) {
			x += child_width;
			if (i < s->children.len - 1) {
				x += ui__Stack_spacing(s, i);
			}
		} else {
			y += child_height;
			if (i < s->children.len - 1) {
				y += ui__Stack_spacing(s, i);
			}
		}
		if ((child)->_typ == _ui__Widget_ui__Stack_index) {
			ui__Stack_set_children_pos((child->_ui__Stack));
		} else if ((child)->_typ == _ui__Widget_ui__CanvasLayout_index) {
			ui__CanvasLayout_set_children_pos((child->_ui__CanvasLayout));
		}
	}
}

void ui__Stack_set_child_pos(ui__Stack* s, ui__Widget* child, int i, int x, int y) {
	multi_return_int_int mr_27623 = ui__Widget_name_table[child->_typ]._method_size(child->_object);
	int child_width = mr_27623.arg0;
	int child_height = mr_27623.arg1;
	if (s->direction == ui__Direction__column) {
		int container_width = s->width;
		int x_offset = 0;
		ui__HorizontalAlignment _t1 = ui__Stack_get_horizontal_alignment(s, i);
		
		if (_t1 == (ui__HorizontalAlignment__left)) {
			x_offset = 0;
		}
		else if (_t1 == (ui__HorizontalAlignment__center)) {
			if (container_width > child_width) {
				x_offset = (container_width - child_width) / 2;
			} else {
				x_offset = 0;
			}
		}
		else if (_t1 == (ui__HorizontalAlignment__right)) {
			if (container_width > child_width) {
				x_offset = (container_width - child_width);
			} else {
				x_offset = 0;
			}
		};
		ui__Widget_name_table[child->_typ]._method_set_pos(child->_object, x + x_offset, y);
	} else {
		int container_height = s->height;
		int y_offset = 0;
		ui__VerticalAlignment _t2 = ui__Stack_get_vertical_alignment(s, i);
		
		if (_t2 == (ui__VerticalAlignment__top)) {
			y_offset = 0;
		}
		else if (_t2 == (ui__VerticalAlignment__center)) {
			if (container_height > child_height) {
				y_offset = (container_height - child_height) / 2;
			} else {
				y_offset = 0;
			}
		}
		else if (_t2 == (ui__VerticalAlignment__bottom)) {
			if (container_height > child_height) {
				y_offset = container_height - child_height;
			} else {
				y_offset = 0;
			}
		};
		ui__Widget_name_table[child->_typ]._method_set_pos(child->_object, x, y + y_offset);
	}
}

eventbus__Subscriber* ui__Stack_get_subscriber(ui__Stack* s) {
	ui__Layout parent = s->parent;
	eventbus__Subscriber* _t1 = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	return _t1;
}

void ui__Stack_set_children_visible(ui__Stack* s, bool state, Array_int children) {
	for (int i = 0; i < s->children.len; ++i) {
		ui__Widget* child = ((ui__Widget*)s->children.data) + i;
		if (Array_int_contains(children, i)) {
			ui__Widget_name_table[child->_typ]._method_set_visible(child->_object, state);
		}
	}
	ui__Stack_set_drawing_children(s);
}

void ui__Stack_set_children_depth(ui__Stack* s, int z_index, Array_int children) {
	for (int i = 0; i < s->children.len; ++i) {
		ui__Widget* child = ((ui__Widget*)s->children.data) + i;
		if (Array_int_contains(children, i)) {
			(*(child->z_index)) = z_index;
		}
	}
	ui__Stack_set_drawing_children(s);
}

void ui__Stack_set_drawing_children(ui__Stack* s) {
	for (int _t1 = 0; _t1 < s->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)s->children.data) + _t1;
		if ((child)->_typ == _ui__Widget_ui__Stack_index) {
			if ((child->_ui__Stack)->z_index > _const_ui__z_index_hidden) {
				ui__Stack_set_drawing_children((child->_ui__Stack));
			}
		} else if ((child)->_typ == _ui__Widget_ui__CanvasLayout_index) {
			if ((child->_ui__CanvasLayout)->z_index > _const_ui__z_index_hidden) {
				ui__CanvasLayout_set_drawing_children((child->_ui__CanvasLayout));
			}
		}
		if ((*(child->z_index)) > s->z_index) {
			s->z_index = (*(child->z_index)) - 1;
		}
	}
	Array_ui__Widget _t2 = {0};
	Array_ui__Widget _t2_orig = s->children;
	int _t2_len = _t2_orig.len;
	_t2 = __new_array(0, _t2_len, sizeof(ui__Widget));

	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		ui__Widget it = ((ui__Widget*) _t2_orig.data)[_t3];
		if (!(*(it.hidden)) && (*(it.z_index)) > _const_ui__z_index_hidden) {
			array_push((array*)&_t2, &it);
		}
	}
	s->drawing_children =_t2;
	ui__Stack_sorted_drawing_children(s);
}

void ui__Stack_draw(ui__Stack* s) {
	if (s->hidden) {
		return;
	}
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget(s)));
	if (!gx__Color_struct_eq(s->bg_color, _const_ui__no_color)) {
		if (s->bg_radius > 0) {
			f32 radius = ui__relative_size(s->bg_radius, s->real_width, s->real_height);
			gg__Context_draw_rounded_rect_filled(s->ui->gg, s->real_x, s->real_y, s->real_width, s->real_height, radius, s->bg_color);
		} else {
			gg__Context_draw_rect_filled(s->ui->gg, s->real_x, s->real_y, s->real_width, s->real_height, s->bg_color);
		}
	}
	ui__scrollview_draw_begin_T_ui__Stack(s);
	if (ui__Layout_has_scrollview_or_parent_scrollview(/*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(s))) {
		for (int _t1 = 0; _t1 < s->drawing_children.len; ++_t1) {
			ui__Widget* child = ((ui__Widget*)s->drawing_children.data) + _t1;
			if (I_ui__Widget_is_I_ui__Layout(*child) || !ui__is_empty_intersection(s->scrollview->scissor_rect, ui__Widget_scaled_bounds(child))) {
				ui__Widget_name_table[child->_typ]._method_draw(child->_object);
			}
		}
	} else {
		for (int _t2 = 0; _t2 < s->drawing_children.len; ++_t2) {
			ui__Widget* child = ((ui__Widget*)s->drawing_children.data) + _t2;
			ui__Widget_name_table[child->_typ]._method_draw(child->_object);
		}
	}
	ui__scrollview_draw_end_T_ui__Stack(s);
	if ((s->title).len != 0) {
		multi_return_int_int mr_31193 = gg__Context_text_size(s->ui->gg, s->title);
		int text_width = mr_31193.arg0;
		int text_height = mr_31193.arg1;
		gg__Context_draw_rect_empty(s->ui->gg, s->x - text_height / 2, s->y - text_height / 2, s->real_width + text_height, s->real_height + ((int)(((f32)(text_height)) * .75)), _const_gx__black);
		int tx = s->x + s->real_width / 2 - text_width / 2 - 3;
		int ty = s->y - ((int)(((f32)(text_height)) * 1.25));
		gg__Context_draw_rect_filled(s->ui->gg, tx, ty, text_width + 5, text_height, _const_gx__white);
		gg__Context_draw_rect_empty(s->ui->gg, tx, ty, text_width + 5, text_height, _const_gx__black);
		gg__Context_draw_text_def(s->ui->gg, tx, ty - 2, s->title);
	}
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget(s)));
}

int ui__Stack_margin(ui__Stack* s, ui__Side side) {
	f32 size = ((side == (ui__Side__top)) ? (s->margins.top) : (side == (ui__Side__right)) ? (s->margins.right) : (side == (ui__Side__bottom)) ? (s->margins.bottom) : (s->margins.left));
	int isize = ((int)(size));
	if (0.0 < size && size < 1.0) {
		int psize = ((side == ui__Side__left || side == ui__Side__right) ? (s->real_width) : (s->real_height));
		isize = ((int)(size * ((f32)(psize))));
	}
	if ((s->title).len != 0) {
		int text_height = gg__Context_text_height(s->ui->gg, s->title);

		if (side == (ui__Side__top)) {
			isize += ((int)(((f32)(text_height)) * 1.25));
		}
		else if (side == (ui__Side__bottom)) {
			isize += ((int)(((f32)(text_height)) * 0.75));
		}
		else {
			isize += text_height / 2;
		};
	}
	int _t1 = isize;
	return _t1;
}

int ui__Stack_spacing(ui__Stack* s, int i) {
	f32 size = (*(f32*)/*ee elem_sym */array_get(s->spacings, i));
	int isize = ((int)(size));
	if (0.0 < size && size < 1.0) {
		int psize = (s->direction == ui__Direction__row ? (s->real_width) : (s->real_height));
		isize = ((int)(size * ((f32)(psize))));
	}
	int _t1 = isize;
	return _t1;
}

int ui__Stack_total_spacing(ui__Stack* s) {
	int total_spacing = 0;
	if (s->spacings.len > 0 && s->children.len > 1) {
		for (int i = 0; i < (s->children.len - 1); ++i) {
			total_spacing += ui__Stack_spacing(s, i);
		}
	}
	int _t1 = total_spacing;
	return _t1;
}

ui__UI* ui__Stack_get_ui(ui__Stack* s) {
	ui__UI* _t1 = s->ui;
	return _t1;
}

voidptr ui__Stack_get_state(ui__Stack* s) {
	ui__Layout parent = s->parent;
	voidptr _t1 = ui__Layout_name_table[parent._typ]._method_get_state(parent._object);
	return _t1;
}

bool ui__Stack_point_inside(ui__Stack* s, f64 x, f64 y) {
	bool _t1 = ui__point_inside_T_ui__Stack(s, x, y);
	return _t1;
}

void ui__Stack_set_visible(ui__Stack* s, bool state) {
	s->hidden = !state;
	for (int _t1 = 0; _t1 < s->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)s->children.data) + _t1;
		ui__Widget_name_table[child->_typ]._method_set_visible(child->_object, state);
	}
}

void ui__Stack_resize(ui__Stack* s, int width, int height) {
	ui__Stack_init_size(s);
	ui__Stack_update_pos(s);
	ui__Stack_set_children_sizes(s);
	ui__Stack_set_children_pos(s);
	ui__scrollview_widget_set_orig_xy(/*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget(s));
}

Array_ui__Widget ui__Stack_get_children(ui__Stack* s) {
	Array_ui__Widget _t1 = s->children;
	return _t1;
}

void ui__Stack_set_children(ui__Stack* s, Array_ui__Widget c) {
	s->children = c;
}

ui__VerticalAlignment ui__Stack_get_vertical_alignment(ui__Stack* s, int i) {
	ui__VerticalAlignment align = s->vertical_alignment;
	if (Array_int_contains(s->vertical_alignments.top, i)) {
		align = ui__VerticalAlignment__top;
	} else if (Array_int_contains(s->vertical_alignments.center, i)) {
		align = ui__VerticalAlignment__center;
	} else if (Array_int_contains(s->vertical_alignments.bottom, i)) {
		align = ui__VerticalAlignment__bottom;
	}
	ui__VerticalAlignment _t1 = align;
	return _t1;
}

ui__HorizontalAlignment ui__Stack_get_horizontal_alignment(ui__Stack* s, int i) {
	ui__HorizontalAlignment align = s->horizontal_alignment;
	if (Array_int_contains(s->horizontal_alignments.left, i)) {
		align = ui__HorizontalAlignment__left;
	} else if (Array_int_contains(s->horizontal_alignments.center, i)) {
		align = ui__HorizontalAlignment__center;
	} else if (Array_int_contains(s->horizontal_alignments.right, i)) {
		align = ui__HorizontalAlignment__right;
	}
	ui__HorizontalAlignment _t1 = align;
	return _t1;
}

void ui__Stack_set_child_pos_aligned(ui__Stack* s, ui__Widget* child, int i, int x, int y) {
	multi_return_int_int mr_34589 = ui__Widget_name_table[child->_typ]._method_size(child->_object);
	int child_width = mr_34589.arg0;
	int child_height = mr_34589.arg1;
	multi_return_ui__HorizontalAlignment_ui__VerticalAlignment mr_34647 = ui__Stack_get_alignments(s, i);
	ui__HorizontalAlignment horizontal_alignment = mr_34647.arg0;
	ui__VerticalAlignment vertical_alignment = mr_34647.arg1;
	int container_width = s->width;
	int x_offset = 0;

	if (horizontal_alignment == (ui__HorizontalAlignment__left)) {
		x_offset = 0;
	}
	else if (horizontal_alignment == (ui__HorizontalAlignment__center)) {
		if (container_width > child_width) {
			x_offset = (container_width - child_width) / 2;
		} else {
			x_offset = 0;
		}
	}
	else if (horizontal_alignment == (ui__HorizontalAlignment__right)) {
		if (container_width > child_width) {
			x_offset = (container_width - child_width);
		} else {
			x_offset = 0;
		}
	};
	int container_height = s->height;
	int y_offset = 0;

	if (vertical_alignment == (ui__VerticalAlignment__top)) {
		y_offset = 0;
	}
	else if (vertical_alignment == (ui__VerticalAlignment__center)) {
		if (container_height > child_height) {
			y_offset = (container_height - child_height) / 2;
		} else {
			y_offset = 0;
		}
	}
	else if (vertical_alignment == (ui__VerticalAlignment__bottom)) {
		if (container_height > child_height) {
			y_offset = container_height - child_height;
		} else {
			y_offset = 0;
		}
	};
	ui__Widget_name_table[child->_typ]._method_set_pos(child->_object, x + x_offset, y + y_offset);
}

multi_return_ui__HorizontalAlignment_ui__VerticalAlignment ui__Stack_get_alignments(ui__Stack* s, int i) {
	ui__HorizontalAlignment hor_align = s->horizontal_alignment;
	ui__VerticalAlignment ver_align = s->vertical_alignment;
	if (Array_int_contains(s->alignments.center, i)) {
		hor_align = ui__HorizontalAlignment__center;
		ver_align = ui__VerticalAlignment__center;
	} else if (Array_int_contains(s->alignments.left_top, i)) {
		hor_align = ui__HorizontalAlignment__left;
		ver_align = ui__VerticalAlignment__top;
	} else if (Array_int_contains(s->alignments.top, i)) {
		hor_align = ui__HorizontalAlignment__center;
		ver_align = ui__VerticalAlignment__top;
	} else if (Array_int_contains(s->alignments.right_top, i)) {
		hor_align = ui__HorizontalAlignment__right;
		ver_align = ui__VerticalAlignment__top;
	} else if (Array_int_contains(s->alignments.right, i)) {
		hor_align = ui__HorizontalAlignment__right;
		ver_align = ui__VerticalAlignment__center;
	} else if (Array_int_contains(s->alignments.right_bottom, i)) {
		hor_align = ui__HorizontalAlignment__right;
		ver_align = ui__VerticalAlignment__bottom;
	} else if (Array_int_contains(s->alignments.bottom, i)) {
		hor_align = ui__HorizontalAlignment__center;
		ver_align = ui__VerticalAlignment__bottom;
	} else if (Array_int_contains(s->alignments.left_bottom, i)) {
		hor_align = ui__HorizontalAlignment__left;
		ver_align = ui__VerticalAlignment__bottom;
	} else if (Array_int_contains(s->alignments.left, i)) {
		hor_align = ui__HorizontalAlignment__left;
		ver_align = ui__VerticalAlignment__center;
	}
	return (multi_return_ui__HorizontalAlignment_ui__VerticalAlignment){.arg0=hor_align, .arg1=ver_align};
}

void ui__Stack_add(ui__Stack* s, ui__ChildrenParams cfg_) {
	ui__ChildrenParams cfg = cfg_;
	int pos = (cfg.at == -1 ? (s->children.len) : (cfg.at));
	if (0 <= pos && pos <= s->children.len) {
		if (cfg.children.len > 0) {
			array_insert_many(&s->children, pos, cfg.children.data, cfg.children.len);
			for (int _t1 = 0; _t1 < cfg.children.len; ++_t1) {
				ui__Widget* w = ((ui__Widget*)cfg.children.data) + _t1;
				ui__Widget_name_table[w->_typ]._method_init(w->_object, /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(s));
				ui__Stack_register_child(s, *w);
			}
		} else {
			array_insert(&s->children, pos, &(ui__Widget[]){cfg.child});
			ui__Widget_name_table[cfg.child._typ]._method_init(cfg.child._object, /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(s));
			ui__Stack_register_child(s, cfg.child);
		}
		ui__Stack_update_widths(s, cfg, ui__ChildUpdateType__add);
		ui__Stack_update_heights(s, cfg, ui__ChildUpdateType__add);
		ui__Stack_update_spacings(s, cfg, ui__ChildUpdateType__add);
		ui__Window* window = s->ui->window;
		ui__Window_update_layout(window);
	}
}

void ui__Stack_remove(ui__Stack* s, ui__ChildrenParams cfg) {
	int pos = (cfg.at == -1 ? (s->children.len - 1) : (cfg.at));
	if (0 <= pos && pos < s->children.len) {
		ui__Widget child = (*(ui__Widget*)/*ee elem_sym */array_get(s->children, pos));
		ui__Widget_name_table[child._typ]._method_set_visible(child._object, false);
		ui__Widget_name_table[child._typ]._method_cleanup(child._object);
		array_delete(&s->children, pos);
		ui__Stack_update_widths(s, cfg, ui__ChildUpdateType__remove);
		ui__Stack_update_heights(s, cfg, ui__ChildUpdateType__remove);
		ui__Stack_update_spacings(s, cfg, ui__ChildUpdateType__remove);
		ui__Window* window = s->ui->window;
		ui__Window_update_layout(window);
	}
}

void ui__Stack_move(ui__Stack* s, ui__ChildrenParams cfg) {
	if (cfg.target == 0) {
		int from_pos = (cfg.from == -1 ? (s->children.len - 1) : (cfg.from));
		int to_pos = (cfg.to == -1 ? (s->children.len) : (cfg.to));
		if (0 <= from_pos && from_pos < s->children.len && 0 <= to_pos && to_pos <= s->children.len) {
			if (from_pos < to_pos) {
				to_pos--;
			}
			ui__Widget child = (*(ui__Widget*)/*ee elem_sym */array_get(s->children, from_pos));
			array_delete(&s->children, from_pos);
			array_insert(&s->children, to_pos, &(ui__Widget[]){child});
			ui__Window* window = s->ui->window;
			ui__Window_update_layout(window);
		}
	} else {
		ui__Stack* target_s = cfg.target;
		int from_pos = (cfg.from == -1 ? (s->children.len - 1) : (cfg.from));
		int target_pos = (cfg.to == -1 ? (target_s->children.len) : (cfg.to));
		if (0 <= from_pos && from_pos < s->children.len && 0 <= target_pos && target_pos <= target_s->children.len) {
			println( str_intp(3, _MOV((StrIntpData[]){{_SLIT("migrate from "), 0xfe07, {.d_i32 = from_pos}}, {_SLIT(" to "), 0xfe07, {.d_i32 = target_pos}}, {_SLIT0, 0, { .d_c = 0 }}})));
			ui__Widget child = (*(ui__Widget*)/*ee elem_sym */array_get(s->children, from_pos));
			array_delete(&s->children, from_pos);
			ui__Stack_update_widths(s, cfg, ui__ChildUpdateType__remove);
			ui__Stack_update_heights(s, cfg, ui__ChildUpdateType__remove);
			ui__Stack_update_spacings(s, cfg, ui__ChildUpdateType__remove);
			array_insert(&target_s->children, target_pos, &(ui__Widget[]){child});
			ui__Stack_update_widths(target_s, cfg, ui__ChildUpdateType__migrate);
			ui__Stack_update_heights(target_s, cfg, ui__ChildUpdateType__migrate);
			ui__Stack_update_spacings(target_s, cfg, ui__ChildUpdateType__migrate);
			ui__Window* window = s->ui->window;
			ui__Window_update_layout(window);
		}
	}
}

void ui__Stack_update_widths(ui__Stack* s, ui__ChildrenParams cfg, ui__ChildUpdateType mode) {
	ui__Size cfg_widths = (mode == ui__ChildUpdateType__migrate ? (cfg.target_widths) : (cfg.widths));
	if ((cfg_widths)._typ == 16 /* f64 */) {
		if ((*cfg_widths._f64) == -1.0) {

			if (mode == (ui__ChildUpdateType__add) || mode == (ui__ChildUpdateType__migrate)) {
				f64 widths = (s->direction == ui__Direction__row ? (_const_ui__compact) : (_const_ui__stretch));
				s->widths = ui__Size_as_f32_array(f64_to_sumtype_ui__Size(&widths), s->children.len);
			}
			else if (mode == (ui__ChildUpdateType__remove)) {
				if (s->children.len == 0) {
					s->widths = __new_array_with_default(0, 0, sizeof(f32), 0);
				} else {
					int pos = (cfg.at == -1 ? (s->children.len) : (cfg.at));
					array_delete(&s->widths, pos);
				}
			}
			else if (mode == (ui__ChildUpdateType__move)) {
			};
		} else {
			s->widths = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(f32), _MOV((f32[1]){((f32)((*cfg_widths._f64)))})), s->children.len, 0);
		}
	} else {
		s->widths = ui__Size_as_f32_array(cfg_widths, s->children.len);
	}
}

void ui__Stack_update_heights(ui__Stack* s, ui__ChildrenParams cfg, ui__ChildUpdateType mode) {
	ui__Size cfg_heights = (mode == ui__ChildUpdateType__migrate ? (cfg.target_heights) : (cfg.heights));
	if ((cfg_heights)._typ == 16 /* f64 */) {
		if ((*cfg_heights._f64) == -1.0) {

			if (mode == (ui__ChildUpdateType__add) || mode == (ui__ChildUpdateType__migrate)) {
				f64 heights = (s->direction == ui__Direction__row ? (_const_ui__stretch) : (_const_ui__compact));
				s->heights = ui__Size_as_f32_array(f64_to_sumtype_ui__Size(&heights), s->children.len);
			}
			else if (mode == (ui__ChildUpdateType__remove)) {
				if (s->children.len == 0) {
					s->heights = __new_array_with_default(0, 0, sizeof(f32), 0);
				} else {
					int pos = (cfg.at == -1 ? (s->children.len) : (cfg.at));
					array_delete(&s->heights, pos);
				}
			}
			else if (mode == (ui__ChildUpdateType__move)) {
			};
		} else {
			s->heights = array_repeat_to_depth(new_array_from_c_array(1, 1, sizeof(f32), _MOV((f32[1]){((f32)((*cfg_heights._f64)))})), s->children.len, 0);
		}
	} else {
		s->heights = ui__Size_as_f32_array(cfg_heights, s->children.len);
	}
}

void ui__Stack_update_spacings(ui__Stack* s, ui__ChildrenParams cfg, ui__ChildUpdateType mode) {
	f64 cfg_spacing = (mode == ui__ChildUpdateType__migrate ? (cfg.target_spacing) : (cfg.spacing));
	Array_f64 cfg_spacings = (mode == ui__ChildUpdateType__migrate ? (cfg.target_spacings) : (cfg.spacings));
	if (cfg_spacing != -1.0 || cfg_spacings.len != 0) {
		if (s->children.len > 0) {
			s->spacings = ui__spacings(cfg_spacing, cfg_spacings, s->children.len - 1);
		}
	} else {

		if (mode == (ui__ChildUpdateType__add) || mode == (ui__ChildUpdateType__migrate)) {
			if (s->children.len <= 1) {
				s->spacings = __new_array_with_default(0, 0, sizeof(f32), 0);
			} else {
				f32 spacing = (s->spacings.len == 0 ? (((f32)(5.0))) : ((*(f32*)/*ee elem_sym */array_get(s->spacings, 0))));
				s->spacings = ui__spacings(spacing, cfg_spacings, s->children.len - 1);
			}
		}
		else if (mode == (ui__ChildUpdateType__remove)) {
			if (s->children.len < 2) {
				s->spacings = __new_array_with_default(0, 0, sizeof(f32), 0);
			} else {
				s->spacings = array_slice(s->spacings, 0, (s->spacings.len - 1));
			}
		}
		else if (mode == (ui__ChildUpdateType__move)) {
		};
	}
}

ui__Widget ui__Stack_child(ui__Stack* s, Array_int from) {
	if (from.len > 0) {
		Array_ui__Widget children = s->children;
		for (int i = 0; i < from.len; ++i) {
			int ind = ((int*)from.data)[i];
			if (i < from.len - 1) {
				if (ind >= 0 && ind < children.len) {
					ui__Widget widget = (*(ui__Widget*)/*ee elem_sym */array_get(children, ind));
					if ((widget)._typ == _ui__Widget_ui__Stack_index) {
						children = (widget._ui__Stack)->children;
					} else {
						eprintln( str_intp(5, _MOV((StrIntpData[]){{_SLIT("(ui warning) "), 0xfe10, {.d_s = Array_int_str(from)}}, {_SLIT(" uncorrect: "), 0xfe10, {.d_s = Array_int_str(from)}}, {_SLIT("["), 0xfe07, {.d_i32 = i}}, {_SLIT("]="), 0xfe07, {.d_i32 = ind}}, {_SLIT(" does not correspond to a Layout"), 0, { .d_c = 0 }}})));
					}
				} else if (i == -1) {
					ui__Widget widget = (*(ui__Widget*)/*ee elem_sym */array_get(children, children.len - 1));
					if ((widget)._typ == _ui__Widget_ui__Stack_index) {
						children = (widget._ui__Stack)->children;
					}
				} else {
					eprintln( str_intp(5, _MOV((StrIntpData[]){{_SLIT("(ui warning) "), 0xfe10, {.d_s = Array_int_str(from)}}, {_SLIT(" uncorrect: "), 0xfe10, {.d_s = Array_int_str(from)}}, {_SLIT("["), 0xfe07, {.d_i32 = i}}, {_SLIT("]="), 0xfe07, {.d_i32 = ind}}, {_SLIT(" out of bounds"), 0, { .d_c = 0 }}})));
				}
			} else {
				if (ind >= 0 && ind < children.len) {
					ui__Widget _t1 = (*(ui__Widget*)/*ee elem_sym */array_get(children, ind));
					return _t1;
				} else if (ind == -1) {
					ui__Widget _t2 = (*(ui__Widget*)/*ee elem_sym */array_get(children, children.len - 1));
					return _t2;
				} else {
					eprintln( str_intp(5, _MOV((StrIntpData[]){{_SLIT("(ui warning) "), 0xfe10, {.d_s = Array_int_str(from)}}, {_SLIT(" uncorrect: "), 0xfe10, {.d_s = Array_int_str(from)}}, {_SLIT("["), 0xfe07, {.d_i32 = i}}, {_SLIT("]="), 0xfe07, {.d_i32 = ind}}, {_SLIT(" out of bounds"), 0, { .d_c = 0 }}})));
				}
			}
		}
	}
	ui__Widget _t3 = /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget(s);
	return _t3;
}

void ui__Stack_transpose(ui__Stack* s, bool size) {
	if (s->direction == ui__Direction__row) {
		s->direction = ui__Direction__column;
	} else {
		s->direction = ui__Direction__row;
	}
	if (size) {
		Array_f32 _var_42982 = s->widths;
		Array_f32 _var_42992 = s->heights;
		s->widths = _var_42992;
		s->heights = _var_42982;
	}
}

void ui__Stack_register_child(ui__Stack* s, ui__Widget child) {
	ui__Window* window = s->ui->window;
	ui__Window_register_child(window, child);
}

int ui__Stack_child_index_by_id(ui__Stack* s, string id) {
	for (int i = 0; i < s->children.len; ++i) {
		ui__Widget child = ((ui__Widget*)s->children.data)[i];
		if (string__eq(ui__Widget_id(&child), id)) {
			int _t1 = i;
			return _t1;
		}
	}
	int _t2 = -1;
	return _t2;
}

int ui__SettingsUI_int(ui__SettingsUI* c, Array_string k) {
	int _t1 = (*(int*)map_get(ADDR(map, c->int_), &(string[]){Array_string_join(k, _SLIT("."))}, &(int[]){ 0 }));
	return _t1;
}

void ui__SettingsUI_int_for(ui__SettingsUI* c, int val, Array_string k) {
	map_set(&c->int_, &(string[]){Array_string_join(k, _SLIT("."))}, &(int[]) { val });
}

Array_int ui__SettingsUI_ints(ui__SettingsUI* c, Array_string k) {
	Array_int _t1 = (*(Array_int*)map_get(ADDR(map, c->ints_), &(string[]){Array_string_join(k, _SLIT("."))}, &(Array_int[]){ __new_array(0, 0, sizeof(int)) }));
	return _t1;
}

void ui__SettingsUI_ints_for(ui__SettingsUI* c, Array_int val, Array_string k) {
	map_set(&c->ints_, &(string[]){Array_string_join(k, _SLIT("."))}, &(Array_int[]) { val });
}

f32 ui__SettingsUI_f32(ui__SettingsUI* c, Array_string k) {
	f32 _t1 = (*(f32*)map_get(ADDR(map, c->f32_), &(string[]){Array_string_join(k, _SLIT("."))}, &(f32[]){ 0 }));
	return _t1;
}

Array_f32 ui__SettingsUI_f32s(ui__SettingsUI* c, Array_string k) {
	Array_f32 _t1 = (*(Array_f32*)map_get(ADDR(map, c->f32s_), &(string[]){Array_string_join(k, _SLIT("."))}, &(Array_f32[]){ __new_array(0, 0, sizeof(f32)) }));
	return _t1;
}

void ui__SettingsUI_f32_for(ui__SettingsUI* c, f32 val, Array_string k) {
	map_set(&c->f32_, &(string[]){Array_string_join(k, _SLIT("."))}, &(f32[]) { val });
}

void ui__SettingsUI_f32s_for(ui__SettingsUI* c, Array_f32 val, Array_string k) {
	map_set(&c->f32s_, &(string[]){Array_string_join(k, _SLIT("."))}, &(Array_f32[]) { val });
}

bool ui__SettingsUI_bool(ui__SettingsUI* c, Array_string k) {
	bool _t1 = (*(bool*)map_get(ADDR(map, c->bool_), &(string[]){Array_string_join(k, _SLIT("."))}, &(bool[]){ 0 }));
	return _t1;
}

void ui__SettingsUI_bool_for(ui__SettingsUI* c, bool val, Array_string k) {
	map_set(&c->bool_, &(string[]){Array_string_join(k, _SLIT("."))}, &(bool[]) { val });
}

Array_bool ui__SettingsUI_bools(ui__SettingsUI* c, Array_string k) {
	Array_bool _t1 = (*(Array_bool*)map_get(ADDR(map, c->bools_), &(string[]){Array_string_join(k, _SLIT("."))}, &(Array_bool[]){ __new_array(0, 0, sizeof(bool)) }));
	return _t1;
}

void ui__SettingsUI_bools_for(ui__SettingsUI* c, Array_bool val, Array_string k) {
	map_set(&c->bools_, &(string[]){Array_string_join(k, _SLIT("."))}, &(Array_bool[]) { val });
}

string ui__SettingsUI_string(ui__SettingsUI* c, Array_string k) {
	string _t1 = (*(string*)map_get(ADDR(map, c->string_), &(string[]){Array_string_join(k, _SLIT("."))}, &(string[]){ (string){.str=(byteptr)"", .is_lit=1} }));
	return _t1;
}

void ui__SettingsUI_string_for(ui__SettingsUI* c, string val, Array_string k) {
	map_set(&c->string_, &(string[]){Array_string_join(k, _SLIT("."))}, &(string[]) { val });
}

Array_string ui__SettingsUI_strings(ui__SettingsUI* c, Array_string k) {
	Array_string _t1 = (*(Array_string*)map_get(ADDR(map, c->strings_), &(string[]){Array_string_join(k, _SLIT("."))}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) }));
	return _t1;
}

void ui__SettingsUI_strings_for(ui__SettingsUI* c, Array_string val, Array_string k) {
	map_set(&c->strings_, &(string[]){Array_string_join(k, _SLIT("."))}, &(Array_string[]) { val });
}

gx__Color ui__SettingsUI_color(ui__SettingsUI* c, Array_string k) {
	gx__Color _t1 = (*(gx__Color*)map_get(ADDR(map, c->color_), &(string[]){Array_string_join(k, _SLIT("."))}, &(gx__Color[]){ (gx__Color){.r = 0,.g = 0,.b = 0,.a = 255,} }));
	return _t1;
}

void ui__SettingsUI_color_for(ui__SettingsUI* c, gx__Color val, Array_string k) {
(*(gx__Color*)map_get_and_set((map*)&c->color_, &(string[]){Array_string_join(k, _SLIT("."))}, &(gx__Color[]){ (gx__Color){.r = 0,.g = 0,.b = 0,.a = 255,} })) = val;
}

Array_gx__Color ui__SettingsUI_colors(ui__SettingsUI* c, Array_string k) {
	Array_gx__Color _t1 = (*(Array_gx__Color*)map_get(ADDR(map, c->colors_), &(string[]){Array_string_join(k, _SLIT("."))}, &(Array_gx__Color[]){ __new_array(0, 0, sizeof(gx__Color)) }));
	return _t1;
}

void ui__SettingsUI_colors_for(ui__SettingsUI* c, Array_gx__Color val, Array_string k) {
	map_set(&c->colors_, &(string[]){Array_string_join(k, _SLIT("."))}, &(Array_gx__Color[]) { val });
}

Option_ui__SettingsUI ui__load_settings(string path) {
	return (Option_ui__SettingsUI){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Option_void ui__save_settings(string path, ui__SettingsUI s) {
	return (Option_void){0};
}

void ui__Window_load_settings(ui__Window* w) {
}

void ui__Window_save_settings(ui__Window* w) {
}

void ui__UI_idle_loop(ui__UI* gui) {
	for (;;) {
		if (time__ticks() - gui->last_type_time < _const_ui__cursor_show_delay) {
			gui->show_cursor = true;
		} else {
			gui->show_cursor = !gui->show_cursor;
		}
		gg__Context_refresh_ui(gui->gg);
		if (gui->gg->native_rendering) {
			darwin_window_refresh();
		}
		gui->ticks = 0;
		for (int i = 0; i < 50; i++) {
			time__sleep(10 * _const_time__millisecond);
			if (gui->closed) {
				return;
			}
		}
	}
}

void ui__UI_load_icos(ui__UI* gui) {
	gui->cb_image = gg__Context_create_image_from_memory(gui->gg, &_const_ui__bytes_check_png[0], 3811);
	#if defined(__APPLE__)
	{
		gui->circle_image = gg__Context_create_image_from_memory(gui->gg, &_const_ui__bytes_darwin_circle_png[0], 3558);
	}
	#else
	{
	}
	#endif
	gui->down_arrow = gg__Context_create_image_from_memory(gui->gg, &_const_ui__bytes_arrow_png[0], 163);
	gui->selected_radio_image = gg__Context_create_image_from_memory(gui->gg, &_const_ui__bytes_selected_radio_png[0], 4411);
}

// Attr: [unsafe]
void ui__UI_free(ui__UI* gui) {
	map_free(&gui->resource_cache);
}

void ui__run(ui__Window* window) {
	ui__UI* gui = window->ui;
	gui->window = window;
	// start go
	thread_arg_ui__UI_idle_loop *arg__t1 = malloc(sizeof(thread_arg_ui__UI_idle_loop));
	arg__t1->arg0 = gui;
	pthread_t thread__t1;
	int _t1_thr_res = pthread_create(&thread__t1, NULL, (void*)ui__UI_idle_loop_thread_wrapper, arg__t1);
	if (_t1_thr_res) panic_error_number(tos3("`go ui__UI_idle_loop()`: "), _t1_thr_res);
	pthread_detach(thread__t1);
	// end go
	;
	gg__Context_run(gui->gg);
	gui->closed = true;
	time__sleep(20 * _const_time__millisecond);
}

void ui__open_url(string url) {
	if (!string_starts_with(url, _SLIT("https://")) && !string_starts_with(url, _SLIT("http://"))) {
		return;
	}
	os__execute( str_intp(2, _MOV((StrIntpData[]){{_SLIT("open \""), 0xfe10, {.d_s = url}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
}

bool ui__confirm(string s) {
	bool _t1 = false;
	return _t1;
}

void ui__message_box(string s) {
	vui_message_box(s);
}

void ui__notify(string title, string msg) {
	vui_notify(title, msg);
}

string ui__bundle_path(void) {
	string _t1 = vui_bundle_path();
	return _t1;
}

void ui__wait_events(void) {
	vui_wait_events();
}

// TypeDecl
// TypeDecl
ui__Button* ui__button(ui__ButtonParams c) {
	ui__Button* b = ((ui__Button*)memdup(&(ui__Button){.width_ = c.width,
		.height_ = c.height,
		.id = c.id,
		.state = ((ui__ButtonState)(1)),
		.height = 0,
		.width = 0,
		.z_index = c.z_index,
		.x = 0,
		.y = 0,
		.offset_x = 0,
		.offset_y = 0,
		.text_width = 0,
		.text_height = 0,
		.bg_color = c.bg_color,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.is_focused = 0,
		.ui = 0,
		.onclick = (voidptr)c.onclick,
		.on_key_down = (voidptr)c.on_key_down,
		.text = c.text,
		.icon_path = c.icon_path,
		.image = (gg__Image){.id = 0,.width = 0,.height = 0,.nr_channels = 0,.ok = 0,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},.simg_ok = 0,.simg = {0},.path = (string){.str=(byteptr)"", .is_lit=1},},
		.use_icon = (c.icon_path).len != 0,
		.padding = ((f32)(c.padding)),
		.radius = ((f32)(c.radius)),
		.hidden = 0,
		.movable = c.movable,
		.hoverable = c.hoverable,
		.to_hover = 0,
		.tooltip = ((ui__TooltipMessage){.text = c.tooltip,.side = c.tooltip_side,}),
		.text_styles = (ui__TextStyles){.current = (ui__TextStyle){.id = _const_ui__no_string,.font_name = _SLIT("system"),.color = _const_gx__black,.size = 16,.align = ui__TextHorizontalAlign__left,.vertical_align = ui__TextVerticalAlign__top,.mono = 0,},.hash = new_map(sizeof(string), sizeof(ui__TextStyle), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},
		.text_size = c.text_size,
		.text_cfg = c.text_cfg,
		.theme_cfg = (c.bg_color == ((voidptr)(0)) ? (c.theme) : (_const_ui__no_theme)),
		.theme = new_map(sizeof(int), sizeof(gx__Color), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),
		.component = 0,
	}, sizeof(ui__Button)));
	if (b->use_icon && !os__exists(c.icon_path)) {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Invalid icon path \""), 0xfe10, {.d_s = c.icon_path}}, {_SLIT("\". The alternate text will be used."), 0, { .d_c = 0 }}})));
		b->use_icon = false;
	}
	ui__Button* _t1 = b;
	return _t1;
}

void ui__Button_init(ui__Button* b, ui__Layout parent) {
	b->parent = parent;
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	b->ui = ui;
	if (b->use_icon) {
		b->image = gg__Context_create_image(b->ui->gg, b->icon_path);
	}
	ui__Button_init_style(b);
	if ((b->tooltip.text).len != 0) {
		ui__Window* win = ui->window;
		ui__Window_append_tooltip(win, /*&ui.Widget*/I_ui__Button_to_Interface_ui__Widget(b), b->tooltip);
	}
	eventbus__Subscriber* subscriber = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_key_down, (voidptr)ui__btn_key_down, b);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_down, (voidptr)ui__btn_mouse_down, b);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_click, (voidptr)ui__btn_click, b);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_touch_down, (voidptr)ui__btn_mouse_down, b);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_move, (voidptr)ui__btn_mouse_move, b);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_up, (voidptr)ui__btn_mouse_up, b);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_touch_up, (voidptr)ui__btn_mouse_up, b);
	ui__EventMngr_add_receiver(&b->ui->window->evt_mngr, /*&ui.Widget*/I_ui__Button_to_Interface_ui__Widget(b), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(_const_ui__events.on_mouse_down)})));
}

// Attr: [manualfree]
void ui__Button_cleanup(ui__Button* b) {
	eventbus__Subscriber* subscriber = ui__Layout_name_table[b->parent._typ]._method_get_subscriber(b->parent._object);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_key_down, b);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_down, b);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_click, b);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_touch_down, b);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_move, b);
	ui__EventMngr_rm_receiver(&b->ui->window->evt_mngr, /*&ui.Widget*/I_ui__Button_to_Interface_ui__Widget(b), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(_const_ui__events.on_mouse_down)})));
	ui__Button_free(b);
}

// Attr: [unsafe]
void ui__Button_free(ui__Button* b) {
	{ // Unsafe block
		string_free(&b->id);
		string_free(&b->text);
		string_free(&b->icon_path);
		ui__TooltipMessage_free(&b->tooltip);
		_v_free(b);
	}
}

void ui__Button_init_style(ui__Button* b) {
	#if defined(CUSTOM_DEFINE_nodtw)
	{
	}
	#else
	{
		ui__DrawTextWidget dtw = /*&ui.DrawTextWidget*/I_ui__Button_to_Interface_ui__DrawTextWidget(b);
		ui__DrawTextWidget_init_style(&dtw, ((ui__TextStyleParams){.id = _const_ui__no_string,.font_name = _const_ui__no_string,.color = _const_ui__no_color,.size = -1,.align = ui__TextHorizontalAlign__center,.vertical_align = ui__TextVerticalAlign__middle,}));
		ui__DrawTextWidget_update_text_size(&dtw, b->text_size);
	}
	#endif
	ui__Button_set_text_size(b);
	ui__Button_update_theme(b);
}

void ui__btn_key_down(ui__Button* b, ui__KeyEvent* e, ui__Window* window) {
	if (b->hidden) {
		return;
	}
	if (!b->is_focused) {
		return;
	}
	if (b->on_key_down != (voidptr)((ui__ButtonKeyDownFn)(0))) {
		b->on_key_down(window->state, b, e->codepoint);
	} else {
		if (e->key == ui__Key__enter || e->key == ui__Key__space) {
			if (b->onclick != (voidptr)((ui__ButtonClickFn)(0))) {
				b->onclick(window->state, b);
			}
		}
	}
}

void ui__btn_click(ui__Button* b, ui__MouseEvent* e, ui__Window* window) {
	if (b->hidden) {
		return;
	}
	if (!ui__Window_is_top_widget(/*rec*/*b->ui->window, /*&ui.Widget*/I_ui__Button_to_Interface_ui__Widget(b), _const_ui__events.on_mouse_down)) {
		return;
	}
	if (!b->is_focused) {
		return;
	}
	if (ui__Button_point_inside(b, e->x, e->y)) {
		if (e->action == ui__MouseAction__down) {
			b->state = ui__ButtonState__pressed;
		} else if (e->action == ui__MouseAction__up) {
			b->state = ui__ButtonState__normal;
			if (b->onclick != (voidptr)((ui__ButtonClickFn)(0)) && b->is_focused) {
				b->onclick(window->state, b);
			}
		}
	}
}

void ui__btn_mouse_down(ui__Button* b, ui__MouseEvent* e, ui__Window* window) {
	if (b->hidden) {
		return;
	}
	if (!ui__Window_is_top_widget(/*rec*/*b->ui->window, /*&ui.Widget*/I_ui__Button_to_Interface_ui__Widget(b), _const_ui__events.on_mouse_down)) {
		return;
	}
	if (ui__Button_point_inside(b, e->x, e->y)) {
		ui__Button_focus(b);
		if (b->movable) {
			ui__drag_register(/*&ui.Widget*/I_ui__Button_to_Interface_ui__Widget(b), b->ui, e);
		}
		b->state = ui__ButtonState__pressed;
	}
}

void ui__btn_mouse_up(ui__Button* b, ui__MouseEvent* e, ui__Window* window) {
	if (b->hidden) {
		return;
	}
	b->state = ui__ButtonState__normal;
}

void ui__btn_mouse_move(ui__Button* b, ui__MouseMoveEvent* e, ui__Window* window) {
	if (b->hidden) {
		return;
	}
	if (e->mouse_button == 256) {
		if (ui__Button_point_inside(b, e->x, e->y)) {
			if (b->hoverable && !b->to_hover) {
				b->to_hover = true;
			}
		} else {
			if (b->hoverable && b->to_hover) {
				b->to_hover = false;
			}
			b->state = ui__ButtonState__normal;
		}
	}
}

void ui__Button_set_pos(ui__Button* b, int x, int y) {
	b->x = x;
	b->y = y;
}

multi_return_int_int ui__Button_size(ui__Button* b) {
	if (b->width == 0 || b->height == 0) {
		ui__Button_set_text_size(b);
	}
	return (multi_return_int_int){.arg0=b->width, .arg1=b->height};
}

multi_return_int_int ui__Button_propose_size(ui__Button* b, int w, int h) {
	if (w != 0) {
		b->width = w;
	}
	if (h != 0) {
		b->height = h;
	}
	ui__update_text_size(HEAP(ui__DrawText, /*&ui.DrawText*/I_ui__Button_to_Interface_ui__DrawText(b)));
	return (multi_return_int_int){.arg0=b->width, .arg1=b->height};
}

void ui__Button_draw(ui__Button* b) {
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Button_to_Interface_ui__Widget(b)));
	int bcenter_x = b->x + b->width / 2;
	int bcenter_y = b->y + b->height / 2;
	f32 padding = ui__relative_size(b->padding, b->width, b->height);
	f32 x = b->x + padding;
	f32 y = b->y + padding;
	f32 width = b->width - 2 * padding;
	f32 height = b->height - 2 * padding;
	gx__Color bg_color = (!ui__ColorThemeCfg_sumtype_eq(b->theme_cfg, _const_ui__no_theme) ? (ui__color(b->theme, (b->to_hover && b->state != ui__ButtonState__pressed ? (3) : (((int)(b->state)))))) : b->bg_color != ((voidptr)(0)) ? (*b->bg_color) : (_const_gx__white));
	if (b->radius > 0) {
		f32 radius = ui__relative_size(b->radius, ((int)(width)), ((int)(height)));
		gg__Context_draw_rounded_rect_filled(b->ui->gg, x, y, width, height, radius, bg_color);
		gg__Context_draw_rounded_rect_empty(b->ui->gg, x, y, width, height, radius, (b->is_focused ? (_const_ui__button_focus_border_color) : (_const_ui__button_border_color)));
	} else {
		gg__Context_draw_rect_filled(b->ui->gg, x, y, width, height, bg_color);
		gg__Context_draw_rect_empty(b->ui->gg, x, y, width, height, (b->is_focused ? (_const_ui__button_focus_border_color) : (_const_ui__button_border_color)));
	}
	if (b->use_icon) {
		gg__Context_draw_image(b->ui->gg, x, y, width, height, (voidptr)&/*qq*/b->image);
	} else {
		#if defined(CUSTOM_DEFINE_nodtw)
		{
		}
		#else
		{
			ui__DrawTextWidget dtw = /*&ui.DrawTextWidget*/I_ui__Button_to_Interface_ui__DrawTextWidget(b);
			ui__DrawTextWidget_load_style(dtw);
			ui__DrawTextWidget_draw_text(dtw, bcenter_x, bcenter_y, b->text);
		}
		#endif
	}
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Button_to_Interface_ui__Widget(b)));
}

void ui__Button_set_text(ui__Button* b, string text) {
	b->text = text;
	ui__Button_set_text_size(b);
}

void ui__Button_set_text_size(ui__Button* b) {
	if (b->use_icon) {
		b->width = b->image.width;
		b->height = b->image.height;
	} else {
		multi_return_int_int mr_9860 = ui__text_size_T_ui__Button(b, b->text);
		b->text_width = mr_9860.arg0;
		b->text_height = mr_9860.arg1;
		b->width = b->text_width + _const_ui__button_horizontal_padding;
		if (b->width_ > b->width) {
			b->width = b->width_;
		}
		b->height = b->text_height + _const_ui__button_vertical_padding;
		if (b->height_ > b->height) {
			b->height = b->height_;
		}
	}
}

bool ui__Button_point_inside(ui__Button* b, f64 x, f64 y) {
	bool _t1 = ui__point_inside_T_ui__Button(b, x, y);
	return _t1;
}

void ui__Button_set_visible(ui__Button* b, bool state) {
	b->hidden = !state;
}

void ui__Button_focus(ui__Button* b) {
	ui__Focusable f = /*&ui.Focusable*/I_ui__Button_to_Interface_ui__Focusable(b);
	ui__Focusable_force_focus(&f);
}

void ui__Button_unfocus(ui__Button* b) {
	b->is_focused = false;
	b->state = ui__ButtonState__normal;
}

void ui__Button_set_theme(ui__Button* b, ui__ColorThemeCfg theme_cfg) {
	b->theme_cfg = theme_cfg;
}

void ui__Button_update_theme(ui__Button* b) {
	ui__update_colors_from((voidptr)&/*qq*/b->theme, ui__theme(/*&ui.ColorThemeWidget*/I_ui__Button_to_Interface_ui__ColorThemeWidget(b)), new_array_from_c_array(3, 3, sizeof(int), _MOV((int[3]){1, 2, 3})));
}

// TypeDecl
ui__Canvas* ui__canvas(ui__CanvasParams c) {
	ui__Canvas* canvas = ((ui__Canvas*)memdup(&(ui__Canvas){.id = c.id,.width = c.width,.height = c.height,.x = 0,.y = 0,.offset_x = 0,.offset_y = 0,.z_index = c.z_index,.ui = 0,.hidden = 0,.component = 0,.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),.draw_fn = (voidptr)c.draw_fn,.gg = 0,}, sizeof(ui__Canvas)));
	ui__Canvas* _t1 = canvas;
	return _t1;
}

void ui__Canvas_init(ui__Canvas* c, ui__Layout parent) {
	c->parent = parent;
	c->gg = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object)->gg;
}

// Attr: [manualfree]
void ui__Canvas_cleanup(ui__Canvas* c) {
	ui__Canvas_free(c);
}

// Attr: [unsafe]
void ui__Canvas_free(ui__Canvas* c) {
	{ // Unsafe block
		string_free(&c->id);
		_v_free(c);
	}
}

void ui__Canvas_set_pos(ui__Canvas* c, int x, int y) {
	c->x = x;
	c->y = y;
}

multi_return_int_int ui__Canvas_size(ui__Canvas* c) {
	return (multi_return_int_int){.arg0=c->width, .arg1=c->height};
}

multi_return_int_int ui__Canvas_propose_size(ui__Canvas* c, int w, int h) {
	c->width = w;
	c->height = h;
	return (multi_return_int_int){.arg0=c->width, .arg1=c->height};
}

void ui__Canvas_draw(ui__Canvas* c) {
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Canvas_to_Interface_ui__Widget(c)));
	voidptr state = ui__Layout_name_table[c->parent._typ]._method_get_state(c->parent._object);
	if (c->draw_fn != (voidptr)((voidptr)(0))) {
		c->draw_fn(c->gg, state, c);
	}
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Canvas_to_Interface_ui__Widget(c)));
}

void ui__Canvas_set_visible(ui__Canvas* c, bool state) {
	c->hidden = !state;
}

bool ui__Canvas_point_inside(ui__Canvas* c, f64 x, f64 y) {
	bool _t1 = ui__point_inside_T_ui__Canvas(c, x, y);
	return _t1;
}

// TypeDecl
// TypeDecl
ui__CheckBox* ui__checkbox(ui__CheckBoxParams c) {
	ui__CheckBox* cb = ((ui__CheckBox*)memdup(&(ui__CheckBox){.id = c.id,
		.height = _const_ui__check_mark_size + 5,
		.width = 0,
		.x = 0,
		.y = 0,
		.offset_x = 0,
		.offset_y = 0,
		.z_index = c.z_index,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.is_focused = 0,
		.checked = c.checked,
		.ui = 0,
		.on_click = (voidptr)c.on_click,
		.on_check_changed = (voidptr)c.on_check_changed,
		.text = c.text,
		.disabled = c.disabled,
		.text_styles = (ui__TextStyles){.current = (ui__TextStyle){.id = _const_ui__no_string,.font_name = _SLIT("system"),.color = _const_gx__black,.size = 16,.align = ui__TextHorizontalAlign__left,.vertical_align = ui__TextVerticalAlign__top,.mono = 0,},.hash = new_map(sizeof(string), sizeof(ui__TextStyle), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},
		.text_size = c.text_size,
		.text_cfg = c.text_cfg,
		.hidden = 0,
		.component = 0,
	}, sizeof(ui__CheckBox)));
	ui__CheckBox* _t1 = cb;
	return _t1;
}

void ui__CheckBox_init(ui__CheckBox* cb, ui__Layout parent) {
	cb->parent = parent;
	cb->ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	cb->width = ui__text_width_T_ui__CheckBox(cb, cb->text) + 5 + _const_ui__check_mark_size;
	ui__CheckBox_init_style(cb);
	eventbus__Subscriber* subscriber = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_key_down, (voidptr)ui__cb_key_down, cb);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_click, (voidptr)ui__cb_click, cb);
}

// Attr: [manualfree]
void ui__CheckBox_cleanup(ui__CheckBox* cb) {
	eventbus__Subscriber* subscriber = ui__Layout_name_table[cb->parent._typ]._method_get_subscriber(cb->parent._object);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_key_down, cb);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_click, cb);
	ui__CheckBox_free(cb);
}

// Attr: [unsafe]
void ui__CheckBox_free(ui__CheckBox* cb) {
	_v_free(cb);
}

void ui__CheckBox_init_style(ui__CheckBox* cb) {
	#if defined(CUSTOM_DEFINE_nodtw)
	{
	}
	#else
	{
		ui__DrawTextWidget dtw = /*&ui.DrawTextWidget*/I_ui__CheckBox_to_Interface_ui__DrawTextWidget(cb);
		ui__DrawTextWidget_init_style(&dtw, ((ui__TextStyleParams){.id = _const_ui__no_string,.font_name = _const_ui__no_string,.color = _const_ui__no_color,.size = -1,.align = ui__TextHorizontalAlign__none,.vertical_align = ui__TextVerticalAlign__none,}));
		ui__DrawTextWidget_update_text_size(&dtw, cb->text_size);
	}
	#endif
}

void ui__cb_key_down(ui__CheckBox* cb, ui__KeyEvent* e, ui__Window* window) {
	if (cb->hidden) {
		return;
	}
	if (!cb->is_focused) {
		return;
	}
	if (e->key == ui__Key__enter || e->key == ui__Key__space) {
		cb->checked = !cb->checked;
		if (cb->on_check_changed != (voidptr)((ui__CheckChangedFn)(0))) {
			cb->on_check_changed(window->state, cb->checked);
		}
		if (cb->on_click != (voidptr)((ui__CheckBowClickFn)(0))) {
			cb->on_click(cb, window->state);
		}
	}
}

void ui__cb_click(ui__CheckBox* cb, ui__MouseEvent* e, ui__Window* window) {
	if (cb->hidden) {
		return;
	}
	if (ui__CheckBox_point_inside(cb, e->x, e->y)) {
		cb->checked = !cb->checked;
		if (cb->on_check_changed != (voidptr)((ui__CheckChangedFn)(0))) {
			cb->on_check_changed(window->state, cb->checked);
		}
		if (cb->on_click != (voidptr)((ui__CheckBowClickFn)(0))) {
			cb->on_click(cb, window->state);
		}
	}
}

void ui__CheckBox_set_pos(ui__CheckBox* cb, int x, int y) {
	cb->x = x;
	cb->y = y;
}

multi_return_int_int ui__CheckBox_size(ui__CheckBox* cb) {
	return (multi_return_int_int){.arg0=cb->width, .arg1=cb->height};
}

multi_return_int_int ui__CheckBox_propose_size(ui__CheckBox* cb, int w, int h) {
	cb->width = w;
	return (multi_return_int_int){.arg0=cb->width, .arg1=cb->height};
}

void ui__CheckBox_draw(ui__CheckBox* cb) {
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__CheckBox_to_Interface_ui__Widget(cb)));
	gg__Context_draw_rect_filled(cb->ui->gg, cb->x, cb->y, _const_ui__check_mark_size, _const_ui__check_mark_size, _const_gx__white);
	ui__draw_inner_border(false, cb->ui->gg, cb->x, cb->y, _const_ui__check_mark_size, _const_ui__check_mark_size, false);
	if (cb->is_focused) {
		gg__Context_draw_rect_empty(cb->ui->gg, cb->x, cb->y, _const_ui__check_mark_size, _const_ui__check_mark_size, _const_ui__cb_border_color);
	}
	if (cb->checked) {
		gg__Context_draw_image(cb->ui->gg, cb->x + 3, cb->y + 3, 8, 8, (voidptr)&/*qq*/cb->ui->cb_image);
	}
	#if defined(CUSTOM_DEFINE_nodtw)
	{
	}
	#else
	{
		ui__DrawTextWidget dtw = /*&ui.DrawTextWidget*/I_ui__CheckBox_to_Interface_ui__DrawTextWidget(cb);
		ui__DrawTextWidget_load_style(dtw);
		ui__DrawTextWidget_draw_text(dtw, cb->x + _const_ui__check_mark_size + 5, cb->y, cb->text);
	}
	#endif
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__CheckBox_to_Interface_ui__Widget(cb)));
}

bool ui__CheckBox_point_inside(ui__CheckBox* cb, f64 x, f64 y) {
	bool _t1 = ui__point_inside_T_ui__CheckBox(cb, x, y);
	return _t1;
}

void ui__CheckBox_mouse_move(ui__CheckBox* cb, ui__MouseEvent e) {
}

void ui__CheckBox_set_visible(ui__CheckBox* cb, bool state) {
	cb->hidden = !state;
}

void ui__CheckBox_focus(ui__CheckBox* cb) {
	ui__Focusable f = /*&ui.Focusable*/I_ui__CheckBox_to_Interface_ui__Focusable(cb);
	ui__Focusable_set_focus(&f);
}

void ui__CheckBox_unfocus(ui__CheckBox* cb) {
	cb->is_focused = false;
}

// TypeDecl
ui__Dropdown* ui__dropdown(ui__DropdownParams c) {
	ui__Dropdown* dd = ((ui__Dropdown*)memdup(&(ui__Dropdown){.id = c.id,
		.def_text = c.def_text,
		.width = c.width,
		.dropdown_height = c.height,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.x = 0,
		.y = 0,
		.offset_x = 0,
		.offset_y = 0,
		.z_index = c.z_index,
		.ui = 0,
		.items = c.items,
		.open = 0,
		.selected_index = c.selected_index,
		.hover_index = 0,
		.is_focused = 0,
		.on_selection_changed = (voidptr)c.on_selection_changed,
		.hidden = 0,
		.bg_color = _const_ui__dropdown_color,
		.component = 0,
	}, sizeof(ui__Dropdown)));
	if (c.texts.len > 0) {
		for (int _t1 = 0; _t1 < c.texts.len; ++_t1) {
			string t = ((string*)c.texts.data)[_t1];
			ui__Dropdown_add_item(dd, t);
		}
	}
	ui__Dropdown* _t2 = dd;
	return _t2;
}

void ui__Dropdown_init(ui__Dropdown* dd, ui__Layout parent) {
	dd->parent = parent;
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	dd->ui = ui;
	eventbus__Subscriber* subscriber = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_click, (voidptr)ui__dd_click, dd);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_key_down, (voidptr)ui__dd_key_down, dd);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_down, (voidptr)ui__dd_mouse_down, dd);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_move, (voidptr)ui__dd_mouse_move, dd);
	ui__EventMngr_add_receiver(&dd->ui->window->evt_mngr, /*&ui.Widget*/I_ui__Dropdown_to_Interface_ui__Widget(dd), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(_const_ui__events.on_mouse_down)})));
}

// Attr: [manualfree]
void ui__Dropdown_cleanup(ui__Dropdown* dd) {
	eventbus__Subscriber* subscriber = ui__Layout_name_table[dd->parent._typ]._method_get_subscriber(dd->parent._object);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_click, dd);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_key_down, dd);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_down, dd);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_move, dd);
	ui__EventMngr_rm_receiver(&dd->ui->window->evt_mngr, /*&ui.Widget*/I_ui__Dropdown_to_Interface_ui__Widget(dd), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(_const_ui__events.on_mouse_down)})));
	ui__Dropdown_free(dd);
}

// Attr: [unsafe]
void ui__Dropdown_free(ui__Dropdown* dd) {
	{ // Unsafe block
		string_free(&dd->id);
		string_free(&dd->def_text);
		for (int _t1 = 0; _t1 < dd->items.len; ++_t1) {
			ui__DropdownItem item = ((ui__DropdownItem*)dd->items.data)[_t1];
			string_free(&item.text);
		}
		array_free(&dd->items);
		_v_free(dd);
	}
}

void ui__Dropdown_set_pos(ui__Dropdown* dd, int x, int y) {
	dd->x = x;
	dd->y = y;
}

multi_return_int_int ui__Dropdown_size(ui__Dropdown* dd) {
	return (multi_return_int_int){.arg0=dd->width, .arg1=dd->dropdown_height};
}

multi_return_int_int ui__Dropdown_propose_size(ui__Dropdown* dd, int w, int h) {
	dd->width = w;
	return (multi_return_int_int){.arg0=w, .arg1=dd->dropdown_height};
}

void ui__Dropdown_draw(ui__Dropdown* dd) {
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Dropdown_to_Interface_ui__Widget(dd)));
	gg__Context* gg = dd->ui->gg;
	gg__Context_draw_rect_filled(gg, dd->x, dd->y, dd->width, dd->dropdown_height, dd->bg_color);
	gg__Context_draw_rect_empty(gg, dd->x, dd->y, dd->width, dd->dropdown_height, (dd->is_focused ? (_const_ui__dropdown_focus_color) : (_const_ui__dropdown_border_color)));
	if (dd->selected_index >= 0) {
		gg__Context_draw_text_def(gg, dd->x + 5, dd->y + 5, (*(ui__DropdownItem*)/*ee elem_sym */array_get(dd->items, dd->selected_index)).text);
	} else {
		gg__Context_draw_text_def(gg, dd->x + 5, dd->y + 5, dd->def_text);
	}
	ui__Dropdown_draw_open(dd);
	gg__Context_draw_image(gg, dd->x + (dd->width - 28), dd->y - 3, 28, 28, (voidptr)&/*qq*/dd->ui->down_arrow);
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Dropdown_to_Interface_ui__Widget(dd)));
}

void ui__Dropdown_draw_open(ui__Dropdown* dd) {
	if (dd->open) {
		gg__Context* gg = dd->ui->gg;
		gg__Context_draw_rect_filled(gg, dd->x, dd->y + dd->dropdown_height, dd->width, dd->items.len * dd->dropdown_height, _const_ui__dropdown_drawer_color);
		gg__Context_draw_rect_empty(gg, dd->x, dd->y + dd->dropdown_height, dd->width, dd->items.len * dd->dropdown_height, _const_ui__dropdown_border_color);
		int y = dd->y + dd->dropdown_height;
		for (int i = 0; i < dd->items.len; ++i) {
			ui__DropdownItem item = ((ui__DropdownItem*)dd->items.data)[i];
			gx__Color color = (i == dd->hover_index ? (_const_ui__dropdown_border_color) : (_const_ui__dropdown_drawer_color));
			gg__Context_draw_rect_filled(gg, dd->x, y + i * dd->dropdown_height, dd->width, dd->dropdown_height, color);
			gg__Context_draw_rect_empty(gg, dd->x, y + i * dd->dropdown_height, dd->width, dd->dropdown_height, _const_ui__dropdown_border_color);
			gg__Context_draw_text_def(gg, dd->x + 5, y + i * dd->dropdown_height + 5, item.text);
		}
	}
}

void ui__Dropdown_add_item(ui__Dropdown* dd, string text) {
	array_push((array*)&dd->items, _MOV((ui__DropdownItem[]){ ((ui__DropdownItem){.text = text,}) }));
}

void ui__Dropdown_open_drawer(ui__Dropdown* dd) {
	dd->open = !dd->open;
	if (!dd->open) {
		dd->hover_index = dd->selected_index;
	}
	ui__Dropdown_focus(dd);
}

void ui__dd_key_down(ui__Dropdown* dd, ui__KeyEvent* e, voidptr zzz) {
	if (dd->hidden || !dd->is_focused) {
		return;
	}
	if (dd->hover_index < 0) {
		dd->hover_index = 0;
		return;
	}

	if (e->key == (ui__Key__down)) {
		if (!dd->open) {
			ui__Dropdown_open_drawer(dd);
			return;
		}
		if (dd->hover_index < dd->items.len - 1) {
			dd->hover_index++;
		}
	}
	else if (e->key == (ui__Key__escape)) {
		ui__Dropdown_unfocus(dd);
	}
	else if (e->key == (ui__Key__up)) {
		if (dd->hover_index > 0) {
			dd->hover_index--;
		}
	}
	else if (e->key == (ui__Key__enter)) {
		dd->selected_index = dd->hover_index;
		if (dd->on_selection_changed != (voidptr)((ui__DropDownSelectionChangedFn)(0))) {
			ui__Layout parent = dd->parent;
			voidptr state = ui__Layout_name_table[parent._typ]._method_get_state(parent._object);
			dd->on_selection_changed(state, dd);
		}
		ui__Dropdown_unfocus(dd);
	}
	else {
	};
}

void ui__dd_click(ui__Dropdown* dd, ui__MouseEvent* e, voidptr zzz) {
	if (dd->hidden) {
		return;
	}
	if (!dd->is_focused) {
		return;
	}
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Dropdown_to_Interface_ui__Widget(dd)));
	if (e->y >= dd->y + dd->offset_y && e->y <= dd->y + dd->offset_y + dd->dropdown_height && e->x >= dd->x + dd->offset_x && e->x <= dd->x + dd->offset_x + dd->width) {
		ui__Dropdown_open_drawer(dd);
	} else if (dd->open) {
		int index = ((int)((e->y - dd->y - dd->offset_y) / dd->dropdown_height)) - 1;
		dd->selected_index = index;
		if (dd->on_selection_changed != (voidptr)((ui__DropDownSelectionChangedFn)(0))) {
			ui__Layout parent = dd->parent;
			voidptr state = ui__Layout_name_table[parent._typ]._method_get_state(parent._object);
			dd->on_selection_changed(state, dd);
		}
		ui__Dropdown_unfocus(dd);
	}
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Dropdown_to_Interface_ui__Widget(dd)));
}

void ui__dd_mouse_down(ui__Dropdown* dd, ui__MouseEvent* e, voidptr zzz) {
	if (dd->hidden) {
		return;
	}
	if (ui__Dropdown_point_inside(dd, e->x, e->y)) {
		ui__Dropdown_focus(dd);
	} else {
		ui__Dropdown_unfocus(dd);
	}
}

void ui__dd_mouse_move(ui__Dropdown* dd, ui__MouseMoveEvent* e, voidptr zzz) {
	if (dd->hidden) {
		return;
	}
	if (dd->open) {
		dd->hover_index = ((int)((e->y - dd->y - dd->offset_y) / dd->dropdown_height)) - 1;
	}
}

void ui__Dropdown_set_visible(ui__Dropdown* dd, bool state) {
	dd->hidden = !state;
}

void ui__Dropdown_focus(ui__Dropdown* dd) {
	ui__Focusable f = /*&ui.Focusable*/I_ui__Dropdown_to_Interface_ui__Focusable(dd);
	ui__Focusable_set_focus(&f);
	ui__Focusable_lock_focus(f);
}

void ui__Dropdown_unfocus(ui__Dropdown* dd) {
	dd->open = false;
	dd->is_focused = false;
	ui__Focusable_unlock_focus(/*&ui.Focusable*/I_ui__Dropdown_to_Interface_ui__Focusable(dd));
}

bool ui__Dropdown_point_inside(ui__Dropdown* dd, f64 x, f64 y) {
	int ddx = dd->x + dd->offset_x;
	int ddy = dd->y + dd->offset_y;
	bool _t1 = y >= ddy && y <= ddy + (dd->open ? (dd->items.len * dd->dropdown_height) : (0)) + dd->dropdown_height && x >= ddx && x <= ddx + dd->width;
	return _t1;
}

ui__DropdownItem ui__Dropdown_selected(ui__Dropdown* dd) {
	ui__DropdownItem _t1 = (*(ui__DropdownItem*)/*ee elem_sym */array_get(dd->items, dd->selected_index));
	return _t1;
}

ui__Grid* ui__grid(ui__GridParams c) {
	ui__Grid* gv = ((ui__Grid*)memdup(&(ui__Grid){.id = (string){.str=(byteptr)"", .is_lit=1},
		.header = c.header,
		.body = c.body,
		.x = 0,
		.y = 0,
		.offset_x = 0,
		.offset_y = 0,
		.height = c.height,
		.width = c.width,
		.z_index = c.z_index,
		.cell_height = c.cell_height,
		.cell_width = 40,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.ui = 0,
		.hidden = 0,
	}, sizeof(ui__Grid)));
	ui__Grid* _t1 = gv;
	return _t1;
}

void ui__Grid_init(ui__Grid* gv, ui__Layout parent) {
	gv->parent = parent;
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	gv->ui = ui;
}

// Attr: [manualfree]
void ui__Grid_cleanup(ui__Grid* g) {
	ui__Grid_free(g);
}

// Attr: [unsafe]
void ui__Grid_free(ui__Grid* g) {
	{ // Unsafe block
		string_free(&g->id);
		for (int _t1 = 0; _t1 < g->header.len; ++_t1) {
			string e = ((string*)g->header.data)[_t1];
			string_free(&e);
		}
		array_free(&g->header);
		for (int _t2 = 0; _t2 < g->body.len; ++_t2) {
			Array_string l = ((Array_string*)g->body.data)[_t2];
			array_free(&l);
		}
		_v_free(g);
	}
}

void ui__Grid_draw(ui__Grid* gv) {
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Grid_to_Interface_ui__Widget(gv)));
	f32 cell_height = gv->cell_height;
	f32 cell_width = gv->cell_width;
	Array_Array_string body = gv->body;
	Array_string header = gv->header;
	ui__check_cells(*gv);
	int x = gv->x;
	int y = gv->y;
	int text_width = 0;
	int text_height = 0;
	gg__Context_draw_rect_filled(gv->ui->gg, x, y, gv->width, gv->height, _const_gx__white);
	gg__Context_draw_rect_empty(gv->ui->gg, x, y, cell_width * header.len, cell_height, _const_gx__gray);
	for (int i = 0; i < header.len; ++i) {
		string c = ((string*)header.data)[i];
		if (i != 0) {
			gg__Context_draw_line(gv->ui->gg, x + cell_width * i, y, x + cell_width * i, y + cell_height, _const_gx__gray);
		}
		text_width = gg__Context_text_width(gv->ui->gg, c);
		text_height = gg__Context_text_height(gv->ui->gg, c);
		gg__Context_draw_text_def(gv->ui->gg, (((int)(cell_width)) - text_width) / 2 + x + ((int)(cell_width)) * i, y + ((int)(cell_height)) / 2 - text_height / 2, c);
	}
	y += ((int)(cell_height)) * (gv->header.len == 0 ? (0) : (1));
	for (int ir = 0; ir < body.len; ++ir) {
		Array_string b_c = ((Array_string*)body.data)[ir];
		gg__Context_draw_rect_empty(gv->ui->gg, x, y + (cell_height * ir), cell_width * (*(Array_string*)/*ee elem_sym */array_get(gv->body, 0)).len, cell_height, _const_gx__gray);
		for (int i = 0; i < b_c.len; ++i) {
			string c = ((string*)b_c.data)[i];
			if (i != 0) {
				gg__Context_draw_line(gv->ui->gg, x + cell_width * i, y, x + cell_width * i, y + cell_height * body.len, _const_gx__gray);
			}
			text_width = gg__Context_text_width(gv->ui->gg, c);
			text_height = gg__Context_text_height(gv->ui->gg, c);
			gg__Context_draw_text_def(gv->ui->gg, (((int)(cell_width)) - text_width) / 2 + x + ((int)(cell_width)) * i, y + ((int)(cell_height)) * ir + ((int)(cell_height)) / 2 - text_height / 2, c);
		}
	}
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Grid_to_Interface_ui__Widget(gv)));
}

int ui__min_text_width(ui__Grid _v_toheap_gv) {
ui__Grid* gv = HEAP(ui__Grid, _v_toheap_gv);
	int min = 0;
	for (int _t1 = 0; _t1 < (*(gv)).header.len; ++_t1) {
		string ch = ((string*)(*(gv)).header.data)[_t1];
		if (gg__Context_text_width((*(gv)).ui->gg, ch) > min) {
			min = gg__Context_text_width((*(gv)).ui->gg, ch);
		}
	}
	for (int _t2 = 0; _t2 < (*(gv)).body.len; ++_t2) {
		Array_string ba = ((Array_string*)(*(gv)).body.data)[_t2];
		for (int _t3 = 0; _t3 < ba.len; ++_t3) {
			string cb = ((string*)ba.data)[_t3];
			if (gg__Context_text_width((*(gv)).ui->gg, cb) > min) {
				min = gg__Context_text_width((*(gv)).ui->gg, cb);
			}
		}
	}
	int _t4 = min;
	return _t4;
}

int ui__check_cells(ui__Grid _v_toheap_gv) {
ui__Grid* gv = HEAP(ui__Grid, _v_toheap_gv);
	int len = 0;
	for (int i = 0; i < (*(gv)).body.len; ++i) {
		Array_string c = ((Array_string*)(*(gv)).body.data)[i];
		if (c.len > 0) {
			if (i == 0) {
				len = c.len;
				continue;
			} else if (len != c.len) {
				panic_debug(149, tos3("/Users/rcqls/.vmodules/ui/widget_grid.v"), tos3("ui"), tos3("check_cells"),  _SLIT("The number of rows cells must be equal"));
				VUNREACHABLE();
			}
		}
	}
	if (len != (*(gv)).header.len && (*(gv)).header.len != 0) {
		panic_debug(154, tos3("/Users/rcqls/.vmodules/ui/widget_grid.v"), tos3("ui"), tos3("check_cells"),  _SLIT("The number of rows cells must be equal"));
		VUNREACHABLE();
	}
	int _t1 = len;
	return _t1;
}

void ui__Grid_set_visible(ui__Grid* gv, bool state) {
	gv->hidden = !state;
}

void ui__Grid_set_pos(ui__Grid* gv, int x, int y) {
	gv->x = x;
	gv->y = y;
}

multi_return_int_int ui__Grid_size(ui__Grid* gv) {
	return (multi_return_int_int){.arg0=((int)(gv->width)), .arg1=((int)(gv->height))};
}

multi_return_int_int ui__Grid_propose_size(ui__Grid* gv, int w, int h) {
	gv->width = (gv->width == 0 || gv->width < gv->cell_width * ui__check_cells(*gv) ? (w) : (gv->width));
	gv->height = h;
	gv->cell_width = ((f32)(gv->width)) / (*(Array_string*)/*ee elem_sym */array_get(gv->body, 0)).len;
	gv->cell_height = gv->cell_height;
	return (multi_return_int_int){.arg0=gv->width, .arg1=gv->height};
}

bool ui__Grid_point_inside(ui__Grid* gv, f64 x, f64 y) {
	bool _t1 = ui__point_inside_T_ui__Grid(gv, x, y);
	return _t1;
}

ui__Label* ui__label(ui__LabelParams c) {
	ui__Label* lbl = ((ui__Label*)memdup(&(ui__Label){.id = c.id,
		.text = c.text,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.x = 0,
		.y = 0,
		.offset_x = 0,
		.offset_y = 0,
		.width = c.width,
		.height = c.height,
		.z_index = c.z_index,
		.adj_width = 0,
		.adj_height = 0,
		.ui = 0,
		.text_styles = (ui__TextStyles){.current = (ui__TextStyle){.id = _const_ui__no_string,.font_name = _SLIT("system"),.color = _const_gx__black,.size = 16,.align = ui__TextHorizontalAlign__left,.vertical_align = ui__TextVerticalAlign__top,.mono = 0,},.hash = new_map(sizeof(string), sizeof(ui__TextStyle), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},
		.text_size = c.text_size,
		.text_cfg = c.text_cfg,
		.hidden = 0,
		.component = 0,
	}, sizeof(ui__Label)));
	ui__Label* _t1 = lbl;
	return _t1;
}

void ui__Label_init(ui__Label* l, ui__Layout parent) {
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	l->ui = ui;
	ui__Label_init_style(l);
	ui__Label_init_size(l);
}

// Attr: [manualfree]
void ui__Label_cleanup(ui__Label* l) {
	ui__Label_free(l);
}

// Attr: [unsafe]
void ui__Label_free(ui__Label* l) {
	{ // Unsafe block
		string_free(&l->id);
		string_free(&l->text);
		_v_free(l);
	}
}

void ui__Label_init_style(ui__Label* l) {
	#if defined(CUSTOM_DEFINE_nodtw)
	{
	}
	#else
	{
		ui__DrawTextWidget dtw = /*&ui.DrawTextWidget*/I_ui__Label_to_Interface_ui__DrawTextWidget(l);
		ui__DrawTextWidget_init_style(&dtw, ((ui__TextStyleParams){.id = _const_ui__no_string,.font_name = _const_ui__no_string,.color = _const_ui__no_color,.size = -1,.align = ui__TextHorizontalAlign__none,.vertical_align = ui__TextVerticalAlign__none,}));
		ui__DrawTextWidget_update_text_size(&dtw, l->text_size);
	}
	#endif
}

void ui__Label_set_pos(ui__Label* l, int x, int y) {
	l->x = x;
	l->y = y;
}

multi_return_int_int ui__Label_adj_size(ui__Label* l) {
	if (l->adj_width == 0 || l->adj_height == 0) {
		multi_return_int_int mr_1771 = ui__text_size_T_ui__Label(l, l->text);
		int w = mr_1771.arg0;
		int h = mr_1771.arg1;
		l->adj_width = w;
		l->adj_height = h * string_split(l->text, _SLIT("\n")).len;
	}
	return (multi_return_int_int){.arg0=l->adj_width, .arg1=l->adj_height};
}

void ui__Label_init_size(ui__Label* l) {
	if (l->width == 0) {
		multi_return_int_int mr_2019 = ui__Label_adj_size(l);
		l->width = mr_2019.arg0;
	}
	if (l->height == 0) {
		multi_return_int_int mr_2071 = ui__Label_adj_size(l);
		l->height = mr_2071.arg1;
	}
}

multi_return_int_int ui__Label_size(ui__Label* l) {
	return (multi_return_int_int){.arg0=l->width, .arg1=l->height};
}

multi_return_int_int ui__Label_propose_size(ui__Label* l, int w, int h) {
	l->width = w;
	l->height = h;
	multi_return_int_int _t1 = ui__Label_size(l);
	return _t1;
}

void ui__Label_draw(ui__Label* l) {
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Label_to_Interface_ui__Widget(l)));
	Array_string splits = string_split(l->text, _SLIT("\n"));
	gg__Context_set_cfg(l->ui->gg, l->text_cfg);
	int height = gg__Context_text_height(l->ui->gg, _SLIT("W"));
	for (int i = 0; i < splits.len; ++i) {
		string split = ((string*)splits.data)[i];
		#if defined(CUSTOM_DEFINE_nodtw)
		{
		}
		#else
		{
			ui__DrawTextWidget dtw = /*&ui.DrawTextWidget*/I_ui__Label_to_Interface_ui__DrawTextWidget(l);
			ui__DrawTextWidget_load_style(dtw);
			ui__DrawTextWidget_draw_text(dtw, l->x, l->y + (height * i), split);
		}
		#endif
	}
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Label_to_Interface_ui__Widget(l)));
}

void ui__Label_set_visible(ui__Label* l, bool state) {
	l->hidden = !state;
}

bool ui__Label_point_inside(ui__Label* l, f64 x, f64 y) {
	bool _t1 = x >= l->x && x <= l->x + l->width && y >= l->y && y <= l->y + l->height;
	return _t1;
}

void ui__Label_set_text(ui__Label* l, string s) {
	l->text = s;
}

// TypeDecl
ui__ListBox* ui__listbox(ui__ListBoxParams c) {
	ui__ListBox* list = ((ui__ListBox*)memdup(&(ui__ListBox){.height = c.height,
		.width = c.width,
		.x = c.x,
		.y = c.y,
		.offset_x = 0,
		.offset_y = 0,
		.z_index = c.z_index,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.ui = 0,
		.items = __new_array_with_default(0, 0, sizeof(ui__ListItem), 0),
		.selection = c.selection,
		.draw_count = 0,
		.on_change = (voidptr)c.on_change,
		.is_focused = 0,
		.draw_lines = c.draw_lines,
		.col_bkgrnd = c.col_bkgrnd,
		.col_selected = c.col_selected,
		.col_border = c.col_border,
		.item_height = c.item_height,
		.text_offset_y = c.text_offset_y,
		.id = c.id,
		.text_styles = (ui__TextStyles){.current = (ui__TextStyle){.id = _const_ui__no_string,.font_name = _SLIT("system"),.color = _const_gx__black,.size = 16,.align = ui__TextHorizontalAlign__left,.vertical_align = ui__TextVerticalAlign__top,.mono = 0,},.hash = new_map(sizeof(string), sizeof(ui__TextStyle), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},
		.text_size = c.text_size,
		.text_cfg = c.text_cfg,
		.hidden = 0,
		.files_droped = c.files_droped,
		.adj_width = 0,
		.adj_height = 0,
		.component = 0,
		.has_scrollview = 0,
		.scrollview = 0,
		.on_scroll_change = ((ui__ScrollViewChangedFn)(0)),
	}, sizeof(ui__ListBox)));
	Map_string_string _t1 = c.items;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string id = /*key*/ *(string*)DenseArray_key(&_t1.key_values, _t2);
		id = string_clone(id);
		string text = (*(string*)DenseArray_value(&_t1.key_values, _t2));
		ui__ListBox_append_item(list, id, text, 0);
	}
	if (c.scrollview) {
		ui__scrollview_add_T_ui__ListBox(list);
	}
	ui__ListBox* _t5 = list;
	return _t5;
}

void ui__ListBox_init(ui__ListBox* lb, ui__Layout parent) {
	lb->parent = parent;
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	lb->ui = ui;
	ui__ListBox_init_style(lb);
	lb->draw_count = lb->height / lb->item_height;
	lb->text_offset_y = (lb->item_height - ui__text_height_T_ui__ListBox(lb, _SLIT("W"))) / 2;
	if (lb->text_offset_y < 0) {
		lb->text_offset_y = 0;
	}
	ui__ListBox_init_size(lb);
	ui__ListBox_init_items(lb);
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__ListBox_to_Interface_ui__ScrollableWidget(lb))) {
		ui__ScrollView_init(lb->scrollview, parent);
		ui__scrollview_update_T_ui__ListBox(lb);
	}
	eventbus__Subscriber* subscriber = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_click, (voidptr)ui__on_change, lb);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_key_up, (voidptr)ui__on_key_up, lb);
	ui__EventMngr_add_receiver(&lb->ui->window->evt_mngr, /*&ui.Widget*/I_ui__ListBox_to_Interface_ui__Widget(lb), new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){string_clone(_const_ui__events.on_mouse_down), string_clone(_const_ui__events.on_scroll)})));
	if (lb->files_droped) {
		eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_files_droped, (voidptr)ui__on_files_droped, lb);
	}
}

// Attr: [manualfree]
void ui__ListBox_cleanup(ui__ListBox* lb) {
	eventbus__Subscriber* subscriber = ui__Layout_name_table[lb->parent._typ]._method_get_subscriber(lb->parent._object);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_click, lb);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_key_up, lb);
	ui__EventMngr_rm_receiver(&lb->ui->window->evt_mngr, /*&ui.Widget*/I_ui__ListBox_to_Interface_ui__Widget(lb), new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){string_clone(_const_ui__events.on_mouse_down), string_clone(_const_ui__events.on_scroll)})));
	if (lb->files_droped) {
		eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_files_droped, lb);
	}
	ui__ListBox_free(lb);
}

// Attr: [unsafe]
void ui__ListBox_free(ui__ListBox* lb) {
	{ // Unsafe block
		string_free(&lb->id);
		for (int _t1 = 0; _t1 < lb->items.len; ++_t1) {
			ui__ListItem item = ((ui__ListItem*)lb->items.data)[_t1];
			ui__ListItem_free(&item);
		}
		array_free(&lb->items);
		_v_free(lb);
	}
}

// Attr: [unsafe]
void ui__ListItem_free(ui__ListItem* item) {
	{ // Unsafe block
		string_free(&item->id);
		string_free(&item->text);
		string_free(&item->draw_text);
	}
}

void ui__ListBox_init_style(ui__ListBox* lb) {
	#if defined(CUSTOM_DEFINE_nodtw)
	{
	}
	#else
	{
		ui__DrawTextWidget dtw = /*&ui.DrawTextWidget*/I_ui__ListBox_to_Interface_ui__DrawTextWidget(lb);
		ui__DrawTextWidget_init_style(&dtw, ((ui__TextStyleParams){.id = _const_ui__no_string,.font_name = _const_ui__no_string,.color = _const_ui__no_color,.size = -1,.align = ui__TextHorizontalAlign__none,.vertical_align = ui__TextVerticalAlign__none,}));
		ui__DrawTextWidget_update_text_size(&dtw, lb->text_size);
	}
	#endif
}

void ui__ListBox_init_items(ui__ListBox* lb) {
	for (int i = 0; i < lb->items.len; ++i) {
		ui__ListItem* item = ((ui__ListItem*)lb->items.data) + i;
		item->draw_text = string_substr(item->text, 0, ui__ListBox_get_draw_to(lb, item->text));
		item->x = 0;
		item->y = lb->item_height * i;
	}
}

void ui__ListBox_add_item(ui__ListBox* lb, string id, string text) {
	ui__ListBox_append_item(lb, id, text, ui__ListBox_get_draw_to(lb, text));
	ui__ListBox_update_adj_size(lb);
}

int ui__ListBox_get_draw_to(ui__ListBox* lb, string text) {
	if (lb->has_scrollview) {
		int _t1 = 0;
		return _t1;
	}
	int width = ui__text_width_T_ui__ListBox(lb, text);
	int real_w = lb->width + _const_ui___text_offset_x * 2;
	int draw_to = text.len;
	if (width >= real_w) {
		draw_to = ((int)(((f32)(text.len)) * (((f32)(real_w)) / ((f32)(width)))));
		for (;;) {
			if (!(draw_to > 1 && ui__text_width_T_ui__ListBox(lb, string_substr(text, 0, draw_to)) > real_w)) break;
			draw_to--;
		}
	}
	int _t2 = draw_to;
	return _t2;
}

void ui__ListBox_append_item(ui__ListBox* lb, string id, string text, int draw_to) {
	array_push((array*)&lb->items, _MOV((ui__ListItem[]){ ((ui__ListItem){
		.id = id,
		.list = lb,
		.x = 0,
		.y = lb->item_height * lb->items.len,
		.text = text,
		.draw_text = string_substr(text, 0, draw_to),
	}) }));
}

bool ui__ListBox_is_selected(ui__ListBox* lb) {
	if (lb->selection < 0 || lb->selection >= lb->items.len) {
		bool _t1 = false;
		return _t1;
	}
	bool _t2 = true;
	return _t2;
}

Array_string ui__ListBox_ids(ui__ListBox* lb) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < lb->items.len; ++_t1) {
		ui__ListItem item = ((ui__ListItem*)lb->items.data)[_t1];
		array_push((array*)&res, _MOV((string[]){ string_clone(item.id) }));
	}
	Array_string _t3 = res;
	return _t3;
}

Array_string ui__ListBox_values(ui__ListBox* lb) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < lb->items.len; ++_t1) {
		ui__ListItem item = ((ui__ListItem*)lb->items.data)[_t1];
		array_push((array*)&res, _MOV((string[]){ string_clone(item.text) }));
	}
	Array_string _t3 = res;
	return _t3;
}

Array_int ui__ListBox_indices(ui__ListBox* lb) {
	Array_int res = __new_array_with_default(0, 0, sizeof(int), 0);
	for (int inx = 0; inx < lb->items.len; ++inx) {
		array_push((array*)&res, _MOV((int[]){ inx }));
	}
	Array_int _t2 = res;
	return _t2;
}

Option_multi_return_string_string ui__ListBox_selected(ui__ListBox* lb) {
	if (!ui__ListBox_is_selected(lb)) {
		return (Option_multi_return_string_string){ .state=2, .err=_v_error(_SLIT("Nothing is selected")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_multi_return_string_string _t2;
	opt_ok(&(multi_return_string_string/*X*/[]) { (multi_return_string_string){.arg0=(*(ui__ListItem*)/*ee elem_sym */array_get(lb->items, lb->selection)).id, .arg1=(*(ui__ListItem*)/*ee elem_sym */array_get(lb->items, lb->selection)).text} }, (Option*)(&_t2), sizeof(multi_return_string_string));
	return _t2;
}

Option_int ui__ListBox_selected_inx(ui__ListBox* lb) {
	if (!ui__ListBox_is_selected(lb)) {
		return (Option_int){ .state=2, .err=_v_error(_SLIT("Nothing is selected")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Option_int _t2;
	opt_ok(&(int[]) { lb->selection }, (Option*)(&_t2), sizeof(int));
	return _t2;
}

void ui__ListBox_set_text(ui__ListBox* lb, string id, string text) {
	for (int i = 0; i < lb->items.len; ++i) {
		if (string__eq((*(ui__ListItem*)/*ee elem_sym */array_get(lb->items, i)).id, id)) {
			(*(ui__ListItem*)/*ee elem_sym */array_get(lb->items, i)).text = text;
			(*(ui__ListItem*)/*ee elem_sym */array_get(lb->items, i)).draw_text = string_substr(text, 0, ui__ListBox_get_draw_to(lb, text));
			break;
		}
	}
}

void ui__ListBox_remove_item(ui__ListBox* lb, string id) {
	for (int i = 0; i < lb->items.len; ++i) {
		if (string__eq((*(ui__ListItem*)/*ee elem_sym */array_get(lb->items, i)).id, id)) {
			ui__ListBox_remove_inx(lb, i);
			ui__ListBox_update_adj_size(lb);
			break;
		}
	}
}

void ui__ListBox_remove_inx(ui__ListBox* lb, int i) {
	if (i < 0 || i >= lb->items.len) {
		return;
	}
	for (int j = (i + 1); j < lb->items.len; ++j) {
		(*(ui__ListItem*)/*ee elem_sym */array_get(lb->items, j)).y -= lb->item_height;
	}
	array_delete(&lb->items, i);
}

// Attr: [manualfree]
void ui__ListBox_clear(ui__ListBox* lb) {
	for (int _t1 = 0; _t1 < lb->items.len; ++_t1) {
		ui__ListItem item = ((ui__ListItem*)lb->items.data)[_t1];
		ui__ListItem_free(&item);
	}
	array_clear(&lb->items);
	lb->selection = -1;
}

void ui__ListBox_draw_item(ui__ListBox* lb, ui__ListItem _v_toheap_li, bool selected) {
ui__ListItem* li = HEAP(ui__ListItem, _v_toheap_li);
	gx__Color col = (selected ? (lb->col_selected) : (lb->col_bkgrnd));
	int width = (lb->has_scrollview && lb->adj_width > lb->width ? (lb->adj_width) : (lb->width));
	gg__Context_draw_rect_filled(lb->ui->gg, (*(li)).x + lb->x + _const_ui___text_offset_x, (*(li)).y + lb->y + lb->text_offset_y, width - 2 * _const_ui___text_offset_x, lb->item_height, col);
	#if defined(CUSTOM_DEFINE_nodtw)
	{
	}
	#else
	{
		ui__DrawTextWidget_draw_text(/*&ui.DrawTextWidget*/I_ui__ListBox_to_Interface_ui__DrawTextWidget(lb), (*(li)).x + lb->x + _const_ui___text_offset_x, (*(li)).y + lb->y + lb->text_offset_y, (lb->has_scrollview ? ((*(li)).text) : ((*(li)).draw_text)));
	}
	#endif
	if (lb->draw_lines) {
		gg__Context_draw_rect_empty(lb->ui->gg, (*(li)).x + lb->x + _const_ui___text_offset_x, (*(li)).y + lb->y + lb->text_offset_y, width, lb->item_height, lb->col_border);
	}
}

multi_return_int_int ui__ListBox_visible_items(ui__ListBox* lb) {
	int j1 = 0;
	int j2 = 0;
	if (lb->has_scrollview) {
		j1 = lb->scrollview->offset_y / lb->item_height;
		if (j1 < 0) {
			j1 = 0;
		}
	}
	if (lb->has_scrollview) {
		j2 = (lb->scrollview->offset_y + lb->height) / lb->item_height;
	} else {
		j2 = lb->height / lb->item_height;
	}
	int jmax = lb->items.len - 1;
	if (j2 > jmax) {
		j2 = jmax;
	}
	return (multi_return_int_int){.arg0=j1, .arg1=j2};
}

void ui__ListBox_draw(ui__ListBox* lb) {
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__ListBox_to_Interface_ui__Widget(lb)));
	ui__DrawTextWidget_load_style(/*&ui.DrawTextWidget*/I_ui__ListBox_to_Interface_ui__DrawTextWidget(lb));
	ui__scrollview_draw_begin_T_ui__ListBox(lb);
	int height = (lb->has_scrollview && lb->adj_height > lb->height ? (lb->adj_height + lb->text_offset_y) : (lb->height));
	gg__Context_draw_rect_filled(lb->ui->gg, lb->x, lb->y, lb->width, height, lb->col_bkgrnd);
	multi_return_int_int mr_9984 = ui__ListBox_visible_items(lb);
	int from = mr_9984.arg0;
	int to = mr_9984.arg1;
	if (lb->items.len == 0) {
		#if defined(CUSTOM_DEFINE_nodtw)
		{
		}
		#else
		{
			ui__DrawTextWidget_draw_styled_text(/*&ui.DrawTextWidget*/I_ui__ListBox_to_Interface_ui__DrawTextWidget(lb), lb->x + _const_ui___text_offset_x, lb->y + lb->text_offset_y, (lb->files_droped ? (_SLIT("Empty listbox. Drop files here ...")) : (_SLIT(""))), ((ui__TextStyleParams){.id = _const_ui__no_string,.font_name = _const_ui__no_string,.color = _const_gx__gray,.size = -1,.align = ui__TextHorizontalAlign__none,.vertical_align = ui__TextVerticalAlign__none,}));
		}
		#endif
	} else {
		for (int inx = 0; inx < lb->items.len; ++inx) {
			ui__ListItem item = ((ui__ListItem*)lb->items.data)[inx];
			if (inx >= lb->draw_count && !ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__ListBox_to_Interface_ui__ScrollableWidget(lb))) {
				break;
			}
			if (!ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__ListBox_to_Interface_ui__ScrollableWidget(lb)) || (inx >= from && inx <= to)) {
				ui__ListBox_draw_item(lb, item, inx == lb->selection);
			}
		}
	}
	if (!lb->draw_lines) {
		gg__Context_draw_rect_empty(lb->ui->gg, lb->x - 1, lb->y - 1, lb->width + 2, height + 2, lb->col_border);
	}
	ui__scrollview_draw_end_T_ui__ListBox(lb);
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__ListBox_to_Interface_ui__Widget(lb)));
}

bool ui__ListBox_point_inside(ui__ListBox* lb, f64 x, f64 y) {
	if (lb->has_scrollview) {
		bool _t1 = ui__ScrollView_point_inside(lb->scrollview, x, y, ui__ScrollViewPart__view);
		return _t1;
	} else {
		bool _t2 = ui__point_inside_T_ui__ListBox(lb, x, y);
		return _t2;
	}
	return 0;
}

bool ui__ListItem_point_inside(ui__ListItem* li, f64 x, f64 y) {
	int lix = li->x + li->list->x + li->list->offset_x;
	int liy = li->y + li->list->y + li->list->offset_y;
	bool _t1 = x >= lix && x <= lix + li->list->width && y >= liy && y <= liy + li->list->item_height;
	return _t1;
}

void ui__on_change(ui__ListBox* lb, ui__MouseEvent* e, ui__Window* window) {
	if (lb->hidden) {
		return;
	}
	if (!ui__Window_is_top_widget(/*rec*/*lb->ui->window, /*&ui.Widget*/I_ui__ListBox_to_Interface_ui__Widget(lb), _const_ui__events.on_mouse_down)) {
		return;
	}
	if (e->action != ui__MouseAction__up) {
		return;
	}
	if (!ui__ListBox_point_inside(lb, e->x, e->y)) {
		ui__ListBox_unfocus(lb);
		return;
	}
	ui__ListBox_focus(lb);
	for (int inx = 0; inx < lb->items.len; ++inx) {
		ui__ListItem item = ((ui__ListItem*)lb->items.data)[inx];
		if (!lb->has_scrollview && inx >= lb->draw_count) {
			break;
		}
		if (ui__ListItem_point_inside(&item, e->x, e->y)) {
			if (lb->selection != inx) {
				lb->selection = inx;
				if (lb->on_change != (voidptr)((ui__ListBoxSelectionChangedFn)(0))) {
					lb->on_change(window->state, lb);
				}
			}
			break;
		}
	}
}

void ui__on_files_droped(ui__ListBox* lb, ui__MouseEvent* e, ui__Window* window) {
	if (lb->hidden) {
		return;
	}
	if (!ui__ListBox_point_inside(lb, e->x, e->y)) {
		return;
	}
	int num_dropped = ui__get_num_dropped_files();
	for (int i = 0; i < num_dropped; ++i) {
		string path = ui__get_dropped_file_path(i);
		ui__ListBox_add_item(lb, path, string_clone(path));
	}
	ui__Window_update_layout(lb->ui->window);
}

void ui__on_key_up(ui__ListBox* lb, ui__KeyEvent* e, ui__Window* window) {
	if (lb->hidden) {
		return;
	}
	if (!lb->is_focused) {
		return;
	}

	if (e->key == (ui__Key__down)) {
		if (lb->selection >= lb->draw_count - 1) {
			return;
		}
		if (lb->selection >= lb->items.len - 1) {
			return;
		}
		lb->selection++;
	}
	else if (e->key == (ui__Key__up)) {
		if (lb->selection <= 0) {
			return;
		}
		lb->selection--;
	}
	else {
		return;
	};
	if (lb->on_change != (voidptr)((ui__ListBoxSelectionChangedFn)(0))) {
		lb->on_change(window->state, lb);
	}
}

void ui__ListBox_set_pos(ui__ListBox* lb, int x, int y) {
	if (lb->x != x || lb->y != y) {
		lb->x = x;
		lb->y = y;
	}
}

void ui__ListBox_set_visible(ui__ListBox* lb, bool state) {
	lb->hidden = !state;
}

void ui__ListBox_focus(ui__ListBox* lb) {
	ui__Focusable f = /*&ui.Focusable*/I_ui__ListBox_to_Interface_ui__Focusable(lb);
	ui__Focusable_set_focus(&f);
}

void ui__ListBox_unfocus(ui__ListBox* lb) {
	lb->is_focused = false;
}

multi_return_int_int ui__ListBox_adj_size(ui__ListBox* lb) {
	if (lb->adj_width == 0) {
		int width = 0;
		for (int _t1 = 0; _t1 < lb->items.len; ++_t1) {
			ui__ListItem item = ((ui__ListItem*)lb->items.data)[_t1];
			width = ui__text_width_T_ui__ListBox(lb, item.text) + _const_ui___text_offset_x * 2;
			if (width > lb->adj_width) {
				lb->adj_width = width;
			}
		}
	}
	if (lb->adj_height == 0) {
		lb->adj_height = lb->items.len * lb->item_height + 2 * lb->text_offset_y;
	}
	return (multi_return_int_int){.arg0=lb->adj_width, .arg1=lb->adj_height};
}

void ui__ListBox_update_adj_size(ui__ListBox* lb) {
	int width = 0;
	for (int _t1 = 0; _t1 < lb->items.len; ++_t1) {
		ui__ListItem item = ((ui__ListItem*)lb->items.data)[_t1];
		width = ui__text_width_T_ui__ListBox(lb, item.text) + _const_ui___text_offset_x * 2;
		if (width > lb->adj_width) {
			lb->adj_width = width;
		}
	}
	lb->adj_height = lb->items.len * lb->item_height;
	ui__scrollview_update_T_ui__ListBox(lb);
}

void ui__ListBox_init_size(ui__ListBox* lb) {
	if (lb->width == 0) {
		multi_return_int_int mr_14409 = ui__ListBox_adj_size(lb);
		lb->width = mr_14409.arg0;
	}
	if (lb->height == 0) {
		multi_return_int_int mr_14464 = ui__ListBox_adj_size(lb);
		lb->height = mr_14464.arg1;
	}
}

multi_return_int_int ui__ListBox_size(ui__ListBox* lb) {
	return (multi_return_int_int){.arg0=lb->width, .arg1=lb->height};
}

multi_return_int_int ui__ListBox_propose_size(ui__ListBox* lb, int w, int h) {
	ui__ListBox_resize(lb, w, h);
	ui__scrollview_update_T_ui__ListBox(lb);
	return (multi_return_int_int){.arg0=lb->width, .arg1=lb->height};
}

void ui__ListBox_resize(ui__ListBox* lb, int width, int height) {
	if (width != lb->width) {
		ui__ListBox_init_items(lb);
	}
	lb->width = width;
	lb->height = height;
	lb->draw_count = lb->height / lb->item_height;
}

void ui__ListBox_set_children_pos(ui__ListBox* lb) {
}

// TypeDecl
ui__Menu* ui__menu(ui__MenuParams c) {
	ui__Menu* _t1 = ((ui__Menu*)memdup(&(ui__Menu){.id = c.id,
		.offset_x = 0,
		.offset_y = 0,
		.hidden = 0,
		.ui = 0,
		.text_cfg = c.text_cfg,
		.text_size = c.text_size,
		.component = 0,
		.width = c.width,
		.height = 0,
		.text = c.text,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.x = 0,
		.y = 0,
		.z_index = c.z_index,
		.items = c.items,
	}, sizeof(ui__Menu)));
	return _t1;
}

void ui__Menu_init(ui__Menu* m, ui__Layout parent) {
	m->parent = parent;
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	m->ui = ui;
	ui__init_text_cfg(HEAP(ui__DrawText, /*&ui.DrawText*/I_ui__Menu_to_Interface_ui__DrawText(m)));
	ui__Menu_update_height(m);
	eventbus__Subscriber* subscriber = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_click, (voidptr)ui__menu_click, m);
}

// Attr: [manualfree]
void ui__Menu_cleanup(ui__Menu* m) {
	eventbus__Subscriber* subscriber = ui__Layout_name_table[m->parent._typ]._method_get_subscriber(m->parent._object);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_click, m);
	ui__Menu_free(m);
}

// Attr: [unsafe]
void ui__Menu_free(ui__Menu* m) {
	{ // Unsafe block
		string_free(&m->id);
		string_free(&m->text);
		for (int _t1 = 0; _t1 < m->items.len; ++_t1) {
			ui__MenuItem item = ((ui__MenuItem*)m->items.data)[_t1];
			string_free(&item.text);
		}
		array_free(&m->items);
		_v_free(m);
	}
}

void ui__menu_click(ui__Menu* m, ui__MouseEvent* e, ui__Window* window) {
	if (m->hidden) {
		return;
	}
	if (ui__Menu_point_inside(m, e->x, e->y)) {
		int i = ((int)((e->y - m->y - m->offset_y) / _const_ui__menu_height));
		ui__MenuItem item = (*(ui__MenuItem*)/*ee elem_sym */array_get(m->items, i));
		if (item.action != (voidptr)((voidptr)(0))) {
			ui__Layout parent = m->parent;
			voidptr state = ui__Layout_name_table[parent._typ]._method_get_state(parent._object);
			item.action(m, &item, state);
		}
	}
}

void ui__Menu_set_pos(ui__Menu* m, int x, int y) {
	m->x = x;
	m->y = y;
}

void ui__Menu_update_height(ui__Menu* m) {
	m->height = m->items.len * _const_ui__menu_height;
}

multi_return_int_int ui__Menu_size(ui__Menu* m) {
	ui__Menu_update_height(m);
	return (multi_return_int_int){.arg0=m->width, .arg1=m->height};
}

multi_return_int_int ui__Menu_propose_size(ui__Menu* m, int w, int h) {
	m->width = w;
	m->height = h;
	return (multi_return_int_int){.arg0=m->width, .arg1=m->height};
}

void ui__Menu_draw(ui__Menu* m) {
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Menu_to_Interface_ui__Widget(m)));
	if (m->hidden) {
		return;
	}
	gg__Context* gg = m->ui->gg;
	gg__Context_draw_rect_filled(gg, m->x, m->y, m->width, m->height, _const_ui__menu_color);
	gg__Context_draw_rect_empty(gg, m->x, m->y, m->width, m->height, _const_ui__menu_border_color);
	for (int i = 0; i < m->items.len; ++i) {
		ui__MenuItem item = ((ui__MenuItem*)m->items.data)[i];
		gg__Context_draw_text_def(m->ui->gg, m->x + 10, m->y + i * _const_ui__menu_height + 10, item.text);
	}
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Menu_to_Interface_ui__Widget(m)));
}

void ui__Menu_add_item(ui__Menu* m, string text, void (*action)(ui__Menu* m, ui__MenuItem* item, voidptr state)) {
	array_push((array*)&m->items, _MOV((ui__MenuItem[]){ ((ui__MenuItem){.action = (voidptr)action,.text = text,}) }));
}

void ui__Menu_set_visible(ui__Menu* m, bool state) {
	m->hidden = !state;
}

bool ui__Menu_point_inside(ui__Menu* m, f64 x, f64 y) {
	bool _t1 = ui__point_inside_T_ui__Menu(m, x, y);
	return _t1;
}

void ui__Menu_set_text(ui__Menu* m, string s) {
	m->text = s;
}

// TypeDecl
ui__Picture* ui__picture(ui__PictureParams _v_toheap_c) {
ui__PictureParams* c = HEAP(ui__PictureParams, _v_toheap_c);
	if (!os__exists((*(c)).path)) {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("V UI: picture file \""), 0xfe10, {.d_s = (*(c)).path}}, {_SLIT("\" not found"), 0, { .d_c = 0 }}})));
	}
	ui__Picture* pic = ((ui__Picture*)memdup(&(ui__Picture){.id = (*(c)).id,
		.offset_x = 0,
		.offset_y = 0,
		.hidden = 0,
		.component = 0,
		.width = (*(c)).width,
		.height = (*(c)).height,
		.text = (string){.str=(byteptr)"", .is_lit=1},
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.x = 0,
		.y = 0,
		.z_index = (*(c)).z_index,
		.movable = (*(c)).movable,
		.path = (*(c)).path,
		.ui = 0,
		.image = (*(c)).image,
		.on_click = (voidptr)(*(c)).on_click,
		.use_cache = (*(c)).use_cache,
		.tooltip = ((ui__TooltipMessage){.text = (*(c)).tooltip,.side = (*(c)).tooltip_side,}),
	}, sizeof(ui__Picture)));
	ui__Picture* _t1 = pic;
	return _t1;
}

void ui__Picture_init(ui__Picture* pic, ui__Layout parent) {
	pic->parent = parent;
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	pic->ui = ui;
	eventbus__Subscriber* subscriber = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_click, (voidptr)ui__pic_click, pic);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_down, (voidptr)ui__pic_mouse_down, pic);
	ui__EventMngr_add_receiver(&pic->ui->window->evt_mngr, /*&ui.Widget*/I_ui__Picture_to_Interface_ui__Widget(pic), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(_const_ui__events.on_mouse_down)})));
	if (!pic->use_cache && _IN_MAP(ADDR(string, pic->path), ADDR(map, ui->resource_cache))) {
		pic->image = (*(gg__Image*)map_get(ADDR(map, ui->resource_cache), &(string[]){pic->path}, &(gg__Image[]){ (gg__Image){.id = 0,.width = 0,.height = 0,.nr_channels = 0,.ok = 0,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},.simg_ok = 0,.simg = {0},.path = (string){.str=(byteptr)"", .is_lit=1},} }));
	} else {
		pic->image = gg__Context_create_image(pic->ui->gg, pic->path);
		(*(gg__Image*)map_get_and_set((map*)&ui->resource_cache, &(string[]){pic->path}, &(gg__Image[]){ (gg__Image){.id = 0,.width = 0,.height = 0,.nr_channels = 0,.ok = 0,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},.simg_ok = 0,.simg = {0},.path = (string){.str=(byteptr)"", .is_lit=1},} })) = pic->image;
	}
	if (pic->width == 0 || pic->height == 0) {
		pic->width = pic->image.width;
		pic->height = pic->image.height;
	}
	if ((pic->tooltip.text).len != 0) {
		ui__Window* win = ui->window;
		ui__Window_append_tooltip(win, /*&ui.Widget*/I_ui__Picture_to_Interface_ui__Widget(pic), pic->tooltip);
	}
}

// Attr: [manualfree]
void ui__Picture_cleanup(ui__Picture* p) {
	eventbus__Subscriber* subscriber = ui__Layout_name_table[p->parent._typ]._method_get_subscriber(p->parent._object);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_click, p);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_down, p);
	ui__EventMngr_rm_receiver(&p->ui->window->evt_mngr, /*&ui.Widget*/I_ui__Picture_to_Interface_ui__Widget(p), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(_const_ui__events.on_mouse_down)})));
	ui__Picture_free(p);
}

// Attr: [unsafe]
void ui__Picture_free(ui__Picture* p) {
	_v_free(p);
}

void ui__pic_click(ui__Picture* pic, ui__MouseEvent* e, ui__Window* window) {
	if (pic->hidden) {
		return;
	}
	if (ui__Picture_point_inside(pic, e->x, e->y)) {
		if (((int)(e->action)) == 0) {
			if (pic->on_click != (voidptr)((voidptr)(0))) {
				pic->on_click(window->state, pic);
			}
		}
	}
}

void ui__pic_mouse_down(ui__Picture* pic, ui__MouseEvent* e, ui__Window* window) {
	if (pic->hidden) {
		return;
	}
	if (ui__Picture_point_inside(pic, e->x, e->y)) {
		if (pic->movable) {
			ui__drag_register(/*&ui.Widget*/I_ui__Picture_to_Interface_ui__Widget(pic), pic->ui, e);
		}
	}
}

void ui__Picture_set_pos(ui__Picture* pic, int x, int y) {
	pic->x = x;
	pic->y = y;
}

multi_return_int_int ui__Picture_size(ui__Picture* pic) {
	return (multi_return_int_int){.arg0=pic->width, .arg1=pic->height};
}

multi_return_int_int ui__Picture_propose_size(ui__Picture* pic, int w, int h) {
	return (multi_return_int_int){.arg0=pic->width, .arg1=pic->height};
}

void ui__Picture_draw(ui__Picture* pic) {
	gg__Context_draw_image(pic->ui->gg, pic->x + pic->offset_x, pic->y + pic->offset_y, pic->width, pic->height, (voidptr)&/*qq*/pic->image);
}

void ui__Picture_set_visible(ui__Picture* pic, bool state) {
	pic->hidden = !state;
}

bool ui__Picture_point_inside(ui__Picture* pic, f64 x, f64 y) {
	bool _t1 = ui__point_inside_T_ui__Picture(pic, x, y);
	return _t1;
}

ui__ProgressBar* ui__progressbar(ui__ProgressBarParams c) {
	ui__ProgressBar* pb = ((ui__ProgressBar*)memdup(&(ui__ProgressBar){.id = c.id,
		.height = c.height,
		.width = c.width,
		.x = 0,
		.y = 0,
		.offset_x = 0,
		.offset_y = 0,
		.z_index = c.z_index,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.ui = 0,
		.val = c.val,
		.min = c.min,
		.max = c.max,
		.hidden = 0,
		.component = 0,
	}, sizeof(ui__ProgressBar)));
	ui__ProgressBar* _t1 = pb;
	return _t1;
}

void ui__ProgressBar_init(ui__ProgressBar* pb, ui__Layout parent) {
	pb->parent = parent;
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	pb->ui = ui;
}

// Attr: [manualfree]
void ui__ProgressBar_cleanup(ui__ProgressBar* pb) {
	ui__ProgressBar_free(pb);
}

// Attr: [unsafe]
void ui__ProgressBar_free(ui__ProgressBar* pb) {
	{ // Unsafe block
		string_free(&pb->id);
		_v_free(pb);
	}
}

void ui__ProgressBar_set_pos(ui__ProgressBar* pb, int x, int y) {
	pb->x = x;
	pb->y = y;
}

multi_return_int_int ui__ProgressBar_size(ui__ProgressBar* pb) {
	return (multi_return_int_int){.arg0=pb->width, .arg1=pb->height};
}

multi_return_int_int ui__ProgressBar_propose_size(ui__ProgressBar* pb, int w, int h) {
	pb->width = w;
	pb->height = h;
	return (multi_return_int_int){.arg0=pb->width, .arg1=pb->height};
}

void ui__ProgressBar_draw(ui__ProgressBar* pb) {
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__ProgressBar_to_Interface_ui__Widget(pb)));
	gg__Context_draw_rect_filled(pb->ui->gg, pb->x, pb->y, pb->width, pb->height, _const_ui__progress_bar_background_color);
	gg__Context_draw_rect_empty(pb->ui->gg, pb->x, pb->y, pb->width, pb->height, _const_ui__progress_bar_background_border_color);
	int width = ((int)(((f64)(pb->width)) * (((f64)(pb->val)) / ((f64)(pb->max)))));
	gg__Context_draw_rect_empty(pb->ui->gg, pb->x, pb->y, width, pb->height, _const_ui__progress_bar_border_color);
	gg__Context_draw_rect_filled(pb->ui->gg, pb->x, pb->y, width, pb->height, _const_ui__progress_bar_color);
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__ProgressBar_to_Interface_ui__Widget(pb)));
}

bool ui__ProgressBar_point_inside(ui__ProgressBar* pb, f64 x, f64 y) {
	bool _t1 = ui__point_inside_T_ui__ProgressBar(pb, x, y);
	return _t1;
}

void ui__ProgressBar_set_visible(ui__ProgressBar* pb, bool state) {
	pb->hidden = !state;
}

// TypeDecl
ui__Radio* ui__radio(ui__RadioParams c) {
	ui__Radio* r = ((ui__Radio*)memdup(&(ui__Radio){.id = c.id,
		.selected_index = 0,
		.values = c.values,
		.title = c.title,
		.height = 20,
		.width = c.width,
		.real_height = 20,
		.real_width = 0,
		.widths = __new_array(0, 0, sizeof(int)),
		.adj_height = 0,
		.adj_width = 0,
		.x = 0,
		.y = 0,
		.offset_x = 0,
		.offset_y = 0,
		.z_index = c.z_index,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.is_focused = 0,
		.is_checked = 0,
		.ui = 0,
		.text_styles = (ui__TextStyles){.current = (ui__TextStyle){.id = _const_ui__no_string,.font_name = _SLIT("system"),.color = _const_gx__black,.size = 16,.align = ui__TextHorizontalAlign__left,.vertical_align = ui__TextVerticalAlign__top,.mono = 0,},.hash = new_map(sizeof(string), sizeof(ui__TextStyle), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},
		.text_size = c.text_size,
		.text_cfg = c.text_cfg,
		.hidden = 0,
		.horizontal = c.horizontal,
		.compact = c.compact,
		.component = 0,
		.on_click = (voidptr)c.on_click,
	}, sizeof(ui__Radio)));
	ui__Radio_update_size(r);
	ui__Radio* _t1 = r;
	return _t1;
}

void ui__Radio_init(ui__Radio* r, ui__Layout parent) {
	r->parent = parent;
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	r->ui = ui;
	if (r->width == 0) {
		ui__Radio_set_size_from_values(r);
	}
	ui__Radio_init_style(r);
	eventbus__Subscriber* subscriber = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_key_down, (voidptr)ui__radio_key_down, r);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_click, (voidptr)ui__radio_click, r);
}

// Attr: [manualfree]
void ui__Radio_cleanup(ui__Radio* r) {
	eventbus__Subscriber* subscriber = ui__Layout_name_table[r->parent._typ]._method_get_subscriber(r->parent._object);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_key_down, r);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_click, r);
	ui__Radio_free(r);
}

// Attr: [unsafe]
void ui__Radio_free(ui__Radio* r) {
	{ // Unsafe block
		string_free(&r->id);
		for (int _t1 = 0; _t1 < r->values.len; ++_t1) {
			string v = ((string*)r->values.data)[_t1];
			string_free(&v);
		}
		array_free(&r->values);
		string_free(&r->title);
		_v_free(r);
	}
}

void ui__Radio_init_style(ui__Radio* r) {
	#if defined(CUSTOM_DEFINE_nodtw)
	{
	}
	#else
	{
		ui__DrawTextWidget dtw = /*&ui.DrawTextWidget*/I_ui__Radio_to_Interface_ui__DrawTextWidget(r);
		ui__DrawTextWidget_init_style(&dtw, ((ui__TextStyleParams){.id = _const_ui__no_string,.font_name = _const_ui__no_string,.color = _const_ui__no_color,.size = -1,.align = ui__TextHorizontalAlign__none,.vertical_align = ui__TextVerticalAlign__none,}));
		ui__DrawTextWidget_update_text_size(&dtw, r->text_size);
	}
	#endif
}

void ui__radio_key_down(ui__Radio* r, ui__KeyEvent* e, ui__Window* window) {
	if (r->hidden) {
		return;
	}
	if (!r->is_focused) {
		return;
	}

	if (e->key == (ui__Key__enter) || e->key == (ui__Key__space) || e->key == (ui__Key__right) || e->key == (ui__Key__down)) {
		ui__Radio_select_next_value(r);
	}
	else if (e->key == (ui__Key__left) || e->key == (ui__Key__up)) {
		ui__Radio_select_prev_value(r);
	}
	else {
	};
}

void ui__radio_click(ui__Radio* r, ui__MouseEvent* e, ui__Window* window) {
	if (r->hidden) {
		return;
	}
	if (!ui__Radio_point_inside(r, e->x, e->y)) {
		return;
	}
	if (r->horizontal) {
		int x = e->x - r->x;
		if (r->compact) {
			int w = 0;
			r->selected_index = r->values.len - 1;
			for (int i = 0; i < (r->values.len - 1); ++i) {
				w += (*(int*)/*ee elem_sym */array_get(r->widths, i));
				if (x <= w) {
					r->selected_index = i;
					break;
				}
			}
		} else {
			int dx = ((r->title).len == 0 ? (0) : (5));
			r->selected_index = x / (r->width + dx);
			if (r->selected_index == r->values.len) {
				r->selected_index = r->values.len - 1;
			}
		}
	} else {
		int dy = ((r->title).len == 0 ? (15) : (0));
		int y = e->y - r->y + dy;
		r->selected_index = y / (r->height + 5);
		if (r->selected_index == r->values.len) {
			r->selected_index = r->values.len - 1;
		}
	}
	if (r->on_click != (voidptr)((voidptr)(0))) {
		r->on_click(window->state, r);
	}
}

void ui__Radio_set_pos(ui__Radio* r, int x, int y) {
	r->x = x;
	r->y = y;
}

multi_return_int_int ui__Radio_size(ui__Radio* r) {
	if (r->horizontal) {
		if (r->compact) {
			return (multi_return_int_int){.arg0=r->width, .arg1=r->height + 15};
		} else {
			return (multi_return_int_int){.arg0=r->values.len * r->width, .arg1=r->height + 15};
		}
	} else {
		return (multi_return_int_int){.arg0=r->width, .arg1=r->values.len * (r->height + 5)};
	}
	return (multi_return_int_int){0};
}

multi_return_int_int ui__Radio_propose_size(ui__Radio* r, int w, int h) {
	if (r->horizontal) {
		if (r->compact) {
			if (r->real_width > w) {
			}
		} else {
			r->width = w / r->values.len;
		}
	} else {
		r->width = w;
	}
	ui__Radio_update_size(r);
	return (multi_return_int_int){.arg0=r->real_width, .arg1=r->real_height};
}

void ui__Radio_set_size_from_values(ui__Radio* r) {
	int max = 0;
	if (r->horizontal) {
		r->adj_width = 0;
		r->adj_height = r->height + 15;
	} else {
		r->adj_width = 0;
		r->adj_height = (r->height + 5) * r->values.len;
	}
	for (int _t1 = 0; _t1 < r->values.len; ++_t1) {
		string value = ((string*)r->values.data)[_t1];
		int width = ui__text_width_T_ui__Radio(r, value);
		if (r->horizontal) {
			if (r->compact) {
				int w = width + _const_ui__check_mark_size + 10;
				array_push((array*)&r->widths, _MOV((int[]){ w }));
				r->adj_width += w;
			}
		} else {
			if (width > max) {
				max = width;
			}
		}
	}
	if (!r->horizontal) {
		r->width = max + _const_ui__check_mark_size + 10;
		r->adj_width = r->width;
	}
}

void ui__Radio_update_size(ui__Radio* r) {
	if (r->horizontal) {
		if (r->compact) {
			r->real_width = r->adj_width;
			r->real_height = r->height + 15;
		} else {
			r->real_width = r->values.len * r->width;
			r->real_height = r->height + 15;
		}
	} else {
		r->real_width = r->width;
		r->real_height = r->values.len * (r->height + 5);
	}
}

void ui__Radio_draw(ui__Radio* r) {
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Radio_to_Interface_ui__Widget(r)));
	ui__DrawTextWidget dtw = /*&ui.DrawTextWidget*/I_ui__Radio_to_Interface_ui__DrawTextWidget(r);
	if ((r->title).len != 0) {
		gg__Context_draw_rect_empty(r->ui->gg, r->x, r->y, r->real_width, r->real_height, (r->is_focused ? (_const_ui__radio_focus_color) : (_const_gx__gray)));
		gg__Context_draw_rect_filled(r->ui->gg, r->x + _const_ui__check_mark_size, r->y - 5, gg__Context_text_width(r->ui->gg, r->title) + 5, 10, _const_ui__default_window_color);
		#if defined(CUSTOM_DEFINE_nodtw)
		{
		}
		#else
		{
			ui__DrawTextWidget_load_style(dtw);
			ui__DrawTextWidget_draw_text(dtw, r->x + _const_ui__check_mark_size + 3, r->y - 7, r->title);
		}
		#endif
	}
	int dy = ((r->title).len == 0 ? (0) : (15));
	int x = r->x + 5;
	int y = r->y + dy;
	for (int i = 0; i < r->values.len; ++i) {
		string val = ((string*)r->values.data)[i];
		if (i > 0) {
			if (r->horizontal) {
				x += (r->compact ? ((*(int*)/*ee elem_sym */array_get(r->widths, i - 1))) : (r->width));
			} else {
				y += r->height;
			}
		}
		gg__Context_draw_image(r->ui->gg, x, y - 1, 16, 16, (voidptr)&/*qq*/r->ui->selected_radio_image);
		if (i != r->selected_index) {
			gg__Context_draw_rect_filled(r->ui->gg, x + 4, y + 3, 8, 8, _const_gx__white);
		}
		#if defined(CUSTOM_DEFINE_nodtw)
		{
		}
		#else
		{
			ui__DrawTextWidget_load_style(dtw);
			ui__DrawTextWidget_draw_text(dtw, x + _const_ui__check_mark_size + 5, y, val);
		}
		#endif
	}
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Radio_to_Interface_ui__Widget(r)));
}

bool ui__Radio_point_inside(ui__Radio* r, f64 x, f64 y) {
	int rx = r->x + r->offset_x;
	int ry = r->y + r->offset_y;
	bool _t1 = x >= rx && x <= rx + r->real_width && y >= ry && y <= ry + r->real_height;
	return _t1;
}

void ui__Radio_set_visible(ui__Radio* r, bool state) {
	r->hidden = !state;
}

void ui__Radio_focus(ui__Radio* r) {
	ui__Focusable f = /*&ui.Focusable*/I_ui__Radio_to_Interface_ui__Focusable(r);
	ui__Focusable_set_focus(&f);
}

void ui__Radio_unfocus(ui__Radio* r) {
	r->is_focused = false;
}

string ui__Radio_selected_value(ui__Radio* r) {
	string _t1 = (*(string*)/*ee elem_sym */array_get(r->values, r->selected_index));
	return _t1;
}

void ui__Radio_select_next_value(ui__Radio* r) {
	r->selected_index++;
	if (r->selected_index >= r->values.len) {
		r->selected_index = 0;
	}
}

void ui__Radio_select_prev_value(ui__Radio* r) {
	r->selected_index--;
	if (r->selected_index < 0) {
		r->selected_index = r->values.len - 1;
	}
}

ui__Rectangle* ui__rectangle(ui__RectangleParams c) {
	ui__Rectangle* rect = ((ui__Rectangle*)memdup(&(ui__Rectangle){.id = c.id,
		.color = c.color,
		.text = c.text,
		.offset_x = 0,
		.offset_y = 0,
		.height = c.height,
		.width = c.width,
		.ui = 0,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.text_cfg = c.text_cfg,
		.text_size = c.text_size,
		.component = 0,
		.x = c.x,
		.y = c.y,
		.z_index = c.z_index,
		.radius = c.radius,
		.border = c.border,
		.border_color = c.border_color,
		.hidden = 0,
	}, sizeof(ui__Rectangle)));
	ui__Rectangle* _t1 = rect;
	return _t1;
}

ui__Rectangle* ui__spacing(ui__RectangleParams c) {
	ui__Rectangle* rect = ((ui__Rectangle*)memdup(&(ui__Rectangle){.id = (string){.str=(byteptr)"", .is_lit=1},.color = c.color,.text = (string){.str=(byteptr)"", .is_lit=1},.offset_x = 0,.offset_y = 0,.height = 0,.width = 0,.ui = 0,.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,.component = 0,.x = 0,.y = 0,.z_index = 0,.radius = 0,.border = 0,.border_color = (gx__Color){.r = 0,.g = 0,.b = 0,.a = 255,},.hidden = 0,}, sizeof(ui__Rectangle)));
	rect->hidden = true;
	ui__Rectangle* _t1 = rect;
	return _t1;
}

void ui__Rectangle_init(ui__Rectangle* r, ui__Layout parent) {
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	r->ui = ui;
	ui__init_text_cfg(HEAP(ui__DrawText, /*&ui.DrawText*/I_ui__Rectangle_to_Interface_ui__DrawText(r)));
}

// Attr: [manualfree]
void ui__Rectangle_cleanup(ui__Rectangle* r) {
	ui__Rectangle_free(r);
}

// Attr: [unsafe]
void ui__Rectangle_free(ui__Rectangle* r) {
	{ // Unsafe block
		string_free(&r->text);
		string_free(&r->id);
		_v_free(r);
	}
}

void ui__Rectangle_set_pos(ui__Rectangle* r, int x, int y) {
	r->x = x;
	r->y = y;
}

multi_return_int_int ui__Rectangle_size(ui__Rectangle* r) {
	return (multi_return_int_int){.arg0=r->width, .arg1=r->height};
}

multi_return_int_int ui__Rectangle_propose_size(ui__Rectangle* r, int w, int h) {
	r->width = w;
	r->height = h;
	return (multi_return_int_int){.arg0=r->width, .arg1=r->height};
}

void ui__Rectangle_draw(ui__Rectangle* r) {
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Rectangle_to_Interface_ui__Widget(r)));
	if (r->radius > 0) {
		gg__Context_draw_rounded_rect_filled(r->ui->gg, r->x, r->y, r->width, r->height, r->radius, r->color);
		if (r->border) {
			gg__Context_draw_rounded_rect_empty(r->ui->gg, r->x, r->y, r->width, r->height, r->radius, r->border_color);
		}
	} else {
		gg__Context_draw_rect_filled(r->ui->gg, r->x, r->y, r->width, r->height, r->color);
		if (r->border) {
			gg__Context_draw_rect_empty(r->ui->gg, r->x, r->y, r->width, r->height, r->border_color);
		}
	}
	if ((r->text).len != 0) {
		multi_return_int_int mr_2627 = ui__text_size_T_ui__Rectangle(r, r->text);
		int text_width = mr_2627.arg0;
		int text_height = mr_2627.arg1;
		int dx = (r->width - text_width) / 2;
		int dy = (r->height - text_height) / 2;
		if (dx < 0) {
			dx = 0;
		}
		if (dy < 0) {
			dy = 0;
		}
		ui__draw_text_T_ui__Rectangle(r, r->x + dx, r->y + dy, r->text);
	}
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Rectangle_to_Interface_ui__Widget(r)));
}

void ui__Rectangle_set_visible(ui__Rectangle* r, bool state) {
	r->hidden = !state;
}

bool ui__Rectangle_point_inside(ui__Rectangle* r, f64 x, f64 y) {
	bool _t1 = ui__point_inside_T_ui__Rectangle(r, x, y);
	return _t1;
}

// TypeDecl
ui__Slider* ui__slider(ui__SliderParams c) {
	ui__Slider* s = ((ui__Slider*)memdup(&(ui__Slider){.id = c.id,
		.height = c.height,
		.width = c.width,
		.thumb_width = 0,
		.thumb_height = 0,
		.slider_size = c.slider_size,
		.orientation = c.orientation,
		.x = 0,
		.y = 0,
		.offset_x = 0,
		.offset_y = 0,
		.z_index = c.z_index,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.ui = 0,
		.val = c.val,
		.min = c.min,
		.max = c.max,
		.is_focused = 0,
		.dragging = 0,
		.on_value_changed = (voidptr)c.on_value_changed,
		.focus_on_thumb_only = c.focus_on_thumb_only,
		.rev_min_max_pos = c.rev_min_max_pos,
		.thumb_in_track = c.thumb_in_track,
		.track_line_displayed = c.track_line_displayed,
		.entering = c.entering,
		.hidden = 0,
		.component = 0,
	}, sizeof(ui__Slider)));
	ui__Slider_set_thumb_size(s);
	if (s->min > s->max) {
		int tmp = s->max;
		s->max = s->min;
		s->min = tmp;
	}
	ui__Slider* _t1 = s;
	return _t1;
}

void ui__Slider_init(ui__Slider* s, ui__Layout parent) {
	s->parent = parent;
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	s->ui = ui;
	eventbus__Subscriber* subscriber = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_click, (voidptr)ui__slider_click, s);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_key_down, (voidptr)ui__slider_key_down, s);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_down, (voidptr)ui__slider_mouse_down, s);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_up, (voidptr)ui__slider_mouse_up, s);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_move, (voidptr)ui__slider_mouse_move, s);
	ui__EventMngr_add_receiver(&s->ui->window->evt_mngr, /*&ui.Widget*/I_ui__Slider_to_Interface_ui__Widget(s), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(_const_ui__events.on_mouse_down)})));
}

// Attr: [manualfree]
void ui__Slider_cleanup(ui__Slider* s) {
	eventbus__Subscriber* subscriber = ui__Layout_name_table[s->parent._typ]._method_get_subscriber(s->parent._object);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_click, s);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_key_down, s);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_down, s);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_up, s);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_move, s);
	ui__EventMngr_rm_receiver(&s->ui->window->evt_mngr, /*&ui.Widget*/I_ui__Slider_to_Interface_ui__Widget(s), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(_const_ui__events.on_mouse_down)})));
	ui__Slider_free(s);
}

// Attr: [unsafe]
void ui__Slider_free(ui__Slider* s) {
	{ // Unsafe block
		string_free(&s->id);
		_v_free(s);
	}
}

void ui__Slider_set_pos(ui__Slider* s, int x, int y) {
	s->x = x;
	s->y = y;
}

void ui__Slider_set_thumb_size(ui__Slider* s) {
	if (!s->thumb_in_track) {
		s->thumb_height = (s->orientation == ui__Orientation__horizontal ? (s->slider_size + 10) : (10));
		s->thumb_width = (s->orientation == ui__Orientation__horizontal ? (10) : (s->slider_size + 10));
	} else {
		s->thumb_height = (s->orientation == ui__Orientation__horizontal ? (s->slider_size - 3) : (10));
		s->thumb_width = (s->orientation == ui__Orientation__horizontal ? (10) : (s->slider_size - 3));
	}
}

multi_return_int_int ui__Slider_size(ui__Slider* s) {
	return (multi_return_int_int){.arg0=s->width, .arg1=s->height};
}

multi_return_int_int ui__Slider_propose_size(ui__Slider* s, int w, int h) {
	s->width = w;
	s->height = h;
	ui__Slider_set_thumb_size(s);
	multi_return_int_int _t1 = ui__Slider_size(s);
	return _t1;
}

void ui__Slider_draw(ui__Slider* s) {
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Slider_to_Interface_ui__Widget(s)));
	multi_return_int_int_int_int mr_4951 = (s->orientation == ui__Orientation__horizontal ? ((multi_return_int_int_int_int){.arg0=s->x,.arg1=s->y + (s->height - s->slider_size) / 2,.arg2=s->width,.arg3=s->slider_size}) : ((multi_return_int_int_int_int){.arg0=s->x + (s->width - s->slider_size) / 2,.arg1=s->y,.arg2=s->slider_size,.arg3=s->height}));
	int x = mr_4951.arg0;
	int y = mr_4951.arg1;
	int w = mr_4951.arg2;
	int h = mr_4951.arg3;
	gg__Context_draw_rect_filled(s->ui->gg, x, y, w, h, _const_ui__slider_background_color);
	if (s->track_line_displayed) {
		if (s->orientation == ui__Orientation__horizontal) {
			gg__Context_draw_line(s->ui->gg, x + 2, y + h / 2, x + w - 4, y + h / 2, gx__rgb(0, 0, 0));
		} else {
			gg__Context_draw_line(s->ui->gg, x + w / 2, y + 2, x + w / 2, y + h - 4, gx__rgb(0, 0, 0));
		}
	}
	gg__Context_draw_rect_empty(s->ui->gg, x, y, w, h, (s->is_focused ? (_const_ui__slider_focused_background_border_color) : (_const_ui__slider_background_border_color)));
	ui__Slider_draw_thumb(s);
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Slider_to_Interface_ui__Widget(s)));
}

void ui__Slider_draw_thumb(ui__Slider* s) {
	int axis = (s->orientation == ui__Orientation__horizontal ? (s->x) : (s->y));
	int rev_axis = (s->orientation == ui__Orientation__horizontal ? (s->y) : (s->x));
	int rev_dim = (s->orientation == ui__Orientation__horizontal ? (s->height) : (s->width));
	int rev_thumb_dim = (s->orientation == ui__Orientation__horizontal ? (s->thumb_height) : (s->thumb_width));
	int dim = (s->orientation == ui__Orientation__horizontal ? (s->width) : (s->height));
	f32 pos = ((f32)(dim)) * ((s->val - ((f32)(s->min))) / ((f32)(s->max - s->min)));
	if (s->rev_min_max_pos) {
		pos = -pos + ((f32)(dim));
	}
	pos += ((f32)(axis));
	if (pos > axis + dim) {
		pos = ((f32)(dim)) + ((f32)(axis));
	}
	if (pos < axis) {
		pos = ((f32)(axis));
	}
	f32 middle = ((f32)(rev_axis)) - (((f32)(rev_thumb_dim - rev_dim)) / 2);
	if (s->orientation == ui__Orientation__horizontal) {
		gg__Context_draw_rect_filled(s->ui->gg, pos - ((f32)(s->thumb_width)) / 2, middle, s->thumb_width, s->thumb_height, _const_ui__thumb_color);
	} else {
		gg__Context_draw_rect_filled(s->ui->gg, middle, pos - ((f32)(s->thumb_height)) / 2, s->thumb_width, s->thumb_height, _const_ui__thumb_color);
	}
}

void ui__slider_key_down(ui__Slider* s, ui__KeyEvent* e, voidptr zzz) {
	if (s->hidden) {
		return;
	}
	if (!s->is_focused) {
		return;
	}

	if (e->key == (ui__Key__up) || e->key == (ui__Key__left)) {
		if (!s->rev_min_max_pos) {
			if (((int)(s->val)) > s->min) {
				s->val--;
			}
		} else {
			if (((int)(s->val)) < s->max) {
				s->val++;
			}
		}
	}
	else if (e->key == (ui__Key__down) || e->key == (ui__Key__right)) {
		if (!s->rev_min_max_pos) {
			if (((int)(s->val)) < s->max) {
				s->val++;
			}
		} else {
			if (((int)(s->val)) > s->min) {
				s->val--;
			}
		}
	}
	else {
	};
	if (s->on_value_changed != (voidptr)((voidptr)(0))) {
		ui__Layout parent = s->parent;
		voidptr state = ui__Layout_name_table[parent._typ]._method_get_state(parent._object);
		s->on_value_changed(state, s);
	}
}

bool ui__Slider_point_inside(ui__Slider* s, f64 x, f64 y) {
	bool _t1 = ui__point_inside_T_ui__Slider(s, x, y);
	return _t1;
}

bool ui__Slider_point_inside_thumb(ui__Slider* s, f64 x, f64 y) {
	int sx = s->x + s->offset_x;
	int sy = s->y + s->offset_y;
	int axis = (s->orientation == ui__Orientation__horizontal ? (sx) : (sy));
	int rev_axis = (s->orientation == ui__Orientation__horizontal ? (sy) : (sx));
	int rev_dim = (s->orientation == ui__Orientation__horizontal ? (s->height) : (s->width));
	int rev_thumb_dim = (s->orientation == ui__Orientation__horizontal ? (s->thumb_height) : (s->thumb_width));
	int dim = (s->orientation == ui__Orientation__horizontal ? (s->width) : (s->height));
	f32 pos = ((f32)(dim)) * ((s->val - ((f32)(s->min))) / ((f32)(s->max - s->min)));
	if (s->rev_min_max_pos) {
		pos = -pos + ((f32)(dim));
	}
	pos += ((f32)(axis));
	if (pos > axis + dim) {
		pos = ((f32)(dim)) + ((f32)(axis));
	}
	if (pos < axis) {
		pos = ((f32)(axis));
	}
	f32 middle = ((f32)(rev_axis)) - (((f32)(rev_thumb_dim - rev_dim)) / 2);
	#if defined(__ANDROID__)
	{
	}
	#else
	{
		if (s->orientation == ui__Orientation__horizontal) {
			f32 t_x = pos - ((f32)(s->thumb_width)) / 2;
			f32 t_y = middle;
			bool _t1 = x >= t_x && x <= t_x + ((f32)(s->thumb_width)) && y >= t_y && y <= t_y + ((f32)(s->thumb_height));
			return _t1;
		} else {
			f32 t_x = middle;
			f32 t_y = pos - ((f32)(s->thumb_height)) / 2;
			bool _t2 = x >= t_x && x <= t_x + ((f32)(s->thumb_width)) && y >= t_y && y <= t_y + ((f32)(s->thumb_height));
			return _t2;
		}
	}
	#endif
	return 0;
}

void ui__slider_click(ui__Slider* s, ui__MouseEvent* e, voidptr zzz) {
	if (s->hidden) {
		return;
	}
	if (!ui__Slider_point_inside_thumb(s, e->x, e->y) && (!ui__Slider_point_inside(s, e->x, e->y) || s->focus_on_thumb_only)) {
		s->is_focused = false;
		return;
	}
	if (!s->focus_on_thumb_only) {
		ui__Slider_change_value(s, e->x, e->y);
	}
	s->is_focused = true;
}

void ui__slider_mouse_down(ui__Slider* s, ui__MouseEvent* e, voidptr zzz) {
	if (s->hidden) {
		return;
	}
	if (((int)(e->button)) == 0 && ui__Slider_point_inside_thumb(s, e->x, e->y)) {
		s->dragging = true;
	}
}

void ui__slider_mouse_up(ui__Slider* s, ui__MouseEvent* e, voidptr zzz) {
	s->dragging = false;
}

void ui__slider_mouse_move(ui__Slider* s, ui__MouseMoveEvent* e, voidptr zzz) {
	if (s->ui->btn_down[0]) {
		if (s->entering && ui__Slider_point_inside_thumb(s, e->x, e->y)) {
			s->dragging = true;
		}
	} else {
		s->dragging = false;
	}
	if (s->dragging) {
		ui__Slider_change_value(s, ((int)(e->x)), ((int)(e->y)));
	}
}

void ui__slider_touch_move(ui__Slider* s, ui__MouseMoveEvent* e, voidptr zzz) {
	if (s->hidden) {
		return;
	}
	if (s->entering && ui__Slider_point_inside_thumb(s, e->x, e->y)) {
		s->dragging = true;
	}
	if (s->dragging) {
		ui__Slider_change_value(s, ((int)(e->x)), ((int)(e->y)));
	}
}

void ui__Slider_change_value(ui__Slider* s, int x, int y) {
	int dim = (s->orientation == ui__Orientation__horizontal ? (s->width) : (s->height));
	int axis = (s->orientation == ui__Orientation__horizontal ? (s->x) : (s->y));
	int pos = (s->orientation == ui__Orientation__horizontal ? (x) : (y));
	pos -= axis;
	if (s->rev_min_max_pos) {
		pos = -pos + dim;
	}
	s->val = ((f32)(s->min)) + (((f32)(pos)) * ((f32)(s->max - s->min))) / ((f32)(dim));
	if (((int)(s->val)) < s->min) {
		s->val = ((f32)(s->min));
	} else if (((int)(s->val)) > s->max) {
		s->val = ((f32)(s->max));
	}
	if (s->on_value_changed != (voidptr)((voidptr)(0))) {
		ui__Layout parent = s->parent;
		voidptr state = ui__Layout_name_table[parent._typ]._method_get_state(parent._object);
		s->on_value_changed(state, s);
	}
}

void ui__Slider_set_visible(ui__Slider* s, bool state) {
	s->hidden = !state;
}

void ui__Slider_focus(ui__Slider* s) {
	ui__Focusable f = /*&ui.Focusable*/I_ui__Slider_to_Interface_ui__Focusable(s);
	ui__Focusable_set_focus(&f);
}

void ui__Slider_unfocus(ui__Slider* s) {
	s->is_focused = false;
}

ui__SubWindow* ui__subwindow(ui__SubWindowParams c) {
	ui__SubWindow* s = ((ui__SubWindow*)memdup(&(ui__SubWindow){.id = c.id,
		.x = c.x,
		.y = c.y,
		.z_index = _const_ui__sw_z_index,
		.z_index_children_orig = __new_array(0, 0, sizeof(int)),
		.offset_x = 0,
		.offset_y = 0,
		.hidden = c.hidden,
		.ui = 0,
		.drag = c.drag,
		.dragging = 0,
		.drag_x = 0,
		.drag_y = 0,
		.decoration = c.decoration,
		.layout = c.layout,
		.is_focused = 0,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.component = 0,
	}, sizeof(ui__SubWindow)));
	ui__SubWindow* _t1 = s;
	return _t1;
}

void ui__SubWindow_init(ui__SubWindow* s, ui__Layout parent) {
	s->parent = parent;
	ui__UI* pui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	s->ui = pui;
	eventbus__Subscriber* subscriber = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_down, (voidptr)ui__sw_mouse_down, s);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_move, (voidptr)ui__sw_mouse_move, s);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_up, (voidptr)ui__sw_mouse_up, s);
	ui__EventMngr_add_receiver(&s->ui->window->evt_mngr, /*&ui.Widget*/I_ui__SubWindow_to_Interface_ui__Widget(s), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(_const_ui__events.on_mouse_down)})));
	ui__Layout l = s->layout;
	if (I_ui__Layout_is_I_ui__Widget(l)) {
		ui__Widget w = I_ui__Layout_as_I_ui__Widget(l);
		ui__Widget_name_table[w._typ]._method_init(w._object, /*&ui.Layout*/I_ui__SubWindow_to_Interface_ui__Layout(s));
	}
	ui__SubWindow_set_children_depth(s, s->z_index + _const_ui__sw_z_index_child);
	ui__SubWindow_set_pos(s, s->x, s->y);
	ui__SubWindow_update_layout(s);
	ui__SubWindow_set_visible(s, !s->hidden);
}

// Attr: [manualfree]
void ui__SubWindow_cleanup(ui__SubWindow* s) {
	eventbus__Subscriber* subscriber = ui__Layout_name_table[s->parent._typ]._method_get_subscriber(s->parent._object);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_down, s);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_move, s);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_up, s);
	ui__UI* ui = ui__SubWindow_get_ui(s);
	ui__EventMngr_rm_receiver(&ui->window->evt_mngr, /*&ui.Widget*/I_ui__SubWindow_to_Interface_ui__Widget(s), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(_const_ui__events.on_mouse_down)})));
	ui__SubWindow_free(s);
}

void ui__SubWindow_draw(ui__SubWindow* s) {
	if (s->hidden) {
		return;
	}
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__SubWindow_to_Interface_ui__Widget(s)));
	if (s->decoration) {
		multi_return_int_int mr_2426 = ui__SubWindow_size(s);
		int w = mr_2426.arg0;
		gg__Context_draw_rounded_rect_filled(s->ui->gg, s->x, s->y, w, _const_ui__sw_decoration, 5, _const_gx__black);
	}
	ui__Layout_name_table[s->layout._typ]._method_draw(s->layout._object);
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__SubWindow_to_Interface_ui__Widget(s)));
}

// Attr: [unsafe]
void ui__SubWindow_free(ui__SubWindow* s) {
	{ // Unsafe block
		string_free(&s->id);
		_v_free(s);
	}
}

void ui__sw_mouse_down(ui__SubWindow* s, ui__MouseEvent* e, ui__Window* window) {
	if (s->hidden) {
		return;
	}
	if (s->decoration && ui__SubWindow_point_inside_bar(s, e->x, e->y)) {
		ui__SubWindow_as_top_subwindow(s);
		s->dragging = true;
		s->drag_x = s->x - e->x;
		s->drag_y = s->y - e->y;
	}
}

void ui__sw_mouse_up(ui__SubWindow* s, ui__MouseEvent* e, ui__Window* window) {
	if (s->hidden) {
		return;
	}
	s->dragging = false;
}

void ui__sw_mouse_move(ui__SubWindow* s, ui__MouseMoveEvent* e, ui__Window* window) {
	if (s->hidden) {
		return;
	}
	if (s->dragging) {
		multi_return_int_int mr_3563 = ui__SubWindow_size(s);
		int w = mr_3563.arg0;
		int new_x = s->drag_x + ((int)(e->x));
		int new_y = s->drag_y + ((int)(e->y));
		if (new_x + w - _const_ui__sw_decoration >= 0 && new_y + _const_ui__sw_decoration / 2 >= 0 && new_x + _const_ui__sw_decoration <= s->ui->window->width && new_y + _const_ui__sw_decoration / 2 <= s->ui->window->height) {
			ui__SubWindow_set_pos(s, new_x, new_y);
			ui__SubWindow_update_layout(s);
		}
	}
}

void ui__SubWindow_update_layout(ui__SubWindow* s) {
	ui__Layout_name_table[s->layout._typ]._method_update_layout(s->layout._object);
}

void ui__SubWindow_set_adjusted_size(ui__SubWindow* s, ui__UI* ui) {
}

bool ui__SubWindow_point_inside_bar(ui__SubWindow* s, f64 x, f64 y) {
	if (s->decoration) {
		multi_return_int_int mr_4224 = ui__SubWindow_size(s);
		int w = mr_4224.arg0;
		bool _t1 = x > s->x && x < s->x + w && y > s->y && y < s->y + _const_ui__sw_decoration;
		return _t1;
	} else {
		bool _t2 = false;
		return _t2;
	}
	return 0;
}

bool ui__SubWindow_point_inside(ui__SubWindow* s, f64 x, f64 y) {
	if (s->decoration) {
		multi_return_int_int mr_4449 = ui__SubWindow_size(s);
		int w = mr_4449.arg0;
		int h = mr_4449.arg1;
		bool _t1 = x > s->x && x < s->x + w && y > s->y && y < s->y + h + _const_ui__sw_decoration;
		return _t1;
	} else {
		if (I_ui__Layout_is_I_ui__Widget(s->layout)) {
			ui__Widget w = I_ui__Layout_as_I_ui__Widget(s->layout);
			bool _t2 = ui__Widget_name_table[w._typ]._method_point_inside(w._object, x, y);
			return _t2;
		} else {
			bool _t3 = false;
			return _t3;
		}
	}
	return 0;
}

void ui__SubWindow_set_pos(ui__SubWindow* s, int x, int y) {
	s->x = x;
	s->y = y;
	if (I_ui__Layout_is_I_ui__Widget(s->layout)) {
		ui__Widget w = I_ui__Layout_as_I_ui__Widget(s->layout);
		ui__Widget_name_table[w._typ]._method_set_pos(w._object, x, y + (s->decoration ? (_const_ui__sw_decoration) : (0)));
	}
}

multi_return_int_int ui__SubWindow_propose_size(ui__SubWindow* s, int width, int height) {
	if (I_ui__Layout_is_I_ui__Widget(s->layout)) {
		ui__Widget ws = I_ui__Layout_as_I_ui__Widget(s->layout);
		multi_return_int_int mr_5147 = ui__Widget_name_table[ws._typ]._method_propose_size(ws._object, width, height);
		int w = mr_5147.arg0;
		int h = mr_5147.arg1;
		if (s->decoration) {
			h += _const_ui__sw_decoration;
		}
		return (multi_return_int_int){.arg0=w, .arg1=h};
	} else {
		return (multi_return_int_int){.arg0=-1, .arg1=-1};
	}
	return (multi_return_int_int){0};
}

multi_return_int_int ui__SubWindow_size(ui__SubWindow* s) {
	multi_return_int_int mr_5327 = ui__Layout_name_table[s->layout._typ]._method_size(s->layout._object);
	int w = mr_5327.arg0;
	int h = mr_5327.arg1;
	if (s->decoration) {
		h += _const_ui__sw_decoration;
	}
	return (multi_return_int_int){.arg0=w, .arg1=h};
}

void ui__SubWindow_set_visible(ui__SubWindow* s, bool state) {
	s->hidden = !state;
	if (I_ui__Layout_is_I_ui__Widget(s->layout)) {
		ui__Widget w = I_ui__Layout_as_I_ui__Widget(s->layout);
		ui__Widget_name_table[w._typ]._method_set_visible(w._object, state);
	}
	if (!s->hidden) {
		ui__Window_update_layout(s->ui->window);
	}
}

ui__UI* ui__SubWindow_get_ui(ui__SubWindow* s) {
	ui__UI* _t1 = s->ui;
	return _t1;
}

voidptr ui__SubWindow_get_state(ui__SubWindow* s) {
	ui__Layout parent = s->parent;
	voidptr _t1 = ui__Layout_name_table[parent._typ]._method_get_state(parent._object);
	return _t1;
}

eventbus__Subscriber* ui__SubWindow_get_subscriber(ui__SubWindow* s) {
	ui__Layout parent = s->parent;
	eventbus__Subscriber* _t1 = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	return _t1;
}

void ui__SubWindow_resize(ui__SubWindow* s, int w, int h) {
	ui__Layout_name_table[s->layout._typ]._method_resize(s->layout._object, w, h);
}

Array_ui__Widget ui__SubWindow_get_children(ui__SubWindow* s) {
	if (I_ui__Layout_is_I_ui__Widget(s->layout)) {
		ui__Widget w = I_ui__Layout_as_I_ui__Widget(s->layout);
		Array_ui__Widget _t1 = new_array_from_c_array(1, 1, sizeof(ui__Widget), _MOV((ui__Widget[1]){w}));
		return _t1;
	} else {
		Array_ui__Widget _t2 = __new_array_with_default(0, 0, sizeof(ui__Widget), 0);
		return _t2;
	}
	return __new_array(0, 0, sizeof(ui__Widget));
}

void ui__SubWindow_set_children_depth(ui__SubWindow* s, int z_inc) {
	ui__Layout_incr_children_depth(&s->layout, z_inc);
	ui__EventMngr_sorted_receivers(&s->ui->window->evt_mngr, _const_ui__events.on_mouse_down);
}

bool ui__SubWindow_is_top_subwindow(ui__SubWindow* s) {
	Array_string _t2 = {0};
	Array_ui__SubWindow_ptr _t2_orig = s->ui->window->subwindows;
	int _t2_len = _t2_orig.len;
	_t2 = __new_array(0, _t2_len, sizeof(string));

	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		ui__SubWindow* it = ((ui__SubWindow**) _t2_orig.data)[_t3];
		string ti = it->id;
		array_push((array*)&_t2, &ti);
	}
	bool _t1 = string__eq((*(string*)array_first(_t2)), s->id);
	return _t1;
}

void ui__SubWindow_as_top_subwindow(ui__SubWindow* s) {
	Array_ui__SubWindow_ptr sws = __new_array_with_default(0, 0, sizeof(ui__SubWindow*), 0);
	for (int _t1 = 0; _t1 < s->ui->window->subwindows.len; ++_t1) {
		ui__SubWindow* sw = ((ui__SubWindow**)s->ui->window->subwindows.data)[_t1];
		if (!string__eq(sw->id, s->id)) {
			array_push((array*)&sws, _MOV((ui__SubWindow*[]){ sw }));
		}
	}
	array_push((array*)&sws, _MOV((ui__SubWindow*[]){ s }));
	ui__Window* win = s->ui->window;
	win->subwindows = sws;
	for (int _t4 = 0; _t4 < sws.len; ++_t4) {
		ui__SubWindow** sw = ((ui__SubWindow**)sws.data) + _t4;
		ui__SubWindow_update_depth(/*diff=1*/*sw, string__eq((*sw)->id, s->id));
	}
}

void ui__SubWindow_update_depth(ui__SubWindow* s, bool top) {
	ui__SubWindow_set_children_depth(s, -s->z_index - _const_ui__sw_z_index_child);
	s->z_index = _const_ui__sw_z_index;
	if (top) {
		s->z_index += _const_ui__sw_z_index_top;
	}
	ui__SubWindow_set_children_depth(s, s->z_index + _const_ui__sw_z_index_child);
	ui__SubWindow_update_layout(s);
}

// TypeDecl
// TypeDecl
ui__Switch* ui__switcher(ui__SwitchParams c) {
	ui__Switch* s = ((ui__Switch*)memdup(&(ui__Switch){.id = c.id,
		.idx = 0,
		.height = _const_ui__sw_height,
		.width = _const_ui__sw_width,
		.x = 0,
		.y = 0,
		.offset_x = 0,
		.offset_y = 0,
		.z_index = c.z_index,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.is_focused = 0,
		.open = c.open,
		.ui = 0,
		.onclick = (voidptr)c.onclick,
		.on_key_down = (voidptr)c.on_key_down,
		.hidden = 0,
		.component = 0,
	}, sizeof(ui__Switch)));
	ui__Switch* _t1 = s;
	return _t1;
}

void ui__Switch_init(ui__Switch* s, ui__Layout parent) {
	s->parent = parent;
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	s->ui = ui;
	eventbus__Subscriber* subscriber = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_key_down, (voidptr)ui__sw_key_down, s);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_click, (voidptr)ui__sw_click, s);
}

// Attr: [manualfree]
void ui__Switch_cleanup(ui__Switch* s) {
	eventbus__Subscriber* subscriber = ui__Layout_name_table[s->parent._typ]._method_get_subscriber(s->parent._object);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_key_down, s);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_click, s);
	ui__Switch_free(s);
}

// Attr: [unsafe]
void ui__Switch_free(ui__Switch* s) {
	{ // Unsafe block
		string_free(&s->id);
		_v_free(s);
	}
}

void ui__Switch_set_pos(ui__Switch* s, int x, int y) {
	s->x = x;
	s->y = y;
}

multi_return_int_int ui__Switch_size(ui__Switch* s) {
	return (multi_return_int_int){.arg0=s->width, .arg1=s->height};
}

multi_return_int_int ui__Switch_propose_size(ui__Switch* s, int w, int h) {
	return (multi_return_int_int){.arg0=s->width, .arg1=s->height};
}

void ui__Switch_draw(ui__Switch* s) {
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Switch_to_Interface_ui__Widget(s)));
	int padding = (s->height - _const_ui__sw_dot_size) / 2;
	if (s->open) {
		gg__Context_draw_rect_filled(s->ui->gg, s->x, s->y, s->width, s->height, _const_ui__sw_open_bg_color);
		gg__Context_draw_rect_filled(s->ui->gg, s->x - padding + s->width - _const_ui__sw_dot_size, s->y + padding, _const_ui__sw_dot_size, _const_ui__sw_dot_size, _const_gx__white);
	} else {
		gg__Context_draw_rect_filled(s->ui->gg, s->x, s->y, s->width, s->height, _const_ui__sw_close_bg_color);
		gg__Context_draw_rect_filled(s->ui->gg, s->x + padding, s->y + padding, _const_ui__sw_dot_size, _const_ui__sw_dot_size, _const_gx__white);
	}
	if (s->is_focused) {
		gg__Context_draw_rect_empty(s->ui->gg, s->x, s->y, s->width, s->height, _const_ui__sw_focus_bg_color);
	}
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__Switch_to_Interface_ui__Widget(s)));
}

bool ui__Switch_point_inside(ui__Switch* s, f64 x, f64 y) {
	bool _t1 = ui__point_inside_T_ui__Switch(s, x, y);
	return _t1;
}

void ui__sw_key_down(ui__Switch* s, ui__KeyEvent* e, ui__Window* window) {
	if (s->hidden) {
		return;
	}
	if (!s->is_focused) {
		return;
	}
	if (s->on_key_down != (voidptr)((ui__SwitchKeyDownFn)(0))) {
		s->on_key_down(window->state, s, e->codepoint);
	} else {
		if (e->key == ui__Key__enter || e->key == ui__Key__space) {
			s->open = !s->open;
			if (s->onclick != (voidptr)((ui__SwitchClickFn)(0))) {
				s->onclick(window->state, s);
			}
		}
	}
}

void ui__sw_click(ui__Switch* s, ui__MouseEvent* e, ui__Window* w) {
	if (s->hidden) {
		return;
	}
	if (!ui__Switch_point_inside(s, e->x, e->y)) {
		return;
	}
	if (((int)(e->action)) == 0) {
		s->open = !s->open;
		if (s->onclick != (voidptr)((ui__SwitchClickFn)(0))) {
			s->onclick(w->state, s);
		}
	}
}

void ui__Switch_set_visible(ui__Switch* s, bool state) {
	s->hidden = !state;
}

void ui__Switch_focus(ui__Switch* s) {
	ui__Focusable f = /*&ui.Focusable*/I_ui__Switch_to_Interface_ui__Focusable(s);
	ui__Focusable_set_focus(&f);
}

void ui__Switch_unfocus(ui__Switch* s) {
	s->is_focused = false;
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
ui__TextBox* ui__textbox(ui__TextBoxParams c) {
	ui__TextBox* tb = ((ui__TextBox*)memdup(&(ui__TextBox){.id = c.id,
		.height = c.height,
		.width = (c.width < 30 ? (30) : (c.width)),
		.x = 0,
		.y = 0,
		.offset_x = 0,
		.offset_y = 0,
		.z_index = c.z_index,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.is_focused = c.is_focused,
		.is_typing = 0,
		.ui = 0,
		.text = c.text,
		.text_ = (string){.str=(byteptr)"", .is_lit=1},
		.max_len = c.max_len,
		.line_height = 0,
		.cursor_pos = 0,
		.sel_start = 0,
		.sel_end = 0,
		.placeholder = c.placeholder,
		.placeholder_bind = c.placeholder_bind,
		.is_multiline = c.is_multiline || ui__TextBoxMode_has(&c.mode, ui__TextBoxMode__multiline),
		.tv = (ui__TextView){.text = 0,.cursor_pos = 0,.sel_start = 0,.sel_end = 0,.line_height = 0,.tlv = (ui__TextLinesView){.lines = __new_array(0, 0, sizeof(string)),.from_i = __new_array(0, 0, sizeof(int)),.to_i = __new_array(0, 0, sizeof(int)),.from_j = 0,.to_j = 0,.refresh_visible_lines = 0,.cursor_pos_i = 0,.cursor_pos_j = 0,.sel_start_j = 0,.sel_start_i = 0,.sel_end_i = 0,.sel_end_j = 0,},.tb = 0,.left_margin = 0,.sh = 0,},
		.is_wordwrap = c.is_wordwrap || ui__TextBoxMode_has(&c.mode, ui__TextBoxMode__word_wrap),
		.is_line_number = c.is_line_number || ui__TextBoxMode_has(&c.mode, ui__TextBoxMode__line_numbers),
		.is_sync = c.is_sync || c.read_only,
		.twosided_sel = c.twosided_sel,
		.is_numeric = c.is_numeric,
		.is_password = c.is_password,
		.read_only = c.read_only || ui__TextBoxMode_has(&c.mode, ui__TextBoxMode__read_only),
		.borderless = c.borderless,
		.bg_color = c.bg_color,
		.fitted_height = c.fitted_height || c.is_multiline || ui__TextBoxMode_has(&c.mode, ui__TextBoxMode__multiline),
		.on_key_down = (voidptr)c.on_key_down,
		.on_char = (voidptr)c.on_char,
		.is_selectable = 0,
		.sel_active = 0,
		.dragging = 0,
		.sel_direction = 0,
		.border_accentuated = c.border_accentuated,
		.is_error = c.is_error,
		.on_change = (voidptr)c.on_change,
		.on_enter = (voidptr)c.on_enter,
		.on_changed = (voidptr)c.on_changed,
		.on_entered = (voidptr)c.on_entered,
		.text_styles = (ui__TextStyles){.current = (ui__TextStyle){.id = _const_ui__no_string,.font_name = _SLIT("system"),.color = _const_gx__black,.size = 16,.align = ui__TextHorizontalAlign__left,.vertical_align = ui__TextVerticalAlign__top,.mono = 0,},.hash = new_map(sizeof(string), sizeof(ui__TextStyle), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},
		.text_size = c.text_size,
		.text_cfg = c.text_cfg,
		.hidden = 0,
		.component = 0,
		.has_scrollview = 0,
		.scrollview = 0,
		.on_scroll_change = (voidptr)c.on_scroll_change,
	}, sizeof(ui__TextBox)));
	if (tb->text == 0) {
		tb->text = &tb->text_;
	}
	if (c.scrollview && tb->is_multiline) {
		ui__scrollview_add_T_ui__TextBox(tb);
	}
	ui__TextBox* _t1 = tb;
	return _t1;
}

void ui__TextBox_init(ui__TextBox* tb, ui__Layout parent) {
	tb->parent = parent;
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	tb->ui = ui;
	ui__TextBox_init_style(tb);
	{
	}
	ui__TextBox_update_line_height(tb);
	if (tb->is_multiline) {
		ui__TextView_init(&tb->tv, tb);
	}
	if (ui__has_scrollview(/*&ui.ScrollableWidget*/I_ui__TextBox_to_Interface_ui__ScrollableWidget(tb))) {
		ui__ScrollView_init(tb->scrollview, parent);
		ui__scrollview_update_T_ui__TextBox(tb);
	}
	eventbus__Subscriber* subscriber = ui__Layout_name_table[parent._typ]._method_get_subscriber(parent._object);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_key_down, (voidptr)ui__tb_key_down, tb);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_char, (voidptr)ui__tb_char, tb);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_down, (voidptr)ui__tb_mouse_down, tb);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_touch_down, (voidptr)ui__tb_mouse_down, tb);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_move, (voidptr)ui__tb_mouse_move, tb);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_mouse_up, (voidptr)ui__tb_mouse_up, tb);
	eventbus__Subscriber_subscribe_method(subscriber, _const_ui__events.on_touch_up, (voidptr)ui__tb_mouse_up, tb);
	ui__EventMngr_add_receiver(&tb->ui->window->evt_mngr, /*&ui.Widget*/I_ui__TextBox_to_Interface_ui__Widget(tb), new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){string_clone(_const_ui__events.on_mouse_down), string_clone(_const_ui__events.on_scroll)})));
}

// Attr: [manualfree]
void ui__TextBox_cleanup(ui__TextBox* tb) {
	eventbus__Subscriber* subscriber = ui__Layout_name_table[tb->parent._typ]._method_get_subscriber(tb->parent._object);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_key_down, tb);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_char, tb);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_down, tb);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_touch_down, tb);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_move, tb);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_mouse_up, tb);
	eventbus__Subscriber_unsubscribe_method(subscriber, _const_ui__events.on_touch_up, tb);
	ui__EventMngr_rm_receiver(&tb->ui->window->evt_mngr, /*&ui.Widget*/I_ui__TextBox_to_Interface_ui__Widget(tb), new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){string_clone(_const_ui__events.on_mouse_down), string_clone(_const_ui__events.on_scroll)})));
	ui__TextBox_free(tb);
}

// Attr: [unsafe]
void ui__TextBox_free(ui__TextBox* tb) {
	{ // Unsafe block
		string_free(&tb->id);
		string_free(&tb->placeholder);
		_v_free(tb);
	}
}

void ui__TextBox_init_style(ui__TextBox* tb) {
	#if defined(CUSTOM_DEFINE_nodtw)
	{
	}
	#else
	{
		ui__DrawTextWidget dtw = /*&ui.DrawTextWidget*/I_ui__TextBox_to_Interface_ui__DrawTextWidget(tb);
		ui__DrawTextWidget_init_style(&dtw, ((ui__TextStyleParams){.id = _const_ui__no_string,.font_name = _const_ui__no_string,.color = _const_ui__no_color,.size = -1,.align = ui__TextHorizontalAlign__none,.vertical_align = ui__TextVerticalAlign__none,}));
		ui__DrawTextWidget_update_text_size(&dtw, tb->text_size);
	}
	#endif
}

void ui__draw_inner_border(bool border_accentuated, gg__Context* gg, int x, int y, int width, int height, bool is_error) {
	if (!border_accentuated) {
		gx__Color color = (is_error ? (gx__rgb(255, 0, 0)) : (_const_ui__text_border_color));
		gg__Context_draw_rect_empty(gg, x, y, width, height, color);
		gg__Context_draw_rect_empty(gg, 0.5 + ((f32)(x)), 0.5 + ((f32)(y)), width - 1, height - 1, _const_ui__text_inner_border_color);
	} else {
		gg__Context_draw_rect_empty(gg, x, y, width, height, _const_ui__text_border_accentuated_color);
		gg__Context_draw_rect_empty(gg, 1.5 + ((f32)(x)), 1.5 + ((f32)(y)), width - 3, height - 3, _const_ui__text_border_accentuated_color);
	}
}

void ui__TextBox_set_pos(ui__TextBox* t, int x, int y) {
	t->x = x;
	t->y = y;
}

multi_return_int_int ui__TextBox_adj_size(ui__TextBox* tb) {
	if (tb->is_multiline) {
		multi_return_int_int _t1 = ui__TextView_size(&tb->tv);
		return _t1;
	} else {
		multi_return_int_int _t2 = ui__text_size_T_ui__TextBox(tb, *tb->text);
		return _t2;
	}
	return (multi_return_int_int){0};
}

multi_return_int_int ui__TextBox_size(ui__TextBox* tb) {
	return (multi_return_int_int){.arg0=tb->width, .arg1=tb->height};
}

multi_return_int_int ui__TextBox_propose_size(ui__TextBox* tb, int w, int h) {
	tb->width = w;
	tb->height = h;
	if (tb->height > _const_ui__max_textbox_height && !tb->fitted_height) {
		tb->height = _const_ui__max_textbox_height;
	}
	ui__update_text_size(HEAP(ui__DrawText, /*&ui.DrawText*/I_ui__TextBox_to_Interface_ui__DrawText(tb)));
	if (tb->is_multiline) {
		ui__scrollview_update_T_ui__TextBox(tb);
		ui__TextView_update_lines(&tb->tv);
	}
	return (multi_return_int_int){.arg0=tb->width, .arg1=tb->height};
}

void ui__TextBox_update_line_height(ui__TextBox* tb) {
	tb->line_height = ((int)(((f64)(ui__text_height_T_ui__TextBox(tb, _SLIT("W")))) * 1.5));
}

void ui__TextBox_draw(ui__TextBox* tb) {
	ui__offset_start(HEAP(ui__Widget, /*&ui.Widget*/I_ui__TextBox_to_Interface_ui__Widget(tb)));
	ui__scrollview_draw_begin_T_ui__TextBox(tb);
	if (tb->has_scrollview) {
		gg__Context_draw_rect_filled(tb->ui->gg, tb->x + tb->scrollview->offset_x, tb->y + tb->scrollview->offset_y, tb->scrollview->width, tb->scrollview->height, tb->bg_color);
	} else {
		gg__Context_draw_rect_filled(tb->ui->gg, tb->x, tb->y, tb->width, tb->height, tb->bg_color);
		if (!tb->borderless) {
			ui__draw_inner_border(tb->border_accentuated, tb->ui->gg, tb->x, tb->y, tb->width, tb->height, tb->is_error != 0 && *tb->is_error);
		}
	}
	if (tb->is_multiline) {
		ui__TextView_draw_textlines(&tb->tv);
	} else {
		ui__DrawTextWidget dtw = /*&ui.DrawTextWidget*/I_ui__TextBox_to_Interface_ui__DrawTextWidget(tb);
		string text = *(tb->text);
		Array_rune ustr = string_runes(text);
		int text_len = ustr.len;
		string placeholder = tb->placeholder;
		if (tb->placeholder_bind != 0) {
			placeholder = *(tb->placeholder_bind);
		}
		int width = (text_len == 0 ? (0) : (ui__text_width_T_ui__TextBox(tb, text)));
		int text_y = tb->y + _const_ui__textbox_padding_y;
		int skip_idx = 0;
		if ((text).len == 0 && (placeholder).len != 0) {
			#if defined(CUSTOM_DEFINE_nodtw)
			{
			}
			#else
			{
				ui__DrawTextWidget_draw_styled_text(dtw, tb->x + _const_ui__textbox_padding_x, text_y, placeholder, ((ui__TextStyleParams){.id = _const_ui__no_string,.font_name = _const_ui__no_string,.color = _const_gx__gray,.size = -1,.align = ui__TextHorizontalAlign__none,.vertical_align = ui__TextVerticalAlign__none,}));
			}
			#endif
		} else {
			ui__TextBox_draw_selection(tb);
			if (width > tb->width - 2 * _const_ui__textbox_padding_x && !tb->is_password) {
				gg__Context_set_cfg(tb->ui->gg, tb->text_cfg);
				if (!tb->is_focused || tb->read_only) {
					skip_idx = ui__TextBox_skip_index_from_start(tb, ustr, dtw);
					ui__DrawTextWidget_draw_text(dtw, tb->x + _const_ui__textbox_padding_x, text_y, Array_rune_string(array_slice(ustr, 0, (skip_idx + 1))));
				} else {
					skip_idx = ui__TextBox_skip_index_from_end(tb, ustr, dtw);
					Array_rune _t1;
										ui__DrawTextWidget_draw_text(dtw, tb->x + _const_ui__textbox_padding_x, text_y, Array_rune_string((_t1 = ustr, array_slice(_t1, skip_idx, _t1.len))));
				}
			} else {
				if (tb->is_password) {
					#if defined(CUSTOM_DEFINE_nodtw)
					{
					}
					#else
					{
						ui__DrawTextWidget_draw_text(dtw, tb->x + _const_ui__textbox_padding_x, text_y, string_repeat(_SLIT("*"), text_len));
					}
					#endif
				} else {
					#if defined(CUSTOM_DEFINE_nodtw)
					{
					}
					#else
					{
						ui__DrawTextWidget_draw_text(dtw, tb->x + _const_ui__textbox_padding_x, text_y, text);
					}
					#endif
				}
			}
		}
		if (tb->is_focused && !tb->read_only && tb->ui->show_cursor && !ui__TextBox_is_sel_active(tb)) {
			int cursor_x = tb->x + _const_ui__textbox_padding_x;
			if (text_len > 0) {
				if (tb->is_password) {
					cursor_x += ui__text_width_T_ui__TextBox(tb, string_repeat(_SLIT("*"), tb->cursor_pos));
				} else if (skip_idx > 0) {
					cursor_x += ui__text_width_T_ui__TextBox(tb, string_substr(text, skip_idx, (text).len));
				} else {
					if (tb->cursor_pos > string_runes(text).len) {
						tb->cursor_pos = string_runes(text).len;
					}
					string left = Array_rune_string(array_slice(string_runes(text), 0, tb->cursor_pos));
					cursor_x += ui__text_width_T_ui__TextBox(tb, left);
				}
			}
			gg__Context_draw_rect_filled(tb->ui->gg, cursor_x, tb->y + _const_ui__textbox_padding_y, 1, tb->line_height, _const_gx__black);
		}
	}
	ui__scrollview_draw_end_T_ui__TextBox(tb);
	ui__offset_end(HEAP(ui__Widget, /*&ui.Widget*/I_ui__TextBox_to_Interface_ui__Widget(tb)));
}

int ui__TextBox_skip_index_from_end(ui__TextBox* tb, Array_rune ustr, ui__DrawTextWidget dtw) {
	int text_len = ustr.len;
	int skip_idx = 0;
	for (int i = text_len - 1; i >= 0; i--) {
		Array_rune _t1;
				if (ui__DrawTextWidget_text_width(dtw, Array_rune_string((_t1 = ustr, array_slice(_t1, i, _t1.len)))) > tb->width - 2 * _const_ui__textbox_padding_x) {
			skip_idx = i + 1;
			if (skip_idx >= text_len - 1) {
				skip_idx = text_len - 1;
			}
			break;
		}
	}
	int _t2 = skip_idx;
	return _t2;
}

int ui__TextBox_skip_index_from_start(ui__TextBox* tb, Array_rune ustr, ui__DrawTextWidget dtw) {
	int text_len = ustr.len;
	int skip_idx = 0;
	for (int i = 0; i < text_len; ++i) {
		if (ui__DrawTextWidget_text_width(dtw, Array_rune_string(array_slice(ustr, 0, (i + 1)))) > tb->width - 2 * _const_ui__textbox_padding_x) {
			skip_idx = i - 1;
			if (skip_idx < 0) {
				skip_idx = 0;
			}
			break;
		}
	}
	int _t1 = skip_idx;
	return _t1;
}

bool ui__TextBox_is_sel_active(ui__TextBox* tb) {
	if (tb->is_multiline) {
		bool _t1 = ui__TextView_is_sel_active(&tb->tv);
		return _t1;
	} else {
		bool _t2 = (tb->is_focused || tb->read_only) && tb->sel_active && tb->sel_end != -1;
		return _t2;
	}
	return 0;
}

void ui__TextBox_draw_selection(ui__TextBox* tb) {
	if (!ui__TextBox_is_sel_active(tb)) {
		return;
	}
	multi_return_int_int mr_13794 = ui__text_xminmax_from_pos_T_ui__TextBox(tb, *tb->text, tb->sel_start, tb->sel_end);
	int sel_from = mr_13794.arg0;
	int sel_width = mr_13794.arg1;
	gg__Context_draw_rect_filled(tb->ui->gg, tb->x + _const_ui__textbox_padding_x + sel_from, tb->y + _const_ui__textbox_padding_y, sel_width, tb->line_height, _const_ui__selection_color);
}

void ui__TextBox_cancel_selection(ui__TextBox* tb) {
	if (tb->is_multiline) {
		ui__TextView_cancel_selection(&tb->tv);
	} else {
		tb->sel_start = -1;
		tb->sel_end = -1;
	}
	tb->sel_active = false;
}

void ui__TextBox_delete_selection(ui__TextBox* tb) {
	Array_rune u = string_runes(/*rec*/*tb->text);
	multi_return_int_int mr_14344 = (tb->sel_start < tb->sel_end ? ((multi_return_int_int){.arg0=tb->sel_start,.arg1=tb->sel_end}) : ((multi_return_int_int){.arg0=tb->sel_end,.arg1=tb->sel_start}));
	int sel_start = mr_14344.arg0;
	int sel_end = mr_14344.arg1;
	if (sel_start < 0) {
		return;
	}
	{ // Unsafe block
		Array_rune _t1;
				*tb->text = string__plus(Array_rune_string(array_slice(u, 0, sel_start)), Array_rune_string((_t1 = u, array_slice(_t1, sel_end, _t1.len))));
	}
	tb->cursor_pos = sel_start;
	ui__TextBox_cancel_selection(tb);
}

void ui__tb_key_down(ui__TextBox* tb, ui__KeyEvent* e, ui__Window* window) {
	if (tb->hidden) {
		return;
	}
	if (!tb->is_focused && !tb->read_only) {
		return;
	}
	if (tb->on_key_down != (voidptr)((ui__TextBoxKeyDownFn)(0))) {
		tb->on_key_down(window->state, tb, e->codepoint);
	}
	if (tb->is_multiline) {
		ui__TextView_key_down(&tb->tv, e);
	} else {
		string text = *tb->text;
		switch (e->key) {
			case ui__Key__enter: 
				{
					if (tb->on_enter != (voidptr)((ui__TextBoxEnterFn)(0))) {
						tb->on_enter(*tb->text, window->state);
					}
					if (tb->on_entered != (voidptr)((ui__TextBoxValidatedFn)(0))) {
						tb->on_entered(tb, window->state);
					}
					break;
				}
			case ui__Key__backspace: 
				{
					tb->ui->show_cursor = true;
					if ((text).len != 0) {
						if (tb->cursor_pos == 0) {
							return;
						}
						if (ui__TextBox_is_sel_active(tb)) {
							ui__TextBox_delete_selection(tb);
						} else if (e->mods == ui__KeyMod__super || e->mods == ui__KeyMod__ctrl) {
							int i = tb->cursor_pos;
							for (;;) {
								if (i > 0) {
									i--;
								}
								if (u8_is_space(string_at(text, i)) || i == 0) {
									break;
								}
							}
							tb->cursor_pos = i;
						} else {
							Array_rune u = string_runes(text);
							{ // Unsafe block
								Array_rune _t1;
																*tb->text = string__plus(Array_rune_string(array_slice(u, 0, tb->cursor_pos - 1)), Array_rune_string((_t1 = u, array_slice(_t1, tb->cursor_pos, _t1.len))));
							}
							tb->cursor_pos--;
						}
					}
					if (tb->on_change != (voidptr)((ui__TextBoxChangeFn)(0))) {
					}
					break;
				}
			case ui__Key__delete: 
				{
					tb->ui->show_cursor = true;
					if (tb->cursor_pos == text.len || (text).len == 0) {
						return;
					}
					Array_rune u = string_runes(text);
					{ // Unsafe block
						Array_rune _t2;
												*tb->text = string__plus(Array_rune_string(array_slice(u, 0, tb->cursor_pos)), Array_rune_string((_t2 = u, array_slice(_t2, tb->cursor_pos + 1, _t2.len))));
					}
					if (tb->on_change != (voidptr)((ui__TextBoxChangeFn)(0))) {
					}
					break;
				}
			case ui__Key__left: 
				{
					if (ui__shift_key(e->mods)) {
						if (!ui__TextBox_is_sel_active(tb)) {
							tb->sel_active = true;
							tb->sel_start = tb->cursor_pos;
							tb->ui->show_cursor = false;
						}
						tb->cursor_pos--;
						if (tb->cursor_pos < 0) {
							tb->cursor_pos = 0;
						}
						tb->sel_end = tb->cursor_pos;
					} else {
						ui__TextBox_cancel_selection(tb);
						tb->ui->show_cursor = true;
						tb->cursor_pos--;
						if (tb->cursor_pos < 0) {
							tb->cursor_pos = 0;
						}
					}
					break;
				}
			case ui__Key__right: 
				{
					if (ui__shift_key(e->mods)) {
						if (!ui__TextBox_is_sel_active(tb)) {
							tb->sel_active = true;
							tb->sel_start = tb->cursor_pos;
							tb->ui->show_cursor = false;
						}
						tb->cursor_pos++;
						Array_rune ustr = string_runes(/*rec*/*tb->text);
						if (tb->cursor_pos > ustr.len) {
							tb->cursor_pos = ustr.len;
						}
						tb->sel_end = tb->cursor_pos;
					} else {
						ui__TextBox_cancel_selection(tb);
						tb->ui->show_cursor = true;
						tb->cursor_pos++;
						int text_len = string_runes(text).len;
						if (tb->cursor_pos > text_len) {
							tb->cursor_pos = text_len;
						}
					}
					break;
				}
			case ui__Key__tab: 
				{
					break;
				}
			case ui__Key__invalid:
			case ui__Key__space:
			case ui__Key__apostrophe:
			case ui__Key__comma:
			case ui__Key__minus:
			case ui__Key__period:
			case ui__Key__slash:
			case ui__Key___0:
			case ui__Key___1:
			case ui__Key___2:
			case ui__Key___3:
			case ui__Key___4:
			case ui__Key___5:
			case ui__Key___6:
			case ui__Key___7:
			case ui__Key___8:
			case ui__Key___9:
			case ui__Key__semicolon:
			case ui__Key__equal:
			case ui__Key__a:
			case ui__Key__b:
			case ui__Key__c:
			case ui__Key__d:
			case ui__Key__e:
			case ui__Key__f:
			case ui__Key__g:
			case ui__Key__h:
			case ui__Key__i:
			case ui__Key__j:
			case ui__Key__k:
			case ui__Key__l:
			case ui__Key__m:
			case ui__Key__n:
			case ui__Key__o:
			case ui__Key__p:
			case ui__Key__q:
			case ui__Key__r:
			case ui__Key__s:
			case ui__Key__t:
			case ui__Key__u:
			case ui__Key__v:
			case ui__Key__w:
			case ui__Key__x:
			case ui__Key__y:
			case ui__Key__z:
			case ui__Key__left_bracket:
			case ui__Key__backslash:
			case ui__Key__right_bracket:
			case ui__Key__grave_accent:
			case ui__Key__world_1:
			case ui__Key__world_2:
			case ui__Key__escape:
			case ui__Key__insert:
			case ui__Key__down:
			case ui__Key__up:
			case ui__Key__page_up:
			case ui__Key__page_down:
			case ui__Key__home:
			case ui__Key__end:
			case ui__Key__caps_lock:
			case ui__Key__scroll_lock:
			case ui__Key__num_lock:
			case ui__Key__print_screen:
			case ui__Key__pause:
			case ui__Key__f1:
			case ui__Key__f2:
			case ui__Key__f3:
			case ui__Key__f4:
			case ui__Key__f5:
			case ui__Key__f6:
			case ui__Key__f7:
			case ui__Key__f8:
			case ui__Key__f9:
			case ui__Key__f10:
			case ui__Key__f11:
			case ui__Key__f12:
			case ui__Key__f13:
			case ui__Key__f14:
			case ui__Key__f15:
			case ui__Key__f16:
			case ui__Key__f17:
			case ui__Key__f18:
			case ui__Key__f19:
			case ui__Key__f20:
			case ui__Key__f21:
			case ui__Key__f22:
			case ui__Key__f23:
			case ui__Key__f24:
			case ui__Key__f25:
			case ui__Key__kp_0:
			case ui__Key__kp_1:
			case ui__Key__kp_2:
			case ui__Key__kp_3:
			case ui__Key__kp_4:
			case ui__Key__kp_5:
			case ui__Key__kp_6:
			case ui__Key__kp_7:
			case ui__Key__kp_8:
			case ui__Key__kp_9:
			case ui__Key__kp_decimal:
			case ui__Key__kp_divide:
			case ui__Key__kp_multiply:
			case ui__Key__kp_subtract:
			case ui__Key__kp_add:
			case ui__Key__kp_enter:
			case ui__Key__kp_equal:
			case ui__Key__left_shift:
			case ui__Key__left_control:
			case ui__Key__left_alt:
			case ui__Key__left_super:
			case ui__Key__right_shift:
			case ui__Key__right_control:
			case ui__Key__right_alt:
			case ui__Key__right_super:
			case ui__Key__menu:
			default:
				{
					break;
				}
		}
		;
	}
}

void ui__tb_char(ui__TextBox* tb, ui__KeyEvent* e, ui__Window* window) {
bool ui__tb_char_defer_0 = false;
	if (tb->hidden) {
		return;
	}
	if (!tb->is_focused && !tb->read_only) {
		return;
	}
	if (tb->is_error != ((voidptr)(0))) {
		{ // Unsafe block
			*tb->is_error = false;
		}
	}
	if (e->codepoint == 9U || (e->codepoint == 25U && e->mods == ui__KeyMod__shift)) {
		return;
	}
	if (tb->on_char != (voidptr)((ui__TextBoxCharFn)(0))) {
		tb->on_char(window->state, tb, e->codepoint);
	}
	tb->ui->last_type_time = time__ticks();
	if (tb->is_multiline) {
		ui__TextView_key_char(&tb->tv, e);
	} else {
		string text = *tb->text;
		if (text.len == 0) {
			tb->cursor_pos = 0;
		}
		string s = utf32_to_str(e->codepoint);
		if (!(((int)(e->codepoint)) == 0 || ((int)(e->codepoint)) == 9 || ((int)(e->codepoint)) == 13 || ((int)(e->codepoint)) == 27 || ((int)(e->codepoint)) == 127) && !(e->mods == ui__KeyMod__ctrl || e->mods == ui__KeyMod__super)) {
			if (tb->read_only) {
				return;
			}
			if (tb->max_len > 0 && string_runes(text).len >= tb->max_len) {
				return;
			}
			if (tb->is_numeric && (s.len > 1 || (!u8_is_digit(string_at(s, 0)) && ((string_at(s, 0) != '-') || ((string_runes(text).len > 0) && (tb->cursor_pos > 0)))))) {
				return;
			}
			ui__TextBox_insert(tb, s);
			if (tb->on_change != (voidptr)((ui__TextBoxChangeFn)(0))) {
				tb->on_change(*tb->text, window->state);
			}
			if (tb->on_changed != (voidptr)((ui__TextBoxValidatedFn)(0))) {
				tb->on_changed(tb, window->state);
			}
			return;
		} else if (e->mods == ui__KeyMod__ctrl || e->mods == ui__KeyMod__super) {

			if (string__eq(s, _SLIT("a"))) {
				if (tb->read_only && !tb->is_selectable) {
					return;
				}
				tb->sel_start = 0;
				tb->sel_end = string_runes(text).len;
				tb->sel_active = true;
			}
			else if (string__eq(s, _SLIT("c"))) {
				if (ui__TextBox_is_sel_active(tb)) {
					Array_rune ustr = string_runes(/*rec*/*tb->text);
					multi_return_int_int mr_20633 = (tb->sel_start < tb->sel_end ? ((multi_return_int_int){.arg0=tb->sel_start,.arg1=tb->sel_end}) : ((multi_return_int_int){.arg0=tb->sel_end,.arg1=tb->sel_start}));
					int sel_start = mr_20633.arg0;
					int sel_end = mr_20633.arg1;
					clipboard__Clipboard_copy(tb->ui->clipboard, Array_rune_string(array_slice(ustr, sel_start, sel_end)));
				}
			}
			else if (string__eq(s, _SLIT("v"))) {
				if (tb->read_only) {
					return;
				}
				ui__TextBox_insert(tb, clipboard__Clipboard_paste(tb->ui->clipboard));
			}
			else if (string__eq(s, _SLIT("x"))) {
				if (tb->read_only) {
					return;
				}
				if (ui__TextBox_is_sel_active(tb)) {
					Array_rune ustr = string_runes(/*rec*/*tb->text);
					multi_return_int_int mr_21117 = (tb->sel_start < tb->sel_end ? ((multi_return_int_int){.arg0=tb->sel_start,.arg1=tb->sel_end}) : ((multi_return_int_int){.arg0=tb->sel_end,.arg1=tb->sel_start}));
					int sel_start = mr_21117.arg0;
					int sel_end = mr_21117.arg1;
					clipboard__Clipboard_copy(tb->ui->clipboard, Array_rune_string(array_slice(ustr, sel_start, sel_end)));
					ui__TextBox_delete_selection(tb);
				}
			}
			else if (string__eq(s, _SLIT("-"))) {
				if (tb->read_only && !tb->is_selectable) {
					return;
				}
				if (tb->fitted_height) {
					tb->text_size -= 2;
					if (tb->text_size < 8) {
						tb->text_size = 8;
					}
					ui__update_text_size(HEAP(ui__DrawText, /*&ui.DrawText*/I_ui__TextBox_to_Interface_ui__DrawText(tb)));
					ui__TextBox_update_line_height(tb);
				}
			}
			else if (string__eq(s, _SLIT("=")) || string__eq(s, _SLIT("+"))) {
				if (tb->read_only && !tb->is_selectable) {
					return;
				}
				if (tb->fitted_height) {
					tb->text_size += 2;
					if (tb->text_size > 48) {
						tb->text_size = 48;
					}
					ui__update_text_size(HEAP(ui__DrawText, /*&ui.DrawText*/I_ui__TextBox_to_Interface_ui__DrawText(tb)));
					ui__TextBox_update_line_height(tb);
				}
			}
			else {
			};
		}
		ui__tb_char_defer_0 = true;
	}
// Defer begin
if (ui__tb_char_defer_0) {
	if (tb->on_change != (voidptr)((ui__TextBoxChangeFn)(0))) {
		if (e->key == ui__Key__backspace) {
			tb->on_change(*tb->text, window->state);
		}
	}
}
// Defer end
}

void ui__TextBox_set_sel(ui__TextBox* tb, int sel_start_i, int sel_end_i, ui__Key key) {
	if (tb->sel_direction == ui__SelectionDirection__right_to_left) {
		tb->sel_start = sel_start_i;
		tb->sel_end = sel_end_i;
	} else {
		tb->sel_start = sel_end_i;
		tb->sel_end = sel_start_i;
	}
}

bool ui__TextBox_point_inside(ui__TextBox* tb, f64 x, f64 y) {
	if (tb->has_scrollview) {
		bool _t1 = ui__ScrollView_point_inside(tb->scrollview, x, y, ui__ScrollViewPart__view);
		return _t1;
	} else {
		bool _t2 = ui__point_inside_T_ui__TextBox(tb, x, y);
		return _t2;
	}
	return 0;
}

void ui__tb_mouse_down(ui__TextBox* tb, ui__MouseEvent* e, voidptr zzz) {
	if (tb->hidden) {
		return;
	}
	if (tb->has_scrollview && ui__ScrollView_point_inside(tb->scrollview, e->x, e->y, ui__ScrollViewPart__bar)) {
		return;
	}
	if (!ui__TextBox_point_inside(tb, e->x, e->y)) {
		tb->dragging = false;
		ui__TextBox_unfocus(tb);
		return;
	} else {
		ui__TextBox_focus(tb);
	}
	if (!ui__Window_is_top_widget(/*rec*/*tb->ui->window, /*&ui.Widget*/I_ui__TextBox_to_Interface_ui__Widget(tb), _const_ui__events.on_mouse_down)) {
		return;
	}
	int x = e->x - tb->x - _const_ui__textbox_padding_x;
	int y = e->y - tb->y - _const_ui__textbox_padding_y;
	if (ui__shift_key(e->mods) && ui__TextBox_is_sel_active(tb)) {
		if (tb->is_multiline) {
			ui__TextView_extend_selection(&tb->tv, x, y);
		} else {
			tb->cursor_pos = ui__text_pos_from_x_T_ui__TextBox(tb, *tb->text, x);
			if (tb->twosided_sel) {
				if (tb->sel_start > tb->sel_end) {
					int _var_25531 = tb->sel_start;
					int _var_25545 = tb->sel_end;
					tb->sel_start = _var_25545;
					tb->sel_end = _var_25531;
				}
				if (tb->cursor_pos < tb->sel_start) {
					tb->sel_start = tb->cursor_pos;
				} else if (tb->cursor_pos > tb->sel_end) {
					tb->sel_end = tb->cursor_pos;
				}
			} else {
				tb->sel_end = tb->cursor_pos;
			}
		}
	} else {
		if (!tb->dragging && e->action == ui__MouseAction__down) {
			ui__TextBox_cancel_selection(tb);
		}
		tb->ui->show_cursor = true;
		tb->dragging = e->action == ui__MouseAction__down;
		if (tb->is_multiline) {
			ui__TextView_start_selection(&tb->tv, x, y);
		} else {
			tb->cursor_pos = ui__text_pos_from_x_T_ui__TextBox(tb, *tb->text, x);
			if (tb->dragging) {
				tb->sel_start = tb->cursor_pos;
			}
		}
	}
}

void ui__tb_mouse_move(ui__TextBox* tb, ui__MouseMoveEvent* e, voidptr zzz) {
	if (tb->hidden) {
		return;
	}
	tb->is_selectable = ui__TextBox_point_inside(tb, e->x, e->y);
	if (!(tb->is_selectable)) {
		return;
	}
	if (tb->dragging) {
		int x = ((int)(e->x - tb->x - _const_ui__textbox_padding_x));
		if (tb->is_multiline) {
			int y = ((int)(e->y - tb->y - _const_ui__textbox_padding_y));
			ui__TextView_end_selection(&tb->tv, x, y);
		} else {
			tb->sel_end = ui__text_pos_from_x_T_ui__TextBox(tb, *tb->text, x);
			tb->ui->show_cursor = false;
		}
		tb->sel_active = true;
	}
}

void ui__tb_mouse_up(ui__TextBox* tb, ui__MouseEvent* e, voidptr zzz) {
	if (tb->hidden) {
		return;
	}
	if (!ui__TextBox_point_inside(tb, e->x, e->y)) {
		return;
	}
	tb->dragging = false;
}

void ui__TextBox_set_visible(ui__TextBox* tb, bool state) {
	tb->hidden = !state;
}

void ui__TextBox_focus(ui__TextBox* tb) {
	ui__Focusable f = /*&ui.Focusable*/I_ui__TextBox_to_Interface_ui__Focusable(tb);
	ui__Focusable_force_focus(&f);
}

void ui__TextBox_unfocus(ui__TextBox* tb) {
	tb->is_focused = false;
	tb->sel_active = false;
	tb->sel_start = 0;
	tb->sel_end = 0;
}

void ui__TextBox_hide(ui__TextBox* tb) {
}

void ui__TextBox_set_text(ui__TextBox* tb, string s) {
	if (tb->is_multiline) {
		bool active_x = tb->scrollview->active_x;
		bool active_y = tb->scrollview->active_y;
		{ // Unsafe block
			*tb->text = s;
		}
		ui__TextView_update_lines(&tb->tv);
		if (tb->read_only) {
			ui__TextView_cancel_selection(&tb->tv);
		}
		if ((active_x && !tb->scrollview->active_x) || (active_y && !tb->scrollview->active_y)) {
			ui__scrollview_reset_T_ui__TextBox(tb);
		}
	}
}

void ui__TextBox_insert(ui__TextBox* tb, string s) {
	if (ui__TextBox_is_sel_active(tb)) {
		ui__TextBox_delete_selection(tb);
	}
	Array_rune ustr = string_runes(/*rec*/*tb->text);
	Array_rune sr = string_runes(s);
	array_insert_many(&ustr, tb->cursor_pos, sr.data, sr.len);
	{ // Unsafe block
		*tb->text = Array_rune_string(ustr);
	}
	tb->cursor_pos += sr.len;
}

void ui__TextBox_set_children_pos(ui__TextBox* tb) {
}

ui__Transition* ui__transition(ui__TransitionParams c) {
	ui__Transition* transition = ((ui__Transition*)memdup(&(ui__Transition){.x = 0,
		.y = 0,
		.z_index = c.z_index,
		.offset_x = 0,
		.offset_y = 0,
		.last_draw_time = time__ticks(),
		.started_time = 0,
		.duration = c.duration,
		.animating = false,
		.easing = (voidptr)c.easing,
		.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.start_value = 0,
		.last_draw_target = 0,
		.ui = 0,
		.hidden = 0,
		.id = (string){.str=(byteptr)"", .is_lit=1},
		.target_value = 0,
		.animated_value = 0,
	}, sizeof(ui__Transition)));
	ui__Transition* _t1 = transition;
	return _t1;
}

void ui__Transition_init(ui__Transition* t, ui__Layout parent) {
	t->parent = parent;
	ui__UI* ui = ui__Layout_name_table[parent._typ]._method_get_ui(parent._object);
	t->ui = ui;
}

// Attr: [manualfree]
void ui__Transition_cleanup(ui__Transition* t) {
	ui__Transition_free(t);
}

// Attr: [unsafe]
void ui__Transition_free(ui__Transition* t) {
	{ // Unsafe block
		string_free(&t->id);
		_v_free(t);
	}
}

void ui__Transition_set_value(ui__Transition* t, int* animated_value) {
	t->animated_value = animated_value;
	t->start_value = *animated_value;
	t->target_value = *animated_value;
	t->last_draw_target = *animated_value;
}

void ui__Transition_set_pos(ui__Transition* t, int x, int y) {
}

multi_return_int_int ui__Transition_propose_size(ui__Transition* t, int w, int h) {
	return (multi_return_int_int){.arg0=0, .arg1=0};
}

multi_return_int_int ui__Transition_size(ui__Transition* t) {
	return (multi_return_int_int){.arg0=0, .arg1=0};
}

void ui__Transition_draw(ui__Transition* t) {
	if (t->animated_value == 0) {
		return;
	}
	if (t->target_value != *t->animated_value && !t->animating) {
		t->started_time = time__ticks();
		t->start_value = *t->animated_value;
		t->animating = true;
	} else if (t->animating && t->target_value != t->last_draw_target) {
		t->started_time = time__ticks();
		t->start_value = *t->animated_value;
	}
	if (t->animating) {
		f32 x = ((f32)(time__ticks() - t->started_time + 1)) / ((f32)(t->duration));
		int mapped = t->start_value + ((int)(t->easing(x) * ((f64)(t->target_value - t->start_value))));
		if (x >= 1) {
			t->animating = false;
			mapped = t->target_value;
		}
		(*t->animated_value) = mapped;
		ui__Window_refresh(t->ui->window);
		t->last_draw_target = t->target_value;
		t->last_draw_time = time__ticks();
	}
}

void ui__Transition_set_visible(ui__Transition* t, bool state) {
}

bool ui__Transition_point_inside(ui__Transition* t, f64 x, f64 y) {
	bool _t1 = false;
	return _t1;
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
ui__Window* ui__window(ui__WindowParams cfg) {
	int width = cfg.width;
	int height = cfg.height;
	bool resizable = cfg.resizable;
	bool fullscreen = false;
	gg__Size sc_size = ((gg__Size){.width = width,.height = height,});
	sc_size = gg__screen_size();

	if (cfg.mode == (ui__WindowSizeType__max_size)) {
		if (sc_size.width > 0) {
			width = sc_size.width;
			height = sc_size.height;
			resizable = true;
		}
	}
	else if (cfg.mode == (ui__WindowSizeType__fullscreen)) {
		if (sc_size.width > 10) {
			width = sc_size.width;
			height = sc_size.height;
		}
		fullscreen = true;
	}
	else if (cfg.mode == (ui__WindowSizeType__resizable)) {
		resizable = true;
	}
	else {
	};
	gx__TextCfg text_cfg = ((gx__TextCfg){.color = gx__rgb(38, 38, 38),.size = 16,.align = _const_gx__align_left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,});
	ui__Window* window = ((ui__Window*)memdup(&(ui__Window){.id = _SLIT("_window_"),
		.ui = ((voidptr)(0)),
		.children = cfg.children,
		.child_window = ((voidptr)(0)),
		.parent_window = ((voidptr)(0)),
		.has_textbox = 0,
		.just_tabbed = 0,
		.state = cfg.state,
		.title = cfg.title,
		.width = width,
		.height = height,
		.click_fn = (voidptr)cfg.on_click,
		.mouse_down_fn = (voidptr)cfg.on_mouse_down,
		.mouse_up_fn = (voidptr)cfg.on_mouse_up,
		.files_droped_fn = (voidptr)cfg.on_files_droped,
		.swipe_fn = (voidptr)cfg.on_swipe,
		.mouse_move_fn = (voidptr)cfg.on_mouse_move,
		.scroll_fn = (voidptr)cfg.on_scroll,
		.key_down_fn = (voidptr)cfg.on_key_down,
		.char_fn = (voidptr)cfg.on_char,
		.resize_fn = (voidptr)cfg.on_resize,
		.iconified_fn = (voidptr)cfg.on_iconify,
		.restored_fn = (voidptr)cfg.on_restore,
		.quit_requested_fn = (voidptr)cfg.on_quit_request,
		.suspended_fn = (voidptr)cfg.on_suspend,
		.resumed_fn = (voidptr)cfg.on_resume,
		.on_init = (voidptr)cfg.on_init,
		.on_draw = (voidptr)cfg.on_draw,
		.eventbus = eventbus__new(),
		.resizable = resizable,
		.mode = cfg.mode,
		.root_layout = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.dpi_scale = 0,
		.orig_width = 0,
		.orig_height = 0,
		.touch = (ui__TouchInfo){.start = (ui__Touch){.pos = (ui__Pos){.x = -1,.y = -1,},.time = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,.is_local = 0,},},.move = (ui__Touch){.pos = (ui__Pos){.x = -1,.y = -1,},.time = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,.is_local = 0,},},.end = (ui__Touch){.pos = (ui__Pos){.x = -1,.y = -1,},.time = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,.is_local = 0,},},.button = 0,},
		.bg_color = cfg.bg_color,
		.text_cfg = text_cfg,
		.color_themes = new_map(sizeof(string), sizeof(ui__ColorTheme), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.widgets = new_map(sizeof(string), sizeof(ui__Widget), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.widgets_counts = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.dragger = ((ui__Dragger){.activated = 0,.widget = /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget(_const_ui__empty_stack),.start_x = 0,.start_y = 0,.pos_x = 0,.pos_y = 0,.time = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,.is_local = 0,},}),
		.tooltip = ((ui__Tooltip){.TextLines = ((ui__TextLines){.lines = __new_array(0, 0, sizeof(string)),.x = 0,.y = 0,.width = 0,.height = 0,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,}),.id = (string){.str=(byteptr)"", .is_lit=1},.active = 0,.color = _const_gx__black,.bg_color = ((gx__Color){.r = 255,.g = 220,.b = 127,.a = 220,}),.side = ui__Side__right,.ui = 0,}),
		.widgets_tooltip = __new_array(0, 0, sizeof(ui__Widget)),
		.tooltips = __new_array(0, 0, sizeof(ui__TooltipMessage)),
		.native_message = cfg.native_message,
		.do_focus = 0,
		.locked_focus = (string){.str=(byteptr)"", .is_lit=1},
		.evt_mngr = (ui__EventMngr){.receivers = new_map(sizeof(string), sizeof(Array_ui__Widget), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.point_inside = new_map(sizeof(string), sizeof(Array_ui__Widget), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},
		.subwindows = __new_array(0, 0, sizeof(ui__SubWindow*)),
		.immediate = cfg.immediate,
		.children_immediate = __new_array(0, 0, sizeof(ui__Widget)),
		.needs_refresh = true,
		.settings = (ui__SettingsUI){.int_ = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.f32_ = new_map(sizeof(string), sizeof(f32), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.bool_ = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.string_ = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.color_ = new_map(sizeof(string), sizeof(gx__Color), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.ints_ = new_map(sizeof(string), sizeof(Array_int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.f32s_ = new_map(sizeof(string), sizeof(Array_f32), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.bools_ = new_map(sizeof(string), sizeof(Array_bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.strings_ = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.colors_ = new_map(sizeof(string), sizeof(Array_gx__Color), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},
	}, sizeof(ui__Window)));
	ui__Window_register_default_color_themes(window);
	gg__Context* gcontext = gg__new_context(((gg__Config){
		.width = width,
		.height = height,
		.use_ortho = true,
		.retina = 0,
		.resizable = resizable,
		.user_data = window,
		.font_size = 0,
		.create_window = true,
		.window_title = cfg.title,
		.borderless_window = 0,
		.always_on_top = 0,
		.bg_color = cfg.bg_color,
		.init_fn = (voidptr)ui__gg_init,
		.frame_fn = (voidptr)(cfg.immediate ? (ui__frame_immediate) : cfg.native_rendering ? (ui__native_frame) : (ui__frame)),
		.native_frame_fn = ((voidptr)(0)),
		.cleanup_fn = (voidptr)ui__gg_cleanup,
		.fail_fn = ((voidptr)(0)),
		.event_fn = (voidptr)ui__on_event,
		.quit_fn = ((voidptr)(0)),
		.keydown_fn = ((voidptr)(0)),
		.keyup_fn = ((voidptr)(0)),
		.char_fn = ((voidptr)(0)),
		.move_fn = ((voidptr)(0)),
		.click_fn = ((voidptr)(0)),
		.unclick_fn = ((voidptr)(0)),
		.leave_fn = ((voidptr)(0)),
		.enter_fn = ((voidptr)(0)),
		.resized_fn = ((voidptr)(0)),
		.scroll_fn = ((voidptr)(0)),
		.fullscreen = fullscreen,
		.scale = 1.0,
		.sample_count = 0,
		.swap_interval = 1,
		.font_path = ((cfg.font_path).len == 0 ? (os__font__default()) : (cfg.font_path)),
		.custom_bold_font_path = cfg.custom_bold_font_path,
		.ui_mode = !cfg.immediate,
		.font_bytes_normal = __new_array(0, 0, sizeof(u8)),
		.font_bytes_bold = __new_array(0, 0, sizeof(u8)),
		.font_bytes_mono = __new_array(0, 0, sizeof(u8)),
		.font_bytes_italic = __new_array(0, 0, sizeof(u8)),
		.native_rendering = cfg.native_rendering,
		.enable_dragndrop = cfg.enable_dragndrop,
		.max_dropped_files = cfg.max_dropped_files,
		.max_dropped_file_path_length = cfg.max_dropped_file_path_length,
	}));
	ui__UI* ui_ctx = ((ui__UI*)memdup(&(ui__UI){.gg = gcontext,.window = ((voidptr)(0)),.show_cursor = 0,.last_type_time = 0,.clipboard = clipboard__new(),.btn_down = {0},.cb_image = (gg__Image){.id = 0,.width = 0,.height = 0,.nr_channels = 0,.ok = 0,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},.simg_ok = 0,.simg = {0},.path = (string){.str=(byteptr)"", .is_lit=1},},.circle_image = (gg__Image){.id = 0,.width = 0,.height = 0,.nr_channels = 0,.ok = 0,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},.simg_ok = 0,.simg = {0},.path = (string){.str=(byteptr)"", .is_lit=1},},.selected_radio_image = (gg__Image){.id = 0,.width = 0,.height = 0,.nr_channels = 0,.ok = 0,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},.simg_ok = 0,.simg = {0},.path = (string){.str=(byteptr)"", .is_lit=1},},.down_arrow = (gg__Image){.id = 0,.width = 0,.height = 0,.nr_channels = 0,.ok = 0,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},.simg_ok = 0,.simg = {0},.path = (string){.str=(byteptr)"", .is_lit=1},},.resource_cache = new_map(sizeof(string), sizeof(gg__Image), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.closed = 0,.ticks = 0,.text_styles = new_map(sizeof(string), sizeof(ui__TextStyle), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.fonts = (ui__FontSet){.hash = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},}, sizeof(ui__UI)));
	ui__UI_load_icos(ui_ctx);
	window->ui = ui_ctx;
	ui__Window* _t1 = window;
	return _t1;
}

ui__Window* ui__Window_child_window(ui__Window* parent_window, ui__WindowParams cfg) {
	ui__Window* window = ((ui__Window*)memdup(&(ui__Window){.id = _SLIT("_window_"),
		.ui = parent_window->ui,
		.children = cfg.children,
		.child_window = ((voidptr)(0)),
		.parent_window = parent_window,
		.has_textbox = 0,
		.just_tabbed = 0,
		.state = cfg.state,
		.title = cfg.title,
		.width = cfg.width,
		.height = cfg.height,
		.click_fn = (voidptr)cfg.on_click,
		.mouse_down_fn = 0,
		.mouse_up_fn = 0,
		.files_droped_fn = 0,
		.swipe_fn = 0,
		.mouse_move_fn = 0,
		.scroll_fn = 0,
		.key_down_fn = 0,
		.char_fn = 0,
		.resize_fn = 0,
		.iconified_fn = 0,
		.restored_fn = 0,
		.quit_requested_fn = 0,
		.suspended_fn = 0,
		.resumed_fn = 0,
		.on_init = 0,
		.on_draw = (voidptr)cfg.on_draw,
		.eventbus = eventbus__new(),
		.resizable = 0,
		.mode = 0,
		.root_layout = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),
		.dpi_scale = 0,
		.orig_width = 0,
		.orig_height = 0,
		.touch = (ui__TouchInfo){.start = (ui__Touch){.pos = (ui__Pos){.x = -1,.y = -1,},.time = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,.is_local = 0,},},.move = (ui__Touch){.pos = (ui__Pos){.x = -1,.y = -1,},.time = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,.is_local = 0,},},.end = (ui__Touch){.pos = (ui__Pos){.x = -1,.y = -1,},.time = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,.is_local = 0,},},.button = 0,},
		.bg_color = cfg.bg_color,
		.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},
		.color_themes = new_map(sizeof(string), sizeof(ui__ColorTheme), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.widgets = new_map(sizeof(string), sizeof(ui__Widget), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.widgets_counts = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),
		.dragger = ((ui__Dragger){.activated = 0,.widget = /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget(_const_ui__empty_stack),.start_x = 0,.start_y = 0,.pos_x = 0,.pos_y = 0,.time = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.microsecond = 0,._v_unix = 0,.is_local = 0,},}),
		.tooltip = ((ui__Tooltip){.TextLines = ((ui__TextLines){.lines = __new_array(0, 0, sizeof(string)),.x = 0,.y = 0,.width = 0,.height = 0,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,}),.id = (string){.str=(byteptr)"", .is_lit=1},.active = 0,.color = _const_gx__black,.bg_color = ((gx__Color){.r = 255,.g = 220,.b = 127,.a = 220,}),.side = ui__Side__right,.ui = 0,}),
		.widgets_tooltip = __new_array(0, 0, sizeof(ui__Widget)),
		.tooltips = __new_array(0, 0, sizeof(ui__TooltipMessage)),
		.native_message = 0,
		.do_focus = 0,
		.locked_focus = (string){.str=(byteptr)"", .is_lit=1},
		.evt_mngr = (ui__EventMngr){.receivers = new_map(sizeof(string), sizeof(Array_ui__Widget), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.point_inside = new_map(sizeof(string), sizeof(Array_ui__Widget), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},
		.subwindows = __new_array(0, 0, sizeof(ui__SubWindow*)),
		.immediate = 0,
		.children_immediate = __new_array(0, 0, sizeof(ui__Widget)),
		.needs_refresh = true,
		.settings = (ui__SettingsUI){.int_ = new_map(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.f32_ = new_map(sizeof(string), sizeof(f32), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.bool_ = new_map(sizeof(string), sizeof(bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.string_ = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.color_ = new_map(sizeof(string), sizeof(gx__Color), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.ints_ = new_map(sizeof(string), sizeof(Array_int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.f32s_ = new_map(sizeof(string), sizeof(Array_f32), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.bools_ = new_map(sizeof(string), sizeof(Array_bool), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.strings_ = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.colors_ = new_map(sizeof(string), sizeof(Array_gx__Color), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),},
	}, sizeof(ui__Window)));
	window->widgets = *&parent_window->widgets;
	window->widgets_counts = *&parent_window->widgets_counts;
	parent_window->child_window = window;
	window->evt_mngr = *&parent_window->evt_mngr;
	for (int _t1 = 0; _t1 < window->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)window->children.data) + _t1;
		ui__Window_register_child(parent_window, *child);
		ui__Widget_name_table[child->_typ]._method_init(child->_object, /*&ui.Layout*/I_ui__Window_to_Interface_ui__Layout(parent_window));
	}
	ui__Window* _t2 = window;
	return _t2;
}

void ui__gg_init(ui__Window* window) {
	ui__Window_load_settings(window);
	ui__Window_init_styles(window);
	window->dpi_scale = gg__dpi_scale();
	gg__Size window_size = gg__window_size_real_pixels();
	int w = ((int)(((f32)(window_size.width)) / window->dpi_scale));
	int h = ((int)(((f32)(window_size.height)) / window->dpi_scale));
	window->width = w;
	window->height = h;
	window->orig_width = w;
	window->orig_height = h;
	if (!window->native_message) {
		ui__Window_add_message_dialog(window);
	}
	for (int _t1 = 0; _t1 < window->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)window->children.data) + _t1;
		ui__Window_register_child(window, *child);
		ui__Widget_name_table[child->_typ]._method_init(child->_object, /*&ui.Layout*/I_ui__Window_to_Interface_ui__Layout(window));
	}
	for (int _t2 = 0; _t2 < window->subwindows.len; ++_t2) {
		ui__SubWindow** sw = ((ui__SubWindow**)window->subwindows.data) + _t2;
		ui__Window_register_child(window, /*&ui.Widget*/I_ui__SubWindow_to_Interface_ui__Widget(*sw));
		ui__SubWindow_init(/*diff=1*/*sw, /*&ui.Layout*/I_ui__Window_to_Interface_ui__Layout(window));
	}
	ui__Window_update_layout(window);
	if (window->on_init != (voidptr)((voidptr)(0))) {
		window->on_init(window);
	}
}

// Attr: [manualfree]
void ui__gg_cleanup(ui__Window* window) {
	for (int _t1 = 0; _t1 < window->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)window->children.data) + _t1;
		ui__Widget_name_table[child->_typ]._method_cleanup(child->_object);
	}
	ui__Window_free(window);
}

void ui__frame(ui__Window* w) {
	gg__Context_begin(w->ui->gg);
	Array_ui__Widget children = (w->child_window == 0 ? (w->children) : (w->child_window->children));
	for (int _t1 = 0; _t1 < children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)children.data) + _t1;
		ui__Widget_name_table[child->_typ]._method_draw(child->_object);
	}
	for (int _t2 = 0; _t2 < w->subwindows.len; ++_t2) {
		ui__SubWindow** sw = ((ui__SubWindow**)w->subwindows.data) + _t2;
		ui__SubWindow_draw(/*diff=1*/*sw);
	}
	ui__draw_tooltip(*w);
	if (w->on_draw != (voidptr)((voidptr)(0))) {
		w->on_draw(w);
	}
	gg__Context_end(w->ui->gg);
}

void ui__frame_immediate(ui__Window* w) {
	gg__Context_begin(w->ui->gg);
	for (int _t1 = 0; _t1 < w->children_immediate.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)w->children_immediate.data) + _t1;
		ui__Widget_name_table[child->_typ]._method_draw(child->_object);
	}
	if (!w->needs_refresh) {
		w->ui->ticks++;
		if (w->ui->ticks > 3) {
			return;
		}
	}
	Array_ui__Widget children = (w->child_window == 0 ? (w->children) : (w->child_window->children));
	for (int _t2 = 0; _t2 < children.len; ++_t2) {
		ui__Widget* child = ((ui__Widget*)children.data) + _t2;
		ui__Widget_name_table[child->_typ]._method_draw(child->_object);
	}
	ui__draw_tooltip(*w);
	if (w->on_draw != (voidptr)((voidptr)(0))) {
		w->on_draw(w);
	}
	w->needs_refresh = false;
	gg__Context_end(w->ui->gg);
}

void ui__native_frame(ui__Window* w) {
	Array_ui__Widget children = (w->child_window == 0 ? (w->children) : (w->child_window->children));
	for (int _t1 = 0; _t1 < children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)children.data) + _t1;
		ui__Widget_name_table[child->_typ]._method_draw(child->_object);
	}
}

void ui__on_event(gg__Event* e, ui__Window* window) {
	if (window->ui->gg->native_rendering) {
		if (e->typ == sokol__sapp__EventType__key_down || e->typ == sokol__sapp__EventType__mouse_scroll || e->typ == sokol__sapp__EventType__mouse_up) {
			darwin_window_refresh();
		} else {
			darwin_window_refresh();
		}
	}
	window->ui->ticks = 0;
	switch (e->typ) {
		case sokol__sapp__EventType__mouse_down: 
			{
				ui__window_mouse_down(*e, window->ui);
				window->touch.start = ((ui__Touch){.pos = ((ui__Pos){.x = ((int)(e->mouse_x / window->ui->gg->scale)),.y = ((int)(e->mouse_y / window->ui->gg->scale)),}),.time = time__now(),});
				break;
			}
		case sokol__sapp__EventType__mouse_up: 
			{
				ui__window_mouse_up(*e, window->ui);
				window->touch.end = ((ui__Touch){.pos = ((ui__Pos){.x = ((int)(e->mouse_x / window->ui->gg->scale)),.y = ((int)(e->mouse_y / window->ui->gg->scale)),}),.time = time__now(),});
				ui__window_touch_tap_and_swipe(*e, window->ui);
				break;
			}
		case sokol__sapp__EventType__files_droped: 
			{
				ui__window_files_droped(*e, window->ui);
				break;
			}
		case sokol__sapp__EventType__key_down: 
			{
				ui__window_key_down(*e, window->ui);
				break;
			}
		case sokol__sapp__EventType__char: 
			{
				ui__window_char(*e, window->ui);
				break;
			}
		case sokol__sapp__EventType__mouse_scroll: 
			{
				ui__window_scroll(*e, window->ui);
				break;
			}
		case sokol__sapp__EventType__mouse_move: 
			{
				ui__window_mouse_move(*e, window->ui);
				break;
			}
		case sokol__sapp__EventType__resized: 
			{
				ui__window_resize(*e, window->ui);
				break;
			}
		case sokol__sapp__EventType__iconified: 
			{
				if (window->iconified_fn != (voidptr)((voidptr)(0))) {
					window->iconified_fn(window);
				}
				break;
			}
		case sokol__sapp__EventType__restored: 
			{
				if (window->restored_fn != (voidptr)((voidptr)(0))) {
					window->restored_fn(window);
				}
				break;
			}
		case sokol__sapp__EventType__quit_requested: 
			{
				if (window->quit_requested_fn != (voidptr)((voidptr)(0))) {
					window->quit_requested_fn(window);
				}
				break;
			}
		case sokol__sapp__EventType__suspended: 
			{
				if (window->suspended_fn != (voidptr)((voidptr)(0))) {
					window->suspended_fn(window);
				}
				break;
			}
		case sokol__sapp__EventType__resumed: 
			{
				if (window->resumed_fn != (voidptr)((voidptr)(0))) {
					window->resumed_fn(window);
				}
				break;
			}
		case sokol__sapp__EventType__touches_began: 
			{
				if (e->num_touches > 0) {
					gg__TouchPoint t = e->touches[0];
					window->touch.start = ((ui__Touch){.pos = ((ui__Pos){.x = ((int)(t.pos_x / window->ui->gg->scale)),.y = ((int)(t.pos_y / window->ui->gg->scale)),}),.time = time__now(),});
					window->touch.button = 0;
					ui__window_touch_down(*e, window->ui);
				}
				break;
			}
		case sokol__sapp__EventType__touches_ended: 
			{
				if (e->num_touches > 0) {
					gg__TouchPoint t = e->touches[0];
					window->touch.end = ((ui__Touch){.pos = ((ui__Pos){.x = ((int)(t.pos_x / window->ui->gg->scale)),.y = ((int)(t.pos_y / window->ui->gg->scale)),}),.time = time__now(),});
					window->touch.button = -1;
					ui__window_touch_up(*e, window->ui);
					ui__window_touch_tap_and_swipe(*e, window->ui);
				}
				break;
			}
		case sokol__sapp__EventType__touches_moved: 
			{
				if (e->num_touches > 0) {
					gg__TouchPoint t = e->touches[0];
					window->touch.move = ((ui__Touch){.pos = ((ui__Pos){.x = ((int)(t.pos_x / window->ui->gg->scale)),.y = ((int)(t.pos_y / window->ui->gg->scale)),}),.time = time__now(),});
					if (e->num_touches > 1) {
						ui__window_touch_scroll(*e, window->ui);
					} else {
						ui__window_touch_move(*e, window->ui);
					}
				}
				break;
			}
		case sokol__sapp__EventType__invalid:
		case sokol__sapp__EventType__key_up:
		case sokol__sapp__EventType__mouse_enter:
		case sokol__sapp__EventType__mouse_leave:
		case sokol__sapp__EventType__touches_cancelled:
		case sokol__sapp__EventType__focused:
		case sokol__sapp__EventType__unfocused:
		case sokol__sapp__EventType__update_cursor:
		case sokol__sapp__EventType__clipboard_pasted:
		case sokol__sapp__EventType__num:
		default:
			{
				break;
			}
	}
	;
}

void ui__window_resize(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	if (!window->resizable) {
		return;
	}
	ui__Window_resize(window, event.window_width, event.window_height);
	eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_resize, window, ((voidptr)(0)));
	if (window->resize_fn != (voidptr)((voidptr)(0))) {
		window->resize_fn(event.window_width, event.window_height, window);
	}
}

void ui__window_key_down(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	ui__KeyEvent e = ((ui__KeyEvent){.key = ((ui__Key)(event.key_code)),.action = 0,.code = ((int)(event.key_code)),.mods = ((ui__KeyMod)(event.modifiers)),.codepoint = event.char_code,});
	if (e.key == ui__Key__tab) {
		if (ui__shift_key(e.mods)) {
			ui__Window_focus_prev(window);
		} else {
			ui__Window_focus_next(window);
		}
	} else if (e.key == ui__Key__escape) {
		println(_SLIT("escape"));
	}
	if (e.key == ui__Key__escape && window->child_window != 0) {
		for (int _t1 = 0; _t1 < window->child_window->children.len; ++_t1) {
			ui__Widget* child = ((ui__Widget*)window->child_window->children.data) + _t1;
			ui__Widget_name_table[child->_typ]._method_cleanup(child->_object);
		}
		window->child_window = ((ui__Window*)(0));
	}
	if (window->key_down_fn != (voidptr)((ui__KeyFn)(0))) {
		window->key_down_fn(e, window);
	}
	{
		eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_key_down, window, (voidptr)&/*qq*/e);
	}
}

void ui__window_char(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	ui__KeyEvent e = ((ui__KeyEvent){.key = 0,.action = 0,.code = 0,.mods = ((ui__KeyMod)(event.modifiers)),.codepoint = event.char_code,});
	if (window->char_fn != (voidptr)((ui__KeyFn)(0))) {
		window->char_fn(e, window);
	}
	eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_char, window, (voidptr)&/*qq*/e);
}

void ui__window_mouse_down(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	ui__MouseEvent e = ((ui__MouseEvent){.x = ((int)(event.mouse_x / ui->gg->scale)),.y = ((int)(event.mouse_y / ui->gg->scale)),.button = ((ui__MouseButton)(event.mouse_button)),.action = ui__MouseAction__down,.mods = ((ui__KeyMod)(event.modifiers)),});
	if (((int)(event.mouse_button)) < 3) {
		ui->btn_down[v_fixed_index(((int)(event.mouse_button)), 3)] = true;
	}
	if (window->mouse_down_fn != (voidptr)((voidptr)(0))) {
		window->mouse_down_fn(e, window);
	}
	ui__EventMngr_point_inside_receivers_mouse_event(&window->evt_mngr, e, _const_ui__events.on_mouse_down);
	if (window->child_window != 0) {
		eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_mouse_down, window->child_window, (voidptr)&/*qq*/e);
	} else {
		eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_mouse_down, window, (voidptr)&/*qq*/e);
	}
}

void ui__window_mouse_move(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	ui__MouseMoveEvent e = ((ui__MouseMoveEvent){.x = event.mouse_x / ui->gg->scale,.y = event.mouse_y / ui->gg->scale,.mouse_button = ((int)(event.mouse_button)),});
	if (window->dragger.activated) {
		ui__drag_child(window, e.x, e.y);
	}
	if (window->mouse_move_fn != (voidptr)((voidptr)(0))) {
		window->mouse_move_fn(e, window);
	}
	ui__Window_update_tooltip(window, (voidptr)&/*qq*/e);
	eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_mouse_move, window, (voidptr)&/*qq*/e);
}

void ui__window_mouse_up(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	ui__MouseEvent e = ((ui__MouseEvent){.x = ((int)(event.mouse_x / ui->gg->scale)),.y = ((int)(event.mouse_y / ui->gg->scale)),.button = ((ui__MouseButton)(event.mouse_button)),.action = ui__MouseAction__up,.mods = ((ui__KeyMod)(event.modifiers)),});
	if (((int)(event.mouse_button)) < 3) {
		ui->btn_down[v_fixed_index(((int)(event.mouse_button)), 3)] = false;
	}
	if (window->dragger.activated) {
		ui__drop_child(window);
	}
	if (window->child_window == 0 && window->mouse_up_fn != (voidptr)((voidptr)(0))) {
		window->mouse_up_fn(e, window);
	}
	if (window->child_window != 0) {
		eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_mouse_up, window->child_window, (voidptr)&/*qq*/e);
	} else {
		eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_mouse_up, window, (voidptr)&/*qq*/e);
	}
}

void ui__window_click(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	ui__MouseEvent e = ((ui__MouseEvent){.x = ((int)(event.mouse_x / ui->gg->scale)),.y = ((int)(event.mouse_y / ui->gg->scale)),.button = ((ui__MouseButton)(event.mouse_button)),.action = (event.typ == sokol__sapp__EventType__mouse_up ? (ui__MouseAction__up) : (ui__MouseAction__down)),.mods = ((ui__KeyMod)(event.modifiers)),});
	if (window->click_fn != (voidptr)((voidptr)(0))) {
		window->click_fn(e, window);
	}
	if (window->child_window != 0) {
		eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_click, window->child_window, (voidptr)&/*qq*/e);
	} else {
		eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_click, window, (voidptr)&/*qq*/e);
	}
}

void ui__window_scroll(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	ui__ScrollEvent e = ((ui__ScrollEvent){.x = event.scroll_x / ui->gg->scale,.y = event.scroll_y / ui->gg->scale,.mouse_x = event.mouse_x / ui->gg->scale,.mouse_y = event.mouse_y / ui->gg->scale,});
	if (window->scroll_fn != (voidptr)((voidptr)(0))) {
		window->scroll_fn(e, window);
	}
	ui__EventMngr_point_inside_receivers_scroll(&window->evt_mngr, e);
	eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_scroll, window, (voidptr)&/*qq*/e);
}

void ui__window_touch_down(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	ui__MouseEvent e = ((ui__MouseEvent){.x = window->touch.start.pos.x,.y = window->touch.start.pos.y,.button = 0,.action = ui__MouseAction__down,.mods = 0,});
	ui__EventMngr_point_inside_receivers_mouse_event(&window->evt_mngr, e, _const_ui__events.on_mouse_down);
	if (window->mouse_down_fn != (voidptr)((voidptr)(0))) {
		window->mouse_down_fn(e, window);
	}
	eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_touch_down, window, (voidptr)&/*qq*/e);
}

void ui__window_touch_move(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	ui__MouseMoveEvent e = ((ui__MouseMoveEvent){.x = ((f64)(window->touch.move.pos.x)),.y = ((f64)(window->touch.move.pos.y)),.mouse_button = window->touch.button,});
	if (window->mouse_move_fn != (voidptr)((voidptr)(0))) {
		window->mouse_move_fn(e, window);
	}
	eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_touch_move, window, (voidptr)&/*qq*/e);
}

void ui__window_touch_up(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	ui__MouseEvent e = ((ui__MouseEvent){.x = window->touch.end.pos.x,.y = window->touch.end.pos.y,.button = 0,.action = ui__MouseAction__up,.mods = 0,});
	if (window->mouse_up_fn != (voidptr)((voidptr)(0))) {
		window->mouse_up_fn(e, window);
	}
	eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_touch_up, window, (voidptr)&/*qq*/e);
}

void ui__window_touch_tap(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	ui__MouseEvent e = ((ui__MouseEvent){.x = window->touch.end.pos.x,.y = window->touch.end.pos.y,.button = 0,.action = ui__MouseAction__up,.mods = 0,});
	if (window->click_fn != (voidptr)((voidptr)(0)) && window->child_window == 0) {
		window->click_fn(e, window);
	}
	if (window->child_window != 0) {
		eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_click, window->child_window, (voidptr)&/*qq*/e);
	} else {
		eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_click, window, (voidptr)&/*qq*/e);
	}
}

void ui__window_touch_scroll(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	ui__Touch s = window->touch.start;
	ui__Touch m = window->touch.move;
	int adx = m.pos.x - s.pos.x;
	int ady = m.pos.y - s.pos.y;
	ui__ScrollEvent e = ((ui__ScrollEvent){.x = ((f64)(adx)) / 30.0,.y = ((f64)(ady)) / 30.0,.mouse_x = ((f64)(m.pos.x)),.mouse_y = ((f64)(m.pos.y)),});
	window->touch.start = window->touch.move;
	if (window->scroll_fn != (voidptr)((voidptr)(0))) {
		window->scroll_fn(e, window);
	}
	eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_scroll, window, (voidptr)&/*qq*/e);
}

void ui__window_touch_swipe(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	ui__MouseEvent e = ((ui__MouseEvent){.x = window->touch.end.pos.x,.y = window->touch.end.pos.y,.button = 0,.action = ui__MouseAction__up,.mods = 0,});
	if (window->swipe_fn != (voidptr)((voidptr)(0)) && window->child_window == 0) {
		window->swipe_fn(e, window);
	}
	if (window->child_window != 0) {
		eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_swipe, window->child_window, (voidptr)&/*qq*/e);
	} else {
		eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_swipe, window, (voidptr)&/*qq*/e);
	}
}

void ui__window_touch_tap_and_swipe(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	ui__Touch s = window->touch.start;
	ui__Touch e = window->touch.end;
	int adx = math__abs_T_int(e.pos.x - s.pos.x);
	int ady = math__abs_T_int(e.pos.y - s.pos.y);
	if (math__max_T_int(adx, ady) < 10) {
		ui__window_touch_tap(event, ui);
	} else {
		ui__window_touch_swipe(event, ui);
	}
}

void ui__window_files_droped(gg__Event event, ui__UI* ui) {
	ui__Window* window = ui->window;
	ui__MouseEvent e = ((ui__MouseEvent){.x = ((int)(event.mouse_x / ui->gg->scale)),.y = ((int)(event.mouse_y / ui->gg->scale)),.button = ((ui__MouseButton)(event.mouse_button)),.action = ui__MouseAction__down,.mods = ((ui__KeyMod)(event.modifiers)),});
	if (window->files_droped_fn != (voidptr)((voidptr)(0))) {
		window->files_droped_fn(e, window);
	}
	if (window->child_window != 0) {
		eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_files_droped, window->child_window, (voidptr)&/*qq*/e);
	} else {
		eventbus__EventBus_publish(window->eventbus, _const_ui__events.on_files_droped, window, (voidptr)&/*qq*/e);
	}
}

void ui__Window_set_title(ui__Window* w, string title) {
	w->title = title;
	sapp_set_window_title(title.str);
}

void ui__Window_refresh(ui__Window* w) {
	gg__Context_refresh_ui(w->ui->gg);
	darwin_window_refresh();
}

bool ui__Window_mouse_inside(ui__Window* w, int x, int y, int width, int height) {
	bool _t1 = false;
	return _t1;
}

void ui__Window_on_click(ui__Window* w, void (*func)(ui__MouseEvent e, ui__Window* window)) {
	w->click_fn = (voidptr)func;
}

void ui__Window_on_mousemove(ui__Window* w, void (*func)(ui__MouseMoveEvent e, ui__Window* window)) {
	w->mouse_move_fn = (voidptr)func;
}

void ui__Window_on_scroll(ui__Window* w, void (*func)(ui__ScrollEvent e, ui__Window* window)) {
	w->scroll_fn = (voidptr)func;
}

ui__Widget ui__Window_child(ui__Window* w, Array_int from) {
	if (from.len > 0) {
		Array_ui__Widget children = ui__Layout_name_table[w->root_layout._typ]._method_get_children(w->root_layout._object);
		for (int i = 0; i < from.len; ++i) {
			int ind = ((int*)from.data)[i];
			if (i < from.len - 1) {
				if (ind >= 0 && ind < children.len) {
					ui__Widget widget = (*(ui__Widget*)/*ee elem_sym */array_get(children, ind));
					if ((widget)._typ == _ui__Widget_ui__Stack_index) {
						children = (widget._ui__Stack)->children;
					} else if ((widget)._typ == _ui__Widget_ui__Group_index) {
						children = (widget._ui__Group)->children;
					} else if ((widget)._typ == _ui__Widget_ui__CanvasLayout_index) {
						children = (widget._ui__CanvasLayout)->children;
					} else {
						eprintln( str_intp(5, _MOV((StrIntpData[]){{_SLIT("(ui warning) "), 0xfe10, {.d_s = Array_int_str(from)}}, {_SLIT(" uncorrect: "), 0xfe10, {.d_s = Array_int_str(from)}}, {_SLIT("["), 0xfe07, {.d_i32 = i}}, {_SLIT("]="), 0xfe07, {.d_i32 = ind}}, {_SLIT(" does not correspond to a Layout"), 0, { .d_c = 0 }}})));
						ui__Layout root = w->root_layout;
						if ((root)._typ == _ui__Layout_ui__Stack_index) {
							ui__Widget _t1 = /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget((root._ui__Stack));
							return _t1;
						}
					}
				} else if (i == -1) {
					ui__Widget widget = (*(ui__Widget*)/*ee elem_sym */array_get(children, children.len - 1));
					if ((widget)._typ == _ui__Widget_ui__Stack_index) {
						children = (widget._ui__Stack)->children;
					} else if ((widget)._typ == _ui__Widget_ui__Group_index) {
						children = (widget._ui__Group)->children;
					}
				} else {
					eprintln( str_intp(5, _MOV((StrIntpData[]){{_SLIT("(ui warning) "), 0xfe10, {.d_s = Array_int_str(from)}}, {_SLIT(" uncorrect: "), 0xfe10, {.d_s = Array_int_str(from)}}, {_SLIT("["), 0xfe07, {.d_i32 = i}}, {_SLIT("]="), 0xfe07, {.d_i32 = ind}}, {_SLIT(" out of bounds"), 0, { .d_c = 0 }}})));
					ui__Layout root = w->root_layout;
					if ((root)._typ == _ui__Layout_ui__Stack_index) {
						ui__Widget _t2 = /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget((root._ui__Stack));
						return _t2;
					}
				}
			} else {
				if (ind >= 0 && ind < children.len) {
					ui__Widget _t3 = (*(ui__Widget*)/*ee elem_sym */array_get(children, ind));
					return _t3;
				} else if (ind == -1) {
					ui__Widget _t4 = (*(ui__Widget*)/*ee elem_sym */array_get(children, children.len - 1));
					return _t4;
				} else {
					eprintln( str_intp(5, _MOV((StrIntpData[]){{_SLIT("(ui warning) "), 0xfe10, {.d_s = Array_int_str(from)}}, {_SLIT(" uncorrect: "), 0xfe10, {.d_s = Array_int_str(from)}}, {_SLIT("["), 0xfe07, {.d_i32 = i}}, {_SLIT("]="), 0xfe07, {.d_i32 = ind}}, {_SLIT(" out of bounds"), 0, { .d_c = 0 }}})));
				}
			}
		}
	}
	ui__Layout root = w->root_layout;
	if ((root)._typ == _ui__Layout_ui__Stack_index) {
		ui__Widget _t5 = /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget((root._ui__Stack));
		return _t5;
	} else {
		ui__Widget _t6 = /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget(((ui__Stack*)memdup(&(ui__Stack){.cache = (ui__CachedSizes){.width_type = __new_array(0, 0, sizeof(ui__ChildSize)),.height_type = __new_array(0, 0, sizeof(ui__ChildSize)),.adj_widths = __new_array(0, 0, sizeof(int)),.adj_heights = __new_array(0, 0, sizeof(int)),.fixed_widths = __new_array(0, 0, sizeof(int)),.fixed_heights = __new_array(0, 0, sizeof(int)),.fixed_width = 0,.fixed_height = 0,.min_width = 0,.min_height = 0,.weight_widths = __new_array(0, 0, sizeof(f64)),.weight_heights = __new_array(0, 0, sizeof(f64)),},.id = (string){.str=(byteptr)"", .is_lit=1},.offset_x = 0,.offset_y = 0,.x = 0,.y = 0,.width = 0,.height = 0,.z_index = 0,.parent = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),.ui = 0,.vertical_alignment = 0,.horizontal_alignment = 0,.spacings = __new_array(0, 0, sizeof(f32)),.stretch = 0,.direction = 0,.margins = {0},.real_x = -1,.real_y = -1,.real_width = 0,.real_height = 0,.adj_width = 0,.adj_height = 0,.fixed_width = 0,.fixed_height = 0,.title = (string){.str=(byteptr)"", .is_lit=1},.children = __new_array(0, 0, sizeof(ui__Widget)),.drawing_children = __new_array(0, 0, sizeof(ui__Widget)),.widths = __new_array(0, 0, sizeof(f32)),.heights = __new_array(0, 0, sizeof(f32)),.vertical_alignments = (ui__VerticalAlignments){.top = __new_array(0, 0, sizeof(int)),.center = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),},.horizontal_alignments = (ui__HorizontalAlignments){.left = __new_array(0, 0, sizeof(int)),.center = __new_array(0, 0, sizeof(int)),.right = __new_array(0, 0, sizeof(int)),},.alignments = (ui__Alignments){.center = __new_array(0, 0, sizeof(int)),.left_top = __new_array(0, 0, sizeof(int)),.top = __new_array(0, 0, sizeof(int)),.right_top = __new_array(0, 0, sizeof(int)),.right = __new_array(0, 0, sizeof(int)),.right_bottom = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),.left_bottom = __new_array(0, 0, sizeof(int)),.left = __new_array(0, 0, sizeof(int)),},.hidden = 0,.bg_color = (gx__Color){.r = 0,.g = 0,.b = 0,.a = 255,},.bg_radius = 0,.is_root_layout = true,.component = 0,.component_init = 0,.has_scrollview = 0,.scrollview = 0,.on_scroll_change = ((ui__ScrollViewChangedFn)(0)),.debug_ids = __new_array(0, 0, sizeof(string)),}, sizeof(ui__Stack))));
		return _t6;
	}
	return (ui__Widget){0};
}

bool ui__Window_is_registred(ui__Window* w, ui__Widget* widget) {
	bool _t1 = _IN_MAP(ADDR(string, (*(widget->id))), ADDR(map, w->widgets));
	return _t1;
}

// Attr: [unsafe]
void ui__Window_free(ui__Window* w) {
	{ // Unsafe block
		ui__UI_free(w->ui);
		array_free(&w->children);
		string_free(&w->title);
		map_free(&w->color_themes);
		map_free(&w->widgets);
		map_free(&w->widgets_counts);
		ui__Tooltip_free(&w->tooltip);
		_v_free(w);
	}
}

ui__UI* ui__Window_get_ui(ui__Window* w) {
	ui__UI* _t1 = w->ui;
	return _t1;
}

voidptr ui__Window_get_state(ui__Window* w) {
	voidptr _t1 = w->state;
	return _t1;
}

multi_return_int_int ui__Window_size(ui__Window* w) {
	return (multi_return_int_int){.arg0=w->width, .arg1=w->height};
}

Array_ui__Widget ui__Window_get_children(ui__Window* w) {
	Array_ui__Widget _t1 = w->children;
	return _t1;
}

eventbus__Subscriber* ui__Window_get_subscriber(ui__Window* w) {
	eventbus__Subscriber* _t1 = w->eventbus->subscriber;
	return _t1;
}

void ui__Window_resize(ui__Window* window, int w, int h) {
	window->width = w;
	window->height = h;
	gg__Context_resize(window->ui->gg, w, h);
	for (int _t1 = 0; _t1 < window->children.len; ++_t1) {
		ui__Widget* child = ((ui__Widget*)window->children.data) + _t1;
		if ((child)->_typ == _ui__Widget_ui__Stack_index) {
			ui__Stack_resize((child->_ui__Stack), w, h);
		}
		if ((child)->_typ == _ui__Widget_ui__CanvasLayout_index) {
			ui__CanvasLayout_resize((child->_ui__CanvasLayout), w, h);
		}
	}
}

void ui__Window_update_layout(ui__Window* w) {
	ui__Layout s = w->root_layout;
	if ((s)._typ == _ui__Layout_ui__Stack_index) {
		if (!string__eq((s._ui__Stack)->id, _const_ui__empty_stack->id)) {
			ui__Stack_update_layout((s._ui__Stack));
		}
	}
}

void ui__Window_update_layout_without_pos(ui__Window* w) {
	ui__Layout s = w->root_layout;
	if ((s)._typ == _ui__Layout_ui__Stack_index) {
		if (!string__eq((s._ui__Stack)->id, _const_ui__empty_stack->id)) {
			ui__Stack_update_layout_without_pos((s._ui__Stack));
		}
	}
}

void ui__Window_draw(ui__Window* w) {
}

bool ui__Window_unlocked_focus(ui__Window* w) {
	bool _t1 = (w->locked_focus).len == 0;
	return _t1;
}

void ui__Window_focus_next(ui__Window* w) {
	w->do_focus = false;
	if (!ui__Layout_set_focus_next(/*&ui.Layout*/I_ui__Window_to_Interface_ui__Layout(w))) {
		ui__Layout_set_focus_first(/*&ui.Layout*/I_ui__Window_to_Interface_ui__Layout(w));
	}
}

void ui__Window_focus_prev(ui__Window* w) {
	w->do_focus = false;
	if (!ui__Layout_set_focus_prev(/*&ui.Layout*/I_ui__Window_to_Interface_ui__Layout(w))) {
		ui__Layout_set_focus_last(/*&ui.Layout*/I_ui__Window_to_Interface_ui__Layout(w));
	}
}

void ui__Window_always_on_top(ui__Window* w, bool val) {
}

void ui__Window_set_cursor(ui__Window* w, ui__Cursor cursor) {
}

void ui__Window_onmousedown(ui__Window* w, voidptr cb) {
}

void ui__Window_close(ui__Window* w) {
}

void ui__Window_register_child(ui__Window* w, ui__Widget child_) {
	ui__Widget child = child_;
	if ((child)._typ == _ui__Widget_ui__Button_index) {
		if (((child._ui__Button)->id).len == 0) {
			string mode = _SLIT("btn");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__Button)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__Button)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Button_to_Interface_ui__Widget((child._ui__Button)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__Button)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Button_to_Interface_ui__Widget((child._ui__Button)) });
		}
		#if defined(CUSTOM_DEFINE_register)
		{
		}
		#else
		{
		}
		#endif
	} else if ((child)._typ == _ui__Widget_ui__Canvas_index) {
		if (((child._ui__Canvas)->id).len == 0) {
			string mode = _SLIT("can");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__Canvas)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__Canvas)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Canvas_to_Interface_ui__Widget((child._ui__Canvas)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__Canvas)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Canvas_to_Interface_ui__Widget((child._ui__Canvas)) });
		}
	} else if ((child)._typ == _ui__Widget_ui__CheckBox_index) {
		if (((child._ui__CheckBox)->id).len == 0) {
			string mode = _SLIT("cb");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__CheckBox)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__CheckBox)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__CheckBox_to_Interface_ui__Widget((child._ui__CheckBox)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__CheckBox)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__CheckBox_to_Interface_ui__Widget((child._ui__CheckBox)) });
		}
	} else if ((child)._typ == _ui__Widget_ui__Dropdown_index) {
		if (((child._ui__Dropdown)->id).len == 0) {
			string mode = _SLIT("dd");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__Dropdown)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__Dropdown)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Dropdown_to_Interface_ui__Widget((child._ui__Dropdown)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__Dropdown)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Dropdown_to_Interface_ui__Widget((child._ui__Dropdown)) });
		}
	} else if ((child)._typ == _ui__Widget_ui__Grid_index) {
		if (((child._ui__Grid)->id).len == 0) {
			string mode = _SLIT("grid");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__Grid)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__Grid)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Grid_to_Interface_ui__Widget((child._ui__Grid)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__Grid)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Grid_to_Interface_ui__Widget((child._ui__Grid)) });
		}
	} else if ((child)._typ == _ui__Widget_ui__Label_index) {
		if (((child._ui__Label)->id).len == 0) {
			string mode = _SLIT("lab");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__Label)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__Label)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Label_to_Interface_ui__Widget((child._ui__Label)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__Label)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Label_to_Interface_ui__Widget((child._ui__Label)) });
		}
	} else if ((child)._typ == _ui__Widget_ui__ListBox_index) {
		if (((child._ui__ListBox)->id).len == 0) {
			string mode = _SLIT("lb");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__ListBox)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__ListBox)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__ListBox_to_Interface_ui__Widget((child._ui__ListBox)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__ListBox)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__ListBox_to_Interface_ui__Widget((child._ui__ListBox)) });
		}
	} else if ((child)._typ == _ui__Widget_ui__Menu_index) {
		if (((child._ui__Menu)->id).len == 0) {
			string mode = _SLIT("menu");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__Menu)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__Menu)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Menu_to_Interface_ui__Widget((child._ui__Menu)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__Menu)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Menu_to_Interface_ui__Widget((child._ui__Menu)) });
		}
	} else if ((child)._typ == _ui__Widget_ui__Picture_index) {
		if (((child._ui__Picture)->id).len == 0) {
			string mode = _SLIT("pic");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__Picture)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__Picture)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Picture_to_Interface_ui__Widget((child._ui__Picture)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__Picture)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Picture_to_Interface_ui__Widget((child._ui__Picture)) });
		}
	} else if ((child)._typ == _ui__Widget_ui__ProgressBar_index) {
		if (((child._ui__ProgressBar)->id).len == 0) {
			string mode = _SLIT("pb");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__ProgressBar)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__ProgressBar)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__ProgressBar_to_Interface_ui__Widget((child._ui__ProgressBar)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__ProgressBar)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__ProgressBar_to_Interface_ui__Widget((child._ui__ProgressBar)) });
		}
	} else if ((child)._typ == _ui__Widget_ui__Radio_index) {
		if (((child._ui__Radio)->id).len == 0) {
			string mode = _SLIT("rad");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__Radio)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__Radio)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Radio_to_Interface_ui__Widget((child._ui__Radio)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__Radio)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Radio_to_Interface_ui__Widget((child._ui__Radio)) });
		}
	} else if ((child)._typ == _ui__Widget_ui__Rectangle_index) {
		if (((child._ui__Rectangle)->id).len == 0) {
			string mode = _SLIT("rec");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__Rectangle)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__Rectangle)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Rectangle_to_Interface_ui__Widget((child._ui__Rectangle)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__Rectangle)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Rectangle_to_Interface_ui__Widget((child._ui__Rectangle)) });
		}
	} else if ((child)._typ == _ui__Widget_ui__Slider_index) {
		if (((child._ui__Slider)->id).len == 0) {
			string mode = _SLIT("sli");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__Slider)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__Slider)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Slider_to_Interface_ui__Widget((child._ui__Slider)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__Slider)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Slider_to_Interface_ui__Widget((child._ui__Slider)) });
		}
	} else if ((child)._typ == _ui__Widget_ui__Switch_index) {
		if (((child._ui__Switch)->id).len == 0) {
			string mode = _SLIT("swi");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__Switch)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__Switch)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Switch_to_Interface_ui__Widget((child._ui__Switch)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__Switch)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Switch_to_Interface_ui__Widget((child._ui__Switch)) });
		}
	} else if ((child)._typ == _ui__Widget_ui__TextBox_index) {
		if (((child._ui__TextBox)->id).len == 0) {
			string mode = _SLIT("tb");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__TextBox)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__TextBox)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__TextBox_to_Interface_ui__Widget((child._ui__TextBox)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__TextBox)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__TextBox_to_Interface_ui__Widget((child._ui__TextBox)) });
		}
	} else if ((child)._typ == _ui__Widget_ui__Transition_index) {
		if (((child._ui__Transition)->id).len == 0) {
			string mode = _SLIT("tra");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__Transition)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__Transition)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Transition_to_Interface_ui__Widget((child._ui__Transition)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__Transition)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Transition_to_Interface_ui__Widget((child._ui__Transition)) });
		}
	} else if ((child)._typ == _ui__Widget_ui__Stack_index) {
		if (((child._ui__Stack)->id).len == 0) {
			string mode = ((child._ui__Stack)->direction == ui__Direction__row ? (_SLIT("row")) : (_SLIT("col")));
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__Stack)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__Stack)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget((child._ui__Stack)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__Stack)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget((child._ui__Stack)) });
		}
		for (int _t1 = 0; _t1 < (child._ui__Stack)->children.len; ++_t1) {
			ui__Widget child2 = ((ui__Widget*)(child._ui__Stack)->children.data)[_t1];
			ui__Window_register_child(w, child2);
		}
	} else if ((child)._typ == _ui__Widget_ui__Group_index) {
		if (((child._ui__Group)->id).len == 0) {
			string mode = _SLIT("gr");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__Group)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__Group)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Group_to_Interface_ui__Widget((child._ui__Group)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__Group)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__Group_to_Interface_ui__Widget((child._ui__Group)) });
		}
		for (int _t2 = 0; _t2 < (child._ui__Group)->children.len; ++_t2) {
			ui__Widget child2 = ((ui__Widget*)(child._ui__Group)->children.data)[_t2];
			ui__Window_register_child(w, child2);
		}
	} else if ((child)._typ == _ui__Widget_ui__CanvasLayout_index) {
		if (((child._ui__CanvasLayout)->id).len == 0) {
			string mode = _SLIT("cl");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__CanvasLayout)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__CanvasLayout)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__CanvasLayout_to_Interface_ui__Widget((child._ui__CanvasLayout)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__CanvasLayout)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__CanvasLayout_to_Interface_ui__Widget((child._ui__CanvasLayout)) });
		}
		for (int _t3 = 0; _t3 < (child._ui__CanvasLayout)->children.len; ++_t3) {
			ui__Widget child2 = ((ui__Widget*)(child._ui__CanvasLayout)->children.data)[_t3];
			ui__Window_register_child(w, child2);
		}
	} else if ((child)._typ == _ui__Widget_ui__SubWindow_index) {
		if (((child._ui__SubWindow)->id).len == 0) {
			string mode = _SLIT("sw");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			(child._ui__SubWindow)->id =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(child._ui__SubWindow)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__SubWindow_to_Interface_ui__Widget((child._ui__SubWindow)) });
		} else {
			map_set(&w->widgets, &(string[]){(child._ui__SubWindow)->id}, &(ui__Widget[]) { /*&ui.Widget*/I_ui__SubWindow_to_Interface_ui__Widget((child._ui__SubWindow)) });
		}
		if (I_ui__Layout_is_I_ui__Widget((child._ui__SubWindow)->layout)) {
			ui__Widget l = I_ui__Layout_as_I_ui__Widget((child._ui__SubWindow)->layout);
			ui__Window_register_child(w, l);
		}
	} else {
		if (((*(child.id))).len == 0) {
			string mode = _SLIT("unknown");
			(*((int*)map_get_and_set((map*)&w->widgets_counts, &(string[]){mode}, &(int[]) { 0 }))) += 1;
			ui__Widget u = child;
			(*(u.id)) =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("_"), 0xfe10, {.d_s = mode}}, {_SLIT("_"), 0xfe07, {.d_i32 = (*(int*)map_get(ADDR(map, w->widgets_counts), &(string[]){mode}, &(int[]){ 0 }))}}, {_SLIT0, 0, { .d_c = 0 }}}));
			map_set(&w->widgets, &(string[]){(*(child.id))}, &(ui__Widget[]) { child });
		} else {
			map_set(&w->widgets, &(string[]){(*(child.id))}, &(ui__Widget[]) { child });
		}
	}
}

ui__Button* ui__Window_button(ui__Window* w, string id) {
	ui__Widget* _t2 = (ui__Widget*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->widgets), &(string[]){id}));
	Option_ui__Widget _t1 = {0};
	if (_t2) {
		*((ui__Widget*)&_t1.data) = *((ui__Widget*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		panic_debug(1426, tos3("/Users/rcqls/.vmodules/ui/window.v"), tos3("ui"), tos3("button"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("widget with id  "), 0xfe10, {.d_s = id}}, {_SLIT(" does not exist"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
	ui__Widget widget = *(ui__Widget*)_t1.data;
	if ((widget)._typ == _ui__Widget_ui__Button_index) {
		ui__Button* _t3 = (widget._ui__Button);
		return _t3;
	} else {
		ui__Button* _t4 = ui__button(((ui__ButtonParams){.id = (string){.str=(byteptr)"", .is_lit=1},.text = (string){.str=(byteptr)"", .is_lit=1},.icon_path = (string){.str=(byteptr)"", .is_lit=1},.onclick = 0,.on_key_down = 0,.height = 0,.width = 0,.z_index = 0,.movable = 0,.hoverable = 0,.tooltip = (string){.str=(byteptr)"", .is_lit=1},.tooltip_side = ui__Side__top,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,.bg_color = 0,.theme = string_to_sumtype_ui__ColorThemeCfg(ADDR(string, (_SLIT("classic")))),.radius = 0,.padding = 0,}));
		return _t4;
	}
	return 0;
}

ui__Label* ui__Window_label(ui__Window* w, string id) {
	ui__Widget* _t2 = (ui__Widget*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->widgets), &(string[]){id}));
	Option_ui__Widget _t1 = {0};
	if (_t2) {
		*((ui__Widget*)&_t1.data) = *((ui__Widget*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		panic_debug(1435, tos3("/Users/rcqls/.vmodules/ui/window.v"), tos3("ui"), tos3("label"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("widget with id  "), 0xfe10, {.d_s = id}}, {_SLIT(" does not exist"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
	ui__Widget widget = *(ui__Widget*)_t1.data;
	if ((widget)._typ == _ui__Widget_ui__Label_index) {
		ui__Label* _t3 = (widget._ui__Label);
		return _t3;
	} else {
		ui__Label* _t4 = ui__label(((ui__LabelParams){.id = (string){.str=(byteptr)"", .is_lit=1},.width = 0,.height = 0,.z_index = 0,.text = (string){.str=(byteptr)"", .is_lit=1},.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,}));
		return _t4;
	}
	return 0;
}

ui__ListBox* ui__Window_listbox(ui__Window* w, string id) {
	ui__Widget* _t2 = (ui__Widget*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->widgets), &(string[]){id}));
	Option_ui__Widget _t1 = {0};
	if (_t2) {
		*((ui__Widget*)&_t1.data) = *((ui__Widget*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		panic_debug(1444, tos3("/Users/rcqls/.vmodules/ui/window.v"), tos3("ui"), tos3("listbox"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("widget with id  "), 0xfe10, {.d_s = id}}, {_SLIT(" does not exist"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
	ui__Widget widget = *(ui__Widget*)_t1.data;
	if ((widget)._typ == _ui__Widget_ui__ListBox_index) {
		ui__ListBox* _t3 = (widget._ui__ListBox);
		return _t3;
	} else {
		ui__ListBox* _t4 = ui__listbox(((ui__ListBoxParams){.x = 0,.y = 0,.width = 0,.height = 0,.z_index = 0,.on_change = ((ui__ListBoxSelectionChangedFn)(0)),.draw_lines = 0,.col_border = _const_ui___col_border,.col_bkgrnd = _const_ui___col_list_bkgrnd,.col_selected = _const_ui___col_item_select,.item_height = _const_ui___item_height,.text_offset_y = _const_ui___text_offset_y,.id = (string){.str=(byteptr)"", .is_lit=1},.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,.selection = -1,.scrollview = true,.items = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.files_droped = 0,}));
		return _t4;
	}
	return 0;
}

ui__Dropdown* ui__Window_dropdown(ui__Window* w, string id) {
	ui__Widget* _t2 = (ui__Widget*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->widgets), &(string[]){id}));
	Option_ui__Widget _t1 = {0};
	if (_t2) {
		*((ui__Widget*)&_t1.data) = *((ui__Widget*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		panic_debug(1453, tos3("/Users/rcqls/.vmodules/ui/window.v"), tos3("ui"), tos3("dropdown"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("widget with id  "), 0xfe10, {.d_s = id}}, {_SLIT(" does not exist"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
	ui__Widget widget = *(ui__Widget*)_t1.data;
	if ((widget)._typ == _ui__Widget_ui__Dropdown_index) {
		ui__Dropdown* _t3 = (widget._ui__Dropdown);
		return _t3;
	} else {
		ui__Dropdown* _t4 = ui__dropdown(((ui__DropdownParams){.id = (string){.str=(byteptr)"", .is_lit=1},.def_text = (string){.str=(byteptr)"", .is_lit=1},.x = 0,.y = 0,.width = 150,.height = 25,.z_index = 10,.selected_index = -1,.on_selection_changed = 0,.items = __new_array(0, 0, sizeof(ui__DropdownItem)),.texts = __new_array(0, 0, sizeof(string)),}));
		return _t4;
	}
	return 0;
}

ui__TextBox* ui__Window_textbox(ui__Window* w, string id) {
	ui__Widget* _t2 = (ui__Widget*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->widgets), &(string[]){id}));
	Option_ui__Widget _t1 = {0};
	if (_t2) {
		*((ui__Widget*)&_t1.data) = *((ui__Widget*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		panic_debug(1462, tos3("/Users/rcqls/.vmodules/ui/window.v"), tos3("ui"), tos3("textbox"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("widget with id  "), 0xfe10, {.d_s = id}}, {_SLIT(" does not exist"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
	ui__Widget widget = *(ui__Widget*)_t1.data;
	if ((widget)._typ == _ui__Widget_ui__TextBox_index) {
		ui__TextBox* _t3 = (widget._ui__TextBox);
		return _t3;
	} else {
		panic_debug(1466, tos3("/Users/rcqls/.vmodules/ui/window.v"), tos3("ui"), tos3("textbox"),   str_intp(3, _MOV((StrIntpData[]){{_SLIT("widget "), 0xfe10, {.d_s = id}}, {_SLIT(" is not a ui.TextBox but a "), 0xfe10, {.d_s = charptr_vstring_literal( /* ui.Widget */ v_typeof_interface_ui__Widget( (widget)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
		ui__TextBox* _t4 = ui__textbox(((ui__TextBoxParams){.id = (string){.str=(byteptr)"", .is_lit=1},.width = 0,.height = 22,.read_only = 0,.is_multiline = 0,.is_wordwrap = 0,.is_line_number = 0,.mode = 0,.is_sync = true,.twosided_sel = 0,.z_index = 0,.min = 0,.max = 0,.val = 0,.placeholder = (string){.str=(byteptr)"", .is_lit=1},.placeholder_bind = ((voidptr)(0)),.max_len = 0,.is_numeric = 0,.is_password = 0,.text = ((voidptr)(0)),.is_error = ((voidptr)(0)),.is_focused = 0,.bg_color = _const_gx__white,.borderless = 0,.fitted_height = 0,.on_key_down = 0,.on_char = 0,.on_change = 0,.on_enter = 0,.on_changed = ((ui__TextBoxValidatedFn)(0)),.on_entered = ((ui__TextBoxValidatedFn)(0)),.border_accentuated = 0,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,.scrollview = true,.on_scroll_change = ((ui__ScrollViewChangedFn)(0)),}));
		return _t4;
	}
	return 0;
}

ui__Radio* ui__Window_radio(ui__Window* w, string id) {
	ui__Widget* _t2 = (ui__Widget*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->widgets), &(string[]){id}));
	Option_ui__Widget _t1 = {0};
	if (_t2) {
		*((ui__Widget*)&_t1.data) = *((ui__Widget*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		panic_debug(1472, tos3("/Users/rcqls/.vmodules/ui/window.v"), tos3("ui"), tos3("radio"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("widget with id  "), 0xfe10, {.d_s = id}}, {_SLIT(" does not exist"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
	ui__Widget widget = *(ui__Widget*)_t1.data;
	if ((widget)._typ == _ui__Widget_ui__Radio_index) {
		ui__Radio* _t3 = (widget._ui__Radio);
		return _t3;
	} else {
		ui__Radio* _t4 = ui__radio(((ui__RadioParams){.id = (string){.str=(byteptr)"", .is_lit=1},.on_click = 0,.values = __new_array(0, 0, sizeof(string)),.title = (string){.str=(byteptr)"", .is_lit=1},.width = 0,.z_index = 0,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,.horizontal = 0,.compact = 0,}));
		return _t4;
	}
	return 0;
}

ui__CheckBox* ui__Window_checkbox(ui__Window* w, string id) {
	ui__Widget* _t2 = (ui__Widget*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->widgets), &(string[]){id}));
	Option_ui__Widget _t1 = {0};
	if (_t2) {
		*((ui__Widget*)&_t1.data) = *((ui__Widget*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		panic_debug(1481, tos3("/Users/rcqls/.vmodules/ui/window.v"), tos3("ui"), tos3("checkbox"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("widget with id  "), 0xfe10, {.d_s = id}}, {_SLIT(" does not exist"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
	ui__Widget widget = *(ui__Widget*)_t1.data;
	if ((widget)._typ == _ui__Widget_ui__CheckBox_index) {
		ui__CheckBox* _t3 = (widget._ui__CheckBox);
		return _t3;
	} else {
		ui__CheckBox* _t4 = ui__checkbox(((ui__CheckBoxParams){.id = (string){.str=(byteptr)"", .is_lit=1},.x = 0,.y = 0,.z_index = 0,.text = (string){.str=(byteptr)"", .is_lit=1},.on_click = 0,.on_check_changed = 0,.checked = 0,.disabled = 0,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,}));
		return _t4;
	}
	return 0;
}

ui__Stack* ui__Window_stack(ui__Window* w, string id) {
	ui__Widget* _t2 = (ui__Widget*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->widgets), &(string[]){id}));
	Option_ui__Widget _t1 = {0};
	if (_t2) {
		*((ui__Widget*)&_t1.data) = *((ui__Widget*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		panic_debug(1490, tos3("/Users/rcqls/.vmodules/ui/window.v"), tos3("ui"), tos3("stack"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("widget with id  "), 0xfe10, {.d_s = id}}, {_SLIT(" does not exist"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
	ui__Widget widget = *(ui__Widget*)_t1.data;
	if ((widget)._typ == _ui__Widget_ui__Stack_index) {
		ui__Stack* _t3 = (widget._ui__Stack);
		return _t3;
	} else {
		ui__Stack* _t4 = ui__stack(((ui__StackParams){.id = (string){.str=(byteptr)"", .is_lit=1},.width = 0,.height = 0,.vertical_alignment = 0,.horizontal_alignment = 0,.spacings = __new_array(0, 0, sizeof(f32)),.spacing = 0,.stretch = 0,.direction = 0,.margins = {0},.title = (string){.str=(byteptr)"", .is_lit=1},.widths = __new_array(0, 0, sizeof(f32)),.heights = __new_array(0, 0, sizeof(f32)),.align = (ui__Alignments){.center = __new_array(0, 0, sizeof(int)),.left_top = __new_array(0, 0, sizeof(int)),.top = __new_array(0, 0, sizeof(int)),.right_top = __new_array(0, 0, sizeof(int)),.right = __new_array(0, 0, sizeof(int)),.right_bottom = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),.left_bottom = __new_array(0, 0, sizeof(int)),.left = __new_array(0, 0, sizeof(int)),},.vertical_alignments = (ui__VerticalAlignments){.top = __new_array(0, 0, sizeof(int)),.center = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),},.horizontal_alignments = (ui__HorizontalAlignments){.left = __new_array(0, 0, sizeof(int)),.center = __new_array(0, 0, sizeof(int)),.right = __new_array(0, 0, sizeof(int)),},.bg_color = (gx__Color){.r = 0,.g = 0,.b = 0,.a = 255,},.bg_radius = 0,.scrollview = 0,.children = __new_array(0, 0, sizeof(ui__Widget)),}));
		return _t4;
	}
	return 0;
}

ui__Group* ui__Window_group(ui__Window* w, string id) {
	ui__Widget* _t2 = (ui__Widget*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->widgets), &(string[]){id}));
	Option_ui__Widget _t1 = {0};
	if (_t2) {
		*((ui__Widget*)&_t1.data) = *((ui__Widget*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		panic_debug(1499, tos3("/Users/rcqls/.vmodules/ui/window.v"), tos3("ui"), tos3("group"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("widget with id  "), 0xfe10, {.d_s = id}}, {_SLIT(" does not exist"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
	ui__Widget widget = *(ui__Widget*)_t1.data;
	if ((widget)._typ == _ui__Widget_ui__Group_index) {
		ui__Group* _t3 = (widget._ui__Group);
		return _t3;
	} else {
		ui__Group* _t4 = ui__group(((ui__GroupParams){.id = (string){.str=(byteptr)"", .is_lit=1},.title = (string){.str=(byteptr)"", .is_lit=1},.x = 0,.y = 0,.width = 0,.height = 0,.spacing = 5,.children = __new_array(0, 0, sizeof(ui__Widget)),}));
		return _t4;
	}
	return 0;
}

ui__CanvasLayout* ui__Window_canvas_layout(ui__Window* w, string id) {
	ui__Widget* _t2 = (ui__Widget*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->widgets), &(string[]){id}));
	Option_ui__Widget _t1 = {0};
	if (_t2) {
		*((ui__Widget*)&_t1.data) = *((ui__Widget*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		panic_debug(1508, tos3("/Users/rcqls/.vmodules/ui/window.v"), tos3("ui"), tos3("canvas_layout"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("widget with id  "), 0xfe10, {.d_s = id}}, {_SLIT(" does not exist"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
	ui__Widget widget = *(ui__Widget*)_t1.data;
	if ((widget)._typ == _ui__Widget_ui__CanvasLayout_index) {
		ui__CanvasLayout* _t3 = (widget._ui__CanvasLayout);
		return _t3;
	} else {
		ui__CanvasLayout* _t4 = ui__canvas_layout(((ui__CanvasLayoutParams){.id = (string){.str=(byteptr)"", .is_lit=1},.width = 0,.height = 0,.full_width = -1,.full_height = -1,.z_index = 0,.text = (string){.str=(byteptr)"", .is_lit=1},.bg_color = _const_ui__no_color,.bg_radius = 0,.scrollview = 0,.on_draw = ((voidptr)(0)),.on_click = ((voidptr)(0)),.on_mouse_down = ((voidptr)(0)),.on_mouse_up = ((voidptr)(0)),.on_scroll = ((voidptr)(0)),.on_mouse_move = ((voidptr)(0)),.on_key_down = ((voidptr)(0)),.on_char = ((voidptr)(0)),.full_size_fn = ((voidptr)(0)),.on_scroll_change = ((ui__ScrollViewChangedFn)(0)),.children = __new_array(0, 0, sizeof(ui__Widget)),}));
		return _t4;
	}
	return 0;
}

ui__Menu* ui__Window_menu(ui__Window* w, string id) {
	ui__Widget* _t2 = (ui__Widget*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->widgets), &(string[]){id}));
	Option_ui__Widget _t1 = {0};
	if (_t2) {
		*((ui__Widget*)&_t1.data) = *((ui__Widget*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		panic_debug(1517, tos3("/Users/rcqls/.vmodules/ui/window.v"), tos3("ui"), tos3("menu"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("widget with id  "), 0xfe10, {.d_s = id}}, {_SLIT(" does not exist"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
	ui__Widget widget = *(ui__Widget*)_t1.data;
	if ((widget)._typ == _ui__Widget_ui__Menu_index) {
		ui__Menu* _t3 = (widget._ui__Menu);
		return _t3;
	} else {
		ui__Menu* _t4 = ui__menu(((ui__MenuParams){.id = (string){.str=(byteptr)"", .is_lit=1},.width = 150,.z_index = 0,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,.text = (string){.str=(byteptr)"", .is_lit=1},.items = __new_array(0, 0, sizeof(ui__MenuItem)),}));
		return _t4;
	}
	return 0;
}

ui__Rectangle* ui__Window_rectangle(ui__Window* w, string id) {
	ui__Widget* _t2 = (ui__Widget*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->widgets), &(string[]){id}));
	Option_ui__Widget _t1 = {0};
	if (_t2) {
		*((ui__Widget*)&_t1.data) = *((ui__Widget*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		panic_debug(1526, tos3("/Users/rcqls/.vmodules/ui/window.v"), tos3("ui"), tos3("rectangle"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("widget with id  "), 0xfe10, {.d_s = id}}, {_SLIT(" does not exist"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
	ui__Widget widget = *(ui__Widget*)_t1.data;
	if ((widget)._typ == _ui__Widget_ui__Rectangle_index) {
		ui__Rectangle* _t3 = (widget._ui__Rectangle);
		return _t3;
	} else {
		ui__Rectangle* _t4 = ui__rectangle(((ui__RectangleParams){.id = (string){.str=(byteptr)"", .is_lit=1},.text = (string){.str=(byteptr)"", .is_lit=1},.height = 0,.width = 0,.z_index = 0,.color = ((gx__Color){.r = 0,.g = 0,.b = 0,.a = 0,}),.radius = 0,.border = 0,.border_color = ((gx__Color){.r = 180,.g = 180,.b = 190,.a = 255,}),.x = 0,.y = 0,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,}));
		return _t4;
	}
	return 0;
}

ui__SubWindow* ui__Window_subwindow(ui__Window* w, string id) {
	ui__Widget* _t2 = (ui__Widget*)/*ee elem_ptr_typ */(map_get_check(ADDR(map, w->widgets), &(string[]){id}));
	Option_ui__Widget _t1 = {0};
	if (_t2) {
		*((ui__Widget*)&_t1.data) = *((ui__Widget*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	;
	if (_t1.state != 0) { /*or block*/ 
		IError err = _t1.err;
		panic_debug(1535, tos3("/Users/rcqls/.vmodules/ui/window.v"), tos3("ui"), tos3("subwindow"),   str_intp(2, _MOV((StrIntpData[]){{_SLIT("widget with id  "), 0xfe10, {.d_s = id}}, {_SLIT(" does not exist"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
	ui__Widget widget = *(ui__Widget*)_t1.data;
	if ((widget)._typ == _ui__Widget_ui__SubWindow_index) {
		ui__SubWindow* _t3 = (widget._ui__SubWindow);
		return _t3;
	} else {
		ui__SubWindow* _t4 = ui__subwindow(((ui__SubWindowParams){.id = (string){.str=(byteptr)"", .is_lit=1},.x = 0,.y = 0,.hidden = true,.layout = /*&ui.Layout*/I_ui__Stack_to_Interface_ui__Layout(_const_ui__empty_stack),.drag = true,.decoration = true,}));
		return _t4;
	}
	return 0;
}

// Attr: [inline]
inline bool ui__KeyMod_is_empty(ui__KeyMod* e) {
	bool _t1 = ((int)(*e)) == 0;
	return _t1;
}

// Attr: [inline]
inline bool ui__KeyMod_has(ui__KeyMod* e, ui__KeyMod flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) != 0;
	return _t1;
}

// Attr: [inline]
inline bool ui__KeyMod_all(ui__KeyMod* e, ui__KeyMod flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) == ((int)(flag));
	return _t1;
}

// Attr: [inline]
inline void ui__KeyMod_set(ui__KeyMod* e, ui__KeyMod flag) {
	{ // Unsafe block
		*e = ((ui__KeyMod)((((int)(*e)) | (((int)(flag))))));
	}
}

// Attr: [inline]
inline void ui__KeyMod_clear(ui__KeyMod* e, ui__KeyMod flag) {
	{ // Unsafe block
		*e = ((ui__KeyMod)((((int)(*e)) & ~(((int)(flag))))));
	}
}

// Attr: [inline]
inline void ui__KeyMod_toggle(ui__KeyMod* e, ui__KeyMod flag) {
	{ // Unsafe block
		*e = ((ui__KeyMod)((((int)(*e)) ^ (((int)(flag))))));
	}
}

// Attr: [inline]
inline bool ui__TextBoxMode_is_empty(ui__TextBoxMode* e) {
	bool _t1 = ((int)(*e)) == 0;
	return _t1;
}

// Attr: [inline]
inline bool ui__TextBoxMode_has(ui__TextBoxMode* e, ui__TextBoxMode flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) != 0;
	return _t1;
}

// Attr: [inline]
inline bool ui__TextBoxMode_all(ui__TextBoxMode* e, ui__TextBoxMode flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) == ((int)(flag));
	return _t1;
}

// Attr: [inline]
inline void ui__TextBoxMode_set(ui__TextBoxMode* e, ui__TextBoxMode flag) {
	{ // Unsafe block
		*e = ((ui__TextBoxMode)((((int)(*e)) | (((int)(flag))))));
	}
}

// Attr: [inline]
inline void ui__TextBoxMode_clear(ui__TextBoxMode* e, ui__TextBoxMode flag) {
	{ // Unsafe block
		*e = ((ui__TextBoxMode)((((int)(*e)) & ~(((int)(flag))))));
	}
}

// Attr: [inline]
inline void ui__TextBoxMode_toggle(ui__TextBoxMode* e, ui__TextBoxMode flag) {
	{ // Unsafe block
		*e = ((ui__TextBoxMode)((((int)(*e)) ^ (((int)(flag))))));
	}
}

void main__main(void) {
	string logo = os__resource_abs_path(os__join_path(_SLIT("assets/img"), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){_SLIT("logo.png")}))));
	main__State* app = ((main__State*)memdup(&(main__State){.first_name = (string){.str=(byteptr)"", .is_lit=1},.last_name = (string){.str=(byteptr)"", .is_lit=1},.age = (string){.str=(byteptr)"", .is_lit=1},.password = (string){.str=(byteptr)"", .is_lit=1},.pbar = ui__progressbar(((ui__ProgressBarParams){.id = (string){.str=(byteptr)"", .is_lit=1},.width = 170,.height = 16,.z_index = 0,.min = 0,.max = 10,.val = 2,})),.users = new_array_from_c_array(2, 2, sizeof(main__User), _MOV((main__User[2]){((main__User){.first_name = _SLIT("Sam"),.last_name = _SLIT("Johnson"),.age = 29,.country = _SLIT("United States"),}), ((main__User){.first_name = _SLIT("Kate"),.last_name = _SLIT("Williams"),.age = 26,.country = _SLIT("Canada"),})})),.window = ((voidptr)(0)),.label = ui__label(((ui__LabelParams){.id = (string){.str=(byteptr)"", .is_lit=1},.width = 0,.height = 0,.z_index = 0,.text = _SLIT("2/10"),.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,})),.country = ui__radio(((ui__RadioParams){.id = (string){.str=(byteptr)"", .is_lit=1},.on_click = 0,.values = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("United States"), _SLIT("Canada"), _SLIT("United Kingdom"), _SLIT("Australia")})),.title = _SLIT("Country"),.width = 200,.z_index = 0,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,.horizontal = 0,.compact = 0,})),.txt_pos = 0,.started = 0,.is_error = 0,}, sizeof(main__State)));
	ui__Window* window = ui__window(((ui__WindowParams){
		.width = _const_main__win_width,
		.height = _const_main__win_height,
		.font_path = (string){.str=(byteptr)"", .is_lit=1},
		.title = _SLIT("V UI Demo"),
		.always_on_top = 0,
		.state = app,
		.bg_color = _const_ui__default_window_color,
		.on_click = 0,
		.on_mouse_down = 0,
		.on_mouse_up = 0,
		.on_files_droped = 0,
		.on_swipe = 0,
		.on_key_down = 0,
		.on_char = 0,
		.on_scroll = 0,
		.on_resize = 0,
		.on_iconify = 0,
		.on_restore = 0,
		.on_quit_request = 0,
		.on_suspend = 0,
		.on_resume = 0,
		.on_mouse_move = 0,
		.on_init = 0,
		.on_draw = 0,
		.children = new_array_from_c_array(1, 1, sizeof(ui__Widget), _MOV((ui__Widget[1]){/*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget(ui__row(((ui__RowParams){.id = (string){.str=(byteptr)"", .is_lit=1},.width = 0,.height = 0,.alignment = 0,.spacing = .02,.spacings = __new_array_with_default(0, 0, sizeof(f64), 0),.stretch = 0,.margin_ = .02,.margin = {0},.widths = Array_f64_to_sumtype_ui__Size(ADDR(Array_f64, (new_array_from_c_array(2, 2, sizeof(f64), _MOV((f64[2]){.3, .64}))))),.heights = {0},.align = (ui__Alignments){.center = __new_array(0, 0, sizeof(int)),.left_top = __new_array(0, 0, sizeof(int)),.top = __new_array(0, 0, sizeof(int)),.right_top = __new_array(0, 0, sizeof(int)),.right = __new_array(0, 0, sizeof(int)),.right_bottom = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),.left_bottom = __new_array(0, 0, sizeof(int)),.left = __new_array(0, 0, sizeof(int)),},.alignments = (ui__VerticalAlignments){.top = __new_array(0, 0, sizeof(int)),.center = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),},.bg_color = _const_ui__no_color,.bg_radius = 0,.title = (string){.str=(byteptr)"", .is_lit=1},.scrollview = 0,.children = new_array_from_c_array(2, 2, sizeof(ui__Widget), _MOV((ui__Widget[2]){/*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget(ui__column(((ui__ColumnParams){.id = (string){.str=(byteptr)"", .is_lit=1},.width = 0,.height = 0,.alignment = 0,.spacing = 10,.spacings = __new_array_with_default(0, 0, sizeof(f64), 0),.stretch = 0,.margin = {0},.margin_ = 0,.widths = {0},.heights = f64_to_sumtype_ui__Size(ADDR(f64, (_const_ui__compact))),.alignments = (ui__HorizontalAlignments){.left = __new_array(0, 0, sizeof(int)),.center = __new_array(0, 0, sizeof(int)),.right = __new_array(0, 0, sizeof(int)),},.align = (ui__Alignments){.center = __new_array(0, 0, sizeof(int)),.left_top = __new_array(0, 0, sizeof(int)),.top = __new_array(0, 0, sizeof(int)),.right_top = __new_array(0, 0, sizeof(int)),.right = __new_array(0, 0, sizeof(int)),.right_bottom = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),.left_bottom = __new_array(0, 0, sizeof(int)),.left = __new_array(0, 0, sizeof(int)),},.bg_color = _const_ui__no_color,.bg_radius = 0,.title = (string){.str=(byteptr)"", .is_lit=1},.scrollview = true,.children = new_array_from_c_array(9, 9, sizeof(ui__Widget), _MOV((ui__Widget[9]){
				/*&ui.Widget*/I_ui__TextBox_to_Interface_ui__Widget(ui__textbox(((ui__TextBoxParams){
			.id = (string){.str=(byteptr)"", .is_lit=1},
			.width = 200,
			.height = 22,
			.read_only = 0,
			.is_multiline = 0,
			.is_wordwrap = 0,
			.is_line_number = 0,
			.mode = 0,
			.is_sync = true,
			.twosided_sel = 0,
			.z_index = 0,
			.min = 0,
			.max = 0,
			.val = 0,
			.placeholder = _SLIT("First name"),
			.placeholder_bind = ((voidptr)(0)),
			.max_len = 20,
			.is_numeric = 0,
			.is_password = 0,
			.text = &app->first_name,
			.is_error = &app->is_error,
			.is_focused = true,
			.bg_color = _const_gx__white,
			.borderless = 0,
			.fitted_height = 0,
			.on_key_down = 0,
			.on_char = 0,
			.on_change = 0,
			.on_enter = 0,
			.on_changed = ((ui__TextBoxValidatedFn)(0)),
			.on_entered = ((ui__TextBoxValidatedFn)(0)),
			.border_accentuated = 0,
			.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},
			.text_size = 0,
			.scrollview = true,
			.on_scroll_change = ((ui__ScrollViewChangedFn)(0)),
		}))), /*&ui.Widget*/I_ui__TextBox_to_Interface_ui__Widget(ui__textbox(((ui__TextBoxParams){.id = (string){.str=(byteptr)"", .is_lit=1},.width = 200,.height = 22,.read_only = 0,.is_multiline = 0,.is_wordwrap = 0,.is_line_number = 0,.mode = 0,.is_sync = true,.twosided_sel = 0,.z_index = 0,.min = 0,.max = 0,.val = 0,.placeholder = _SLIT("Last name"),.placeholder_bind = ((voidptr)(0)),.max_len = 50,.is_numeric = 0,.is_password = 0,.text = &app->last_name,.is_error = &app->is_error,.is_focused = 0,.bg_color = _const_gx__white,.borderless = 0,.fitted_height = 0,.on_key_down = 0,.on_char = 0,.on_change = 0,.on_enter = 0,.on_changed = ((ui__TextBoxValidatedFn)(0)),.on_entered = ((ui__TextBoxValidatedFn)(0)),.border_accentuated = 0,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,.scrollview = true,.on_scroll_change = ((ui__ScrollViewChangedFn)(0)),}))), /*&ui.Widget*/I_ui__TextBox_to_Interface_ui__Widget(ui__textbox(((ui__TextBoxParams){
			.id = (string){.str=(byteptr)"", .is_lit=1},
			.width = 200,
			.height = 22,
			.read_only = 0,
			.is_multiline = 0,
			.is_wordwrap = 0,
			.is_line_number = 0,
			.mode = 0,
			.is_sync = true,
			.twosided_sel = 0,
			.z_index = 0,
			.min = 0,
			.max = 0,
			.val = 0,
			.placeholder = _SLIT("Age"),
			.placeholder_bind = ((voidptr)(0)),
			.max_len = 3,
			.is_numeric = true,
			.is_password = 0,
			.text = &app->age,
			.is_error = &app->is_error,
			.is_focused = 0,
			.bg_color = _const_gx__white,
			.borderless = 0,
			.fitted_height = 0,
			.on_key_down = 0,
			.on_char = 0,
			.on_change = 0,
			.on_enter = 0,
			.on_changed = ((ui__TextBoxValidatedFn)(0)),
			.on_entered = ((ui__TextBoxValidatedFn)(0)),
			.border_accentuated = 0,
			.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},
			.text_size = 0,
			.scrollview = true,
			.on_scroll_change = ((ui__ScrollViewChangedFn)(0)),
		}))), /*&ui.Widget*/I_ui__TextBox_to_Interface_ui__Widget(ui__textbox(((ui__TextBoxParams){.id = (string){.str=(byteptr)"", .is_lit=1},.width = 200,.height = 22,.read_only = 0,.is_multiline = 0,.is_wordwrap = 0,.is_line_number = 0,.mode = 0,.is_sync = true,.twosided_sel = 0,.z_index = 0,.min = 0,.max = 0,.val = 0,.placeholder = _SLIT("Password"),.placeholder_bind = ((voidptr)(0)),.max_len = 20,.is_numeric = 0,.is_password = true,.text = &app->password,.is_error = ((voidptr)(0)),.is_focused = 0,.bg_color = _const_gx__white,.borderless = 0,.fitted_height = 0,.on_key_down = 0,.on_char = 0,.on_change = 0,.on_enter = 0,.on_changed = ((ui__TextBoxValidatedFn)(0)),.on_entered = ((ui__TextBoxValidatedFn)(0)),.border_accentuated = 0,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,.scrollview = true,.on_scroll_change = ((ui__ScrollViewChangedFn)(0)),}))), /*&ui.Widget*/I_ui__CheckBox_to_Interface_ui__Widget(ui__checkbox(((ui__CheckBoxParams){.id = (string){.str=(byteptr)"", .is_lit=1},.x = 0,.y = 0,.z_index = 0,.text = _SLIT("Online registration"),.on_click = 0,.on_check_changed = 0,.checked = true,.disabled = 0,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,}))), /*&ui.Widget*/I_ui__CheckBox_to_Interface_ui__Widget(ui__checkbox(((ui__CheckBoxParams){.id = (string){.str=(byteptr)"", .is_lit=1},.x = 0,.y = 0,.z_index = 0,.text = _SLIT("Subscribe to the newsletter"),.on_click = 0,.on_check_changed = 0,.checked = 0,.disabled = 0,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,}))), /*&ui.Widget*/I_ui__Radio_to_Interface_ui__Widget(app->country), /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget(ui__row(((ui__RowParams){.id = _SLIT("btn_row"),.width = 0,.height = 0,.alignment = 0,.spacing = .3,.spacings = __new_array_with_default(0, 0, sizeof(f64), 0),.stretch = 0,.margin_ = 0,.margin = {0},.widths = Array_f64_to_sumtype_ui__Size(ADDR(Array_f64, (new_array_from_c_array(2, 2, sizeof(f64), _MOV((f64[2]){.5, .2}))))),.heights = f64_to_sumtype_ui__Size(ADDR(f64, (20.0))),.align = (ui__Alignments){.center = __new_array(0, 0, sizeof(int)),.left_top = __new_array(0, 0, sizeof(int)),.top = __new_array(0, 0, sizeof(int)),.right_top = __new_array(0, 0, sizeof(int)),.right = __new_array(0, 0, sizeof(int)),.right_bottom = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),.left_bottom = __new_array(0, 0, sizeof(int)),.left = __new_array(0, 0, sizeof(int)),},.alignments = (ui__VerticalAlignments){.top = __new_array(0, 0, sizeof(int)),.center = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),},.bg_color = _const_ui__no_color,.bg_radius = 0,.title = (string){.str=(byteptr)"", .is_lit=1},.scrollview = 0,.children = new_array_from_c_array(2, 2, sizeof(ui__Widget), _MOV((ui__Widget[2]){/*&ui.Widget*/I_ui__Button_to_Interface_ui__Widget(ui__button(((ui__ButtonParams){.id = (string){.str=(byteptr)"", .is_lit=1},.text = _SLIT("Add user"),.icon_path = (string){.str=(byteptr)"", .is_lit=1},.onclick = (voidptr)main__btn_add_click,.on_key_down = 0,.height = 0,.width = 0,.z_index = 0,.movable = 0,.hoverable = 0,.tooltip = _SLIT("Required fields:\n  * First name\n  * Last name\n  * Age"),.tooltip_side = ui__Side__top,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,.bg_color = 0,.theme = string_to_sumtype_ui__ColorThemeCfg(ADDR(string, (_SLIT("classic")))),.radius = .3,.padding = 0,}))), /*&ui.Widget*/I_ui__Button_to_Interface_ui__Widget(ui__button(((ui__ButtonParams){.id = (string){.str=(byteptr)"", .is_lit=1},.text = _SLIT("?"),.icon_path = (string){.str=(byteptr)"", .is_lit=1},.onclick = (voidptr)main__btn_help_click,.on_key_down = 0,.height = 0,.width = 0,.z_index = 0,.movable = 0,.hoverable = 0,.tooltip = _SLIT("about"),.tooltip_side = ui__Side__top,.text_cfg = (gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,},.text_size = 0,.bg_color = 0,.theme = string_to_sumtype_ui__ColorThemeCfg(ADDR(string, (_SLIT("classic")))),.radius = .3,.padding = 0,})))})),}))), /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget(ui__row(((ui__RowParams){.id = (string){.str=(byteptr)"", .is_lit=1},.width = 0,.height = 0,.alignment = 0,.spacing = .05,.spacings = __new_array_with_default(0, 0, sizeof(f64), 0),.stretch = 0,.margin_ = 0,.margin = {0},.widths = Array_f64_to_sumtype_ui__Size(ADDR(Array_f64, (new_array_from_c_array(2, 2, sizeof(f64), _MOV((f64[2]){.8, .15}))))),.heights = f64_to_sumtype_ui__Size(ADDR(f64, (_const_ui__compact))),.align = (ui__Alignments){.center = __new_array(0, 0, sizeof(int)),.left_top = __new_array(0, 0, sizeof(int)),.top = __new_array(0, 0, sizeof(int)),.right_top = __new_array(0, 0, sizeof(int)),.right = __new_array(0, 0, sizeof(int)),.right_bottom = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),.left_bottom = __new_array(0, 0, sizeof(int)),.left = __new_array(0, 0, sizeof(int)),},.alignments = (ui__VerticalAlignments){.top = __new_array(0, 0, sizeof(int)),.center = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),},.bg_color = _const_ui__no_color,.bg_radius = 0,.title = (string){.str=(byteptr)"", .is_lit=1},.scrollview = 0,.children = new_array_from_c_array(2, 2, sizeof(ui__Widget), _MOV((ui__Widget[2]){/*&ui.Widget*/I_ui__ProgressBar_to_Interface_ui__Widget(app->pbar), /*&ui.Widget*/I_ui__Label_to_Interface_ui__Widget(app->label)})),})))})),}))), /*&ui.Widget*/I_ui__Stack_to_Interface_ui__Widget(ui__column(((ui__ColumnParams){
			.id = (string){.str=(byteptr)"", .is_lit=1},
			.width = 0,
			.height = 0,
			.alignment = 0,
			.spacing = 0,
			.spacings = __new_array_with_default(0, 0, sizeof(f64), 0),
			.stretch = 0,
			.margin = {0},
			.margin_ = 0,
			.widths = Array_f64_to_sumtype_ui__Size(ADDR(Array_f64, (new_array_from_c_array(2, 2, sizeof(f64), _MOV((f64[2]){_const_ui__stretch, _const_ui__compact}))))),
			.heights = Array_f64_to_sumtype_ui__Size(ADDR(Array_f64, (new_array_from_c_array(2, 2, sizeof(f64), _MOV((f64[2]){_const_ui__stretch, _const_ui__compact}))))),
			.alignments = ((ui__HorizontalAlignments){.left = __new_array(0, 0, sizeof(int)),.center = new_array_from_c_array(1, 1, sizeof(int), _MOV((int[1]){0})),.right = new_array_from_c_array(1, 1, sizeof(int), _MOV((int[1]){1})),}),
			.align = (ui__Alignments){.center = __new_array(0, 0, sizeof(int)),.left_top = __new_array(0, 0, sizeof(int)),.top = __new_array(0, 0, sizeof(int)),.right_top = __new_array(0, 0, sizeof(int)),.right = __new_array(0, 0, sizeof(int)),.right_bottom = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),.left_bottom = __new_array(0, 0, sizeof(int)),.left = __new_array(0, 0, sizeof(int)),},
			.bg_color = _const_gx__white,
			.bg_radius = 0,
			.title = (string){.str=(byteptr)"", .is_lit=1},
			.scrollview = true,
			.children = new_array_from_c_array(2, 2, sizeof(ui__Widget), _MOV((ui__Widget[2]){/*&ui.Widget*/I_ui__CanvasLayout_to_Interface_ui__Widget(ui__canvas_plus(((ui__CanvasLayoutParams){.id = (string){.str=(byteptr)"", .is_lit=1},.width = 400,.height = 275,.full_width = -1,.full_height = -1,.z_index = 0,.text = (string){.str=(byteptr)"", .is_lit=1},.bg_color = _const_ui__no_color,.bg_radius = 0,.scrollview = 0,.on_draw = (voidptr)main__draw,.on_click = ((voidptr)(0)),.on_mouse_down = ((voidptr)(0)),.on_mouse_up = ((voidptr)(0)),.on_scroll = ((voidptr)(0)),.on_mouse_move = ((voidptr)(0)),.on_key_down = ((voidptr)(0)),.on_char = ((voidptr)(0)),.full_size_fn = ((voidptr)(0)),.on_scroll_change = ((ui__ScrollViewChangedFn)(0)),.children = __new_array(0, 0, sizeof(ui__Widget)),}))), /*&ui.Widget*/I_ui__Picture_to_Interface_ui__Widget(ui__picture(((ui__PictureParams){.id = (string){.str=(byteptr)"", .is_lit=1},.path = logo,.width = 100,.height = 100,.z_index = 0,.movable = 0,.on_click = 0,.use_cache = true,.ref = ((voidptr)(0)),.image = (gg__Image){.id = 0,.width = 0,.height = 0,.nr_channels = 0,.ok = 0,.data = 0,.ext = (string){.str=(byteptr)"", .is_lit=1},.simg_ok = 0,.simg = {0},.path = (string){.str=(byteptr)"", .is_lit=1},},.tooltip = (string){.str=(byteptr)"", .is_lit=1},.tooltip_side = ui__Side__top,})))})),
		})))})),})))})),
		.custom_bold_font_path = (string){.str=(byteptr)"", .is_lit=1},
		.native_rendering = 0,
		.resizable = 0,
		.mode = ui__WindowSizeType__resizable,
		.immediate = 0,
		.lines = 10,
		.native_message = false,
		.enable_dragndrop = true,
		.max_dropped_files = 5,
		.max_dropped_file_path_length = 2048,
	}));
	app->window = window;
	ui__run(window);
}

void main__menu_click(void) {
}

void main__btn_help_click(voidptr a, ui__Button* b) {
	ui__message_box(_SLIT("Built with V UI"));
}

void main__btn_add_click(main__State* app, voidptr x) {
	if (app->users.len >= 10) {
		return;
	}
	if ((app->first_name).len == 0 || (app->last_name).len == 0 || (app->age).len == 0) {
		app->is_error = true;
		return;
	}
	main__User new_user = ((main__User){.first_name = app->first_name,.last_name = app->last_name,.age = string_int(app->age),.country = ui__Radio_selected_value(app->country),});
	array_push((array*)&app->users, _MOV((main__User[]){ new_user }));
	app->pbar->val++;
	app->first_name = _SLIT("");
	app->last_name = _SLIT("");
	app->age = _SLIT("");
	app->password = _SLIT("");
	ui__Label_set_text(app->label,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, 0xfe07, {.d_i32 = app->users.len}}, {_SLIT("/10"), 0, { .d_c = 0 }}})));
}

void main__draw(ui__CanvasLayout* c, main__State* app) {
	int w = c->width;
	int h = c->height;
	ui__CanvasLayout_draw_rect_filled(c, 0, 0, w, h, _const_gx__white);
	int marginx = 20;
	int marginy = 20;
	for (int i = 0; i < app->users.len; ++i) {
		main__User user = ((main__User*)app->users.data)[i];
		int y = marginy + i * _const_main__cell_height;
		ui__CanvasLayout_draw_rect_empty(c, marginx, y, _const_main__table_width, _const_main__cell_height, _const_gx__gray);
		ui__CanvasLayout_draw_line(c, _const_main__cell_width, y, _const_main__cell_width, y + _const_main__cell_height, _const_gx__gray);
		ui__CanvasLayout_draw_line(c, _const_main__cell_width * 2, y, _const_main__cell_width * 2, y + _const_main__cell_height, _const_gx__gray);
		ui__CanvasLayout_draw_line(c, _const_main__cell_width * 3, y, _const_main__cell_width * 3, y + _const_main__cell_height, _const_gx__gray);
		ui__CanvasLayout_draw_text(c, marginx + 5, y + 5, user.first_name);
		ui__CanvasLayout_draw_text(c, marginx + 5 + _const_main__cell_width, y + 5, user.last_name);
		ui__CanvasLayout_draw_text(c, marginx + 5 + _const_main__cell_width * 2, y + 5, int_str(user.age));
		ui__CanvasLayout_draw_text(c, marginx + 5 + _const_main__cell_width * 3, y + 5, user.country);
	}
}

void _vinit(int ___argc, voidptr ___argv) {
#if __STDC_HOSTED__ == 1
	signal(11, v_segmentation_fault_handler);
#endif
	as_cast_type_indexes = new_array_from_c_array(1, 1, sizeof(VCastTypeIndexName), _MOV((VCastTypeIndexName[1]){(VCastTypeIndexName){.tindex = 0,.tname = _SLIT("unknown")}}));

	builtin_init();
	vinit_string_literals();
	{ // Initializations for module strings :
	}
	{ // Initializations for module math.bits :
	_const_math__bits__de_bruijn32tab = new_array_from_c_array(32, 32, sizeof(u8), _MOV((u8[32]){
		((u8)(0)), 1, 28, 2, 29, 14, 24, 3, 30,
		22, 20, 15, 25, 17, 4, 8, 31,
		27, 13, 23, 21, 19, 16, 7, 26,
		12, 18, 6, 11, 5, 10, 9}));
	_const_math__bits__de_bruijn64tab = new_array_from_c_array(64, 64, sizeof(u8), _MOV((u8[64]){
		((u8)(0)), 1, 56, 2, 57, 49, 28, 3, 61,
		58, 42, 50, 38, 29, 17, 4, 62,
		47, 59, 36, 45, 43, 51, 22, 53,
		39, 33, 30, 24, 18, 12, 5, 63,
		55, 48, 27, 60, 41, 37, 16, 46,
		35, 44, 21, 52, 32, 23, 11, 54,
		26, 40, 15, 34, 20, 31, 10, 25,
		14, 19, 9, 13, 8, 7, 6}));
	_const_math__bits__ntz_8_tab = new_array_from_c_array(256, 256, sizeof(u8), _MOV((u8[256]){
		((u8)(0x08)), 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x07,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03,
		0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00}));
	_const_math__bits__pop_8_tab = new_array_from_c_array(256, 256, sizeof(u8), _MOV((u8[256]){
		((u8)(0x00)), 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01,
		0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x01,
		0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x01,
		0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x01,
		0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04,
		0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x01,
		0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04,
		0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x02,
		0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04,
		0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x03,
		0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04,
		0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x04,
		0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05,
		0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08}));
	_const_math__bits__rev_8_tab = new_array_from_c_array(256, 256, sizeof(u8), _MOV((u8[256]){
		((u8)(0x00)), 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10,
		0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x08,
		0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18,
		0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04,
		0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14,
		0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c,
		0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c,
		0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x02,
		0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12,
		0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a,
		0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a,
		0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06,
		0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16,
		0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 0x0e,
		0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e,
		0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 0x01,
		0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11,
		0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 0x09,
		0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19,
		0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x05,
		0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15,
		0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 0x0d,
		0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d,
		0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x03,
		0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13,
		0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b,
		0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b,
		0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 0x07,
		0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17,
		0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 0x0f,
		0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f,
		0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff}));
	_const_math__bits__len_8_tab = new_array_from_c_array(256, 256, sizeof(u8), _MOV((u8[256]){
		((u8)(0x00)), 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04,
		0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05,
		0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
		0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06,
		0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
		0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
		0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
		0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08}));
	}
	{ // Initializations for module strconv :
	_const_strconv__pos_exp = new_array_from_c_array(309, 309, sizeof(u64), _MOV((u64[309]){
		((u64)(0x3ff0000000000000U)), ((u64)(0x4024000000000000U)), ((u64)(0x4059000000000000U)), ((u64)(0x408f400000000000U)), ((u64)(0x40c3880000000000U)), ((u64)(0x40f86a0000000000U)), ((u64)(0x412e848000000000U)), ((u64)(0x416312d000000000U)), ((u64)(0x4197d78400000000U)),
		((u64)(0x41cdcd6500000000U)), ((u64)(0x4202a05f20000000U)), ((u64)(0x42374876e8000000U)), ((u64)(0x426d1a94a2000000U)), ((u64)(0x42a2309ce5400000U)), ((u64)(0x42d6bcc41e900000U)), ((u64)(0x430c6bf526340000U)), ((u64)(0x4341c37937e08000U)),
		((u64)(0x4376345785d8a000U)), ((u64)(0x43abc16d674ec800U)), ((u64)(0x43e158e460913d00U)), ((u64)(0x4415af1d78b58c40U)), ((u64)(0x444b1ae4d6e2ef50U)), ((u64)(0x4480f0cf064dd592U)), ((u64)(0x44b52d02c7e14af6U)), ((u64)(0x44ea784379d99db4U)),
		((u64)(0x45208b2a2c280291U)), ((u64)(0x4554adf4b7320335U)), ((u64)(0x4589d971e4fe8402U)), ((u64)(0x45c027e72f1f1281U)), ((u64)(0x45f431e0fae6d721U)), ((u64)(0x46293e5939a08ceaU)), ((u64)(0x465f8def8808b024U)), ((u64)(0x4693b8b5b5056e17U)),
		((u64)(0x46c8a6e32246c99cU)), ((u64)(0x46fed09bead87c03U)), ((u64)(0x4733426172c74d82U)), ((u64)(0x476812f9cf7920e3U)), ((u64)(0x479e17b84357691bU)), ((u64)(0x47d2ced32a16a1b1U)), ((u64)(0x48078287f49c4a1dU)), ((u64)(0x483d6329f1c35ca5U)),
		((u64)(0x48725dfa371a19e7U)), ((u64)(0x48a6f578c4e0a061U)), ((u64)(0x48dcb2d6f618c879U)), ((u64)(0x4911efc659cf7d4cU)), ((u64)(0x49466bb7f0435c9eU)), ((u64)(0x497c06a5ec5433c6U)), ((u64)(0x49b18427b3b4a05cU)), ((u64)(0x49e5e531a0a1c873U)),
		((u64)(0x4a1b5e7e08ca3a8fU)), ((u64)(0x4a511b0ec57e649aU)), ((u64)(0x4a8561d276ddfdc0U)), ((u64)(0x4ababa4714957d30U)), ((u64)(0x4af0b46c6cdd6e3eU)), ((u64)(0x4b24e1878814c9ceU)), ((u64)(0x4b5a19e96a19fc41U)), ((u64)(0x4b905031e2503da9U)),
		((u64)(0x4bc4643e5ae44d13U)), ((u64)(0x4bf97d4df19d6057U)), ((u64)(0x4c2fdca16e04b86dU)), ((u64)(0x4c63e9e4e4c2f344U)), ((u64)(0x4c98e45e1df3b015U)), ((u64)(0x4ccf1d75a5709c1bU)), ((u64)(0x4d03726987666191U)), ((u64)(0x4d384f03e93ff9f5U)),
		((u64)(0x4d6e62c4e38ff872U)), ((u64)(0x4da2fdbb0e39fb47U)), ((u64)(0x4dd7bd29d1c87a19U)), ((u64)(0x4e0dac74463a989fU)), ((u64)(0x4e428bc8abe49f64U)), ((u64)(0x4e772ebad6ddc73dU)), ((u64)(0x4eacfa698c95390cU)), ((u64)(0x4ee21c81f7dd43a7U)),
		((u64)(0x4f16a3a275d49491U)), ((u64)(0x4f4c4c8b1349b9b5U)), ((u64)(0x4f81afd6ec0e1411U)), ((u64)(0x4fb61bcca7119916U)), ((u64)(0x4feba2bfd0d5ff5bU)), ((u64)(0x502145b7e285bf99U)), ((u64)(0x50559725db272f7fU)), ((u64)(0x508afcef51f0fb5fU)),
		((u64)(0x50c0de1593369d1bU)), ((u64)(0x50f5159af8044462U)), ((u64)(0x512a5b01b605557bU)), ((u64)(0x516078e111c3556dU)), ((u64)(0x5194971956342ac8U)), ((u64)(0x51c9bcdfabc1357aU)), ((u64)(0x5200160bcb58c16cU)), ((u64)(0x52341b8ebe2ef1c7U)),
		((u64)(0x526922726dbaae39U)), ((u64)(0x529f6b0f092959c7U)), ((u64)(0x52d3a2e965b9d81dU)), ((u64)(0x53088ba3bf284e24U)), ((u64)(0x533eae8caef261adU)), ((u64)(0x53732d17ed577d0cU)), ((u64)(0x53a7f85de8ad5c4fU)), ((u64)(0x53ddf67562d8b363U)),
		((u64)(0x5412ba095dc7701eU)), ((u64)(0x5447688bb5394c25U)), ((u64)(0x547d42aea2879f2eU)), ((u64)(0x54b249ad2594c37dU)), ((u64)(0x54e6dc186ef9f45cU)), ((u64)(0x551c931e8ab87173U)), ((u64)(0x5551dbf316b346e8U)), ((u64)(0x558652efdc6018a2U)),
		((u64)(0x55bbe7abd3781ecaU)), ((u64)(0x55f170cb642b133fU)), ((u64)(0x5625ccfe3d35d80eU)), ((u64)(0x565b403dcc834e12U)), ((u64)(0x569108269fd210cbU)), ((u64)(0x56c54a3047c694feU)), ((u64)(0x56fa9cbc59b83a3dU)), ((u64)(0x5730a1f5b8132466U)),
		((u64)(0x5764ca732617ed80U)), ((u64)(0x5799fd0fef9de8e0U)), ((u64)(0x57d03e29f5c2b18cU)), ((u64)(0x58044db473335defU)), ((u64)(0x583961219000356bU)), ((u64)(0x586fb969f40042c5U)), ((u64)(0x58a3d3e2388029bbU)), ((u64)(0x58d8c8dac6a0342aU)),
		((u64)(0x590efb1178484135U)), ((u64)(0x59435ceaeb2d28c1U)), ((u64)(0x59783425a5f872f1U)), ((u64)(0x59ae412f0f768fadU)), ((u64)(0x59e2e8bd69aa19ccU)), ((u64)(0x5a17a2ecc414a03fU)), ((u64)(0x5a4d8ba7f519c84fU)), ((u64)(0x5a827748f9301d32U)),
		((u64)(0x5ab7151b377c247eU)), ((u64)(0x5aecda62055b2d9eU)), ((u64)(0x5b22087d4358fc82U)), ((u64)(0x5b568a9c942f3ba3U)), ((u64)(0x5b8c2d43b93b0a8cU)), ((u64)(0x5bc19c4a53c4e697U)), ((u64)(0x5bf6035ce8b6203dU)), ((u64)(0x5c2b843422e3a84dU)),
		((u64)(0x5c6132a095ce4930U)), ((u64)(0x5c957f48bb41db7cU)), ((u64)(0x5ccadf1aea12525bU)), ((u64)(0x5d00cb70d24b7379U)), ((u64)(0x5d34fe4d06de5057U)), ((u64)(0x5d6a3de04895e46dU)), ((u64)(0x5da066ac2d5daec4U)), ((u64)(0x5dd4805738b51a75U)),
		((u64)(0x5e09a06d06e26112U)), ((u64)(0x5e400444244d7cabU)), ((u64)(0x5e7405552d60dbd6U)), ((u64)(0x5ea906aa78b912ccU)), ((u64)(0x5edf485516e7577fU)), ((u64)(0x5f138d352e5096afU)), ((u64)(0x5f48708279e4bc5bU)), ((u64)(0x5f7e8ca3185deb72U)),
		((u64)(0x5fb317e5ef3ab327U)), ((u64)(0x5fe7dddf6b095ff1U)), ((u64)(0x601dd55745cbb7edU)), ((u64)(0x6052a5568b9f52f4U)), ((u64)(0x60874eac2e8727b1U)), ((u64)(0x60bd22573a28f19dU)), ((u64)(0x60f2357684599702U)), ((u64)(0x6126c2d4256ffcc3U)),
		((u64)(0x615c73892ecbfbf4U)), ((u64)(0x6191c835bd3f7d78U)), ((u64)(0x61c63a432c8f5cd6U)), ((u64)(0x61fbc8d3f7b3340cU)), ((u64)(0x62315d847ad00087U)), ((u64)(0x6265b4e5998400a9U)), ((u64)(0x629b221effe500d4U)), ((u64)(0x62d0f5535fef2084U)),
		((u64)(0x630532a837eae8a5U)), ((u64)(0x633a7f5245e5a2cfU)), ((u64)(0x63708f936baf85c1U)), ((u64)(0x63a4b378469b6732U)), ((u64)(0x63d9e056584240feU)), ((u64)(0x64102c35f729689fU)), ((u64)(0x6444374374f3c2c6U)), ((u64)(0x647945145230b378U)),
		((u64)(0x64af965966bce056U)), ((u64)(0x64e3bdf7e0360c36U)), ((u64)(0x6518ad75d8438f43U)), ((u64)(0x654ed8d34e547314U)), ((u64)(0x6583478410f4c7ecU)), ((u64)(0x65b819651531f9e8U)), ((u64)(0x65ee1fbe5a7e7861U)), ((u64)(0x6622d3d6f88f0b3dU)),
		((u64)(0x665788ccb6b2ce0cU)), ((u64)(0x668d6affe45f818fU)), ((u64)(0x66c262dfeebbb0f9U)), ((u64)(0x66f6fb97ea6a9d38U)), ((u64)(0x672cba7de5054486U)), ((u64)(0x6761f48eaf234ad4U)), ((u64)(0x679671b25aec1d89U)), ((u64)(0x67cc0e1ef1a724ebU)),
		((u64)(0x680188d357087713U)), ((u64)(0x6835eb082cca94d7U)), ((u64)(0x686b65ca37fd3a0dU)), ((u64)(0x68a11f9e62fe4448U)), ((u64)(0x68d56785fbbdd55aU)), ((u64)(0x690ac1677aad4ab1U)), ((u64)(0x6940b8e0acac4eafU)), ((u64)(0x6974e718d7d7625aU)),
		((u64)(0x69aa20df0dcd3af1U)), ((u64)(0x69e0548b68a044d6U)), ((u64)(0x6a1469ae42c8560cU)), ((u64)(0x6a498419d37a6b8fU)), ((u64)(0x6a7fe52048590673U)), ((u64)(0x6ab3ef342d37a408U)), ((u64)(0x6ae8eb0138858d0aU)), ((u64)(0x6b1f25c186a6f04cU)),
		((u64)(0x6b537798f4285630U)), ((u64)(0x6b88557f31326bbbU)), ((u64)(0x6bbe6adefd7f06aaU)), ((u64)(0x6bf302cb5e6f642aU)), ((u64)(0x6c27c37e360b3d35U)), ((u64)(0x6c5db45dc38e0c82U)), ((u64)(0x6c9290ba9a38c7d1U)), ((u64)(0x6cc734e940c6f9c6U)),
		((u64)(0x6cfd022390f8b837U)), ((u64)(0x6d3221563a9b7323U)), ((u64)(0x6d66a9abc9424febU)), ((u64)(0x6d9c5416bb92e3e6U)), ((u64)(0x6dd1b48e353bce70U)), ((u64)(0x6e0621b1c28ac20cU)), ((u64)(0x6e3baa1e332d728fU)), ((u64)(0x6e714a52dffc6799U)),
		((u64)(0x6ea59ce797fb817fU)), ((u64)(0x6edb04217dfa61dfU)), ((u64)(0x6f10e294eebc7d2cU)), ((u64)(0x6f451b3a2a6b9c76U)), ((u64)(0x6f7a6208b5068394U)), ((u64)(0x6fb07d457124123dU)), ((u64)(0x6fe49c96cd6d16ccU)), ((u64)(0x7019c3bc80c85c7fU)),
		((u64)(0x70501a55d07d39cfU)), ((u64)(0x708420eb449c8843U)), ((u64)(0x70b9292615c3aa54U)), ((u64)(0x70ef736f9b3494e9U)), ((u64)(0x7123a825c100dd11U)), ((u64)(0x7158922f31411456U)), ((u64)(0x718eb6bafd91596bU)), ((u64)(0x71c33234de7ad7e3U)),
		((u64)(0x71f7fec216198ddcU)), ((u64)(0x722dfe729b9ff153U)), ((u64)(0x7262bf07a143f6d4U)), ((u64)(0x72976ec98994f489U)), ((u64)(0x72cd4a7bebfa31abU)), ((u64)(0x73024e8d737c5f0bU)), ((u64)(0x7336e230d05b76cdU)), ((u64)(0x736c9abd04725481U)),
		((u64)(0x73a1e0b622c774d0U)), ((u64)(0x73d658e3ab795204U)), ((u64)(0x740bef1c9657a686U)), ((u64)(0x74417571ddf6c814U)), ((u64)(0x7475d2ce55747a18U)), ((u64)(0x74ab4781ead1989eU)), ((u64)(0x74e10cb132c2ff63U)), ((u64)(0x75154fdd7f73bf3cU)),
		((u64)(0x754aa3d4df50af0bU)), ((u64)(0x7580a6650b926d67U)), ((u64)(0x75b4cffe4e7708c0U)), ((u64)(0x75ea03fde214caf1U)), ((u64)(0x7620427ead4cfed6U)), ((u64)(0x7654531e58a03e8cU)), ((u64)(0x768967e5eec84e2fU)), ((u64)(0x76bfc1df6a7a61bbU)),
		((u64)(0x76f3d92ba28c7d15U)), ((u64)(0x7728cf768b2f9c5aU)), ((u64)(0x775f03542dfb8370U)), ((u64)(0x779362149cbd3226U)), ((u64)(0x77c83a99c3ec7eb0U)), ((u64)(0x77fe494034e79e5cU)), ((u64)(0x7832edc82110c2f9U)), ((u64)(0x7867a93a2954f3b8U)),
		((u64)(0x789d9388b3aa30a5U)), ((u64)(0x78d27c35704a5e67U)), ((u64)(0x79071b42cc5cf601U)), ((u64)(0x793ce2137f743382U)), ((u64)(0x79720d4c2fa8a031U)), ((u64)(0x79a6909f3b92c83dU)), ((u64)(0x79dc34c70a777a4dU)), ((u64)(0x7a11a0fc668aac70U)),
		((u64)(0x7a46093b802d578cU)), ((u64)(0x7a7b8b8a6038ad6fU)), ((u64)(0x7ab137367c236c65U)), ((u64)(0x7ae585041b2c477fU)), ((u64)(0x7b1ae64521f7595eU)), ((u64)(0x7b50cfeb353a97dbU)), ((u64)(0x7b8503e602893dd2U)), ((u64)(0x7bba44df832b8d46U)),
		((u64)(0x7bf06b0bb1fb384cU)), ((u64)(0x7c2485ce9e7a065fU)), ((u64)(0x7c59a742461887f6U)), ((u64)(0x7c9008896bcf54faU)), ((u64)(0x7cc40aabc6c32a38U)), ((u64)(0x7cf90d56b873f4c7U)), ((u64)(0x7d2f50ac6690f1f8U)), ((u64)(0x7d63926bc01a973bU)),
		((u64)(0x7d987706b0213d0aU)), ((u64)(0x7dce94c85c298c4cU)), ((u64)(0x7e031cfd3999f7b0U)), ((u64)(0x7e37e43c8800759cU)), ((u64)(0x7e6ddd4baa009303U)), ((u64)(0x7ea2aa4f4a405be2U)), ((u64)(0x7ed754e31cd072daU)), ((u64)(0x7f0d2a1be4048f90U)),
		((u64)(0x7f423a516e82d9baU)), ((u64)(0x7f76c8e5ca239029U)), ((u64)(0x7fac7b1f3cac7433U)), ((u64)(0x7fe1ccf385ebc8a0U))}));
	_const_strconv__neg_exp = new_array_from_c_array(324, 324, sizeof(u64), _MOV((u64[324]){
		((u64)(0x3ff0000000000000U)), ((u64)(0x3fb999999999999aU)), ((u64)(0x3f847ae147ae147bU)), ((u64)(0x3f50624dd2f1a9fcU)), ((u64)(0x3f1a36e2eb1c432dU)), ((u64)(0x3ee4f8b588e368f1U)), ((u64)(0x3eb0c6f7a0b5ed8dU)), ((u64)(0x3e7ad7f29abcaf48U)), ((u64)(0x3e45798ee2308c3aU)),
		((u64)(0x3e112e0be826d695U)), ((u64)(0x3ddb7cdfd9d7bdbbU)), ((u64)(0x3da5fd7fe1796495U)), ((u64)(0x3d719799812dea11U)), ((u64)(0x3d3c25c268497682U)), ((u64)(0x3d06849b86a12b9bU)), ((u64)(0x3cd203af9ee75616U)), ((u64)(0x3c9cd2b297d889bcU)),
		((u64)(0x3c670ef54646d497U)), ((u64)(0x3c32725dd1d243acU)), ((u64)(0x3bfd83c94fb6d2acU)), ((u64)(0x3bc79ca10c924223U)), ((u64)(0x3b92e3b40a0e9b4fU)), ((u64)(0x3b5e392010175ee6U)), ((u64)(0x3b282db34012b251U)), ((u64)(0x3af357c299a88ea7U)),
		((u64)(0x3abef2d0f5da7dd9U)), ((u64)(0x3a88c240c4aecb14U)), ((u64)(0x3a53ce9a36f23c10U)), ((u64)(0x3a1fb0f6be506019U)), ((u64)(0x39e95a5efea6b347U)), ((u64)(0x39b4484bfeebc2a0U)), ((u64)(0x398039d665896880U)), ((u64)(0x3949f623d5a8a733U)),
		((u64)(0x3914c4e977ba1f5cU)), ((u64)(0x38e09d8792fb4c49U)), ((u64)(0x38aa95a5b7f87a0fU)), ((u64)(0x38754484932d2e72U)), ((u64)(0x3841039d428a8b8fU)), ((u64)(0x380b38fb9daa78e4U)), ((u64)(0x37d5c72fb1552d83U)), ((u64)(0x37a16c262777579cU)),
		((u64)(0x376be03d0bf225c7U)), ((u64)(0x37364cfda3281e39U)), ((u64)(0x3701d7314f534b61U)), ((u64)(0x36cc8b8218854567U)), ((u64)(0x3696d601ad376ab9U)), ((u64)(0x366244ce242c5561U)), ((u64)(0x362d3ae36d13bbceU)), ((u64)(0x35f7624f8a762fd8U)),
		((u64)(0x35c2b50c6ec4f313U)), ((u64)(0x358dee7a4ad4b81fU)), ((u64)(0x3557f1fb6f10934cU)), ((u64)(0x352327fc58da0f70U)), ((u64)(0x34eea6608e29b24dU)), ((u64)(0x34b8851a0b548ea4U)), ((u64)(0x34839dae6f76d883U)), ((u64)(0x344f62b0b257c0d2U)),
		((u64)(0x34191bc08eac9a41U)), ((u64)(0x33e41633a556e1ceU)), ((u64)(0x33b011c2eaabe7d8U)), ((u64)(0x3379b604aaaca626U)), ((u64)(0x3344919d5556eb52U)), ((u64)(0x3310747ddddf22a8U)), ((u64)(0x32da53fc9631d10dU)), ((u64)(0x32a50ffd44f4a73dU)),
		((u64)(0x3270d9976a5d5297U)), ((u64)(0x323af5bf109550f2U)), ((u64)(0x32059165a6ddda5bU)), ((u64)(0x31d1411e1f17e1e3U)), ((u64)(0x319b9b6364f30304U)), ((u64)(0x316615e91d8f359dU)), ((u64)(0x3131ab20e472914aU)), ((u64)(0x30fc45016d841baaU)),
		((u64)(0x30c69d9abe034955U)), ((u64)(0x309217aefe690777U)), ((u64)(0x305cf2b1970e7258U)), ((u64)(0x3027288e1271f513U)), ((u64)(0x2ff286d80ec190dcU)), ((u64)(0x2fbda48ce468e7c7U)), ((u64)(0x2f87b6d71d20b96cU)), ((u64)(0x2f52f8ac174d6123U)),
		((u64)(0x2f1e5aacf2156838U)), ((u64)(0x2ee8488a5b445360U)), ((u64)(0x2eb36d3b7c36a91aU)), ((u64)(0x2e7f152bf9f10e90U)), ((u64)(0x2e48ddbcc7f40ba6U)), ((u64)(0x2e13e497065cd61fU)), ((u64)(0x2ddfd424d6faf031U)), ((u64)(0x2da97683df2f268dU)),
		((u64)(0x2d745ecfe5bf520bU)), ((u64)(0x2d404bd984990e6fU)), ((u64)(0x2d0a12f5a0f4e3e5U)), ((u64)(0x2cd4dbf7b3f71cb7U)), ((u64)(0x2ca0aff95cc5b092U)), ((u64)(0x2c6ab328946f80eaU)), ((u64)(0x2c355c2076bf9a55U)), ((u64)(0x2c0116805effaeaaU)),
		((u64)(0x2bcb5733cb32b111U)), ((u64)(0x2b95df5ca28ef40dU)), ((u64)(0x2b617f7d4ed8c33eU)), ((u64)(0x2b2bff2ee48e0530U)), ((u64)(0x2af665bf1d3e6a8dU)), ((u64)(0x2ac1eaff4a98553dU)), ((u64)(0x2a8cab3210f3bb95U)), ((u64)(0x2a56ef5b40c2fc77U)),
		((u64)(0x2a225915cd68c9f9U)), ((u64)(0x29ed5b561574765bU)), ((u64)(0x29b77c44ddf6c516U)), ((u64)(0x2982c9d0b1923745U)), ((u64)(0x294e0fb44f50586eU)), ((u64)(0x29180c903f7379f2U)), ((u64)(0x28e33d4032c2c7f5U)), ((u64)(0x28aec866b79e0cbaU)),
		((u64)(0x2878a0522c7e7095U)), ((u64)(0x2843b374f06526deU)), ((u64)(0x280f8587e7083e30U)), ((u64)(0x27d9379fec069826U)), ((u64)(0x27a42c7ff0054685U)), ((u64)(0x277023998cd10537U)), ((u64)(0x2739d28f47b4d525U)), ((u64)(0x2704a8729fc3ddb7U)),
		((u64)(0x26d086c219697e2cU)), ((u64)(0x269a71368f0f3047U)), ((u64)(0x2665275ed8d8f36cU)), ((u64)(0x2630ec4be0ad8f89U)), ((u64)(0x25fb13ac9aaf4c0fU)), ((u64)(0x25c5a956e225d672U)), ((u64)(0x2591544581b7dec2U)), ((u64)(0x255bba08cf8c979dU)),
		((u64)(0x25262e6d72d6dfb0U)), ((u64)(0x24f1bebdf578b2f4U)), ((u64)(0x24bc6463225ab7ecU)), ((u64)(0x2486b6b5b5155ff0U)), ((u64)(0x24522bc490dde65aU)), ((u64)(0x241d12d41afca3c3U)), ((u64)(0x23e7424348ca1c9cU)), ((u64)(0x23b29b69070816e3U)),
		((u64)(0x237dc574d80cf16bU)), ((u64)(0x2347d12a4670c123U)), ((u64)(0x23130dbb6b8d674fU)), ((u64)(0x22de7c5f127bd87eU)), ((u64)(0x22a8637f41fcad32U)), ((u64)(0x227382cc34ca2428U)), ((u64)(0x223f37ad21436d0cU)), ((u64)(0x2208f9574dcf8a70U)),
		((u64)(0x21d3faac3e3fa1f3U)), ((u64)(0x219ff779fd329cb9U)), ((u64)(0x216992c7fdc216faU)), ((u64)(0x2134756ccb01abfbU)), ((u64)(0x21005df0a267bcc9U)), ((u64)(0x20ca2fe76a3f9475U)), ((u64)(0x2094f31f8832dd2aU)), ((u64)(0x2060c27fa028b0efU)),
		((u64)(0x202ad0cc33744e4bU)), ((u64)(0x1ff573d68f903ea2U)), ((u64)(0x1fc1297872d9cbb5U)), ((u64)(0x1f8b758d848fac55U)), ((u64)(0x1f55f7a46a0c89ddU)), ((u64)(0x1f2192e9ee706e4bU)), ((u64)(0x1eec1e43171a4a11U)), ((u64)(0x1eb67e9c127b6e74U)),
		((u64)(0x1e81fee341fc585dU)), ((u64)(0x1e4ccb0536608d61U)), ((u64)(0x1e1708d0f84d3de7U)), ((u64)(0x1de26d73f9d764b9U)), ((u64)(0x1dad7becc2f23ac2U)), ((u64)(0x1d779657025b6235U)), ((u64)(0x1d42deac01e2b4f7U)), ((u64)(0x1d0e3113363787f2U)),
		((u64)(0x1cd8274291c6065bU)), ((u64)(0x1ca3529ba7d19eafU)), ((u64)(0x1c6eea92a61c3118U)), ((u64)(0x1c38bba884e35a7aU)), ((u64)(0x1c03c9539d82aec8U)), ((u64)(0x1bcfa885c8d117a6U)), ((u64)(0x1b99539e3a40dfb8U)), ((u64)(0x1b6442e4fb671960U)),
		((u64)(0x1b303583fc527ab3U)), ((u64)(0x1af9ef3993b72ab8U)), ((u64)(0x1ac4bf6142f8eefaU)), ((u64)(0x1a90991a9bfa58c8U)), ((u64)(0x1a5a8e90f9908e0dU)), ((u64)(0x1a253eda614071a4U)), ((u64)(0x19f0ff151a99f483U)), ((u64)(0x19bb31bb5dc320d2U)),
		((u64)(0x1985c162b168e70eU)), ((u64)(0x1951678227871f3eU)), ((u64)(0x191bd8d03f3e9864U)), ((u64)(0x18e6470cff6546b6U)), ((u64)(0x18b1d270cc51055fU)), ((u64)(0x187c83e7ad4e6efeU)), ((u64)(0x1846cfec8aa52598U)), ((u64)(0x18123ff06eea847aU)),
		((u64)(0x17dd331a4b10d3f6U)), ((u64)(0x17a75c1508da432bU)), ((u64)(0x1772b010d3e1cf56U)), ((u64)(0x173de6815302e556U)), ((u64)(0x1707eb9aa8cf1ddeU)), ((u64)(0x16d322e220a5b17eU)), ((u64)(0x169e9e369aa2b597U)), ((u64)(0x16687e92154ef7acU)),
		((u64)(0x16339874ddd8c623U)), ((u64)(0x15ff5a549627a36cU)), ((u64)(0x15c91510781fb5f0U)), ((u64)(0x159410d9f9b2f7f3U)), ((u64)(0x15600d7b2e28c65cU)), ((u64)(0x1529af2b7d0e0a2dU)), ((u64)(0x14f48c22ca71a1bdU)), ((u64)(0x14c0701bd527b498U)),
		((u64)(0x148a4cf9550c5426U)), ((u64)(0x14550a6110d6a9b8U)), ((u64)(0x1420d51a73deee2dU)), ((u64)(0x13eaee90b964b047U)), ((u64)(0x13b58ba6fab6f36cU)), ((u64)(0x13813c85955f2923U)), ((u64)(0x134b9408eefea839U)), ((u64)(0x1316100725988694U)),
		((u64)(0x12e1a66c1e139eddU)), ((u64)(0x12ac3d79c9b8fe2eU)), ((u64)(0x12769794a160cb58U)), ((u64)(0x124212dd4de70913U)), ((u64)(0x120ceafbafd80e85U)), ((u64)(0x11d72262f3133ed1U)), ((u64)(0x11a281e8c275cbdaU)), ((u64)(0x116d9ca79d89462aU)),
		((u64)(0x1137b08617a104eeU)), ((u64)(0x1102f39e794d9d8bU)), ((u64)(0x10ce5297287c2f45U)), ((u64)(0x1098421286c9bf6bU)), ((u64)(0x1063680ed23aff89U)), ((u64)(0x102f0ce4839198dbU)), ((u64)(0x0ff8d71d360e13e2U)), ((u64)(0x0fc3df4a91a4dcb5U)),
		((u64)(0x0f8fcbaa82a16121U)), ((u64)(0x0f596fbb9bb44db4U)), ((u64)(0x0f245962e2f6a490U)), ((u64)(0x0ef047824f2bb6daU)), ((u64)(0x0eba0c03b1df8af6U)), ((u64)(0x0e84d6695b193bf8U)), ((u64)(0x0e50ab877c142ffaU)), ((u64)(0x0e1aac0bf9b9e65cU)),
		((u64)(0x0de5566ffafb1eb0U)), ((u64)(0x0db111f32f2f4bc0U)), ((u64)(0x0d7b4feb7eb212cdU)), ((u64)(0x0d45d98932280f0aU)), ((u64)(0x0d117ad428200c08U)), ((u64)(0x0cdbf7b9d9cce00dU)), ((u64)(0x0ca65fc7e170b33eU)), ((u64)(0x0c71e6398126f5cbU)),
		((u64)(0x0c3ca38f350b22dfU)), ((u64)(0x0c06e93f5da2824cU)), ((u64)(0x0bd25432b14ecea3U)), ((u64)(0x0b9d53844ee47dd1U)), ((u64)(0x0b677603725064a8U)), ((u64)(0x0b32c4cf8ea6b6ecU)), ((u64)(0x0afe07b27dd78b14U)), ((u64)(0x0ac8062864ac6f43U)),
		((u64)(0x0a9338205089f29cU)), ((u64)(0x0a5ec033b40fea93U)), ((u64)(0x0a2899c2f6732210U)), ((u64)(0x09f3ae3591f5b4d9U)), ((u64)(0x09bf7d228322baf5U)), ((u64)(0x098930e868e89591U)), ((u64)(0x0954272053ed4474U)), ((u64)(0x09201f4d0ff10390U)),
		((u64)(0x08e9cbae7fe805b3U)), ((u64)(0x08b4a2f1ffecd15cU)), ((u64)(0x0880825b3323dab0U)), ((u64)(0x084a6a2b85062ab3U)), ((u64)(0x081521bc6a6b555cU)), ((u64)(0x07e0e7c9eebc444aU)), ((u64)(0x07ab0c764ac6d3a9U)), ((u64)(0x0775a391d56bdc87U)),
		((u64)(0x07414fa7ddefe3a0U)), ((u64)(0x070bb2a62fe638ffU)), ((u64)(0x06d62884f31e93ffU)), ((u64)(0x06a1ba03f5b21000U)), ((u64)(0x066c5cd322b67fffU)), ((u64)(0x0636b0a8e891ffffU)), ((u64)(0x060226ed86db3333U)), ((u64)(0x05cd0b15a491eb84U)),
		((u64)(0x05973c115074bc6aU)), ((u64)(0x05629674405d6388U)), ((u64)(0x052dbd86cd6238d9U)), ((u64)(0x04f7cad23de82d7bU)), ((u64)(0x04c308a831868ac9U)), ((u64)(0x048e74404f3daadbU)), ((u64)(0x04585d003f6488afU)), ((u64)(0x04237d99cc506d59U)),
		((u64)(0x03ef2f5c7a1a488eU)), ((u64)(0x03b8f2b061aea072U)), ((u64)(0x0383f559e7bee6c1U)), ((u64)(0x034feef63f97d79cU)), ((u64)(0x03198bf832dfdfb0U)), ((u64)(0x02e46ff9c24cb2f3U)), ((u64)(0x02b059949b708f29U)), ((u64)(0x027a28edc580e50eU)),
		((u64)(0x0244ed8b04671da5U)), ((u64)(0x0210be08d0527e1dU)), ((u64)(0x01dac9a7b3b7302fU)), ((u64)(0x01a56e1fc2f8f359U)), ((u64)(0x017124e63593f5e1U)), ((u64)(0x013b6e3d22865634U)), ((u64)(0x0105f1ca820511c3U)), ((u64)(0x00d18e3b9b374169U)),
		((u64)(0x009c16c5c5253575U)), ((u64)(0x0066789e3750f791U)), ((u64)(0x0031fa182c40c60dU)), ((u64)(0x000730d67819e8d2U)), ((u64)(0x0000b8157268fdafU)), ((u64)(0x000012688b70e62bU)), ((u64)(0x000001d74124e3d1U)), ((u64)(0x0000002f201d49fbU)),
		((u64)(0x00000004b6695433U)), ((u64)(0x0000000078a42205U)), ((u64)(0x000000000c1069cdU)), ((u64)(0x000000000134d761U)), ((u64)(0x00000000001ee257U)), ((u64)(0x00000000000316a2U)), ((u64)(0x0000000000004f10U)), ((u64)(0x00000000000007e8U)),
		((u64)(0x00000000000000caU)), ((u64)(0x0000000000000014U)), ((u64)(0x0000000000000002U))}));
	_const_strconv__ten_pow_table_32 = new_array_from_c_array(12, 12, sizeof(u32), _MOV((u32[12]){
		((u32)(1U)), ((u32)(10U)), ((u32)(100U)), ((u32)(1000U)), ((u32)(10000U)), ((u32)(100000U)), ((u32)(1000000U)), ((u32)(10000000U)), ((u32)(100000000U)),
		((u32)(1000000000U)), ((u32)(10000000000U)), ((u32)(100000000000U))}));
	_const_strconv__ten_pow_table_64 = new_array_from_c_array(20, 20, sizeof(u64), _MOV((u64[20]){
		((u64)(1U)), ((u64)(10U)), ((u64)(100U)), ((u64)(1000U)), ((u64)(10000U)), ((u64)(100000U)), ((u64)(1000000U)), ((u64)(10000000U)), ((u64)(100000000U)),
		((u64)(1000000000U)), ((u64)(10000000000U)), ((u64)(100000000000U)), ((u64)(1000000000000U)), ((u64)(10000000000000U)), ((u64)(100000000000000U)), ((u64)(1000000000000000U)), ((u64)(10000000000000000U)),
		((u64)(100000000000000000U)), ((u64)(1000000000000000000U)), ((u64)(10000000000000000000U))}));
	_const_strconv__dec_round = new_array_from_c_array(20, 20, sizeof(f64), _MOV((f64[20]){
		((f64)(0.5)), 0.05, 0.005, 0.0005, 0.00005, 0.000005, 0.0000005, 0.00000005, 0.000000005,
		0.0000000005, 0.00000000005, 0.000000000005, 0.0000000000005, 0.00000000000005, 0.000000000000005, 0.0000000000000005, 0.00000000000000005,
		0.000000000000000005, 0.0000000000000000005, 0.00000000000000000005}));
	_const_strconv__powers_of_10 = new_array_from_c_array(18, 18, sizeof(u64), _MOV((u64[18]){
		((u64)(1e0)), ((u64)(1e1)), ((u64)(1e2)), ((u64)(1e3)), ((u64)(1e4)), ((u64)(1e5)), ((u64)(1e6)), ((u64)(1e7)), ((u64)(1e8)),
		((u64)(1e9)), ((u64)(1e10)), ((u64)(1e11)), ((u64)(1e12)), ((u64)(1e13)), ((u64)(1e14)), ((u64)(1e15)), ((u64)(1e16)),
		((u64)(1e17))}));
	_const_strconv__pow5_split_32 = new_array_from_c_array(47, 47, sizeof(u64), _MOV((u64[47]){
		((u64)(1152921504606846976U)), ((u64)(1441151880758558720U)), ((u64)(1801439850948198400U)), ((u64)(2251799813685248000U)), ((u64)(1407374883553280000U)), ((u64)(1759218604441600000U)), ((u64)(2199023255552000000U)), ((u64)(1374389534720000000U)), ((u64)(1717986918400000000U)),
		((u64)(2147483648000000000U)), ((u64)(1342177280000000000U)), ((u64)(1677721600000000000U)), ((u64)(2097152000000000000U)), ((u64)(1310720000000000000U)), ((u64)(1638400000000000000U)), ((u64)(2048000000000000000U)), ((u64)(1280000000000000000U)),
		((u64)(1600000000000000000U)), ((u64)(2000000000000000000U)), ((u64)(1250000000000000000U)), ((u64)(1562500000000000000U)), ((u64)(1953125000000000000U)), ((u64)(1220703125000000000U)), ((u64)(1525878906250000000U)), ((u64)(1907348632812500000U)),
		((u64)(1192092895507812500U)), ((u64)(1490116119384765625U)), ((u64)(1862645149230957031U)), ((u64)(1164153218269348144U)), ((u64)(1455191522836685180U)), ((u64)(1818989403545856475U)), ((u64)(2273736754432320594U)), ((u64)(1421085471520200371U)),
		((u64)(1776356839400250464U)), ((u64)(2220446049250313080U)), ((u64)(1387778780781445675U)), ((u64)(1734723475976807094U)), ((u64)(2168404344971008868U)), ((u64)(1355252715606880542U)), ((u64)(1694065894508600678U)), ((u64)(2117582368135750847U)),
		((u64)(1323488980084844279U)), ((u64)(1654361225106055349U)), ((u64)(2067951531382569187U)), ((u64)(1292469707114105741U)), ((u64)(1615587133892632177U)), ((u64)(2019483917365790221U))}));
	_const_strconv__pow5_inv_split_32 = new_array_from_c_array(31, 31, sizeof(u64), _MOV((u64[31]){
		((u64)(576460752303423489U)), ((u64)(461168601842738791U)), ((u64)(368934881474191033U)), ((u64)(295147905179352826U)), ((u64)(472236648286964522U)), ((u64)(377789318629571618U)), ((u64)(302231454903657294U)), ((u64)(483570327845851670U)), ((u64)(386856262276681336U)),
		((u64)(309485009821345069U)), ((u64)(495176015714152110U)), ((u64)(396140812571321688U)), ((u64)(316912650057057351U)), ((u64)(507060240091291761U)), ((u64)(405648192073033409U)), ((u64)(324518553658426727U)), ((u64)(519229685853482763U)),
		((u64)(415383748682786211U)), ((u64)(332306998946228969U)), ((u64)(531691198313966350U)), ((u64)(425352958651173080U)), ((u64)(340282366920938464U)), ((u64)(544451787073501542U)), ((u64)(435561429658801234U)), ((u64)(348449143727040987U)),
		((u64)(557518629963265579U)), ((u64)(446014903970612463U)), ((u64)(356811923176489971U)), ((u64)(570899077082383953U)), ((u64)(456719261665907162U)), ((u64)(365375409332725730U))}));
	_const_strconv__pow5_split_64 = new_array_from_c_array(326, 326, sizeof(strconv__Uint128), _MOV((strconv__Uint128[326]){
		((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0100000000000000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0140000000000000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0190000000000000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01f4000000000000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0138800000000000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0186a00000000000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01e8480000000000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01312d0000000000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x017d784000000000U)),}),
		((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01dcd65000000000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x012a05f200000000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0174876e80000000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01d1a94a20000000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x012309ce54000000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x016bcc41e9000000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01c6bf5263400000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x011c37937e080000U)),}),
		((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x016345785d8a0000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01bc16d674ec8000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01158e460913d000U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x015af1d78b58c400U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01b1ae4d6e2ef500U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x010f0cf064dd5920U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x0152d02c7e14af68U)),}), ((strconv__Uint128){.lo = ((u64)(0x0000000000000000U)),.hi = ((u64)(0x01a784379d99db42U)),}),
		((strconv__Uint128){.lo = ((u64)(0x4000000000000000U)),.hi = ((u64)(0x0108b2a2c2802909U)),}), ((strconv__Uint128){.lo = ((u64)(0x9000000000000000U)),.hi = ((u64)(0x014adf4b7320334bU)),}), ((strconv__Uint128){.lo = ((u64)(0x7400000000000000U)),.hi = ((u64)(0x019d971e4fe8401eU)),}), ((strconv__Uint128){.lo = ((u64)(0x0880000000000000U)),.hi = ((u64)(0x01027e72f1f12813U)),}), ((strconv__Uint128){.lo = ((u64)(0xcaa0000000000000U)),.hi = ((u64)(0x01431e0fae6d7217U)),}), ((strconv__Uint128){.lo = ((u64)(0xbd48000000000000U)),.hi = ((u64)(0x0193e5939a08ce9dU)),}), ((strconv__Uint128){.lo = ((u64)(0x2c9a000000000000U)),.hi = ((u64)(0x01f8def8808b0245U)),}), ((strconv__Uint128){.lo = ((u64)(0x3be0400000000000U)),.hi = ((u64)(0x013b8b5b5056e16bU)),}),
		((strconv__Uint128){.lo = ((u64)(0x0ad8500000000000U)),.hi = ((u64)(0x018a6e32246c99c6U)),}), ((strconv__Uint128){.lo = ((u64)(0x8d8e640000000000U)),.hi = ((u64)(0x01ed09bead87c037U)),}), ((strconv__Uint128){.lo = ((u64)(0xb878fe8000000000U)),.hi = ((u64)(0x013426172c74d822U)),}), ((strconv__Uint128){.lo = ((u64)(0x66973e2000000000U)),.hi = ((u64)(0x01812f9cf7920e2bU)),}), ((strconv__Uint128){.lo = ((u64)(0x403d0da800000000U)),.hi = ((u64)(0x01e17b84357691b6U)),}), ((strconv__Uint128){.lo = ((u64)(0xe826288900000000U)),.hi = ((u64)(0x012ced32a16a1b11U)),}), ((strconv__Uint128){.lo = ((u64)(0x622fb2ab40000000U)),.hi = ((u64)(0x0178287f49c4a1d6U)),}), ((strconv__Uint128){.lo = ((u64)(0xfabb9f5610000000U)),.hi = ((u64)(0x01d6329f1c35ca4bU)),}),
		((strconv__Uint128){.lo = ((u64)(0x7cb54395ca000000U)),.hi = ((u64)(0x0125dfa371a19e6fU)),}), ((strconv__Uint128){.lo = ((u64)(0x5be2947b3c800000U)),.hi = ((u64)(0x016f578c4e0a060bU)),}), ((strconv__Uint128){.lo = ((u64)(0x32db399a0ba00000U)),.hi = ((u64)(0x01cb2d6f618c878eU)),}), ((strconv__Uint128){.lo = ((u64)(0xdfc9040047440000U)),.hi = ((u64)(0x011efc659cf7d4b8U)),}), ((strconv__Uint128){.lo = ((u64)(0x17bb450059150000U)),.hi = ((u64)(0x0166bb7f0435c9e7U)),}), ((strconv__Uint128){.lo = ((u64)(0xddaa16406f5a4000U)),.hi = ((u64)(0x01c06a5ec5433c60U)),}), ((strconv__Uint128){.lo = ((u64)(0x8a8a4de845986800U)),.hi = ((u64)(0x0118427b3b4a05bcU)),}), ((strconv__Uint128){.lo = ((u64)(0xad2ce16256fe8200U)),.hi = ((u64)(0x015e531a0a1c872bU)),}),
		((strconv__Uint128){.lo = ((u64)(0x987819baecbe2280U)),.hi = ((u64)(0x01b5e7e08ca3a8f6U)),}), ((strconv__Uint128){.lo = ((u64)(0x1f4b1014d3f6d590U)),.hi = ((u64)(0x0111b0ec57e6499aU)),}), ((strconv__Uint128){.lo = ((u64)(0xa71dd41a08f48af4U)),.hi = ((u64)(0x01561d276ddfdc00U)),}), ((strconv__Uint128){.lo = ((u64)(0xd0e549208b31adb1U)),.hi = ((u64)(0x01aba4714957d300U)),}), ((strconv__Uint128){.lo = ((u64)(0x828f4db456ff0c8eU)),.hi = ((u64)(0x010b46c6cdd6e3e0U)),}), ((strconv__Uint128){.lo = ((u64)(0xa33321216cbecfb2U)),.hi = ((u64)(0x014e1878814c9cd8U)),}), ((strconv__Uint128){.lo = ((u64)(0xcbffe969c7ee839eU)),.hi = ((u64)(0x01a19e96a19fc40eU)),}), ((strconv__Uint128){.lo = ((u64)(0x3f7ff1e21cf51243U)),.hi = ((u64)(0x0105031e2503da89U)),}),
		((strconv__Uint128){.lo = ((u64)(0x8f5fee5aa43256d4U)),.hi = ((u64)(0x014643e5ae44d12bU)),}), ((strconv__Uint128){.lo = ((u64)(0x7337e9f14d3eec89U)),.hi = ((u64)(0x0197d4df19d60576U)),}), ((strconv__Uint128){.lo = ((u64)(0x1005e46da08ea7abU)),.hi = ((u64)(0x01fdca16e04b86d4U)),}), ((strconv__Uint128){.lo = ((u64)(0x8a03aec4845928cbU)),.hi = ((u64)(0x013e9e4e4c2f3444U)),}), ((strconv__Uint128){.lo = ((u64)(0xac849a75a56f72fdU)),.hi = ((u64)(0x018e45e1df3b0155U)),}), ((strconv__Uint128){.lo = ((u64)(0x17a5c1130ecb4fbdU)),.hi = ((u64)(0x01f1d75a5709c1abU)),}), ((strconv__Uint128){.lo = ((u64)(0xeec798abe93f11d6U)),.hi = ((u64)(0x013726987666190aU)),}), ((strconv__Uint128){.lo = ((u64)(0xaa797ed6e38ed64bU)),.hi = ((u64)(0x0184f03e93ff9f4dU)),}),
		((strconv__Uint128){.lo = ((u64)(0x1517de8c9c728bdeU)),.hi = ((u64)(0x01e62c4e38ff8721U)),}), ((strconv__Uint128){.lo = ((u64)(0xad2eeb17e1c7976bU)),.hi = ((u64)(0x012fdbb0e39fb474U)),}), ((strconv__Uint128){.lo = ((u64)(0xd87aa5ddda397d46U)),.hi = ((u64)(0x017bd29d1c87a191U)),}), ((strconv__Uint128){.lo = ((u64)(0x4e994f5550c7dc97U)),.hi = ((u64)(0x01dac74463a989f6U)),}), ((strconv__Uint128){.lo = ((u64)(0xf11fd195527ce9deU)),.hi = ((u64)(0x0128bc8abe49f639U)),}), ((strconv__Uint128){.lo = ((u64)(0x6d67c5faa71c2456U)),.hi = ((u64)(0x0172ebad6ddc73c8U)),}), ((strconv__Uint128){.lo = ((u64)(0x88c1b77950e32d6cU)),.hi = ((u64)(0x01cfa698c95390baU)),}), ((strconv__Uint128){.lo = ((u64)(0x957912abd28dfc63U)),.hi = ((u64)(0x0121c81f7dd43a74U)),}),
		((strconv__Uint128){.lo = ((u64)(0xbad75756c7317b7cU)),.hi = ((u64)(0x016a3a275d494911U)),}), ((strconv__Uint128){.lo = ((u64)(0x298d2d2c78fdda5bU)),.hi = ((u64)(0x01c4c8b1349b9b56U)),}), ((strconv__Uint128){.lo = ((u64)(0xd9f83c3bcb9ea879U)),.hi = ((u64)(0x011afd6ec0e14115U)),}), ((strconv__Uint128){.lo = ((u64)(0x50764b4abe865297U)),.hi = ((u64)(0x0161bcca7119915bU)),}), ((strconv__Uint128){.lo = ((u64)(0x2493de1d6e27e73dU)),.hi = ((u64)(0x01ba2bfd0d5ff5b2U)),}), ((strconv__Uint128){.lo = ((u64)(0x56dc6ad264d8f086U)),.hi = ((u64)(0x01145b7e285bf98fU)),}), ((strconv__Uint128){.lo = ((u64)(0x2c938586fe0f2ca8U)),.hi = ((u64)(0x0159725db272f7f3U)),}), ((strconv__Uint128){.lo = ((u64)(0xf7b866e8bd92f7d2U)),.hi = ((u64)(0x01afcef51f0fb5efU)),}),
		((strconv__Uint128){.lo = ((u64)(0xfad34051767bdae3U)),.hi = ((u64)(0x010de1593369d1b5U)),}), ((strconv__Uint128){.lo = ((u64)(0x79881065d41ad19cU)),.hi = ((u64)(0x015159af80444623U)),}), ((strconv__Uint128){.lo = ((u64)(0x57ea147f49218603U)),.hi = ((u64)(0x01a5b01b605557acU)),}), ((strconv__Uint128){.lo = ((u64)(0xb6f24ccf8db4f3c1U)),.hi = ((u64)(0x01078e111c3556cbU)),}), ((strconv__Uint128){.lo = ((u64)(0xa4aee003712230b2U)),.hi = ((u64)(0x014971956342ac7eU)),}), ((strconv__Uint128){.lo = ((u64)(0x4dda98044d6abcdfU)),.hi = ((u64)(0x019bcdfabc13579eU)),}), ((strconv__Uint128){.lo = ((u64)(0xf0a89f02b062b60bU)),.hi = ((u64)(0x010160bcb58c16c2U)),}), ((strconv__Uint128){.lo = ((u64)(0xacd2c6c35c7b638eU)),.hi = ((u64)(0x0141b8ebe2ef1c73U)),}),
		((strconv__Uint128){.lo = ((u64)(0x98077874339a3c71U)),.hi = ((u64)(0x01922726dbaae390U)),}), ((strconv__Uint128){.lo = ((u64)(0xbe0956914080cb8eU)),.hi = ((u64)(0x01f6b0f092959c74U)),}), ((strconv__Uint128){.lo = ((u64)(0xf6c5d61ac8507f38U)),.hi = ((u64)(0x013a2e965b9d81c8U)),}), ((strconv__Uint128){.lo = ((u64)(0x34774ba17a649f07U)),.hi = ((u64)(0x0188ba3bf284e23bU)),}), ((strconv__Uint128){.lo = ((u64)(0x01951e89d8fdc6c8U)),.hi = ((u64)(0x01eae8caef261acaU)),}), ((strconv__Uint128){.lo = ((u64)(0x40fd3316279e9c3dU)),.hi = ((u64)(0x0132d17ed577d0beU)),}), ((strconv__Uint128){.lo = ((u64)(0xd13c7fdbb186434cU)),.hi = ((u64)(0x017f85de8ad5c4edU)),}), ((strconv__Uint128){.lo = ((u64)(0x458b9fd29de7d420U)),.hi = ((u64)(0x01df67562d8b3629U)),}),
		((strconv__Uint128){.lo = ((u64)(0xcb7743e3a2b0e494U)),.hi = ((u64)(0x012ba095dc7701d9U)),}), ((strconv__Uint128){.lo = ((u64)(0x3e5514dc8b5d1db9U)),.hi = ((u64)(0x017688bb5394c250U)),}), ((strconv__Uint128){.lo = ((u64)(0x4dea5a13ae346527U)),.hi = ((u64)(0x01d42aea2879f2e4U)),}), ((strconv__Uint128){.lo = ((u64)(0xb0b2784c4ce0bf38U)),.hi = ((u64)(0x01249ad2594c37ceU)),}), ((strconv__Uint128){.lo = ((u64)(0x5cdf165f6018ef06U)),.hi = ((u64)(0x016dc186ef9f45c2U)),}), ((strconv__Uint128){.lo = ((u64)(0xf416dbf7381f2ac8U)),.hi = ((u64)(0x01c931e8ab871732U)),}), ((strconv__Uint128){.lo = ((u64)(0xd88e497a83137abdU)),.hi = ((u64)(0x011dbf316b346e7fU)),}), ((strconv__Uint128){.lo = ((u64)(0xceb1dbd923d8596cU)),.hi = ((u64)(0x01652efdc6018a1fU)),}),
		((strconv__Uint128){.lo = ((u64)(0xc25e52cf6cce6fc7U)),.hi = ((u64)(0x01be7abd3781eca7U)),}), ((strconv__Uint128){.lo = ((u64)(0xd97af3c1a40105dcU)),.hi = ((u64)(0x01170cb642b133e8U)),}), ((strconv__Uint128){.lo = ((u64)(0x0fd9b0b20d014754U)),.hi = ((u64)(0x015ccfe3d35d80e3U)),}), ((strconv__Uint128){.lo = ((u64)(0xd3d01cde90419929U)),.hi = ((u64)(0x01b403dcc834e11bU)),}), ((strconv__Uint128){.lo = ((u64)(0x6462120b1a28ffb9U)),.hi = ((u64)(0x01108269fd210cb1U)),}), ((strconv__Uint128){.lo = ((u64)(0xbd7a968de0b33fa8U)),.hi = ((u64)(0x0154a3047c694fddU)),}), ((strconv__Uint128){.lo = ((u64)(0x2cd93c3158e00f92U)),.hi = ((u64)(0x01a9cbc59b83a3d5U)),}), ((strconv__Uint128){.lo = ((u64)(0x3c07c59ed78c09bbU)),.hi = ((u64)(0x010a1f5b81324665U)),}),
		((strconv__Uint128){.lo = ((u64)(0x8b09b7068d6f0c2aU)),.hi = ((u64)(0x014ca732617ed7feU)),}), ((strconv__Uint128){.lo = ((u64)(0x2dcc24c830cacf34U)),.hi = ((u64)(0x019fd0fef9de8dfeU)),}), ((strconv__Uint128){.lo = ((u64)(0xdc9f96fd1e7ec180U)),.hi = ((u64)(0x0103e29f5c2b18beU)),}), ((strconv__Uint128){.lo = ((u64)(0x93c77cbc661e71e1U)),.hi = ((u64)(0x0144db473335deeeU)),}), ((strconv__Uint128){.lo = ((u64)(0x38b95beb7fa60e59U)),.hi = ((u64)(0x01961219000356aaU)),}), ((strconv__Uint128){.lo = ((u64)(0xc6e7b2e65f8f91efU)),.hi = ((u64)(0x01fb969f40042c54U)),}), ((strconv__Uint128){.lo = ((u64)(0xfc50cfcffbb9bb35U)),.hi = ((u64)(0x013d3e2388029bb4U)),}), ((strconv__Uint128){.lo = ((u64)(0x3b6503c3faa82a03U)),.hi = ((u64)(0x018c8dac6a0342a2U)),}),
		((strconv__Uint128){.lo = ((u64)(0xca3e44b4f9523484U)),.hi = ((u64)(0x01efb1178484134aU)),}), ((strconv__Uint128){.lo = ((u64)(0xbe66eaf11bd360d2U)),.hi = ((u64)(0x0135ceaeb2d28c0eU)),}), ((strconv__Uint128){.lo = ((u64)(0x6e00a5ad62c83907U)),.hi = ((u64)(0x0183425a5f872f12U)),}), ((strconv__Uint128){.lo = ((u64)(0x0980cf18bb7a4749U)),.hi = ((u64)(0x01e412f0f768fad7U)),}), ((strconv__Uint128){.lo = ((u64)(0x65f0816f752c6c8dU)),.hi = ((u64)(0x012e8bd69aa19cc6U)),}), ((strconv__Uint128){.lo = ((u64)(0xff6ca1cb527787b1U)),.hi = ((u64)(0x017a2ecc414a03f7U)),}), ((strconv__Uint128){.lo = ((u64)(0xff47ca3e2715699dU)),.hi = ((u64)(0x01d8ba7f519c84f5U)),}), ((strconv__Uint128){.lo = ((u64)(0xbf8cde66d86d6202U)),.hi = ((u64)(0x0127748f9301d319U)),}),
		((strconv__Uint128){.lo = ((u64)(0x2f7016008e88ba83U)),.hi = ((u64)(0x017151b377c247e0U)),}), ((strconv__Uint128){.lo = ((u64)(0x3b4c1b80b22ae923U)),.hi = ((u64)(0x01cda62055b2d9d8U)),}), ((strconv__Uint128){.lo = ((u64)(0x250f91306f5ad1b6U)),.hi = ((u64)(0x012087d4358fc827U)),}), ((strconv__Uint128){.lo = ((u64)(0xee53757c8b318623U)),.hi = ((u64)(0x0168a9c942f3ba30U)),}), ((strconv__Uint128){.lo = ((u64)(0x29e852dbadfde7acU)),.hi = ((u64)(0x01c2d43b93b0a8bdU)),}), ((strconv__Uint128){.lo = ((u64)(0x3a3133c94cbeb0ccU)),.hi = ((u64)(0x0119c4a53c4e6976U)),}), ((strconv__Uint128){.lo = ((u64)(0xc8bd80bb9fee5cffU)),.hi = ((u64)(0x016035ce8b6203d3U)),}), ((strconv__Uint128){.lo = ((u64)(0xbaece0ea87e9f43eU)),.hi = ((u64)(0x01b843422e3a84c8U)),}),
		((strconv__Uint128){.lo = ((u64)(0x74d40c9294f238a7U)),.hi = ((u64)(0x01132a095ce492fdU)),}), ((strconv__Uint128){.lo = ((u64)(0xd2090fb73a2ec6d1U)),.hi = ((u64)(0x0157f48bb41db7bcU)),}), ((strconv__Uint128){.lo = ((u64)(0x068b53a508ba7885U)),.hi = ((u64)(0x01adf1aea12525acU)),}), ((strconv__Uint128){.lo = ((u64)(0x8417144725748b53U)),.hi = ((u64)(0x010cb70d24b7378bU)),}), ((strconv__Uint128){.lo = ((u64)(0x651cd958eed1ae28U)),.hi = ((u64)(0x014fe4d06de5056eU)),}), ((strconv__Uint128){.lo = ((u64)(0xfe640faf2a8619b2U)),.hi = ((u64)(0x01a3de04895e46c9U)),}), ((strconv__Uint128){.lo = ((u64)(0x3efe89cd7a93d00fU)),.hi = ((u64)(0x01066ac2d5daec3eU)),}), ((strconv__Uint128){.lo = ((u64)(0xcebe2c40d938c413U)),.hi = ((u64)(0x014805738b51a74dU)),}),
		((strconv__Uint128){.lo = ((u64)(0x426db7510f86f518U)),.hi = ((u64)(0x019a06d06e261121U)),}), ((strconv__Uint128){.lo = ((u64)(0xc9849292a9b4592fU)),.hi = ((u64)(0x0100444244d7cab4U)),}), ((strconv__Uint128){.lo = ((u64)(0xfbe5b73754216f7aU)),.hi = ((u64)(0x01405552d60dbd61U)),}), ((strconv__Uint128){.lo = ((u64)(0x7adf25052929cb59U)),.hi = ((u64)(0x01906aa78b912cbaU)),}), ((strconv__Uint128){.lo = ((u64)(0x1996ee4673743e2fU)),.hi = ((u64)(0x01f485516e7577e9U)),}), ((strconv__Uint128){.lo = ((u64)(0xaffe54ec0828a6ddU)),.hi = ((u64)(0x0138d352e5096af1U)),}), ((strconv__Uint128){.lo = ((u64)(0x1bfdea270a32d095U)),.hi = ((u64)(0x018708279e4bc5aeU)),}), ((strconv__Uint128){.lo = ((u64)(0xa2fd64b0ccbf84baU)),.hi = ((u64)(0x01e8ca3185deb719U)),}),
		((strconv__Uint128){.lo = ((u64)(0x05de5eee7ff7b2f4U)),.hi = ((u64)(0x01317e5ef3ab3270U)),}), ((strconv__Uint128){.lo = ((u64)(0x0755f6aa1ff59fb1U)),.hi = ((u64)(0x017dddf6b095ff0cU)),}), ((strconv__Uint128){.lo = ((u64)(0x092b7454a7f3079eU)),.hi = ((u64)(0x01dd55745cbb7ecfU)),}), ((strconv__Uint128){.lo = ((u64)(0x65bb28b4e8f7e4c3U)),.hi = ((u64)(0x012a5568b9f52f41U)),}), ((strconv__Uint128){.lo = ((u64)(0xbf29f2e22335ddf3U)),.hi = ((u64)(0x0174eac2e8727b11U)),}), ((strconv__Uint128){.lo = ((u64)(0x2ef46f9aac035570U)),.hi = ((u64)(0x01d22573a28f19d6U)),}), ((strconv__Uint128){.lo = ((u64)(0xdd58c5c0ab821566U)),.hi = ((u64)(0x0123576845997025U)),}), ((strconv__Uint128){.lo = ((u64)(0x54aef730d6629ac0U)),.hi = ((u64)(0x016c2d4256ffcc2fU)),}),
		((strconv__Uint128){.lo = ((u64)(0x29dab4fd0bfb4170U)),.hi = ((u64)(0x01c73892ecbfbf3bU)),}), ((strconv__Uint128){.lo = ((u64)(0xfa28b11e277d08e6U)),.hi = ((u64)(0x011c835bd3f7d784U)),}), ((strconv__Uint128){.lo = ((u64)(0x38b2dd65b15c4b1fU)),.hi = ((u64)(0x0163a432c8f5cd66U)),}), ((strconv__Uint128){.lo = ((u64)(0xc6df94bf1db35de7U)),.hi = ((u64)(0x01bc8d3f7b3340bfU)),}), ((strconv__Uint128){.lo = ((u64)(0xdc4bbcf772901ab0U)),.hi = ((u64)(0x0115d847ad000877U)),}), ((strconv__Uint128){.lo = ((u64)(0xd35eac354f34215cU)),.hi = ((u64)(0x015b4e5998400a95U)),}), ((strconv__Uint128){.lo = ((u64)(0x48365742a30129b4U)),.hi = ((u64)(0x01b221effe500d3bU)),}), ((strconv__Uint128){.lo = ((u64)(0x0d21f689a5e0ba10U)),.hi = ((u64)(0x010f5535fef20845U)),}),
		((strconv__Uint128){.lo = ((u64)(0x506a742c0f58e894U)),.hi = ((u64)(0x01532a837eae8a56U)),}), ((strconv__Uint128){.lo = ((u64)(0xe4851137132f22b9U)),.hi = ((u64)(0x01a7f5245e5a2cebU)),}), ((strconv__Uint128){.lo = ((u64)(0x6ed32ac26bfd75b4U)),.hi = ((u64)(0x0108f936baf85c13U)),}), ((strconv__Uint128){.lo = ((u64)(0x4a87f57306fcd321U)),.hi = ((u64)(0x014b378469b67318U)),}), ((strconv__Uint128){.lo = ((u64)(0x5d29f2cfc8bc07e9U)),.hi = ((u64)(0x019e056584240fdeU)),}), ((strconv__Uint128){.lo = ((u64)(0xfa3a37c1dd7584f1U)),.hi = ((u64)(0x0102c35f729689eaU)),}), ((strconv__Uint128){.lo = ((u64)(0xb8c8c5b254d2e62eU)),.hi = ((u64)(0x014374374f3c2c65U)),}), ((strconv__Uint128){.lo = ((u64)(0x26faf71eea079fb9U)),.hi = ((u64)(0x01945145230b377fU)),}),
		((strconv__Uint128){.lo = ((u64)(0xf0b9b4e6a48987a8U)),.hi = ((u64)(0x01f965966bce055eU)),}), ((strconv__Uint128){.lo = ((u64)(0x5674111026d5f4c9U)),.hi = ((u64)(0x013bdf7e0360c35bU)),}), ((strconv__Uint128){.lo = ((u64)(0x2c111554308b71fbU)),.hi = ((u64)(0x018ad75d8438f432U)),}), ((strconv__Uint128){.lo = ((u64)(0xb7155aa93cae4e7aU)),.hi = ((u64)(0x01ed8d34e547313eU)),}), ((strconv__Uint128){.lo = ((u64)(0x326d58a9c5ecf10cU)),.hi = ((u64)(0x013478410f4c7ec7U)),}), ((strconv__Uint128){.lo = ((u64)(0xff08aed437682d4fU)),.hi = ((u64)(0x01819651531f9e78U)),}), ((strconv__Uint128){.lo = ((u64)(0x3ecada89454238a3U)),.hi = ((u64)(0x01e1fbe5a7e78617U)),}), ((strconv__Uint128){.lo = ((u64)(0x873ec895cb496366U)),.hi = ((u64)(0x012d3d6f88f0b3ceU)),}),
		((strconv__Uint128){.lo = ((u64)(0x290e7abb3e1bbc3fU)),.hi = ((u64)(0x01788ccb6b2ce0c2U)),}), ((strconv__Uint128){.lo = ((u64)(0xb352196a0da2ab4fU)),.hi = ((u64)(0x01d6affe45f818f2U)),}), ((strconv__Uint128){.lo = ((u64)(0xb0134fe24885ab11U)),.hi = ((u64)(0x01262dfeebbb0f97U)),}), ((strconv__Uint128){.lo = ((u64)(0x9c1823dadaa715d6U)),.hi = ((u64)(0x016fb97ea6a9d37dU)),}), ((strconv__Uint128){.lo = ((u64)(0x031e2cd19150db4bU)),.hi = ((u64)(0x01cba7de5054485dU)),}), ((strconv__Uint128){.lo = ((u64)(0x21f2dc02fad2890fU)),.hi = ((u64)(0x011f48eaf234ad3aU)),}), ((strconv__Uint128){.lo = ((u64)(0xaa6f9303b9872b53U)),.hi = ((u64)(0x01671b25aec1d888U)),}), ((strconv__Uint128){.lo = ((u64)(0xd50b77c4a7e8f628U)),.hi = ((u64)(0x01c0e1ef1a724eaaU)),}),
		((strconv__Uint128){.lo = ((u64)(0xc5272adae8f199d9U)),.hi = ((u64)(0x01188d357087712aU)),}), ((strconv__Uint128){.lo = ((u64)(0x7670f591a32e004fU)),.hi = ((u64)(0x015eb082cca94d75U)),}), ((strconv__Uint128){.lo = ((u64)(0xd40d32f60bf98063U)),.hi = ((u64)(0x01b65ca37fd3a0d2U)),}), ((strconv__Uint128){.lo = ((u64)(0xc4883fd9c77bf03eU)),.hi = ((u64)(0x0111f9e62fe44483U)),}), ((strconv__Uint128){.lo = ((u64)(0xb5aa4fd0395aec4dU)),.hi = ((u64)(0x0156785fbbdd55a4U)),}), ((strconv__Uint128){.lo = ((u64)(0xe314e3c447b1a760U)),.hi = ((u64)(0x01ac1677aad4ab0dU)),}), ((strconv__Uint128){.lo = ((u64)(0xaded0e5aaccf089cU)),.hi = ((u64)(0x010b8e0acac4eae8U)),}), ((strconv__Uint128){.lo = ((u64)(0xd96851f15802cac3U)),.hi = ((u64)(0x014e718d7d7625a2U)),}),
		((strconv__Uint128){.lo = ((u64)(0x8fc2666dae037d74U)),.hi = ((u64)(0x01a20df0dcd3af0bU)),}), ((strconv__Uint128){.lo = ((u64)(0x39d980048cc22e68U)),.hi = ((u64)(0x010548b68a044d67U)),}), ((strconv__Uint128){.lo = ((u64)(0x084fe005aff2ba03U)),.hi = ((u64)(0x01469ae42c8560c1U)),}), ((strconv__Uint128){.lo = ((u64)(0x4a63d8071bef6883U)),.hi = ((u64)(0x0198419d37a6b8f1U)),}), ((strconv__Uint128){.lo = ((u64)(0x9cfcce08e2eb42a4U)),.hi = ((u64)(0x01fe52048590672dU)),}), ((strconv__Uint128){.lo = ((u64)(0x821e00c58dd309a7U)),.hi = ((u64)(0x013ef342d37a407cU)),}), ((strconv__Uint128){.lo = ((u64)(0xa2a580f6f147cc10U)),.hi = ((u64)(0x018eb0138858d09bU)),}), ((strconv__Uint128){.lo = ((u64)(0x8b4ee134ad99bf15U)),.hi = ((u64)(0x01f25c186a6f04c2U)),}),
		((strconv__Uint128){.lo = ((u64)(0x97114cc0ec80176dU)),.hi = ((u64)(0x0137798f428562f9U)),}), ((strconv__Uint128){.lo = ((u64)(0xfcd59ff127a01d48U)),.hi = ((u64)(0x018557f31326bbb7U)),}), ((strconv__Uint128){.lo = ((u64)(0xfc0b07ed7188249aU)),.hi = ((u64)(0x01e6adefd7f06aa5U)),}), ((strconv__Uint128){.lo = ((u64)(0xbd86e4f466f516e0U)),.hi = ((u64)(0x01302cb5e6f642a7U)),}), ((strconv__Uint128){.lo = ((u64)(0xace89e3180b25c98U)),.hi = ((u64)(0x017c37e360b3d351U)),}), ((strconv__Uint128){.lo = ((u64)(0x1822c5bde0def3beU)),.hi = ((u64)(0x01db45dc38e0c826U)),}), ((strconv__Uint128){.lo = ((u64)(0xcf15bb96ac8b5857U)),.hi = ((u64)(0x01290ba9a38c7d17U)),}), ((strconv__Uint128){.lo = ((u64)(0xc2db2a7c57ae2e6dU)),.hi = ((u64)(0x01734e940c6f9c5dU)),}),
		((strconv__Uint128){.lo = ((u64)(0x3391f51b6d99ba08U)),.hi = ((u64)(0x01d022390f8b8375U)),}), ((strconv__Uint128){.lo = ((u64)(0x403b393124801445U)),.hi = ((u64)(0x01221563a9b73229U)),}), ((strconv__Uint128){.lo = ((u64)(0x904a077d6da01956U)),.hi = ((u64)(0x016a9abc9424feb3U)),}), ((strconv__Uint128){.lo = ((u64)(0x745c895cc9081facU)),.hi = ((u64)(0x01c5416bb92e3e60U)),}), ((strconv__Uint128){.lo = ((u64)(0x48b9d5d9fda513cbU)),.hi = ((u64)(0x011b48e353bce6fcU)),}), ((strconv__Uint128){.lo = ((u64)(0x5ae84b507d0e58beU)),.hi = ((u64)(0x01621b1c28ac20bbU)),}), ((strconv__Uint128){.lo = ((u64)(0x31a25e249c51eeeeU)),.hi = ((u64)(0x01baa1e332d728eaU)),}), ((strconv__Uint128){.lo = ((u64)(0x5f057ad6e1b33554U)),.hi = ((u64)(0x0114a52dffc67992U)),}),
		((strconv__Uint128){.lo = ((u64)(0xf6c6d98c9a2002aaU)),.hi = ((u64)(0x0159ce797fb817f6U)),}), ((strconv__Uint128){.lo = ((u64)(0xb4788fefc0a80354U)),.hi = ((u64)(0x01b04217dfa61df4U)),}), ((strconv__Uint128){.lo = ((u64)(0xf0cb59f5d8690214U)),.hi = ((u64)(0x010e294eebc7d2b8U)),}), ((strconv__Uint128){.lo = ((u64)(0x2cfe30734e83429aU)),.hi = ((u64)(0x0151b3a2a6b9c767U)),}), ((strconv__Uint128){.lo = ((u64)(0xf83dbc9022241340U)),.hi = ((u64)(0x01a6208b50683940U)),}), ((strconv__Uint128){.lo = ((u64)(0x9b2695da15568c08U)),.hi = ((u64)(0x0107d457124123c8U)),}), ((strconv__Uint128){.lo = ((u64)(0xc1f03b509aac2f0aU)),.hi = ((u64)(0x0149c96cd6d16cbaU)),}), ((strconv__Uint128){.lo = ((u64)(0x726c4a24c1573acdU)),.hi = ((u64)(0x019c3bc80c85c7e9U)),}),
		((strconv__Uint128){.lo = ((u64)(0xe783ae56f8d684c0U)),.hi = ((u64)(0x0101a55d07d39cf1U)),}), ((strconv__Uint128){.lo = ((u64)(0x616499ecb70c25f0U)),.hi = ((u64)(0x01420eb449c8842eU)),}), ((strconv__Uint128){.lo = ((u64)(0xf9bdc067e4cf2f6cU)),.hi = ((u64)(0x019292615c3aa539U)),}), ((strconv__Uint128){.lo = ((u64)(0x782d3081de02fb47U)),.hi = ((u64)(0x01f736f9b3494e88U)),}), ((strconv__Uint128){.lo = ((u64)(0x4b1c3e512ac1dd0cU)),.hi = ((u64)(0x013a825c100dd115U)),}), ((strconv__Uint128){.lo = ((u64)(0x9de34de57572544fU)),.hi = ((u64)(0x018922f31411455aU)),}), ((strconv__Uint128){.lo = ((u64)(0x455c215ed2cee963U)),.hi = ((u64)(0x01eb6bafd91596b1U)),}), ((strconv__Uint128){.lo = ((u64)(0xcb5994db43c151deU)),.hi = ((u64)(0x0133234de7ad7e2eU)),}),
		((strconv__Uint128){.lo = ((u64)(0x7e2ffa1214b1a655U)),.hi = ((u64)(0x017fec216198ddbaU)),}), ((strconv__Uint128){.lo = ((u64)(0x1dbbf89699de0febU)),.hi = ((u64)(0x01dfe729b9ff1529U)),}), ((strconv__Uint128){.lo = ((u64)(0xb2957b5e202ac9f3U)),.hi = ((u64)(0x012bf07a143f6d39U)),}), ((strconv__Uint128){.lo = ((u64)(0x1f3ada35a8357c6fU)),.hi = ((u64)(0x0176ec98994f4888U)),}), ((strconv__Uint128){.lo = ((u64)(0x270990c31242db8bU)),.hi = ((u64)(0x01d4a7bebfa31aaaU)),}), ((strconv__Uint128){.lo = ((u64)(0x5865fa79eb69c937U)),.hi = ((u64)(0x0124e8d737c5f0aaU)),}), ((strconv__Uint128){.lo = ((u64)(0xee7f791866443b85U)),.hi = ((u64)(0x016e230d05b76cd4U)),}), ((strconv__Uint128){.lo = ((u64)(0x2a1f575e7fd54a66U)),.hi = ((u64)(0x01c9abd04725480aU)),}),
		((strconv__Uint128){.lo = ((u64)(0x5a53969b0fe54e80U)),.hi = ((u64)(0x011e0b622c774d06U)),}), ((strconv__Uint128){.lo = ((u64)(0xf0e87c41d3dea220U)),.hi = ((u64)(0x01658e3ab7952047U)),}), ((strconv__Uint128){.lo = ((u64)(0xed229b5248d64aa8U)),.hi = ((u64)(0x01bef1c9657a6859U)),}), ((strconv__Uint128){.lo = ((u64)(0x3435a1136d85eea9U)),.hi = ((u64)(0x0117571ddf6c8138U)),}), ((strconv__Uint128){.lo = ((u64)(0x4143095848e76a53U)),.hi = ((u64)(0x015d2ce55747a186U)),}), ((strconv__Uint128){.lo = ((u64)(0xd193cbae5b2144e8U)),.hi = ((u64)(0x01b4781ead1989e7U)),}), ((strconv__Uint128){.lo = ((u64)(0xe2fc5f4cf8f4cb11U)),.hi = ((u64)(0x0110cb132c2ff630U)),}), ((strconv__Uint128){.lo = ((u64)(0x1bbb77203731fdd5U)),.hi = ((u64)(0x0154fdd7f73bf3bdU)),}),
		((strconv__Uint128){.lo = ((u64)(0x62aa54e844fe7d4aU)),.hi = ((u64)(0x01aa3d4df50af0acU)),}), ((strconv__Uint128){.lo = ((u64)(0xbdaa75112b1f0e4eU)),.hi = ((u64)(0x010a6650b926d66bU)),}), ((strconv__Uint128){.lo = ((u64)(0xad15125575e6d1e2U)),.hi = ((u64)(0x014cffe4e7708c06U)),}), ((strconv__Uint128){.lo = ((u64)(0x585a56ead360865bU)),.hi = ((u64)(0x01a03fde214caf08U)),}), ((strconv__Uint128){.lo = ((u64)(0x37387652c41c53f8U)),.hi = ((u64)(0x010427ead4cfed65U)),}), ((strconv__Uint128){.lo = ((u64)(0x850693e7752368f7U)),.hi = ((u64)(0x014531e58a03e8beU)),}), ((strconv__Uint128){.lo = ((u64)(0x264838e1526c4334U)),.hi = ((u64)(0x01967e5eec84e2eeU)),}), ((strconv__Uint128){.lo = ((u64)(0xafda4719a7075402U)),.hi = ((u64)(0x01fc1df6a7a61ba9U)),}),
		((strconv__Uint128){.lo = ((u64)(0x0de86c7008649481U)),.hi = ((u64)(0x013d92ba28c7d14aU)),}), ((strconv__Uint128){.lo = ((u64)(0x9162878c0a7db9a1U)),.hi = ((u64)(0x018cf768b2f9c59cU)),}), ((strconv__Uint128){.lo = ((u64)(0xb5bb296f0d1d280aU)),.hi = ((u64)(0x01f03542dfb83703U)),}), ((strconv__Uint128){.lo = ((u64)(0x5194f9e568323906U)),.hi = ((u64)(0x01362149cbd32262U)),}), ((strconv__Uint128){.lo = ((u64)(0xe5fa385ec23ec747U)),.hi = ((u64)(0x0183a99c3ec7eafaU)),}), ((strconv__Uint128){.lo = ((u64)(0x9f78c67672ce7919U)),.hi = ((u64)(0x01e494034e79e5b9U)),}), ((strconv__Uint128){.lo = ((u64)(0x03ab7c0a07c10bb0U)),.hi = ((u64)(0x012edc82110c2f94U)),}), ((strconv__Uint128){.lo = ((u64)(0x04965b0c89b14e9cU)),.hi = ((u64)(0x017a93a2954f3b79U)),}),
		((strconv__Uint128){.lo = ((u64)(0x45bbf1cfac1da243U)),.hi = ((u64)(0x01d9388b3aa30a57U)),}), ((strconv__Uint128){.lo = ((u64)(0x8b957721cb92856aU)),.hi = ((u64)(0x0127c35704a5e676U)),}), ((strconv__Uint128){.lo = ((u64)(0x2e7ad4ea3e7726c4U)),.hi = ((u64)(0x0171b42cc5cf6014U)),}), ((strconv__Uint128){.lo = ((u64)(0x3a198a24ce14f075U)),.hi = ((u64)(0x01ce2137f7433819U)),}), ((strconv__Uint128){.lo = ((u64)(0xc44ff65700cd1649U)),.hi = ((u64)(0x0120d4c2fa8a030fU)),}), ((strconv__Uint128){.lo = ((u64)(0xb563f3ecc1005bdbU)),.hi = ((u64)(0x016909f3b92c83d3U)),}), ((strconv__Uint128){.lo = ((u64)(0xa2bcf0e7f14072d2U)),.hi = ((u64)(0x01c34c70a777a4c8U)),}), ((strconv__Uint128){.lo = ((u64)(0x65b61690f6c847c3U)),.hi = ((u64)(0x011a0fc668aac6fdU)),}),
		((strconv__Uint128){.lo = ((u64)(0xbf239c35347a59b4U)),.hi = ((u64)(0x016093b802d578bcU)),}), ((strconv__Uint128){.lo = ((u64)(0xeeec83428198f021U)),.hi = ((u64)(0x01b8b8a6038ad6ebU)),}), ((strconv__Uint128){.lo = ((u64)(0x7553d20990ff9615U)),.hi = ((u64)(0x01137367c236c653U)),}), ((strconv__Uint128){.lo = ((u64)(0x52a8c68bf53f7b9aU)),.hi = ((u64)(0x01585041b2c477e8U)),}), ((strconv__Uint128){.lo = ((u64)(0x6752f82ef28f5a81U)),.hi = ((u64)(0x01ae64521f7595e2U)),}), ((strconv__Uint128){.lo = ((u64)(0x8093db1d57999890U)),.hi = ((u64)(0x010cfeb353a97dadU)),}), ((strconv__Uint128){.lo = ((u64)(0xe0b8d1e4ad7ffeb4U)),.hi = ((u64)(0x01503e602893dd18U)),}), ((strconv__Uint128){.lo = ((u64)(0x18e7065dd8dffe62U)),.hi = ((u64)(0x01a44df832b8d45fU)),}),
		((strconv__Uint128){.lo = ((u64)(0x6f9063faa78bfefdU)),.hi = ((u64)(0x0106b0bb1fb384bbU)),}), ((strconv__Uint128){.lo = ((u64)(0x4b747cf9516efebcU)),.hi = ((u64)(0x01485ce9e7a065eaU)),}), ((strconv__Uint128){.lo = ((u64)(0xde519c37a5cabe6bU)),.hi = ((u64)(0x019a742461887f64U)),}), ((strconv__Uint128){.lo = ((u64)(0x0af301a2c79eb703U)),.hi = ((u64)(0x01008896bcf54f9fU)),}), ((strconv__Uint128){.lo = ((u64)(0xcdafc20b798664c4U)),.hi = ((u64)(0x0140aabc6c32a386U)),}), ((strconv__Uint128){.lo = ((u64)(0x811bb28e57e7fdf5U)),.hi = ((u64)(0x0190d56b873f4c68U)),}), ((strconv__Uint128){.lo = ((u64)(0xa1629f31ede1fd72U)),.hi = ((u64)(0x01f50ac6690f1f82U)),}), ((strconv__Uint128){.lo = ((u64)(0xa4dda37f34ad3e67U)),.hi = ((u64)(0x013926bc01a973b1U)),}),
		((strconv__Uint128){.lo = ((u64)(0x0e150c5f01d88e01U)),.hi = ((u64)(0x0187706b0213d09eU)),}), ((strconv__Uint128){.lo = ((u64)(0x919a4f76c24eb181U)),.hi = ((u64)(0x01e94c85c298c4c5U)),}), ((strconv__Uint128){.lo = ((u64)(0x7b0071aa39712ef1U)),.hi = ((u64)(0x0131cfd3999f7afbU)),}), ((strconv__Uint128){.lo = ((u64)(0x59c08e14c7cd7aadU)),.hi = ((u64)(0x017e43c8800759baU)),}), ((strconv__Uint128){.lo = ((u64)(0xf030b199f9c0d958U)),.hi = ((u64)(0x01ddd4baa0093028U)),}), ((strconv__Uint128){.lo = ((u64)(0x961e6f003c1887d7U)),.hi = ((u64)(0x012aa4f4a405be19U)),}), ((strconv__Uint128){.lo = ((u64)(0xfba60ac04b1ea9cdU)),.hi = ((u64)(0x01754e31cd072d9fU)),}), ((strconv__Uint128){.lo = ((u64)(0xfa8f8d705de65440U)),.hi = ((u64)(0x01d2a1be4048f907U)),}),
		((strconv__Uint128){.lo = ((u64)(0xfc99b8663aaff4a8U)),.hi = ((u64)(0x0123a516e82d9ba4U)),}), ((strconv__Uint128){.lo = ((u64)(0x3bc0267fc95bf1d2U)),.hi = ((u64)(0x016c8e5ca239028eU)),}), ((strconv__Uint128){.lo = ((u64)(0xcab0301fbbb2ee47U)),.hi = ((u64)(0x01c7b1f3cac74331U)),}), ((strconv__Uint128){.lo = ((u64)(0x1eae1e13d54fd4ecU)),.hi = ((u64)(0x011ccf385ebc89ffU)),}), ((strconv__Uint128){.lo = ((u64)(0xe659a598caa3ca27U)),.hi = ((u64)(0x01640306766bac7eU)),}), ((strconv__Uint128){.lo = ((u64)(0x9ff00efefd4cbcb1U)),.hi = ((u64)(0x01bd03c81406979eU)),}), ((strconv__Uint128){.lo = ((u64)(0x23f6095f5e4ff5efU)),.hi = ((u64)(0x0116225d0c841ec3U)),}), ((strconv__Uint128){.lo = ((u64)(0xecf38bb735e3f36aU)),.hi = ((u64)(0x015baaf44fa52673U)),}),
		((strconv__Uint128){.lo = ((u64)(0xe8306ea5035cf045U)),.hi = ((u64)(0x01b295b1638e7010U)),}), ((strconv__Uint128){.lo = ((u64)(0x911e4527221a162bU)),.hi = ((u64)(0x010f9d8ede39060aU)),}), ((strconv__Uint128){.lo = ((u64)(0x3565d670eaa09bb6U)),.hi = ((u64)(0x015384f295c7478dU)),}), ((strconv__Uint128){.lo = ((u64)(0x82bf4c0d2548c2a3U)),.hi = ((u64)(0x01a8662f3b391970U)),}), ((strconv__Uint128){.lo = ((u64)(0x51b78f88374d79a6U)),.hi = ((u64)(0x01093fdd8503afe6U)),}), ((strconv__Uint128){.lo = ((u64)(0xe625736a4520d810U)),.hi = ((u64)(0x014b8fd4e6449bdfU)),}), ((strconv__Uint128){.lo = ((u64)(0xdfaed044d6690e14U)),.hi = ((u64)(0x019e73ca1fd5c2d7U)),}), ((strconv__Uint128){.lo = ((u64)(0xebcd422b0601a8ccU)),.hi = ((u64)(0x0103085e53e599c6U)),}),
		((strconv__Uint128){.lo = ((u64)(0xa6c092b5c78212ffU)),.hi = ((u64)(0x0143ca75e8df0038U)),}), ((strconv__Uint128){.lo = ((u64)(0xd070b763396297bfU)),.hi = ((u64)(0x0194bd136316c046U)),}), ((strconv__Uint128){.lo = ((u64)(0x848ce53c07bb3dafU)),.hi = ((u64)(0x01f9ec583bdc7058U)),}), ((strconv__Uint128){.lo = ((u64)(0x52d80f4584d5068dU)),.hi = ((u64)(0x013c33b72569c637U)),}), ((strconv__Uint128){.lo = ((u64)(0x278e1316e60a4831U)),.hi = ((u64)(0x018b40a4eec437c5U)),})}));
	_const_strconv__pow5_inv_split_64 = new_array_from_c_array(292, 292, sizeof(strconv__Uint128), _MOV((strconv__Uint128[292]){
		((strconv__Uint128){.lo = ((u64)(0x0000000000000001U)),.hi = ((u64)(0x0400000000000000U)),}), ((strconv__Uint128){.lo = ((u64)(0x3333333333333334U)),.hi = ((u64)(0x0333333333333333U)),}), ((strconv__Uint128){.lo = ((u64)(0x28f5c28f5c28f5c3U)),.hi = ((u64)(0x028f5c28f5c28f5cU)),}), ((strconv__Uint128){.lo = ((u64)(0xed916872b020c49cU)),.hi = ((u64)(0x020c49ba5e353f7cU)),}), ((strconv__Uint128){.lo = ((u64)(0xaf4f0d844d013a93U)),.hi = ((u64)(0x0346dc5d63886594U)),}), ((strconv__Uint128){.lo = ((u64)(0x8c3f3e0370cdc876U)),.hi = ((u64)(0x029f16b11c6d1e10U)),}), ((strconv__Uint128){.lo = ((u64)(0xd698fe69270b06c5U)),.hi = ((u64)(0x0218def416bdb1a6U)),}), ((strconv__Uint128){.lo = ((u64)(0xf0f4ca41d811a46eU)),.hi = ((u64)(0x035afe535795e90aU)),}), ((strconv__Uint128){.lo = ((u64)(0xf3f70834acdae9f1U)),.hi = ((u64)(0x02af31dc4611873bU)),}),
		((strconv__Uint128){.lo = ((u64)(0x5cc5a02a23e254c1U)),.hi = ((u64)(0x0225c17d04dad296U)),}), ((strconv__Uint128){.lo = ((u64)(0xfad5cd10396a2135U)),.hi = ((u64)(0x036f9bfb3af7b756U)),}), ((strconv__Uint128){.lo = ((u64)(0xfbde3da69454e75eU)),.hi = ((u64)(0x02bfaffc2f2c92abU)),}), ((strconv__Uint128){.lo = ((u64)(0x2fe4fe1edd10b918U)),.hi = ((u64)(0x0232f33025bd4223U)),}), ((strconv__Uint128){.lo = ((u64)(0x4ca19697c81ac1bfU)),.hi = ((u64)(0x0384b84d092ed038U)),}), ((strconv__Uint128){.lo = ((u64)(0x3d4e1213067bce33U)),.hi = ((u64)(0x02d09370d4257360U)),}), ((strconv__Uint128){.lo = ((u64)(0x643e74dc052fd829U)),.hi = ((u64)(0x024075f3dceac2b3U)),}), ((strconv__Uint128){.lo = ((u64)(0x6d30baf9a1e626a7U)),.hi = ((u64)(0x039a5652fb113785U)),}),
		((strconv__Uint128){.lo = ((u64)(0x2426fbfae7eb5220U)),.hi = ((u64)(0x02e1dea8c8da92d1U)),}), ((strconv__Uint128){.lo = ((u64)(0x1cebfcc8b9890e80U)),.hi = ((u64)(0x024e4bba3a487574U)),}), ((strconv__Uint128){.lo = ((u64)(0x94acc7a78f41b0ccU)),.hi = ((u64)(0x03b07929f6da5586U)),}), ((strconv__Uint128){.lo = ((u64)(0xaa23d2ec729af3d7U)),.hi = ((u64)(0x02f394219248446bU)),}), ((strconv__Uint128){.lo = ((u64)(0xbb4fdbf05baf2979U)),.hi = ((u64)(0x025c768141d369efU)),}), ((strconv__Uint128){.lo = ((u64)(0xc54c931a2c4b758dU)),.hi = ((u64)(0x03c7240202ebdcb2U)),}), ((strconv__Uint128){.lo = ((u64)(0x9dd6dc14f03c5e0bU)),.hi = ((u64)(0x0305b66802564a28U)),}), ((strconv__Uint128){.lo = ((u64)(0x4b1249aa59c9e4d6U)),.hi = ((u64)(0x026af8533511d4edU)),}),
		((strconv__Uint128){.lo = ((u64)(0x44ea0f76f60fd489U)),.hi = ((u64)(0x03de5a1ebb4fbb15U)),}), ((strconv__Uint128){.lo = ((u64)(0x6a54d92bf80caa07U)),.hi = ((u64)(0x0318481895d96277U)),}), ((strconv__Uint128){.lo = ((u64)(0x21dd7a89933d54d2U)),.hi = ((u64)(0x0279d346de4781f9U)),}), ((strconv__Uint128){.lo = ((u64)(0x362f2a75b8622150U)),.hi = ((u64)(0x03f61ed7ca0c0328U)),}), ((strconv__Uint128){.lo = ((u64)(0xf825bb91604e810dU)),.hi = ((u64)(0x032b4bdfd4d668ecU)),}), ((strconv__Uint128){.lo = ((u64)(0xc684960de6a5340bU)),.hi = ((u64)(0x0289097fdd7853f0U)),}), ((strconv__Uint128){.lo = ((u64)(0xd203ab3e521dc33cU)),.hi = ((u64)(0x02073accb12d0ff3U)),}), ((strconv__Uint128){.lo = ((u64)(0xe99f7863b696052cU)),.hi = ((u64)(0x033ec47ab514e652U)),}),
		((strconv__Uint128){.lo = ((u64)(0x87b2c6b62bab3757U)),.hi = ((u64)(0x02989d2ef743eb75U)),}), ((strconv__Uint128){.lo = ((u64)(0xd2f56bc4efbc2c45U)),.hi = ((u64)(0x0213b0f25f69892aU)),}), ((strconv__Uint128){.lo = ((u64)(0x1e55793b192d13a2U)),.hi = ((u64)(0x0352b4b6ff0f41deU)),}), ((strconv__Uint128){.lo = ((u64)(0x4b77942f475742e8U)),.hi = ((u64)(0x02a8909265a5ce4bU)),}), ((strconv__Uint128){.lo = ((u64)(0xd5f9435905df68baU)),.hi = ((u64)(0x022073a8515171d5U)),}), ((strconv__Uint128){.lo = ((u64)(0x565b9ef4d6324129U)),.hi = ((u64)(0x03671f73b54f1c89U)),}), ((strconv__Uint128){.lo = ((u64)(0xdeafb25d78283421U)),.hi = ((u64)(0x02b8e5f62aa5b06dU)),}), ((strconv__Uint128){.lo = ((u64)(0x188c8eb12cecf681U)),.hi = ((u64)(0x022d84c4eeeaf38bU)),}),
		((strconv__Uint128){.lo = ((u64)(0x8dadb11b7b14bd9bU)),.hi = ((u64)(0x037c07a17e44b8deU)),}), ((strconv__Uint128){.lo = ((u64)(0x7157c0e2c8dd647cU)),.hi = ((u64)(0x02c99fb46503c718U)),}), ((strconv__Uint128){.lo = ((u64)(0x8ddfcd823a4ab6caU)),.hi = ((u64)(0x023ae629ea696c13U)),}), ((strconv__Uint128){.lo = ((u64)(0x1632e269f6ddf142U)),.hi = ((u64)(0x0391704310a8acecU)),}), ((strconv__Uint128){.lo = ((u64)(0x44f581ee5f17f435U)),.hi = ((u64)(0x02dac035a6ed5723U)),}), ((strconv__Uint128){.lo = ((u64)(0x372ace584c1329c4U)),.hi = ((u64)(0x024899c4858aac1cU)),}), ((strconv__Uint128){.lo = ((u64)(0xbeaae3c079b842d3U)),.hi = ((u64)(0x03a75c6da27779c6U)),}), ((strconv__Uint128){.lo = ((u64)(0x6555830061603576U)),.hi = ((u64)(0x02ec49f14ec5fb05U)),}),
		((strconv__Uint128){.lo = ((u64)(0xb7779c004de6912bU)),.hi = ((u64)(0x0256a18dd89e626aU)),}), ((strconv__Uint128){.lo = ((u64)(0xf258f99a163db512U)),.hi = ((u64)(0x03bdcf495a9703ddU)),}), ((strconv__Uint128){.lo = ((u64)(0x5b7a614811caf741U)),.hi = ((u64)(0x02fe3f6de212697eU)),}), ((strconv__Uint128){.lo = ((u64)(0xaf951aa00e3bf901U)),.hi = ((u64)(0x0264ff8b1b41edfeU)),}), ((strconv__Uint128){.lo = ((u64)(0x7f54f7667d2cc19bU)),.hi = ((u64)(0x03d4cc11c5364997U)),}), ((strconv__Uint128){.lo = ((u64)(0x32aa5f8530f09ae3U)),.hi = ((u64)(0x0310a3416a91d479U)),}), ((strconv__Uint128){.lo = ((u64)(0xf55519375a5a1582U)),.hi = ((u64)(0x0273b5cdeedb1060U)),}), ((strconv__Uint128){.lo = ((u64)(0xbbbb5b8bc3c3559dU)),.hi = ((u64)(0x03ec56164af81a34U)),}),
		((strconv__Uint128){.lo = ((u64)(0x2fc916096969114aU)),.hi = ((u64)(0x03237811d593482aU)),}), ((strconv__Uint128){.lo = ((u64)(0x596dab3ababa743cU)),.hi = ((u64)(0x0282c674aadc39bbU)),}), ((strconv__Uint128){.lo = ((u64)(0x478aef622efb9030U)),.hi = ((u64)(0x0202385d557cfafcU)),}), ((strconv__Uint128){.lo = ((u64)(0xd8de4bd04b2c19e6U)),.hi = ((u64)(0x0336c0955594c4c6U)),}), ((strconv__Uint128){.lo = ((u64)(0xad7ea30d08f014b8U)),.hi = ((u64)(0x029233aaaadd6a38U)),}), ((strconv__Uint128){.lo = ((u64)(0x24654f3da0c01093U)),.hi = ((u64)(0x020e8fbbbbe454faU)),}), ((strconv__Uint128){.lo = ((u64)(0x3a3bb1fc346680ebU)),.hi = ((u64)(0x034a7f92c63a2190U)),}), ((strconv__Uint128){.lo = ((u64)(0x94fc8e635d1ecd89U)),.hi = ((u64)(0x02a1ffa89e94e7a6U)),}),
		((strconv__Uint128){.lo = ((u64)(0xaa63a51c4a7f0ad4U)),.hi = ((u64)(0x021b32ed4baa52ebU)),}), ((strconv__Uint128){.lo = ((u64)(0xdd6c3b607731aaedU)),.hi = ((u64)(0x035eb7e212aa1e45U)),}), ((strconv__Uint128){.lo = ((u64)(0x1789c919f8f488bdU)),.hi = ((u64)(0x02b22cb4dbbb4b6bU)),}), ((strconv__Uint128){.lo = ((u64)(0xac6e3a7b2d906d64U)),.hi = ((u64)(0x022823c3e2fc3c55U)),}), ((strconv__Uint128){.lo = ((u64)(0x13e390c515b3e23aU)),.hi = ((u64)(0x03736c6c9e606089U)),}), ((strconv__Uint128){.lo = ((u64)(0xdcb60d6a77c31b62U)),.hi = ((u64)(0x02c2bd23b1e6b3a0U)),}), ((strconv__Uint128){.lo = ((u64)(0x7d5e7121f968e2b5U)),.hi = ((u64)(0x0235641c8e52294dU)),}), ((strconv__Uint128){.lo = ((u64)(0xc8971b698f0e3787U)),.hi = ((u64)(0x0388a02db0837548U)),}),
		((strconv__Uint128){.lo = ((u64)(0xa078e2bad8d82c6cU)),.hi = ((u64)(0x02d3b357c0692aa0U)),}), ((strconv__Uint128){.lo = ((u64)(0xe6c71bc8ad79bd24U)),.hi = ((u64)(0x0242f5dfcd20eee6U)),}), ((strconv__Uint128){.lo = ((u64)(0x0ad82c7448c2c839U)),.hi = ((u64)(0x039e5632e1ce4b0bU)),}), ((strconv__Uint128){.lo = ((u64)(0x3be023903a356cfaU)),.hi = ((u64)(0x02e511c24e3ea26fU)),}), ((strconv__Uint128){.lo = ((u64)(0x2fe682d9c82abd95U)),.hi = ((u64)(0x0250db01d8321b8cU)),}), ((strconv__Uint128){.lo = ((u64)(0x4ca4048fa6aac8eeU)),.hi = ((u64)(0x03b4919c8d1cf8e0U)),}), ((strconv__Uint128){.lo = ((u64)(0x3d5003a61eef0725U)),.hi = ((u64)(0x02f6dae3a4172d80U)),}), ((strconv__Uint128){.lo = ((u64)(0x9773361e7f259f51U)),.hi = ((u64)(0x025f1582e9ac2466U)),}),
		((strconv__Uint128){.lo = ((u64)(0x8beb89ca6508fee8U)),.hi = ((u64)(0x03cb559e42ad070aU)),}), ((strconv__Uint128){.lo = ((u64)(0x6fefa16eb73a6586U)),.hi = ((u64)(0x0309114b688a6c08U)),}), ((strconv__Uint128){.lo = ((u64)(0xf3261abef8fb846bU)),.hi = ((u64)(0x026da76f86d52339U)),}), ((strconv__Uint128){.lo = ((u64)(0x51d691318e5f3a45U)),.hi = ((u64)(0x03e2a57f3e21d1f6U)),}), ((strconv__Uint128){.lo = ((u64)(0x0e4540f471e5c837U)),.hi = ((u64)(0x031bb798fe8174c5U)),}), ((strconv__Uint128){.lo = ((u64)(0xd8376729f4b7d360U)),.hi = ((u64)(0x027c92e0cb9ac3d0U)),}), ((strconv__Uint128){.lo = ((u64)(0xf38bd84321261effU)),.hi = ((u64)(0x03fa849adf5e061aU)),}), ((strconv__Uint128){.lo = ((u64)(0x293cad0280eb4bffU)),.hi = ((u64)(0x032ed07be5e4d1afU)),}),
		((strconv__Uint128){.lo = ((u64)(0xedca240200bc3cccU)),.hi = ((u64)(0x028bd9fcb7ea4158U)),}), ((strconv__Uint128){.lo = ((u64)(0xbe3b50019a3030a4U)),.hi = ((u64)(0x02097b309321cde0U)),}), ((strconv__Uint128){.lo = ((u64)(0xc9f88002904d1a9fU)),.hi = ((u64)(0x03425eb41e9c7c9aU)),}), ((strconv__Uint128){.lo = ((u64)(0x3b2d3335403daee6U)),.hi = ((u64)(0x029b7ef67ee396e2U)),}), ((strconv__Uint128){.lo = ((u64)(0x95bdc291003158b8U)),.hi = ((u64)(0x0215ff2b98b6124eU)),}), ((strconv__Uint128){.lo = ((u64)(0x892f9db4cd1bc126U)),.hi = ((u64)(0x035665128df01d4aU)),}), ((strconv__Uint128){.lo = ((u64)(0x07594af70a7c9a85U)),.hi = ((u64)(0x02ab840ed7f34aa2U)),}), ((strconv__Uint128){.lo = ((u64)(0x6c476f2c0863aed1U)),.hi = ((u64)(0x0222d00bdff5d54eU)),}),
		((strconv__Uint128){.lo = ((u64)(0x13a57eacda3917b4U)),.hi = ((u64)(0x036ae67966562217U)),}), ((strconv__Uint128){.lo = ((u64)(0x0fb7988a482dac90U)),.hi = ((u64)(0x02bbeb9451de81acU)),}), ((strconv__Uint128){.lo = ((u64)(0xd95fad3b6cf156daU)),.hi = ((u64)(0x022fefa9db1867bcU)),}), ((strconv__Uint128){.lo = ((u64)(0xf565e1f8ae4ef15cU)),.hi = ((u64)(0x037fe5dc91c0a5faU)),}), ((strconv__Uint128){.lo = ((u64)(0x911e4e608b725ab0U)),.hi = ((u64)(0x02ccb7e3a7cd5195U)),}), ((strconv__Uint128){.lo = ((u64)(0xda7ea51a0928488dU)),.hi = ((u64)(0x023d5fe9530aa7aaU)),}), ((strconv__Uint128){.lo = ((u64)(0xf7310829a8407415U)),.hi = ((u64)(0x039566421e7772aaU)),}), ((strconv__Uint128){.lo = ((u64)(0x2c2739baed005cdeU)),.hi = ((u64)(0x02ddeb68185f8eefU)),}),
		((strconv__Uint128){.lo = ((u64)(0xbcec2e2f24004a4bU)),.hi = ((u64)(0x024b22b9ad193f25U)),}), ((strconv__Uint128){.lo = ((u64)(0x94ad16b1d333aa11U)),.hi = ((u64)(0x03ab6ac2ae8ecb6fU)),}), ((strconv__Uint128){.lo = ((u64)(0xaa241227dc2954dbU)),.hi = ((u64)(0x02ef889bbed8a2bfU)),}), ((strconv__Uint128){.lo = ((u64)(0x54e9a81fe35443e2U)),.hi = ((u64)(0x02593a163246e899U)),}), ((strconv__Uint128){.lo = ((u64)(0x2175d9cc9eed396aU)),.hi = ((u64)(0x03c1f689ea0b0dc2U)),}), ((strconv__Uint128){.lo = ((u64)(0xe7917b0a18bdc788U)),.hi = ((u64)(0x03019207ee6f3e34U)),}), ((strconv__Uint128){.lo = ((u64)(0xb9412f3b46fe393aU)),.hi = ((u64)(0x0267a8065858fe90U)),}), ((strconv__Uint128){.lo = ((u64)(0xf535185ed7fd285cU)),.hi = ((u64)(0x03d90cd6f3c1974dU)),}),
		((strconv__Uint128){.lo = ((u64)(0xc42a79e57997537dU)),.hi = ((u64)(0x03140a458fce12a4U)),}), ((strconv__Uint128){.lo = ((u64)(0x03552e512e12a931U)),.hi = ((u64)(0x02766e9e0ca4dbb7U)),}), ((strconv__Uint128){.lo = ((u64)(0x9eeeb081e3510eb4U)),.hi = ((u64)(0x03f0b0fce107c5f1U)),}), ((strconv__Uint128){.lo = ((u64)(0x4bf226ce4f740bc3U)),.hi = ((u64)(0x0326f3fd80d304c1U)),}), ((strconv__Uint128){.lo = ((u64)(0xa3281f0b72c33c9cU)),.hi = ((u64)(0x02858ffe00a8d09aU)),}), ((strconv__Uint128){.lo = ((u64)(0x1c2018d5f568fd4aU)),.hi = ((u64)(0x020473319a20a6e2U)),}), ((strconv__Uint128){.lo = ((u64)(0xf9ccf48988a7fba9U)),.hi = ((u64)(0x033a51e8f69aa49cU)),}), ((strconv__Uint128){.lo = ((u64)(0xfb0a5d3ad3b99621U)),.hi = ((u64)(0x02950e53f87bb6e3U)),}),
		((strconv__Uint128){.lo = ((u64)(0x2f3b7dc8a96144e7U)),.hi = ((u64)(0x0210d8432d2fc583U)),}), ((strconv__Uint128){.lo = ((u64)(0xe52bfc7442353b0cU)),.hi = ((u64)(0x034e26d1e1e608d1U)),}), ((strconv__Uint128){.lo = ((u64)(0xb756639034f76270U)),.hi = ((u64)(0x02a4ebdb1b1e6d74U)),}), ((strconv__Uint128){.lo = ((u64)(0x2c451c735d92b526U)),.hi = ((u64)(0x021d897c15b1f12aU)),}), ((strconv__Uint128){.lo = ((u64)(0x13a1c71efc1deea3U)),.hi = ((u64)(0x0362759355e981ddU)),}), ((strconv__Uint128){.lo = ((u64)(0x761b05b2634b2550U)),.hi = ((u64)(0x02b52adc44bace4aU)),}), ((strconv__Uint128){.lo = ((u64)(0x91af37c1e908eaa6U)),.hi = ((u64)(0x022a88b036fbd83bU)),}), ((strconv__Uint128){.lo = ((u64)(0x82b1f2cfdb417770U)),.hi = ((u64)(0x03774119f192f392U)),}),
		((strconv__Uint128){.lo = ((u64)(0xcef4c23fe29ac5f3U)),.hi = ((u64)(0x02c5cdae5adbf60eU)),}), ((strconv__Uint128){.lo = ((u64)(0x3f2a34ffe87bd190U)),.hi = ((u64)(0x0237d7beaf165e72U)),}), ((strconv__Uint128){.lo = ((u64)(0x984387ffda5fb5b2U)),.hi = ((u64)(0x038c8c644b56fd83U)),}), ((strconv__Uint128){.lo = ((u64)(0xe0360666484c915bU)),.hi = ((u64)(0x02d6d6b6a2abfe02U)),}), ((strconv__Uint128){.lo = ((u64)(0x802b3851d3707449U)),.hi = ((u64)(0x024578921bbccb35U)),}), ((strconv__Uint128){.lo = ((u64)(0x99dec082ebe72075U)),.hi = ((u64)(0x03a25a835f947855U)),}), ((strconv__Uint128){.lo = ((u64)(0xae4bcd358985b391U)),.hi = ((u64)(0x02e8486919439377U)),}), ((strconv__Uint128){.lo = ((u64)(0xbea30a913ad15c74U)),.hi = ((u64)(0x02536d20e102dc5fU)),}),
		((strconv__Uint128){.lo = ((u64)(0xfdd1aa81f7b560b9U)),.hi = ((u64)(0x03b8ae9b019e2d65U)),}), ((strconv__Uint128){.lo = ((u64)(0x97daeece5fc44d61U)),.hi = ((u64)(0x02fa2548ce182451U)),}), ((strconv__Uint128){.lo = ((u64)(0xdfe258a51969d781U)),.hi = ((u64)(0x0261b76d71ace9daU)),}), ((strconv__Uint128){.lo = ((u64)(0x996a276e8f0fbf34U)),.hi = ((u64)(0x03cf8be24f7b0fc4U)),}), ((strconv__Uint128){.lo = ((u64)(0xe121b9253f3fcc2aU)),.hi = ((u64)(0x030c6fe83f95a636U)),}), ((strconv__Uint128){.lo = ((u64)(0xb41afa8432997022U)),.hi = ((u64)(0x02705986994484f8U)),}), ((strconv__Uint128){.lo = ((u64)(0xecf7f739ea8f19cfU)),.hi = ((u64)(0x03e6f5a4286da18dU)),}), ((strconv__Uint128){.lo = ((u64)(0x23f99294bba5ae40U)),.hi = ((u64)(0x031f2ae9b9f14e0bU)),}),
		((strconv__Uint128){.lo = ((u64)(0x4ffadbaa2fb7be99U)),.hi = ((u64)(0x027f5587c7f43e6fU)),}), ((strconv__Uint128){.lo = ((u64)(0x7ff7c5dd1925fdc2U)),.hi = ((u64)(0x03feef3fa6539718U)),}), ((strconv__Uint128){.lo = ((u64)(0xccc637e4141e649bU)),.hi = ((u64)(0x033258ffb842df46U)),}), ((strconv__Uint128){.lo = ((u64)(0xd704f983434b83afU)),.hi = ((u64)(0x028ead9960357f6bU)),}), ((strconv__Uint128){.lo = ((u64)(0x126a6135cf6f9c8cU)),.hi = ((u64)(0x020bbe144cf79923U)),}), ((strconv__Uint128){.lo = ((u64)(0x83dd685618b29414U)),.hi = ((u64)(0x0345fced47f28e9eU)),}), ((strconv__Uint128){.lo = ((u64)(0x9cb12044e08edcddU)),.hi = ((u64)(0x029e63f1065ba54bU)),}), ((strconv__Uint128){.lo = ((u64)(0x16f419d0b3a57d7dU)),.hi = ((u64)(0x02184ff405161dd6U)),}),
		((strconv__Uint128){.lo = ((u64)(0x8b20294dec3bfbfbU)),.hi = ((u64)(0x035a19866e89c956U)),}), ((strconv__Uint128){.lo = ((u64)(0x3c19baa4bcfcc996U)),.hi = ((u64)(0x02ae7ad1f207d445U)),}), ((strconv__Uint128){.lo = ((u64)(0xc9ae2eea30ca3adfU)),.hi = ((u64)(0x02252f0e5b39769dU)),}), ((strconv__Uint128){.lo = ((u64)(0x0f7d17dd1add2afdU)),.hi = ((u64)(0x036eb1b091f58a96U)),}), ((strconv__Uint128){.lo = ((u64)(0x3f97464a7be42264U)),.hi = ((u64)(0x02bef48d41913babU)),}), ((strconv__Uint128){.lo = ((u64)(0xcc790508631ce850U)),.hi = ((u64)(0x02325d3dce0dc955U)),}), ((strconv__Uint128){.lo = ((u64)(0xe0c1a1a704fb0d4dU)),.hi = ((u64)(0x0383c862e3494222U)),}), ((strconv__Uint128){.lo = ((u64)(0x4d67b4859d95a43eU)),.hi = ((u64)(0x02cfd3824f6dce82U)),}),
		((strconv__Uint128){.lo = ((u64)(0x711fc39e17aae9cbU)),.hi = ((u64)(0x023fdc683f8b0b9bU)),}), ((strconv__Uint128){.lo = ((u64)(0xe832d2968c44a945U)),.hi = ((u64)(0x039960a6cc11ac2bU)),}), ((strconv__Uint128){.lo = ((u64)(0xecf575453d03ba9eU)),.hi = ((u64)(0x02e11a1f09a7bcefU)),}), ((strconv__Uint128){.lo = ((u64)(0x572ac4376402fbb1U)),.hi = ((u64)(0x024dae7f3aec9726U)),}), ((strconv__Uint128){.lo = ((u64)(0x58446d256cd192b5U)),.hi = ((u64)(0x03af7d985e47583dU)),}), ((strconv__Uint128){.lo = ((u64)(0x79d0575123dadbc4U)),.hi = ((u64)(0x02f2cae04b6c4697U)),}), ((strconv__Uint128){.lo = ((u64)(0x94a6ac40e97be303U)),.hi = ((u64)(0x025bd5803c569edfU)),}), ((strconv__Uint128){.lo = ((u64)(0x8771139b0f2c9e6cU)),.hi = ((u64)(0x03c62266c6f0fe32U)),}),
		((strconv__Uint128){.lo = ((u64)(0x9f8da948d8f07ebdU)),.hi = ((u64)(0x0304e85238c0cb5bU)),}), ((strconv__Uint128){.lo = ((u64)(0xe60aedd3e0c06564U)),.hi = ((u64)(0x026a5374fa33d5e2U)),}), ((strconv__Uint128){.lo = ((u64)(0xa344afb9679a3bd2U)),.hi = ((u64)(0x03dd5254c3862304U)),}), ((strconv__Uint128){.lo = ((u64)(0xe903bfc78614fca8U)),.hi = ((u64)(0x031775109c6b4f36U)),}), ((strconv__Uint128){.lo = ((u64)(0xba6966393810ca20U)),.hi = ((u64)(0x02792a73b055d8f8U)),}), ((strconv__Uint128){.lo = ((u64)(0x2a423d2859b4769aU)),.hi = ((u64)(0x03f510b91a22f4c1U)),}), ((strconv__Uint128){.lo = ((u64)(0xee9b642047c39215U)),.hi = ((u64)(0x032a73c7481bf700U)),}), ((strconv__Uint128){.lo = ((u64)(0xbee2b680396941aaU)),.hi = ((u64)(0x02885c9f6ce32c00U)),}),
		((strconv__Uint128){.lo = ((u64)(0xff1bc53361210155U)),.hi = ((u64)(0x0206b07f8a4f5666U)),}), ((strconv__Uint128){.lo = ((u64)(0x31c6085235019bbbU)),.hi = ((u64)(0x033de73276e5570bU)),}), ((strconv__Uint128){.lo = ((u64)(0x27d1a041c4014963U)),.hi = ((u64)(0x0297ec285f1ddf3cU)),}), ((strconv__Uint128){.lo = ((u64)(0xeca7b367d0010782U)),.hi = ((u64)(0x021323537f4b18fcU)),}), ((strconv__Uint128){.lo = ((u64)(0xadd91f0c8001a59dU)),.hi = ((u64)(0x0351d21f3211c194U)),}), ((strconv__Uint128){.lo = ((u64)(0xf17a7f3d3334847eU)),.hi = ((u64)(0x02a7db4c280e3476U)),}), ((strconv__Uint128){.lo = ((u64)(0x279532975c2a0398U)),.hi = ((u64)(0x021fe2a3533e905fU)),}), ((strconv__Uint128){.lo = ((u64)(0xd8eeb75893766c26U)),.hi = ((u64)(0x0366376bb8641a31U)),}),
		((strconv__Uint128){.lo = ((u64)(0x7a5892ad42c52352U)),.hi = ((u64)(0x02b82c562d1ce1c1U)),}), ((strconv__Uint128){.lo = ((u64)(0xfb7a0ef102374f75U)),.hi = ((u64)(0x022cf044f0e3e7cdU)),}), ((strconv__Uint128){.lo = ((u64)(0xc59017e8038bb254U)),.hi = ((u64)(0x037b1a07e7d30c7cU)),}), ((strconv__Uint128){.lo = ((u64)(0x37a67986693c8eaaU)),.hi = ((u64)(0x02c8e19feca8d6caU)),}), ((strconv__Uint128){.lo = ((u64)(0xf951fad1edca0bbbU)),.hi = ((u64)(0x023a4e198a20abd4U)),}), ((strconv__Uint128){.lo = ((u64)(0x28832ae97c76792bU)),.hi = ((u64)(0x03907cf5a9cddfbbU)),}), ((strconv__Uint128){.lo = ((u64)(0x2068ef21305ec756U)),.hi = ((u64)(0x02d9fd9154a4b2fcU)),}), ((strconv__Uint128){.lo = ((u64)(0x19ed8c1a8d189f78U)),.hi = ((u64)(0x0247fe0ddd508f30U)),}),
		((strconv__Uint128){.lo = ((u64)(0x5caf4690e1c0ff26U)),.hi = ((u64)(0x03a66349621a7eb3U)),}), ((strconv__Uint128){.lo = ((u64)(0x4a25d20d81673285U)),.hi = ((u64)(0x02eb82a11b48655cU)),}), ((strconv__Uint128){.lo = ((u64)(0x3b5174d79ab8f537U)),.hi = ((u64)(0x0256021a7c39eab0U)),}), ((strconv__Uint128){.lo = ((u64)(0x921bee25c45b21f1U)),.hi = ((u64)(0x03bcd02a605caab3U)),}), ((strconv__Uint128){.lo = ((u64)(0xdb498b5169e2818eU)),.hi = ((u64)(0x02fd735519e3bbc2U)),}), ((strconv__Uint128){.lo = ((u64)(0x15d46f7454b53472U)),.hi = ((u64)(0x02645c4414b62fcfU)),}), ((strconv__Uint128){.lo = ((u64)(0xefba4bed545520b6U)),.hi = ((u64)(0x03d3c6d35456b2e4U)),}), ((strconv__Uint128){.lo = ((u64)(0xf2fb6ff110441a2bU)),.hi = ((u64)(0x030fd242a9def583U)),}),
		((strconv__Uint128){.lo = ((u64)(0x8f2f8cc0d9d014efU)),.hi = ((u64)(0x02730e9bbb18c469U)),}), ((strconv__Uint128){.lo = ((u64)(0xb1e5ae015c80217fU)),.hi = ((u64)(0x03eb4a92c4f46d75U)),}), ((strconv__Uint128){.lo = ((u64)(0xc1848b344a001accU)),.hi = ((u64)(0x0322a20f03f6bdf7U)),}), ((strconv__Uint128){.lo = ((u64)(0xce03a2903b3348a3U)),.hi = ((u64)(0x02821b3f365efe5fU)),}), ((strconv__Uint128){.lo = ((u64)(0xd802e873628f6d4fU)),.hi = ((u64)(0x0201af65c518cb7fU)),}), ((strconv__Uint128){.lo = ((u64)(0x599e40b89db2487fU)),.hi = ((u64)(0x0335e56fa1c14599U)),}), ((strconv__Uint128){.lo = ((u64)(0xe14b66fa17c1d399U)),.hi = ((u64)(0x029184594e3437adU)),}), ((strconv__Uint128){.lo = ((u64)(0x81091f2e7967dc7aU)),.hi = ((u64)(0x020e037aa4f692f1U)),}),
		((strconv__Uint128){.lo = ((u64)(0x9b41cb7d8f0c93f6U)),.hi = ((u64)(0x03499f2aa18a84b5U)),}), ((strconv__Uint128){.lo = ((u64)(0xaf67d5fe0c0a0ff8U)),.hi = ((u64)(0x02a14c221ad536f7U)),}), ((strconv__Uint128){.lo = ((u64)(0xf2b977fe70080cc7U)),.hi = ((u64)(0x021aa34e7bddc592U)),}), ((strconv__Uint128){.lo = ((u64)(0x1df58cca4cd9ae0bU)),.hi = ((u64)(0x035dd2172c9608ebU)),}), ((strconv__Uint128){.lo = ((u64)(0xe4c470a1d7148b3cU)),.hi = ((u64)(0x02b174df56de6d88U)),}), ((strconv__Uint128){.lo = ((u64)(0x83d05a1b1276d5caU)),.hi = ((u64)(0x022790b2abe5246dU)),}), ((strconv__Uint128){.lo = ((u64)(0x9fb3c35e83f1560fU)),.hi = ((u64)(0x0372811ddfd50715U)),}), ((strconv__Uint128){.lo = ((u64)(0xb2f635e5365aab3fU)),.hi = ((u64)(0x02c200e4b310d277U)),}),
		((strconv__Uint128){.lo = ((u64)(0xf591c4b75eaeef66U)),.hi = ((u64)(0x0234cd83c273db92U)),}), ((strconv__Uint128){.lo = ((u64)(0xef4fa125644b18a3U)),.hi = ((u64)(0x0387af39371fc5b7U)),}), ((strconv__Uint128){.lo = ((u64)(0x8c3fb41de9d5ad4fU)),.hi = ((u64)(0x02d2f2942c196af9U)),}), ((strconv__Uint128){.lo = ((u64)(0x3cffc34b2177bdd9U)),.hi = ((u64)(0x02425ba9bce12261U)),}), ((strconv__Uint128){.lo = ((u64)(0x94cc6bab68bf9628U)),.hi = ((u64)(0x039d5f75fb01d09bU)),}), ((strconv__Uint128){.lo = ((u64)(0x10a38955ed6611b9U)),.hi = ((u64)(0x02e44c5e6267da16U)),}), ((strconv__Uint128){.lo = ((u64)(0xda1c6dde5784dafbU)),.hi = ((u64)(0x02503d184eb97b44U)),}), ((strconv__Uint128){.lo = ((u64)(0xf693e2fd58d49191U)),.hi = ((u64)(0x03b394f3b128c53aU)),}),
		((strconv__Uint128){.lo = ((u64)(0xc5431bfde0aa0e0eU)),.hi = ((u64)(0x02f610c2f4209dc8U)),}), ((strconv__Uint128){.lo = ((u64)(0x6a9c1664b3bb3e72U)),.hi = ((u64)(0x025e73cf29b3b16dU)),}), ((strconv__Uint128){.lo = ((u64)(0x10f9bd6dec5eca4fU)),.hi = ((u64)(0x03ca52e50f85e8afU)),}), ((strconv__Uint128){.lo = ((u64)(0xda616457f04bd50cU)),.hi = ((u64)(0x03084250d937ed58U)),}), ((strconv__Uint128){.lo = ((u64)(0xe1e783798d09773dU)),.hi = ((u64)(0x026d01da475ff113U)),}), ((strconv__Uint128){.lo = ((u64)(0x030c058f480f252eU)),.hi = ((u64)(0x03e19c9072331b53U)),}), ((strconv__Uint128){.lo = ((u64)(0x68d66ad906728425U)),.hi = ((u64)(0x031ae3a6c1c27c42U)),}), ((strconv__Uint128){.lo = ((u64)(0x8711ef14052869b7U)),.hi = ((u64)(0x027be952349b969bU)),}),
		((strconv__Uint128){.lo = ((u64)(0x0b4fe4ecd50d75f2U)),.hi = ((u64)(0x03f97550542c242cU)),}), ((strconv__Uint128){.lo = ((u64)(0xa2a650bd773df7f5U)),.hi = ((u64)(0x032df7737689b689U)),}), ((strconv__Uint128){.lo = ((u64)(0xb551da312c31932aU)),.hi = ((u64)(0x028b2c5c5ed49207U)),}), ((strconv__Uint128){.lo = ((u64)(0x5ddb14f4235adc22U)),.hi = ((u64)(0x0208f049e576db39U)),}), ((strconv__Uint128){.lo = ((u64)(0x2fc4ee536bc49369U)),.hi = ((u64)(0x034180763bf15ec2U)),}), ((strconv__Uint128){.lo = ((u64)(0xbfd0bea92303a921U)),.hi = ((u64)(0x029acd2b63277f01U)),}), ((strconv__Uint128){.lo = ((u64)(0x9973cbba8269541aU)),.hi = ((u64)(0x021570ef8285ff34U)),}), ((strconv__Uint128){.lo = ((u64)(0x5bec792a6a42202aU)),.hi = ((u64)(0x0355817f373ccb87U)),}),
		((strconv__Uint128){.lo = ((u64)(0xe3239421ee9b4cefU)),.hi = ((u64)(0x02aacdff5f63d605U)),}), ((strconv__Uint128){.lo = ((u64)(0xb5b6101b25490a59U)),.hi = ((u64)(0x02223e65e5e97804U)),}), ((strconv__Uint128){.lo = ((u64)(0x22bce691d541aa27U)),.hi = ((u64)(0x0369fd6fd64259a1U)),}), ((strconv__Uint128){.lo = ((u64)(0xb563eba7ddce21b9U)),.hi = ((u64)(0x02bb31264501e14dU)),}), ((strconv__Uint128){.lo = ((u64)(0xf78322ecb171b494U)),.hi = ((u64)(0x022f5a850401810aU)),}), ((strconv__Uint128){.lo = ((u64)(0x259e9e47824f8753U)),.hi = ((u64)(0x037ef73b399c01abU)),}), ((strconv__Uint128){.lo = ((u64)(0x1e187e9f9b72d2a9U)),.hi = ((u64)(0x02cbf8fc2e1667bcU)),}), ((strconv__Uint128){.lo = ((u64)(0x4b46cbb2e2c24221U)),.hi = ((u64)(0x023cc73024deb963U)),}),
		((strconv__Uint128){.lo = ((u64)(0x120adf849e039d01U)),.hi = ((u64)(0x039471e6a1645bd2U)),}), ((strconv__Uint128){.lo = ((u64)(0xdb3be603b19c7d9aU)),.hi = ((u64)(0x02dd27ebb4504974U)),}), ((strconv__Uint128){.lo = ((u64)(0x7c2feb3627b0647cU)),.hi = ((u64)(0x024a865629d9d45dU)),}), ((strconv__Uint128){.lo = ((u64)(0x2d197856a5e7072cU)),.hi = ((u64)(0x03aa7089dc8fba2fU)),}), ((strconv__Uint128){.lo = ((u64)(0x8a7ac6abb7ec05bdU)),.hi = ((u64)(0x02eec06e4a0c94f2U)),}), ((strconv__Uint128){.lo = ((u64)(0xd52f05562cbcd164U)),.hi = ((u64)(0x025899f1d4d6dd8eU)),}), ((strconv__Uint128){.lo = ((u64)(0x21e4d556adfae8a0U)),.hi = ((u64)(0x03c0f64fbaf1627eU)),}), ((strconv__Uint128){.lo = ((u64)(0xe7ea444557fbed4dU)),.hi = ((u64)(0x0300c50c958de864U)),}),
		((strconv__Uint128){.lo = ((u64)(0xecbb69d1132ff10aU)),.hi = ((u64)(0x0267040a113e5383U)),}), ((strconv__Uint128){.lo = ((u64)(0xadf8a94e851981aaU)),.hi = ((u64)(0x03d8067681fd526cU)),}), ((strconv__Uint128){.lo = ((u64)(0x8b2d543ed0e13488U)),.hi = ((u64)(0x0313385ece6441f0U)),}), ((strconv__Uint128){.lo = ((u64)(0xd5bddcff0d80f6d3U)),.hi = ((u64)(0x0275c6b23eb69b26U)),}), ((strconv__Uint128){.lo = ((u64)(0x892fc7fe7c018aebU)),.hi = ((u64)(0x03efa45064575ea4U)),}), ((strconv__Uint128){.lo = ((u64)(0x3a8c9ffec99ad589U)),.hi = ((u64)(0x03261d0d1d12b21dU)),}), ((strconv__Uint128){.lo = ((u64)(0xc8707fff07af113bU)),.hi = ((u64)(0x0284e40a7da88e7dU)),}), ((strconv__Uint128){.lo = ((u64)(0x39f39998d2f2742fU)),.hi = ((u64)(0x0203e9a1fe2071feU)),}),
		((strconv__Uint128){.lo = ((u64)(0x8fec28f484b7204bU)),.hi = ((u64)(0x033975cffd00b663U)),}), ((strconv__Uint128){.lo = ((u64)(0xd989ba5d36f8e6a2U)),.hi = ((u64)(0x02945e3ffd9a2b82U)),}), ((strconv__Uint128){.lo = ((u64)(0x47a161e42bfa521cU)),.hi = ((u64)(0x02104b66647b5602U)),}), ((strconv__Uint128){.lo = ((u64)(0x0c35696d132a1cf9U)),.hi = ((u64)(0x034d4570a0c5566aU)),}), ((strconv__Uint128){.lo = ((u64)(0x09c454574288172dU)),.hi = ((u64)(0x02a4378d4d6aab88U)),}), ((strconv__Uint128){.lo = ((u64)(0xa169dd129ba0128bU)),.hi = ((u64)(0x021cf93dd7888939U)),}), ((strconv__Uint128){.lo = ((u64)(0x0242fb50f9001dabU)),.hi = ((u64)(0x03618ec958da7529U)),}), ((strconv__Uint128){.lo = ((u64)(0x9b68c90d940017bcU)),.hi = ((u64)(0x02b4723aad7b90edU)),}),
		((strconv__Uint128){.lo = ((u64)(0x4920a0d7a999ac96U)),.hi = ((u64)(0x0229f4fbbdfc73f1U)),}), ((strconv__Uint128){.lo = ((u64)(0x750101590f5c4757U)),.hi = ((u64)(0x037654c5fcc71fe8U)),}), ((strconv__Uint128){.lo = ((u64)(0x2a6734473f7d05dfU)),.hi = ((u64)(0x02c5109e63d27fedU)),}), ((strconv__Uint128){.lo = ((u64)(0xeeb8f69f65fd9e4cU)),.hi = ((u64)(0x0237407eb641fff0U)),}), ((strconv__Uint128){.lo = ((u64)(0xe45b24323cc8fd46U)),.hi = ((u64)(0x038b9a6456cfffe7U)),}), ((strconv__Uint128){.lo = ((u64)(0xb6af502830a0ca9fU)),.hi = ((u64)(0x02d6151d123fffecU)),}), ((strconv__Uint128){.lo = ((u64)(0xf88c402026e7087fU)),.hi = ((u64)(0x0244ddb0db666656U)),}), ((strconv__Uint128){.lo = ((u64)(0x2746cd003e3e73feU)),.hi = ((u64)(0x03a162b4923d708bU)),}),
		((strconv__Uint128){.lo = ((u64)(0x1f6bd73364fec332U)),.hi = ((u64)(0x02e7822a0e978d3cU)),}), ((strconv__Uint128){.lo = ((u64)(0xe5efdf5c50cbcf5bU)),.hi = ((u64)(0x0252ce880bac70fcU)),}), ((strconv__Uint128){.lo = ((u64)(0x3cb2fefa1adfb22bU)),.hi = ((u64)(0x03b7b0d9ac471b2eU)),}), ((strconv__Uint128){.lo = ((u64)(0x308f3261af195b56U)),.hi = ((u64)(0x02f95a47bd05af58U)),}), ((strconv__Uint128){.lo = ((u64)(0x5a0c284e25ade2abU)),.hi = ((u64)(0x0261150630d15913U)),}), ((strconv__Uint128){.lo = ((u64)(0x29ad0d49d5e30445U)),.hi = ((u64)(0x03ce8809e7b55b52U)),}), ((strconv__Uint128){.lo = ((u64)(0x548a7107de4f369dU)),.hi = ((u64)(0x030ba007ec9115dbU)),}), ((strconv__Uint128){.lo = ((u64)(0xdd3b8d9fe50c2bb1U)),.hi = ((u64)(0x026fb3398a0dab15U)),}),
		((strconv__Uint128){.lo = ((u64)(0x952c15cca1ad12b5U)),.hi = ((u64)(0x03e5eb8f434911bcU)),}), ((strconv__Uint128){.lo = ((u64)(0x775677d6e7bda891U)),.hi = ((u64)(0x031e560c35d40e30U)),}), ((strconv__Uint128){.lo = ((u64)(0xc5dec645863153a7U)),.hi = ((u64)(0x027eab3cf7dcd826U)),})}));
	}
	{ // Initializations for module builtin :
	_const_none__ = /*&IError*/I_None___to_Interface_IError(((None__*)memdup(&(None__){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(None__))));
	_const_children_bytes = sizeof(voidptr) * (_const_max_len + 1);
	}
	{ // Initializations for module os :
	_const_os__args = os__init_os_args(___argc, (byte**)___argv);
	_const_os__wd_at_startup = os__getwd();
	}
	{ // Initializations for module time :
	_const_time__month_days = new_array_from_c_array(12, 12, sizeof(int), _MOV((int[12]){
		31, 28, 31, 30, 31, 30, 31, 31, 30,
		31, 30, 31}));
	_const_time__absolute_zero_year = ((i64)(-292277022399));
	_const_time__days_before = new_array_from_c_array(13, 13, sizeof(int), _MOV((int[13]){
		0, 31, 31 + 28, 31 + 28 + 31, 31 + 28 + 31 + 30, 31 + 28 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,
		31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30, 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31}));
	_const_time__long_days = new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){_SLIT("Monday"), _SLIT("Tuesday"), _SLIT("Wednesday"), _SLIT("Thursday"), _SLIT("Friday"), _SLIT("Saturday"), _SLIT("Sunday")}));
	_const_time__nanosecond = ((time__Duration)(1));
	_const_time__microsecond = ((1000 * _const_time__nanosecond));
	_const_time__millisecond = ((1000 * _const_time__microsecond));
	_const_time__second = ((1000 * _const_time__millisecond));
	_const_time__minute = ((60 * _const_time__second));
	_const_time__hour = ((60 * _const_time__minute));
	_const_time__infinite = ((((i64)(9223372036854775807))));
	_const_time__start_time = mach_absolute_time();
	_const_time__time_base = time__init_time_base();
	}
	{ // Initializations for module eventbus :
	}
	{ // Initializations for module clipboard :
	}
	{ // Initializations for module sync.threads :
	}
	{ // Initializations for module fontstash :
	_const_fontstash__invalid = FONS_INVALID;
	}
	{ // Initializations for module math.internal :
	}
	{ // Initializations for module stbi :
	}
	{ // Initializations for module sokol.c :
	}
	{ // Initializations for module gx :
	_const_gx__black = ((gx__Color){.r = 0,.g = 0,.b = 0,.a = 255,});
	_const_gx__gray = ((gx__Color){.r = 128,.g = 128,.b = 128,.a = 255,});
	_const_gx__white = ((gx__Color){.r = 255,.g = 255,.b = 255,.a = 255,});
	_const_gx__red = ((gx__Color){.r = 255,.g = 0,.b = 0,.a = 255,});
	_const_gx__green = ((gx__Color){.r = 0,.g = 255,.b = 0,.a = 255,});
	_const_gx__blue = ((gx__Color){.r = 0,.g = 0,.b = 255,.a = 255,});
	_const_gx__yellow = ((gx__Color){.r = 255,.g = 255,.b = 0,.a = 255,});
	_const_gx__magenta = ((gx__Color){.r = 255,.g = 0,.b = 255,.a = 255,});
	_const_gx__cyan = ((gx__Color){.r = 0,.g = 255,.b = 255,.a = 255,});
	_const_gx__orange = ((gx__Color){.r = 255,.g = 165,.b = 0,.a = 255,});
	_const_gx__purple = ((gx__Color){.r = 128,.g = 0,.b = 128,.a = 255,});
	_const_gx__indigo = ((gx__Color){.r = 75,.g = 0,.b = 130,.a = 255,});
	_const_gx__pink = ((gx__Color){.r = 255,.g = 192,.b = 203,.a = 255,});
	_const_gx__violet = ((gx__Color){.r = 238,.g = 130,.b = 238,.a = 255,});
	_const_gx__dark_blue = ((gx__Color){.r = 0,.g = 0,.b = 139,.a = 255,});
	_const_gx__dark_gray = ((gx__Color){.r = 169,.g = 169,.b = 169,.a = 255,});
	_const_gx__dark_green = ((gx__Color){.r = 0,.g = 100,.b = 0,.a = 255,});
	_const_gx__dark_red = ((gx__Color){.r = 139,.g = 0,.b = 0,.a = 255,});
	_const_gx__light_blue = ((gx__Color){.r = 173,.g = 216,.b = 230,.a = 255,});
	_const_gx__light_gray = ((gx__Color){.r = 211,.g = 211,.b = 211,.a = 255,});
	_const_gx__light_green = ((gx__Color){.r = 144,.g = 238,.b = 144,.a = 255,});
	_const_gx__light_red = ((gx__Color){.r = 255,.g = 204,.b = 203,.a = 255,});
	_const_gx__string_colors = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 20, sizeof(string), sizeof(gx__Color), _MOV((string[20]){_SLIT("blue"), _SLIT("red"), _SLIT("green"), _SLIT("yellow"), _SLIT("orange"), _SLIT("purple"), _SLIT("black"), _SLIT("gray"), _SLIT("indigo"), _SLIT("pink"), _SLIT("violet"), _SLIT("white"), _SLIT("dark_blue"), _SLIT("dark_gray"), _SLIT("dark_green"), _SLIT("dark_red"), _SLIT("light_blue"), _SLIT("light_gray"), _SLIT("light_green"), _SLIT("light_red"), }), _MOV((gx__Color[20]){_const_gx__blue, _const_gx__red, _const_gx__green, _const_gx__yellow, _const_gx__orange, _const_gx__purple, _const_gx__black, _const_gx__gray, _const_gx__indigo, _const_gx__pink, _const_gx__violet, _const_gx__white, _const_gx__dark_blue, _const_gx__dark_gray, _const_gx__dark_green, _const_gx__dark_red, _const_gx__light_blue, _const_gx__light_gray, _const_gx__light_green, _const_gx__light_red, }));
	_const_gx__align_left = gx__HorizontalAlign__left;
	_const_gx__align_right = gx__HorizontalAlign__right;
	}
	{ // Initializations for module math :
	_const_math__pi_2 = _const_math__pi / 2.0;
	_const_math__pi_4 = _const_math__pi / 4.0;
	_const_math__log2_e = 1.0 / _const_math__ln2;
	_const_math__log10_e = 1.0 / _const_math__ln10;
	_const_math__min_i64 = ((i64)(-9223372036854775807 - 1));
	_const_math__max_i64 = ((i64)(9223372036854775807));
	_const_math__bernoulli = new_array_from_c_array(10, 10, sizeof(f64), _MOV((f64[10]){
		1.0 / (6.0 * 2.0 * 1.0), -1.0 / (30.0 * 4.0 * 3.0), 1.0 / (42.0 * 6.0 * 5.0), -1.0 / (30.0 * 8.0 * 7.0), 5.0 / (66.0 * 10.0 * 9.0), -691.0 / (2730.0 * 12.0 * 11.0), 7.0 / (6.0 * 14.0 * 13.0), -3617.0 / (510.0 * 16.0 * 15.0), 43867.0 / (796.0 * 18.0 * 17.0),
		-174611.0 / (330.0 * 20.0 * 19.0)}));
	_const_math__factorials_table = new_array_from_c_array(171, 171, sizeof(f64), _MOV((f64[171]){
		1.000000000000000000000e+0, 1.000000000000000000000e+0, 2.000000000000000000000e+0, 6.000000000000000000000e+0, 2.400000000000000000000e+1, 1.200000000000000000000e+2, 7.200000000000000000000e+2, 5.040000000000000000000e+3, 4.032000000000000000000e+4,
		3.628800000000000000000e+5, 3.628800000000000000000e+6, 3.991680000000000000000e+7, 4.790016000000000000000e+8, 6.227020800000000000000e+9, 8.717829120000000000000e+10, 1.307674368000000000000e+12, 2.092278988800000000000e+13,
		3.556874280960000000000e+14, 6.402373705728000000000e+15, 1.216451004088320000000e+17, 2.432902008176640000000e+18, 5.109094217170944000000e+19, 1.124000727777607680000e+21, 2.585201673888497664000e+22, 6.204484017332394393600e+23,
		1.551121004333098598400e+25, 4.032914611266056355840e+26, 1.088886945041835216077e+28, 3.048883446117138605015e+29, 8.841761993739701954544e+30, 2.652528598121910586363e+32, 8.222838654177922817726e+33, 2.631308369336935301672e+35,
		8.683317618811886495518e+36, 2.952327990396041408476e+38, 1.033314796638614492967e+40, 3.719933267899012174680e+41, 1.376375309122634504632e+43, 5.230226174666011117600e+44, 2.039788208119744335864e+46, 8.159152832478977343456e+47,
		3.345252661316380710817e+49, 1.405006117752879898543e+51, 6.041526306337383563736e+52, 2.658271574788448768044e+54, 1.196222208654801945620e+56, 5.502622159812088949850e+57, 2.586232415111681806430e+59, 1.241391559253607267086e+61,
		6.082818640342675608723e+62, 3.041409320171337804361e+64, 1.551118753287382280224e+66, 8.065817517094387857166e+67, 4.274883284060025564298e+69, 2.308436973392413804721e+71, 1.269640335365827592597e+73, 7.109985878048634518540e+74,
		4.052691950487721675568e+76, 2.350561331282878571829e+78, 1.386831185456898357379e+80, 8.320987112741390144276e+81, 5.075802138772247988009e+83, 3.146997326038793752565e+85, 1.982608315404440064116e+87, 1.268869321858841641034e+89,
		8.247650592082470666723e+90, 5.443449390774430640037e+92, 3.647111091818868528825e+94, 2.480035542436830599601e+96, 1.711224524281413113725e+98, 1.197857166996989179607e+100, 8.504785885678623175212e+101, 6.123445837688608686152e+103,
		4.470115461512684340891e+105, 3.307885441519386412260e+107, 2.480914081139539809195e+109, 1.885494701666050254988e+111, 1.451830920282858696341e+113, 1.132428117820629783146e+115, 8.946182130782975286851e+116, 7.156945704626380229481e+118,
		5.797126020747367985880e+120, 4.753643337012841748421e+122, 3.945523969720658651190e+124, 3.314240134565353266999e+126, 2.817104114380550276949e+128, 2.422709538367273238177e+130, 2.107757298379527717214e+132, 1.854826422573984391148e+134,
		1.650795516090846108122e+136, 1.485715964481761497310e+138, 1.352001527678402962552e+140, 1.243841405464130725548e+142, 1.156772507081641574759e+144, 1.087366156656743080274e+146, 1.032997848823905926260e+148, 9.916779348709496892096e+149,
		9.619275968248211985333e+151, 9.426890448883247745626e+153, 9.332621544394415268170e+155, 9.332621544394415268170e+157, 9.425947759838359420852e+159, 9.614466715035126609269e+161, 9.902900716486180407547e+163, 1.029901674514562762385e+166,
		1.081396758240290900504e+168, 1.146280563734708354534e+170, 1.226520203196137939352e+172, 1.324641819451828974500e+174, 1.443859583202493582205e+176, 1.588245541522742940425e+178, 1.762952551090244663872e+180, 1.974506857221074023537e+182,
		2.231192748659813646597e+184, 2.543559733472187557120e+186, 2.925093693493015690688e+188, 3.393108684451898201198e+190, 3.969937160808720895402e+192, 4.684525849754290656574e+194, 5.574585761207605881323e+196, 6.689502913449127057588e+198,
		8.094298525273443739682e+200, 9.875044200833601362412e+202, 1.214630436702532967577e+205, 1.506141741511140879795e+207, 1.882677176888926099744e+209, 2.372173242880046885677e+211, 3.012660018457659544810e+213, 3.856204823625804217357e+215,
		4.974504222477287440390e+217, 6.466855489220473672507e+219, 8.471580690878820510985e+221, 1.118248651196004307450e+224, 1.487270706090685728908e+226, 1.992942746161518876737e+228, 2.690472707318050483595e+230, 3.659042881952548657690e+232,
		5.012888748274991661035e+234, 6.917786472619488492228e+236, 9.615723196941089004197e+238, 1.346201247571752460588e+241, 1.898143759076170969429e+243, 2.695364137888162776589e+245, 3.854370717180072770522e+247, 5.550293832739304789551e+249,
		8.047926057471991944849e+251, 1.174997204390910823948e+254, 1.727245890454638911203e+256, 2.556323917872865588581e+258, 3.808922637630569726986e+260, 5.713383956445854590479e+262, 8.627209774233240431623e+264, 1.311335885683452545607e+267,
		2.006343905095682394778e+269, 3.089769613847350887959e+271, 4.789142901463393876336e+273, 7.471062926282894447084e+275, 1.172956879426414428192e+278, 1.853271869493734796544e+280, 2.946702272495038326504e+282, 4.714723635992061322407e+284,
		7.590705053947218729075e+286, 1.229694218739449434110e+289, 2.004401576545302577600e+291, 3.287218585534296227263e+293, 5.423910666131588774984e+295, 9.003691705778437366474e+297, 1.503616514864999040201e+300, 2.526075744973198387538e+302,
		4.269068009004705274939e+304, 7.257415615307998967397e+306}));
	_const_math__log_factorials_table = new_array_from_c_array(172, 172, sizeof(f64), _MOV((f64[172]){
		0.000000000000000000000e+0, 0.000000000000000000000e+0, 6.931471805599453094172e-1, 1.791759469228055000812e+0, 3.178053830347945619647e+0, 4.787491742782045994248e+0, 6.579251212010100995060e+0, 8.525161361065414300166e+0, 1.060460290274525022842e+1,
		1.280182748008146961121e+1, 1.510441257307551529523e+1, 1.750230784587388583929e+1, 1.998721449566188614952e+1, 2.255216385312342288557e+1, 2.519122118273868150009e+1, 2.789927138384089156609e+1, 3.067186010608067280376e+1,
		3.350507345013688888401e+1, 3.639544520803305357622e+1, 3.933988418719949403622e+1, 4.233561646075348502966e+1, 4.538013889847690802616e+1, 4.847118135183522387964e+1, 5.160667556776437357045e+1, 5.478472939811231919009e+1,
		5.800360522298051993929e+1, 6.126170176100200198477e+1, 6.455753862700633105895e+1, 6.788974313718153498289e+1, 7.125703896716800901007e+1, 7.465823634883016438549e+1, 7.809222355331531063142e+1, 8.155795945611503717850e+1,
		8.505446701758151741396e+1, 8.858082754219767880363e+1, 9.213617560368709248333e+1, 9.571969454214320248496e+1, 9.933061245478742692933e+1, 1.029681986145138126988e+2, 1.066317602606434591262e+2, 1.103206397147573954291e+2,
		1.140342117814617032329e+2, 1.177718813997450715388e+2, 1.215330815154386339623e+2, 1.253172711493568951252e+2, 1.291239336391272148826e+2, 1.329525750356163098828e+2, 1.368027226373263684696e+2, 1.406739236482342593987e+2,
		1.445657439463448860089e+2, 1.484777669517730320675e+2, 1.524095925844973578392e+2, 1.563608363030787851941e+2, 1.603311282166309070282e+2, 1.643201122631951814118e+2, 1.683274454484276523305e+2, 1.723527971391628015638e+2,
		1.763958484069973517152e+2, 1.804562914175437710518e+2, 1.845338288614494905025e+2, 1.886281734236715911873e+2, 1.927390472878449024360e+2, 1.968661816728899939914e+2, 2.010093163992815266793e+2, 2.051681994826411985358e+2,
		2.093425867525368356464e+2, 2.135322414945632611913e+2, 2.177369341139542272510e+2, 2.219564418191303339501e+2, 2.261905483237275933323e+2, 2.304390435657769523214e+2, 2.347017234428182677427e+2, 2.389783895618343230538e+2,
		2.432688490029827141829e+2, 2.475729140961868839366e+2, 2.518904022097231943772e+2, 2.562211355500095254561e+2, 2.605649409718632093053e+2, 2.649216497985528010421e+2, 2.692910976510198225363e+2, 2.736731242856937041486e+2,
		2.780675734403661429141e+2, 2.824742926876303960274e+2, 2.868931332954269939509e+2, 2.913239500942703075662e+2, 2.957666013507606240211e+2, 3.002209486470141317540e+2, 3.046868567656687154726e+2, 3.091641935801469219449e+2,
		3.136528299498790617832e+2, 3.181526396202093268500e+2, 3.226634991267261768912e+2, 3.271852877037752172008e+2, 3.317178871969284731381e+2, 3.362611819791984770344e+2, 3.408150588707990178690e+2, 3.453794070622668541074e+2,
		3.499541180407702369296e+2, 3.545390855194408088492e+2, 3.591342053695753987760e+2, 3.637393755555634901441e+2, 3.683544960724047495950e+2, 3.729794688856890206760e+2, 3.776141978739186564468e+2, 3.822585887730600291111e+2,
		3.869125491232175524822e+2, 3.915759882173296196258e+2, 3.962488170517915257991e+2, 4.009309482789157454921e+2, 4.056222961611448891925e+2, 4.103227765269373054205e+2, 4.150323067282496395563e+2, 4.197508055995447340991e+2,
		4.244781934182570746677e+2, 4.292143918666515701285e+2, 4.339593239950148201939e+2, 4.387129141861211848399e+2, 4.434750881209189409588e+2, 4.482457727453846057188e+2, 4.530248962384961351041e+2, 4.578123879812781810984e+2,
		4.626081785268749221865e+2, 4.674121995716081787447e+2, 4.722243839269805962399e+2, 4.770446654925856331047e+2, 4.818729792298879342285e+2, 4.867092611368394122258e+2, 4.915534482232980034989e+2, 4.964054784872176206648e+2,
		5.012652908915792927797e+2, 5.061328253420348751997e+2, 5.110080226652360267439e+2, 5.158908245878223975982e+2, 5.207811737160441513633e+2, 5.256790135159950627324e+2, 5.305842882944334921812e+2, 5.354969431801695441897e+2,
		5.404169241059976691050e+2, 5.453441777911548737966e+2, 5.502786517242855655538e+2, 5.552202941468948698523e+2, 5.601690540372730381305e+2, 5.651248810948742988613e+2, 5.700877257251342061414e+2, 5.750575390247102067619e+2,
		5.800342727671307811636e+2, 5.850178793888391176022e+2, 5.900083119756178539038e+2, 5.950055242493819689670e+2, 6.000094705553274281080e+2, 6.050201058494236838580e+2, 6.100373856862386081868e+2, 6.150612662070848845750e+2,
		6.200917041284773200381e+2, 6.251286567308909491967e+2, 6.301720818478101958172e+2, 6.352219378550597328635e+2, 6.402781836604080409209e+2, 6.453407786934350077245e+2, 6.504096828956552392500e+2, 6.554848567108890661717e+2,
		6.605662610758735291676e+2, 6.656538574111059132426e+2, 6.707476076119126755767e+2, 6.758474740397368739994e+2, 6.809534195136374546094e+2, 6.860654073019939978423e+2, 6.911834011144107529496e+2, 6.963073650938140118743e+2,
		7.014372638087370853465e+2, 7.065730622457873471107e+2, 7.117147258022900069535e+2}));
	_const_math__gamma_p = new_array_from_c_array(7, 7, sizeof(f64), _MOV((f64[7]){1.60119522476751861407e-04, 1.19135147006586384913e-03, 1.04213797561761569935e-02, 4.76367800457137231464e-02, 2.07448227648435975150e-01, 4.94214826801497100753e-01, 9.99999999999999996796e-01}));
	_const_math__gamma_q = new_array_from_c_array(8, 8, sizeof(f64), _MOV((f64[8]){-2.31581873324120129819e-05, 5.39605580493303397842e-04, -4.45641913851797240494e-03, 1.18139785222060435552e-02, 3.58236398605498653373e-02, -2.34591795718243348568e-01, 7.14304917030273074085e-02, 1.00000000000000000320e+00}));
	_const_math__gamma_s = new_array_from_c_array(5, 5, sizeof(f64), _MOV((f64[5]){7.87311395793093628397e-04, -2.29549961613378126380e-04, -2.68132617805781232825e-03, 3.47222221605458667310e-03, 8.33333333333482257126e-02}));
	_const_math__lgamma_a = new_array_from_c_array(12, 12, sizeof(f64), _MOV((f64[12]){
		7.72156649015328655494e-02, 3.22467033424113591611e-01, 6.73523010531292681824e-02, 2.05808084325167332806e-02, 7.38555086081402883957e-03, 2.89051383673415629091e-03, 1.19270763183362067845e-03, 5.10069792153511336608e-04, 2.20862790713908385557e-04,
		1.08011567247583939954e-04, 2.52144565451257326939e-05, 4.48640949618915160150e-05}));
	_const_math__lgamma_r = new_array_from_c_array(7, 7, sizeof(f64), _MOV((f64[7]){1.0, 1.39200533467621045958e+00, 7.21935547567138069525e-01, 1.71933865632803078993e-01, 1.86459191715652901344e-02, 7.77942496381893596434e-04, 7.32668430744625636189e-06}));
	_const_math__lgamma_s = new_array_from_c_array(7, 7, sizeof(f64), _MOV((f64[7]){-7.72156649015328655494e-02, 2.14982415960608852501e-01, 3.25778796408930981787e-01, 1.46350472652464452805e-01, 2.66422703033638609560e-02, 1.84028451407337715652e-03, 3.19475326584100867617e-05}));
	_const_math__lgamma_t = new_array_from_c_array(15, 15, sizeof(f64), _MOV((f64[15]){
		4.83836122723810047042e-01, -1.47587722994593911752e-01, 6.46249402391333854778e-02, -3.27885410759859649565e-02, 1.79706750811820387126e-02, -1.03142241298341437450e-02, 6.10053870246291332635e-03, -3.68452016781138256760e-03, 2.25964780900612472250e-03,
		-1.40346469989232843813e-03, 8.81081882437654011382e-04, -5.38595305356740546715e-04, 3.15632070903625950361e-04, -3.12754168375120860518e-04, 3.35529192635519073543e-04}));
	_const_math__lgamma_u = new_array_from_c_array(6, 6, sizeof(f64), _MOV((f64[6]){-7.72156649015328655494e-02, 6.32827064025093366517e-01, 1.45492250137234768737e+00, 9.77717527963372745603e-01, 2.28963728064692451092e-01, 1.33810918536787660377e-02}));
	_const_math__lgamma_v = new_array_from_c_array(6, 6, sizeof(f64), _MOV((f64[6]){1.0, 2.45597793713041134822e+00, 2.12848976379893395361e+00, 7.69285150456672783825e-01, 1.04222645593369134254e-01, 3.21709242282423911810e-03}));
	_const_math__lgamma_w = new_array_from_c_array(7, 7, sizeof(f64), _MOV((f64[7]){4.18938533204672725052e-01, 8.33333333333329678849e-02, -2.77777777728775536470e-03, 7.93650558643019558500e-04, -5.95187557450339963135e-04, 8.36339918996282139126e-04, -1.63092934096575273989e-03}));
	_const_math__pow10tab = new_array_from_c_array(32, 32, sizeof(f64), _MOV((f64[32]){
		((f64)(1e+00)), 1e+01, 1e+02, 1e+03, 1e+04, 1e+05, 1e+06, 1e+07, 1e+08,
		1e+09, 1e+10, 1e+11, 1e+12, 1e+13, 1e+14, 1e+15, 1e+16,
		1e+17, 1e+18, 1e+19, 1e+20, 1e+21, 1e+22, 1e+23, 1e+24,
		1e+25, 1e+26, 1e+27, 1e+28, 1e+29, 1e+30, 1e+31}));
	_const_math__pow10postab32 = new_array_from_c_array(10, 10, sizeof(f64), _MOV((f64[10]){
		((f64)(1e+00)), 1e+32, 1e+64, 1e+96, 1e+128, 1e+160, 1e+192, 1e+224, 1e+256,
		1e+288}));
	_const_math__pow10negtab32 = new_array_from_c_array(11, 11, sizeof(f64), _MOV((f64[11]){
		((f64)(1e-00)), 1e-32, 1e-64, 1e-96, 1e-128, 1e-160, 1e-192, 1e-224, 1e-256,
		1e-288, 1e-320}));
	_const_math__sin_data = new_array_from_c_array(12, 12, sizeof(f64), _MOV((f64[12]){
		-0.3295190160663511504173, 0.0025374284671667991990, 0.0006261928782647355874, -4.6495547521854042157541e-06, -5.6917531549379706526677e-07, 3.7283335140973803627866e-09, 3.0267376484747473727186e-10, -1.7400875016436622322022e-12, -1.0554678305790849834462e-13,
		5.3701981409132410797062e-16, 2.5984137983099020336115e-17, -1.1821555255364833468288e-19}));
	_const_math__sin_cs = ((math__ChebSeries){.c = _const_math__sin_data,.order = 11,.a = -1,.b = 1,});
	_const_math__cos_data = new_array_from_c_array(11, 11, sizeof(f64), _MOV((f64[11]){
		0.165391825637921473505668118136, -0.00084852883845000173671196530195, -0.000210086507222940730213625768083, 1.16582269619760204299639757584e-6, 1.43319375856259870334412701165e-7, -7.4770883429007141617951330184e-10, -6.0969994944584252706997438007e-11, 2.90748249201909353949854872638e-13, 1.77126739876261435667156490461e-14,
		-7.6896421502815579078577263149e-17, -3.7363121133079412079201377318e-18}));
	_const_math__cos_cs = ((math__ChebSeries){.c = _const_math__cos_data,.order = 10,.a = -1,.b = 1,});
	_const_math__tan_p = new_array_from_c_array(3, 3, sizeof(f64), _MOV((f64[3]){-1.30936939181383777646e+4, 1.15351664838587416140e+6, -1.79565251976484877988e+7}));
	_const_math__tan_q = new_array_from_c_array(5, 5, sizeof(f64), _MOV((f64[5]){1.00000000000000000000e+0, 1.36812963470692954678e+4, -1.32089234440210967447e+6, 2.50083801823357915839e+7, -5.38695755929454629881e+7}));
	_const_math__tanh_p = new_array_from_c_array(3, 3, sizeof(f64), _MOV((f64[3]){-9.64399179425052238628e-1, -9.92877231001918586564e+1, -1.61468768441708447952e+3}));
	_const_math__tanh_q = new_array_from_c_array(3, 3, sizeof(f64), _MOV((f64[3]){1.12811678491632931402e+2, 2.23548839060100448583e+3, 4.84406305325125486048e+3}));
	}
	{ // Initializations for module os.font :
	}
	{ // Initializations for module sokol.gfx :
	}
	{ // Initializations for module sokol.f :
	}
	{ // Initializations for module sokol.sgl :
	_const_sokol__sgl__context = ((sokol__sgl__Context){.id = 0x00010001U,});
	}
	{ // Initializations for module sokol.sapp :
	}
	{ // Initializations for module sokol.sfons :
	}
	{ // Initializations for module sokol :
	}
	{ // Initializations for module gg :
	_const_gg__recorder_settings = gg__new_gg_recorder_settings();
	}
	{ // Initializations for module ui :
	_const_ui__empty_text_cfg = ((gx__TextCfg){.color = _const_gx__black,.size = 16,.align = gx__HorizontalAlign__left,.vertical_align = gx__VerticalAlign__top,.max_width = 0,.family = (string){.str=(byteptr)"", .is_lit=1},.bold = 0,.mono = 0,.italic = 0,});
	_const_ui__events = ((ui__EventNames){.on_click = _SLIT("on_click"),.on_mouse_move = _SLIT("on_mouse_move"),.on_mouse_down = _SLIT("on_mouse_down"),.on_mouse_up = _SLIT("on_mouse_up"),.on_files_droped = _SLIT("on_files_droped"),.on_swipe = _SLIT("on_swipe"),.on_touch_move = _SLIT("on_touch_move"),.on_touch_down = _SLIT("on_touch_down"),.on_touch_up = _SLIT("on_touch_up"),.on_key_down = _SLIT("on_key_down"),.on_char = _SLIT("on_char"),.on_key_up = _SLIT("on_key_up"),.on_scroll = _SLIT("on_scroll"),.on_resize = _SLIT("on_resize"),});
	_const_ui__scroolbar_thumb_color = gx__rgb(87, 153, 245);
	_const_ui__scrollbar_background_color = gx__rgb(219, 219, 219);
	_const_ui__scrollbar_button_color = gx__rgb(150, 150, 150);
	_const_ui__scrollbar_focused_button_color = gx__rgb(100, 100, 100);
	_const_ui__null_scrollview = ((ui__ScrollView*)(0));
	_const_ui__no_color = ((gx__Color){.r = 0,.g = 0,.b = 0,.a = 0,});
	_const_ui__no_theme = string_to_sumtype_ui__ColorThemeCfg(ADDR(string, (_SLIT("_no_theme_"))));
	_const_ui__empty_stack = ui__stack(((ui__StackParams){.id = _SLIT("_empty_stack_"),.width = 0,.height = 0,.vertical_alignment = 0,.horizontal_alignment = 0,.spacings = __new_array(0, 0, sizeof(f32)),.spacing = 0,.stretch = 0,.direction = 0,.margins = {0},.title = (string){.str=(byteptr)"", .is_lit=1},.widths = __new_array(0, 0, sizeof(f32)),.heights = __new_array(0, 0, sizeof(f32)),.align = (ui__Alignments){.center = __new_array(0, 0, sizeof(int)),.left_top = __new_array(0, 0, sizeof(int)),.top = __new_array(0, 0, sizeof(int)),.right_top = __new_array(0, 0, sizeof(int)),.right = __new_array(0, 0, sizeof(int)),.right_bottom = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),.left_bottom = __new_array(0, 0, sizeof(int)),.left = __new_array(0, 0, sizeof(int)),},.vertical_alignments = (ui__VerticalAlignments){.top = __new_array(0, 0, sizeof(int)),.center = __new_array(0, 0, sizeof(int)),.bottom = __new_array(0, 0, sizeof(int)),},.horizontal_alignments = (ui__HorizontalAlignments){.left = __new_array(0, 0, sizeof(int)),.center = __new_array(0, 0, sizeof(int)),.right = __new_array(0, 0, sizeof(int)),},.bg_color = (gx__Color){.r = 0,.g = 0,.b = 0,.a = 255,},.bg_radius = 0,.scrollview = 0,.children = __new_array(0, 0, sizeof(ui__Widget)),}));
	_const_ui__scrollview_empty_rect = ((gg__Rect){.x = 0,.y = 0,.width = 0,.height = 0,});
	_const_ui__button_bg_color = gx__rgb(28, 28, 28);
	_const_ui__button_border_color = gx__rgb(200, 200, 200);
	_const_ui__button_focus_border_color = gx__rgb(50, 50, 50);
	_const_ui__cb_border_color = gx__rgb(50, 50, 50);
	_const_ui__dropdown_color = gx__rgb(240, 240, 240);
	_const_ui__dropdown_border_color = gx__rgb(223, 223, 223);
	_const_ui__dropdown_focus_color = gx__rgb(50, 50, 50);
	_const_ui__dropdown_drawer_color = gx__rgb(255, 255, 255);
	_const_ui___col_list_bkgrnd = _const_gx__white;
	_const_ui___col_item_select = _const_gx__light_blue;
	_const_ui___col_border = _const_gx__gray;
	_const_ui__menu_color = gx__rgb(240, 240, 240);
	_const_ui__menu_border_color = gx__rgb(223, 223, 223);
	_const_ui__progress_bar_color = gx__rgb(87, 153, 245);
	_const_ui__progress_bar_border_color = gx__rgb(76, 133, 213);
	_const_ui__progress_bar_background_color = gx__rgb(219, 219, 219);
	_const_ui__progress_bar_background_border_color = gx__rgb(191, 191, 191);
	_const_ui__radio_focus_color = gx__rgb(50, 50, 50);
	_const_ui__thumb_color = gx__rgb(87, 153, 245);
	_const_ui__slider_background_color = gx__rgb(219, 219, 219);
	_const_ui__slider_background_border_color = gx__rgb(191, 191, 191);
	_const_ui__slider_focused_background_border_color = gx__rgb(255, 0, 0);
	_const_ui__sw_open_bg_color = gx__rgb(19, 206, 102);
	_const_ui__sw_close_bg_color = gx__rgb(220, 223, 230);
	_const_ui__sw_focus_bg_color = gx__rgb(50, 50, 50);
	_const_ui__text_border_color = gx__rgb(177, 177, 177);
	_const_ui__text_inner_border_color = gx__rgb(240, 240, 240);
	_const_ui__text_border_accentuated_color = gx__rgb(255, 0, 0);
	_const_ui__selection_color = gx__rgb(186, 214, 251);
	_const_ui__default_window_color = gx__rgb(236, 236, 236);
	}
	{ // Initializations for module main :
	}
}
void _vcleanup(void) {
}

int main(int ___argc, char** ___argv){
	_vinit(___argc, (voidptr)___argv);
	main__main();
	_vcleanup();
	return 0;
}

// THE END.
